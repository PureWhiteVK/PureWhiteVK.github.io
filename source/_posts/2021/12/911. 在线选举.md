---
title: 911. 在线选举
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 43d9
---
# 911. 在线选举

给你两个整数数组 `persons` 和 `times` 。在选举中，第` i` 张票是在时刻为` times[i]` 时投给候选人` persons[i]` 的。

对于发生在时刻 `t` 的每个查询，需要找出在` t` 时刻在选举中领先的候选人的编号。

在 `t` 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。

实现 `TopVotedCandidate` 类：

- `TopVotedCandidate(int[] persons, int[] times)` 使用 `persons` 和` times` 数组初始化对象。
- `int q(int t)` 根据前面描述的规则，返回在时刻 `t` 在选举中领先的候选人的编号。

> 链接：https://leetcode-cn.com/problems/online-election

<!-- more -->

## 二分查找

根据题意，第i张票是在times[i]时刻投给persons[i]，那么当时刻t位于区间 [ times[i] , times[i-1] )内时，其结果都是确定的，因为此时并没有新的选票产生，也就不会发生变化，那么我们只需要遍历times[i]，记录下times[i]时刻的获胜候选人即可，使用一个哈希表存储每个候选人的选票，然后不断更新当前的胜者即可

```java
class TopVotedCandidate {
    private int[] times,winner;
    private int l;
    public TopVotedCandidate(int[] persons, int[] _times) {
        times = _times;
        l = times.length;
        winner = new int[l];
        // 使用map还不如数组模拟的哈希表快
        Map<Integer,Integer> voteCount = new HashMap<>();
        int winnerIndex = -1;
        voteCount.put(-1,-1);
        for(int i=0;i<l;++i){
            int candidateIndex = persons[i];
            voteCount.put(candidateIndex,voteCount.getOrDefault(candidateIndex,0)+1);
            if(voteCount.get(candidateIndex) >= voteCount.get(winnerIndex)){
                // 更新当前时刻的票数领先者
                winnerIndex = candidateIndex;
            }
            // winner[i]记录的是times[i]时刻的优胜者
            // 由于在times[i]到times[i+1]的区间内不存在新的选票，那么对[times[i],times[i+1])区间内的时刻，其优胜都是winner[i]
            winner[i] = winnerIndex;
        }
        // for(int i : winner){
        //     System.out.print(i+ " ");
        // }
        // System.out.println();
    }
    
    public int q(int t) {
        // 进行二分查找即可，需要找到upperbound-1即可
        int left = 0;
        int right = l;
        while(left < right){
            int mid = (left + right) >> 1;
            // System.out.println(left+" "+right+" "+mid);
            if(times[mid] > t){
                right = mid;
            }else{
                left = mid + 1;
            }
        }
        // System.out.println(left + " "+times[left] + " " + t);
        return winner[left-1];
    }
}

/**
 * Your TopVotedCandidate object will be instantiated and called as such:
 * TopVotedCandidate obj = new TopVotedCandidate(persons, times);
 * int param_1 = obj.q(t);
 */
```

