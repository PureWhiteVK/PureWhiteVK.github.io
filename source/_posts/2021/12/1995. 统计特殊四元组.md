---
title: 1995. 统计特殊四元组
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: f51a
---
# 1995. 统计特殊四元组

给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：

nums[a] + nums[b] + nums[c] == nums[d] ，且
a < b < c < d

> 链接：https://leetcode-cn.com/problems/count-special-quadruplets

<!-- more -->

## 暴力

题目数据量不大，暴力枚举也还行

```java
class Solution {
    public int countQuadruplets(int[] nums) {
        // 如果暴力的话，就是四重循环
        int l = nums.length;
        int res = 0;
        for(int a=0;a<l;++a){
            for(int b=a+1;b<l;++b){
                for(int c=b+1;c<l;++c){
                    for(int d=c+1;d<l;++d){
                        if(nums[a] + nums[b] + nums[c] == nums[d]) ++res;
                    }
                }
            }
        }
        return res;
    }
}
```

## 哈希表-o(n^3)

枚举的时间复杂度为o(n^4)，实在是太高了，是否存在简单一点的办法呢？

注意到等式

`nums[a] + nums[b] + nums[c] == nums[d]`

如果我们倒着枚举nums[c]，由于d的位置一定大于c，那么实际上我们可以使用哈希表存储d对应值出现的次数，这样可以减少一个维度的判断，将时间复杂度度降低到o(n^3)

```java
class Solution {
    public int countQuadruplets(int[] nums) {
        // 如果暴力的话，就是四重循环
        int l = nums.length;
        int res = 0;
        // 由于nums[a] + nums[b] + nums[c] 的值最大可以到300
        // 未避免溢出，这里取到301
        int[] countD = new int[301];
        for(int c = l-2;c > 0;--c){
            ++countD[nums[c+1]];
            for(int b = 0;b<c;++b){
                for(int a = 0;a<b;++a){
                    // 由于nums[d]的值一直存储着的，直接读取即可
                    res += countD[nums[a] + nums[b] + nums[c]];
                }
            }
        }
        return res;
    }
}
```

## 哈希表-o(n^2)

实际上我们还可以降低一个时间复杂度，将等式进行变换

`nums[a] + nums[b] == nums[d] - nums[c]`

只需要我们使用哈希表存储 `nums[d]-nums[c]`的值就可以

在遍历a之前首先根据b的索引遍历所有nums[d]-nums[c]的情况，然后累加即可

```java
class Solution {
    public int countQuadruplets(int[] nums) {
        // 如果暴力的话，就是四重循环
        int l = nums.length;
        int res = 0;
        // 由于nums[a] + nums[b] + nums[c] 的值最大可以到300
        // 未避免溢出，这里取到301
        int[] count = new int[401];
        for(int b = l-3;b>0;--b){
            int c = b + 1;
            // 在枚举a之前先将当前b的位置枚举出所有d-c的值
            for(int d = l-1;d>c;--d){
                // 只需要遍历到所有的nums[d]-nums[c]对即可，这个实际上只和b有关了，就可以进行降维
                // nums[d] - nums[c] 可能是一个负值，进行偏移，
                ++count[nums[d]-nums[c] + 200];
            }
            for(int a = 0;a < b;++a){
                res += count[nums[a] + nums[b] + 200];
            }
        }
        
        return res;
    }
}
```

