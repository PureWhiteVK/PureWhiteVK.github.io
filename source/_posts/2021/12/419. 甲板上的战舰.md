---
title: 419. 甲板上的战舰
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 6f7
date: 2021-12-18
---
# 419. 甲板上的战舰

给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在甲板 board 上放置的 战舰 的数量。

战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。

> 链接：https://leetcode-cn.com/problems/battleships-in-a-board

<!-- more -->

## 题意

这个题看了半天，才搞明白意思，一艘战舰是直的，它的长度为k，它既可以水平摆也可以竖直摆，现在给你一个甲板，要你统计出甲板上的战舰数目。

这个题关键在于战舰与战舰之间一定是不相连的，而战舰之间一定是水平或竖直的（也就是战舰的部分与部分之间一定是相连的）

对于一个给定的部分，我们可以搜索出其相连的部分，并将其标记一下即可

## 搜索（DFS or BFS）

```java
class Solution {
    private char[][] board;
    private int m,n;
    private int res;
    private static final int[][] dir = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};
    public int countBattleships(char[][] _board) {
        // 看了半天题意都没看懂
        // 'x'代表战舰，'.'代表空位
        // 战舰的形状是 (1,k) 或 (k,1)，其中k为任意大小
        // 需要统计战舰的个数
        // 第一种办法，直接dfs找连通分量
        m = _board.length;
        n = _board[0].length;
        board = _board;
        for(int i=0;i<m;++i){
            for(int j=0;j<n;++j){
                // 直接修改board，将遍历过的节点转换成'.'，这样可以节省空间
                if(board[i][j] == 'X'){
                    dfs(i,j);
                    ++res;
                }
            }
        }
        return res;
    }

    private void dfs(int x,int y){
        board[x][y] = '.';
        for(int[] d : dir){
            int nx = x + d[0];
            int ny = y + d[1];
            // 如果两个X是相连的，那么他们一定属于同一个战舰，这样就可以统计出所有的战舰
            if(nx>=0 && nx < m && ny >= 0 && ny < n && board[nx][ny] == 'X'){
                dfs(nx,ny);
            }
        }
    }
}
```



## 脑筋急转弯

由于战舰和战舰之间不是相连的，那么我们只需要找出一个点，这个点可以唯一代表一个战舰即可，这个点就是战舰头，由于战舰头的上(0,-1)和左(-1,0)一定是不相连的，只需要统计有多少个这个即可

```java
class Solution {
    public int countBattleships(char[][] board) {
        int m = board.length, n = board[0].length;
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i > 0 && board[i - 1][j] == 'X') continue;
                if (j > 0 && board[i][j - 1] == 'X') continue;
                if (board[i][j] == 'X') res++;
            }
        }
        return res;
    }
}
```

