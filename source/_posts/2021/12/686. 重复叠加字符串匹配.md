---
title: 686. 重复叠加字符串匹配
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '14e3'
---
# 686. 重复叠加字符串匹配

给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。

注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。

> 链接：https://leetcode-cn.com/problems/repeated-string-match

<!-- more -->

## 字符串匹配+脑筋急转弯

首先可以知道该题一定要用到字符串匹配，需要判断a的重复叠加字符串是否包含b

又由于重复叠加字串的性质，如果b在重复叠加了s次a内，那么s*a.length()一定要大于b，而且由于重复叠加的特性，能和b匹配的实际字串数就是a的长度，也就是说我们最多比较a.length()次就可以知道是否包含（因为之后的匹配都是循环的）

```java
class Solution {
    public int repeatedStringMatch(String a, String b) {
        // 首先判断b中是否包含a中不存在的字符
        int[] countA = new int[26];
        int[] countB = new int[26];
        for(char ch:a.toCharArray()){
            ++countA[ch-'a'];
        }
        for(char ch:b.toCharArray()){
            ++countB[ch-'a'];
        }
        for(int i=0;i<26;++i){
            // 该字符仅在B中出现过，那么永远无法匹配
            if(countB[i] != 0 && countA[i] == 0) return -1;
        }
        // 进行下一步的匹配
        // 由于重叠字符串的性质，最长叠加字符串的长度是很容易确定的
        StringBuilder sb = new StringBuilder();
        int res = 0;
        // 关键在于当叠加后a的长度超过b的长度，b的起始位置在a上的位置只有a.length()个，如果以这些字符串作为起始构成的重叠字符串都无法匹配，那么之后的也无法匹配
        while(sb.length() < b.length()){
            sb.append(a);
            ++res;
        }
        // 再多加一次
        sb.append(a);
        // KMP，子串匹配
        int index = sb.indexOf(b);
        if(index == -1) return -1;
        // 如果刚好重复了res次就可以匹配，直接返回
        return index + b.length() > res * a.length()  ? res + 1 : res;
    }
}
```

