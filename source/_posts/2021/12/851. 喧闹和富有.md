---
title: 851. 喧闹和富有
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '6519'
---
# 851. 喧闹和富有

有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 "person x "。

给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自恰（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。

现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。

> 链接：https://leetcode-cn.com/problems/loud-and-rich

<!-- more -->

## 题意

该题本质上是一个图论题，quiet数组代表了图中包含的所有节点，richer数组描述了图中所有点边，因此需要先建立图（临接表或临接矩阵），之后进行搜索，找出一个节点可能到达其他节点中具有最小quiet值的节点

## 拓扑排序

```java
class Solution {
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        int n = quiet.length;
        Map<Integer, List<Integer>> map = new HashMap<>();
        int[] in = new int[n];
        // 建图，a->[b,c,d,...]
        // 采用临接表方式建图
        for (int[] r : richer) {
            int a = r[0], b = r[1];
            List<Integer> list = map.getOrDefault(a, new ArrayList<>());
            list.add(b);
            map.put(a, list);
            // 记录每个节点的入度
            in[b]++;
        }
        // 队列
        Deque<Integer> d = new ArrayDeque<>();
        int[] ans = new int[n];
        // 将所有入度为0的节点放进去
        for (int i = 0; i < n; i++) {
            ans[i] = i;
            if (in[i] == 0) d.addLast(i);
        }
        while (!d.isEmpty()) {
            int t = d.pollFirst();
            for (int u : map.getOrDefault(t, new ArrayList<>())) {
                if (quiet[ans[t]] < quiet[ans[u]]) ans[u] = ans[t];
                if (--in[u] == 0) d.addLast(u);
            }
        }
        return ans;
    }
}
```

