---
title: 401. 二进制手表
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '96e0'
date: 2021-06-23 10:58:04
---

# 401. 二进制手表

> 链接：[401. 二进制手表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/binary-watch/)

题意：

有一种手表用二进制来表示时间，小时包含4位（使用0-11），分钟包含6位（0-59），使用10个LED灯就可以表示时间，题目输入打开的LED灯数，给出所有可表示的时间

思路：仅包含小时和分钟，因此直接穷举所有的时间，判断其打开的LED灯数，给出时间表示即可

<!-- more -->

```java
class Solution {

    static int[] binaryCount = new int[60];
    static List<List<String>> res = new ArrayList<>();
    // 为了避免多次计算，第一次运行的时候把表打好，之后直接返回结果就行了
    static{
        for(int i=0;i<60;++i){
            binaryCount[i] = getBinaryCount(i);
            // System.out.println("binaryCount["+i+"] = "+binaryCount[i]);
        }
        for(int i=0;i<10;++i){
            res.add(new ArrayList<String>());
        }
        for(int h=0;h<12;++h){
            int hourCount = binaryCount[h];
            for(int m=0;m<60;++m){
                // 注意输出时间格式要求，小时不要求前导0，但是分钟前面必须有前导0
                res.get(hourCount + binaryCount[m]).add(String.format("%d:%02d",h,m));
            }
        }
    }

    public List<String> readBinaryWatch(int turnedOn) {
        // 总共有10个LED灯表示时间
        // 对于给出亮起的LED灯数，需要输出所有可行的表示时间结果
        // 一种思路是穷举所有LED表示时间的可能性，然后存储到结果中，直接返回即可，这个速度是最快的
        // 表示的时间范围 0-11h 0-59m
        // 总共包含12*60 个即 720个时间 从0:00 -> 11:59
        // 最简单的就是直接遍历720中可能性，计算其二进制表示所需的LED灯数，然后统计LED数是否等于turnedOn即可        
        return res.get(turnedOn);
    }
    
	// 这里是自己写的bitCount，属实丑了点
    static int getBinaryCount(int number){
        // 统计一个数字的二进制中1出现的次数
        int cnt = 0;
        // 思路也很简单，遍历int的每一位，判断其是否是1，最后给出1的个数即可
        for(int i=0;i<32;++i){
            if(((number >> i) & 1) != 0){
                ++cnt;
            }
        }
        return cnt;
    }
}
```

写完之后看官方题解，才发现JDK中是直接包含了求二进制中1的个数的，这里重复造轮子了，而且造出来的还是三角形的轮子

# JDK Integer.bitCount函数理解

> 这个在LeetCode上也有题目：[剑指 Offer 15. 二进制中1的个数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

> java中`>>>`运算符表示无符号右移，即移出的部分前面补充0，这样是不会改变二进制中1的个数的

```java
/**
 * Returns the number of one-bits in the two's complement binary
 * representation of the specified {@code int} value.  This function is
 * sometimes referred to as the <i>population count</i>.
 *
 * @param i the value whose bits are to be counted
 * @return the number of one-bits in the two's complement binary
 *     representation of the specified {@code int} value.
 * @since 1.5
 */
@HotSpotIntrinsicCandidate
public static int bitCount(int i) {
    // HD, Figure 5-2
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
}
```

## 执行结果解析

假设输入的i是 `0x12345678`，即

`0b 0001 0010 0011 0100 0101 0110 0111 1000`

如果将i每位上1理解成该位上1出现的次数，可以写成下面数组形式

`0 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 0 1 1 0 0 1 1 1 1 0 0 0 `

经过第一步计算结果为`0x11245564`，即

`0b 0001 0001 0010 0100 0101 0101 0110 0100`

如果将结果每两位进行观察，可以发现，这一步计算的结果刚好代表输入i上每两位所包含的1的个数

`0b 00 01 00 01 00 10 01 00 01 01 01 01 01 10 01 00`

`0 1 0 1 0 2 1 0 1 1 1 1 1 2 1 0`

经过第二步计算结果为`0x11212231`，即

`0b 0001 0001 0010 0001 0010 0010 0011 0001`

此时将结果每四位进行观察，可以发现，这一步计算的结果刚好代表输入i上每四位所包含的1的个数

`0b 0001 0001 0010 0001 0010 0010 0011 0001`

`1 1 2 1 2 2 3 1`

从这两步的结算结果不难想到，下一步应该就是计算每八位上包含的1的个数，实际上就是将结果中两两相加

`0b 00000010 00000011 00000100 00000100`

`2 3 4 4`

下一步计算每16位上包含的1的个数

本来这里代码应该写成`i = (i + (i >>> 8)) & 0x00ff00ff; `

才可以刚好得到理想结果（前十六位代表前十六中1的个数，后十六位代表后十六位的个数）

`0b 0000000000000101 0000000000001000`

`5 8`

最后就可以得到32位上包含的1的个数

代码也应该写成`i = (i + (i >>> 16)) & 0x0000ffff`

`0b 0000 0000 0000 0000 0000 0000 0000 1101`

`13`

不过在上述源码的执行过程中后两部没有抹去计算中前面十六位计算的结果，而是在最后一步直接通过`i & 0x3f`得到最终结果，如此减少了一次`&`运算，加快计算

从该算法的执行过程也可以看出，是一个不断归并的过程，从统计1位到2位，再到4位、8位，16位，最后统计32位的1的个数

# JDK Long.bitCount函数

```java
/**
 * Returns the number of one-bits in the two's complement binary
 * representation of the specified {@code long} value.  This function is
 * sometimes referred to as the <i>population count</i>.
 *
 * @param i the value whose bits are to be counted
 * @return the number of one-bits in the two's complement binary
 *     representation of the specified {@code long} value.
 * @since 1.5
 */
@HotSpotIntrinsicCandidate
public static int bitCount(long i) {
    // HD, Figure 5-2
    i = i - ((i >>> 1) & 0x5555555555555555L);
    i = (i & 0x3333333333333333L) + ((i >>> 2) & 0x3333333333333333L);
    i = (i + (i >>> 4)) & 0x0f0f0f0f0f0f0f0fL;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    i = i + (i >>> 32);
    return (int)i & 0x7f;
}
```

看懂了Integer.bitCount的执行过程后，对于Long的求解思路也是一样，通过分治思想，并行求取多位上1个个数，再将结果不断累加，最终可得该数中1的个数

执行结果抽象如下：

对于输入i

1. 将i的每2位相加
2. 将i的每4位相加
3. 将i的每8位相加
4. 将i的每16位相加
5. 将i的每32位相加（即该数二进制中包含的1的个数）

最原始的执行过程应该是

i = 0x1234

`0b 0001 0010 0011 0100`

第一步执行结果

`0b 00 01 00 01 00 10 01 00`

第二步执行结果

`0b 0001 0001 0010 0001  `

第三步执行结果

`0b 0000 0010 0000 0011`

第四步执行结果

`0b 0000 0000 0000 0101 `

