---
title: 678. 有效的括号字符串
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 818d
---
# 678. 有效的括号字符串

给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：

- 任何左括号 ( 必须有相应的右括号 )。
- 任何右括号 ) 必须有相应的左括号 ( 。
- 左括号 ( 必须在对应的右括号之前 )。

* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。

一个空字符串也被视为有效字符串。

> 链接：https://leetcode-cn.com/problems/valid-parenthesis-string

<!-- more -->

## 栈

使用两个栈分别存储 '(' 和 '\*' 的下标，分别记为left和star，然后每当碰到 ')' 时优先使用 '(' 栈中的进行匹配，如果实在没有再使用 '\*' 进行匹配，当遍历完成的时候，如果left和star不为空时，此时即为类似 '\*\*\*(((' 或 '(((\*\*\*' 这种情况，当碰到 '\*(' 时就可以直接返回 false，因为无法匹配 '(' 也就是判断 star栈中栈顶元素下标是否比left栈顶元素下标大即可

```java
class Solution {
    public boolean checkValidString(String s) {
        Stack<Integer> left = new Stack<>();
        Stack<Integer> star = new Stack<>();
        int l = s.length();
        char[] arr = s.toCharArray();
        for(int i=0;i<l;++i){
            if(arr[i] == '('){
                left.push(i);
            }else if(arr[i] == '*'){
                star.push(i);
            }else{
                if(!left.isEmpty()){
                    left.pop();
                }else if(!star.isEmpty()){
                    star.pop();
                }else{
                    // 两个栈都为空，实在没有可以匹配的，直接返回
                    return false;
                }
            }
        }
        // 最后遍历结束时候
        while(!left.isEmpty() && !star.isEmpty()){
            // 形成的是 *( 这种，没有可行的，直接返回
            if(star.peek() < left.peek()) return false;
            else{
                star.pop();
                left.pop();
            }
        }
        return left.isEmpty();
    }
}
```

## 动态规划

定义dp[i,j]表示字符串在 [i,j] 闭区间内的子串否是一个有效的括号字符串子串，按子串的长度划分初始状态

- 当长度为1的时候，'\*' 为一个有效的括号字符串
- 当长度为2的时候，'\*)'，'()'，'(\*'，'**'

之后考虑状态转移方程

dp[i,j] = dp[i+1,j-1] && (dp[i+1] == '(' || dp[i+1] == '\*') && (dp[j-1] == '\*' || dp[j-1] == ')' )

dp[i,j] = dp[i,k] && dp[k+1,j] （i到k为合法串，且k+1到j也为合法串时，两个拼接同样满足）

```java
```



## 贪心

