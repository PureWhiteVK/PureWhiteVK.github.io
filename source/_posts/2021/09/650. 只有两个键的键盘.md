---
title: 650. 只有两个键的键盘
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '5050'
date: 2021-09-19
---
# 650. 只有两个键的键盘

最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：

Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
Paste（粘贴）：粘贴 上一次 复制的字符。
给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。

> 链接：https://leetcode-cn.com/problems/2-keys-keyboard

<!-- more -->

## 动态规划

一开始直接看的话很难想到状态转移方程，那么我们先看几个简单的例子，之后逐步推导出状态转移方程。

首先可以想到使用dp[i]表示复制出i个A所需要的最小操作次数为dp[i]，那么需要考察dp[i]和之前计算好的状态之间的转移关系

由于复制是选中所有的字符进行复制，那么假设当前包含k个字符，那么复制了之后可以粘贴j-1次得到j*k个字符，通过这个我们可以想到，如果需要计算所需要的最少操作次数，我们应该从n的全部因数出发，对n进行因数分解，状态转移方程
$$
dp[i] = min(dp[j] + i / j)
$$
此处j需要满足 i % j == 0，即j是i的因子

因此我们只需要不断计算当前n的所有因子，并得出其最小值即可

```java
class Solution {
    public int minSteps(int n) {
        // 只能进行两种操作，复制和粘贴（经典CV工程师）
        int[] dp = new int[n+1];
        dp[1] = 0;
        // 如果是素数好像就只能是那么多，但是如果不是素数就可以稍微计算一手
        for(int i=2;i<=n;++i){
            // 最大可能就是i，也就是质数的情况，此时只能一个一个进行复制
            dp[i] = i;
            // 否则需要进行因数分解，然后计算出最小值？
            // 实际上大部分的时间都划分在质因数分解上面，如何快速找到这个
            for(int j=2;j<i;++j){
                if(i%j == 0){
                    // 可以整除的时候，就先凑出dp[j]，之后就全部进行复制即可
                    // 15的8次怎么来的，凑出5，然后copy，paste，paste，这样就是8次ß
                    dp[i] = Math.min(dp[i],dp[j]+i/j);
                }
            }
        }
        return dp[n];
    }
}
```

