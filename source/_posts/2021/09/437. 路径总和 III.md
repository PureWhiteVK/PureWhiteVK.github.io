---
title: 437. 路径总和III
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '4e47'
date: 2021-09-28
---
# 437. 路径总和III

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

> 链接：https://leetcode-cn.com/problems/path-sum-iii

<!-- more -->

## dfs

### 路径记录

这个题一开始还没搞明白，只想到了从根节点进行搜索的方法，后面想到可以存储访问到当前节点之前的所有路径，之后再遍历路径并求出路径和判断是否等于目标值即可

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int res;
    private int targetSum;
    public int pathSum(TreeNode root, int _targetSum) {
        res = 0;
        targetSum = _targetSum;
        // 一种暴力思路，以每个节点为根节点，搜索从该节点出发路径值为targetSum的?
        // 感觉必定会超时
        dfs(root,new ArrayList<Integer>());
        return res;
    }

    private void dfs(TreeNode root, List<Integer> path){
        if(root == null) return;
        // 向上寻找，是否有sum等于targetSum
        int sum = root.val;
        int length = path.size();
        // 从后向前进行叠加
        if(sum == targetSum) ++res;
        for(int i=length-1;i>-1;--i){
            // 必须是连续的
            sum += path.get(i);
            if(sum == targetSum) ++res;
        }
        // 添加了root.val，当前元素的下标就是length，因为长度变成length+1
        path.add(root.val);
        dfs(root.left,path);
        dfs(root.right,path);
        path.remove(length);
    } 
}
```

### 前缀和

由于树的特性，从根节点到任意一个子节点的路径都是唯一的，那么可以使用一个哈希表存储前缀和，然后可以在o(1)时间复杂度内找到所有满足条件的路径数目

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int res,targetSum;
    private Map<Integer,Integer> map;
    public int pathSum(TreeNode root, int _targetSum) {
        map = new HashMap<>();
        res = 0;
        targetSum = _targetSum;
        map.put(0,1);
        dfs(root,0);
        return res;
    }

    // 前缀和
    private void dfs(TreeNode root,int currSum){
        if(root == null) return;
        currSum += root.val;
        // currSum一定是已经加上了root.val的
        // 如果存在 currSum - targetSum的值，说明存在中间节点，是的从该节点出发到当前节点的路径和为targetSum
        if(map.containsKey(currSum - targetSum)) res += map.get(currSum-targetSum);
        map.put(currSum,map.getOrDefault(currSum,0)+1);
        dfs(root.left,currSum);
        dfs(root.right,currSum);
        map.put(currSum,map.get(currSum)-1);
    }
}
```

