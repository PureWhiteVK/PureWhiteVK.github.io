---
title: 1109. 航班预订统计
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: f3e9
date: 2021-09-17
---
# 1109. 航班预订统计

这里有 n 个航班，它们分别从 1 到 n 进行编号。

有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。

请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。

> 链接：https://leetcode-cn.com/problems/corporate-flight-bookings

<!-- more -->

## 暴力

暴力思路很简单，没什么好说的，开一个数组，然后遍历bookings，然后依次累加即可

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        // 暴力，感觉会超时
        // 外层循环为 2*10^4
        // 内层循环最多为 2*10^4
        // 从 1～n
        int[] res = new int[n];
        for(int[] b:bookings){
            // [f,l]区间内预订了s个座位，感觉没有必要逐个相加的
            int f = b[0];
            int l = b[1];
            int s = b[2];
            for(int i=f;i<=l;++i){
                res[i-1] += s;
            }
        }
        return res;
    }
}
```

这个题作为中等难度的题目，肯定不能使用暴力作为解法，还存在更有的解法

## 差分数组+前缀和

差分数组+前缀和的解题思路在区间问题上很常用，题目 1893. 检查是否区域内所有整数都被覆盖 中也有用到这个思路

在暴力解法中，我们对于区间 [f,l] 内的所有数都进行了一遍操作，这一操作的时间复杂度为o(m)，然而使用差分数组可以将这一操作时间复杂度降至 o(1) ，只需要修改两个位置的值即可 

- diff[l] += s 
- diff[r+1] -= s

下面来演示一下为什么这样做是正确的

输入 

bookings = [[1,2,10],[2,3,20],[2,5,25]]

n = 5

初始化 差分数组 diff = [0,0,0,0,0,0] 差分数组大小为 n+1，因为标记时最大需要到n

step1:

碰到区间 [1,2] ，更新diff如下

diff[0] += 10

diff[1+1] -= 10;

diff = [10,0,-10,0,0,0]

step2:

碰到区间 [2,3]，更新diff

diff[1] += 20

diff[3] -= 20

diff = [10,20,-10,-20]

step3:

碰到区间 [2,5]

diff[1] += 25

diff[5] -= 25

diff = [10,45,-10,-20,0,-25]

step4

计算diff的前缀和

prefixSum = [10,55,45,25,25,0]

原理

>注意到一个预订记录实际上代表了一个区间的增量。我们的任务是将这些增量叠加得到答案。因此，我们可以使用差分解决本题。
>
>差分数组对应的概念是前缀和数组，对于数组 \[1,2,2,4\] ，其差分数组为 \[1,1,0,2\]，差分数组的第 i 个数即为原数组的第 i-1个元素和第 i 个元素的差值，也就是说我们对差分数组求前缀和即可得到原数组。
>
>**差分数组的性质是，当我们希望对原数组的某一个区间 \[l,r\] 施加一个增量 inc 时，差分数组 d 对应的改变是：d[l] 增加 inc，d[r+1] 减少 inc。**这样对于区间的修改就变为了对于两个位置的修改。**并且这种修改是可以叠加的，即当我们多次对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。**
>
>在本题中，我们可以遍历给定的预定记录数组，每次 O(1) 地完成对差分数组的修改即可。当我们完成了差分数组的修改，只需要最后求出差分数组的前缀和即可得到目标数组。
>
>注意本题中日期从 11 开始，因此我们需要相应的调整数组下标对应关系，对于预定记录 booking=\[l,r,inc\]，我们需要让 d\[l−1] 增加 inc，d[r] 减少 inc。特别地，当 r 为 n 时，我们无需修改 d[r]，因为这个位置溢出了下标范围。如果求前缀和时考虑该位置，那么该位置对应的前缀和值必定为 0。读者们可以自行思考原因，以加深对差分数组的理解。
>
>作者：LeetCode-Solution
>链接：https://leetcode-cn.com/problems/corporate-flight-bookings/solution/hang-ban-yu-ding-tong-ji-by-leetcode-sol-5pv8/
>来源：力扣（LeetCode）
>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

*关键点：对差分数组求前缀和就可以还原出原数组，diff[i] = arr[i] - arr[i-1]

例如对于

arr =  [1,2,3,4,5,6]

diff = [1,1,1,1,1,1]

prefix = [1,2,3,4,5,6]

如果将数组 在 [1,4] 区间内的数全部增加10

arr = [1,12,13,14,15,6]

diff = [1,11,1,1,1,-9]

此时diff相对于原来的值

可以发现仅在 diff[1] 加了 10，diff[5] 减了10

再求前缀和又可以还原出数组

prefix = [1,12,13,14,15,6]

了解了差分数组这一独特的性质，再来看题目，就很明显可以看到这是一道差分数组+前缀和的经典题目

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] diff = new int[n];
      	// 进行区间更新
        for(int[] b : bookings){
            diff[b[0]-1]+=b[2];
            if(b[1] < n){
                diff[b[1]]-=b[2];
            }
        }
      	// 计算前缀和
        for(int i=1;i<n;++i){
            diff[i] += diff[i-1];
        }
        return diff;
    }
}
```

