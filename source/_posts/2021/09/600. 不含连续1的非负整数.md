---
title: 600. 不含连续1的非负整数
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 2eb0
---
# 600. 不含连续1的非负整数

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 **连续的1** 的个数。

**说明:** 1 <= n <= 109

<!-- more -->

## 暴力

逐个判断 [0,n] 内的数，是否满足条件，然后进行统计，时间复杂度o(n)，本题数据量极大，必定超时，需要考虑其他解法

```java
class Solution {
    public int findIntegers(int n) {
        // 1 <= n <= 10^9，数据量太大了
        // 先写一个暴力解法吧
        int res = 0;
        for(int i=0;i<=n;++i){
            ++res;
            for(int j=0;j<31;++j){
                // 连续两位都是1
                if(
                    (((i >> j) & 1) == 1) && 
                    (((i >> (j+1)) & 1) == 1)
                ){
                    --res;
                    break;
                }
            }
        }
        return res;
    }
}
```

## 数位DP

dp[i,j]代表长度为 i 的二进制数，其最高位为 j ( 0 或 1 ) 的合法数个数

初始条件 

- dp[1,0] = 1 (此时仅有0一个)
- dp[1,1] = 2 (此时有0、1两个合法数)

那么考虑状态转移方程，已知 dp[i,0] 的方案数，记为A，dp[i,1] 的方案数，记为B

- 对于最高位为0的情况，需要统计所有满足 (0...) 形式的合法数值，当前位的低一位只能填 1（填 0 会出现重复计数，即需要忽略前导零的数值），此时有：

  dp[i + 1,0] = dp[i,1]

- 对于最高位为1的情况，则需要统计所有满足(0...)形式和(1...)形式的合法数值（因为(0...)一定是小于(1...)的，在相同的长度情况下），因此是一定需要进行计数的

  dp[i + 1,1] = dp[i,0] + dp[i,1]

当有了预先计算好的dp数组之后，可以计算所有小于n的合法数个数

下面以30为例

初始化

n = 0b0001_1110

dp = [

​	[0,0],[1,2],[2,3],[3,5],[5,8],[8,13],[13,21],[21,34],[34,55],[55,89]

]

可以很明显的看到，该二进制数的长度为4

step1:

从第4位开始计算，由于 (n >> 4) & 1 == 1，说明该数的第4位为1，很明显可以看到，如果第4位置0，那么 dp[5,0] 是一定满足条件的，则有 res += dp[5,0] = 8 (此时增加的是 0,1,10,100,101,1000,1001,1010)

step2:

从第3位开始计算，由于 (n >> 3) & 1 == 1，说明该数的第3位为1，此时不管前一位是什么，将这一位置0，此时dp[4,0]也是一定满足条件的，有 res += dp[4,0] = 13 (此时增加的是 10000,10001,10010,10100,10101)，相当于是固定了第4位为1，第3位为0的情况下计算满足条件的个数，此时由于第4位是1，第3位也是1，当固定了第4位和第3位是1的情况下，之后的所有数都一定不满足条件，因此可以结束循环

返回所有小于 30 的不含连续1的非负整数个数为13，分别是 0,1,10,100,101,1000,1001,1010,10000,10001,10010,10100,10101

```java
class Solution {
    static int N = 50;
    // f[i][j] 为考虑二进制长度为 i，而且最高位为 j（0 or 1）时的合法数个数
    static int[][] f = new int[N][2];
    static {
        f[1][0] = 1; f[1][1] = 2;
        for (int i = 1; i < N - 1; i++) {
            f[i + 1][0] = f[i][1];
            f[i + 1][1] = f[i][0] + f[i][1];
        }
    }
    int getLen(int n) {
      	// 从最高位开始判断，找到第一个为1的位置即为该二进制数的长度
        for (int i = 31; i >= 0; i--) {
            if (((n >> i) & 1) == 1) return i;
        }
        return 0;
    }
    public int findIntegers(int n) {
        int len = getLen(n);
        int ans = 0, prev = 0;
        for (int i = len; i >= 0; i--) {
            // 当前位是 0 还是 1
            int cur = ((n >> i) & 1); 
            // 如果当前位是 1，那么填 0 的话，后面随便填都符合，将方案数累加
            if (cur == 1) ans += f[i + 1][0]; 
            // 出现连续位为 1，分支结束，方案数被计算完
            if (prev == 1 && cur == 1) break; 
            prev = cur;
            if (i == 0) ans++;
        }
        return ans;
    }
}
```



## 动态规划

从前一个解法的示例中可以看出，所有小于等于30的不含连续1的非负整数的个数为13，其分别是

0,1,10,100,101,1000,1001,1010,10000,10001,10010,10100,10101

我们可以看到

长度为1的不含连续1的非负整数的个数为2，

长度为2的不含连续1的非负整数的个数为3，

长度为3的不含连续1的非负整数的个数为5，

长度为4的不含连续1的非负整数的个数为8，

长度为5的不含连续1的非负整数的个数为13，

很明显这是一个斐波那契数列，那么满足

dp[n] = dp[n-1] + dp[n-2]

那么，知道这个条件之后，再计算所有小于等于n的不含连续1的非负整数的个数为多少

以3000为例，其二进制为 0b1011_1011_1000

dp = [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597]

在计算过程中实际上和数位dp的过程已知，当遍历的该位是1时，那么将该位置0的（即长度为i-1）的所有都可以计算，

即需要加上dp[i-1]，之后再计算下一位的时候则将该位置1（因为置0的已经计算过了）

```java
class Solution {
    public int findIntegers(int n) {
        int[] dp = new int[31];
        dp[0] = dp[1] = 1;
        for (int i = 2; i < 31; ++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        int pre = 0, res = 0;
        for (int i = 29; i >= 0; --i) {
            int val = 1 << i;
            if ((n & val) != 0) {
                System.out.println(dp[i+1]);
                res += dp[i + 1];
                if (pre == 1) {
                    break;
                }
                pre = 1;
            } else {
                pre = 0;
            }

            if (i == 0) {
                ++res;
            }
        }

        return res;
    }
}
```

