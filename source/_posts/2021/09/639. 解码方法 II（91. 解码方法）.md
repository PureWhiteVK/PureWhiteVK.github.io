---
title: 91. 解码方法
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: a9a4
---
# 91. 解码方法

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```

要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 **非空** 字符串 s ，请计算并返回 **解码** 方法的 总数 。

题目数据保证答案肯定是一个 **32 位** 的整数。

> 链接：https://leetcode-cn.com/problems/decode-ways

<!-- more -->

## 动态规划

这个题是一个很经典的动态规划题，字符编码主要有两种情况，长度为1和长度为2，长度为1的是 '1'~'9'，长度为2的则是 '10' ～ '26'，除此之外的都是不合法的，因此只需要考虑字符串中单个字符和两个字符能否组成字母即可

使用dp[i]表示字符串在 [0,i) 的子串共包含多少种解码方式，状态转移方程

需要观察 s[i-1]和s[i]的情况，

- 如果 s[i-1]和s[i]可以组成一个单词，那么其对应的解码方式为 dp[i-2]，
- 如果将这个两个分开来看的话，其对应的解码方式为 dp[i-1]

了解了基本情况之后，需要考虑特殊情况

- 如果当前字符为 '0'，由于 '0' 不存在对应的字符，需要配合前一个字符一起组成字符（'10'或'20')，对应的解码方式为 dp[i-2]，否则就是无法解码（直接返回0）
- 如果前一个字符为 '0'，那么如果当前字符也为 '0'，此时无法解码，直接返回 0，此时只能由单个字符组成字母，对应解码方式为 dp[i-1]

```java
class Solution {
    public int numDecodings(String s) {
        int l = s.length();
        int[] dp = new int[l+1];
        dp[0] = 1;
        char prev = '\0';
        char curr;
        for(int i=1;i<=l;++i){
            curr = s.charAt(i-1);
            if(prev == '0'){
                if(curr == '0') return 0;
                dp[i] = dp[i-1];
            }else if(prev == '1'){
              	// 10，且只有这一种解码方式
                if(curr == '0') dp[i] = dp[i-2];
                // 11~19
              	else dp[i] = dp[i-1] + dp[i-2];
            }else if(prev == '2'){
              	// 20，且只有这一种解码方式
                if(curr == '0') dp[i] = dp[i-2];
              	// 21~26
                else if(curr >= '1' && curr <= '6') dp[i] = dp[i-1] + dp[i-2];
                else dp[i] = dp[i-1];
            }else{
              	// 30等，不存在对应的解码方式，直接返回0
                if(curr == '0') return 0;
              	// 只能单独解码
                dp[i] = dp[i-1];
            }
            prev = curr;
        }
        return dp[l];
    }
}
```

实际上从状态转移方程中可以看到，dp[i]的结果仅与 dp[i-1]和dp[i-2]有关，可以不用数组进行存储，只存储两个值，然后不断更新即可

# 639. 解码方法 II

一条包含字母 A-Z 的消息通过以下的方式进行了编码：

```
'A' -> 1
'B' -> 2
...
'Z' -> 26
```


要 **解码** 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106" 可以映射为：

- "AAJF" 对应分组 (1 1 10 6)
- "KJF" 对应分组 (11 10 6)

注意，像 (1 11 06) 这样的分组是无效的，因为 "06" 不可以映射为 'F' ，因为 "6" 与 "06" 不同。

**除了** 上面描述的数字字母映射方案，编码消息中可能包含 '\*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）。例如，编码字符串 "1\*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条消息。对 "1\*" 进行解码，相当于解码该字符串可以表示的任何编码消息。

给你一个字符串 s ，由数字和 '\*' 字符组成，返回 **解码** 该字符串的方法 数目 。

由于答案数目可能非常大，返回对 10<sup>9</sup> + 7 取余 的结果。

> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/decode-ways-ii
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 动态规划

这一题是上一题的变种，就是在解码中添加了一个可代表 '1'～'9'的'*'，从而使得解码方式更多，但是解题思路是一样的，由于构成字母的字符只有可能是 '1'~'26'中一个，那么可行的长度要么为1要么为2，因此我们只需要考虑情况前一个字符和当前字符能否组成字母，且有多少种组合方式即可

同样使用 dp[i]表示字符串[0,i)中所有的可行解码方式

- 如果将s[i-1]和s[i]组合成一个字母的话，对应的编码方式为 dp[i-2] * (counts(s[i-1]+s[i]))

  counts(s[i-1]+s[i])表示s[i-1]和s[i]组成一个字母对应的所有可行解码方式

- 如果将s[i-1]和s[i]分成两个字母的话，对应的编码方式为 dp[i-1] * (counts(s[i]))

  counts(s[i])表示s[i]单独看成一个字母对应的所有可行解码方式

接下来分析所有可行的解码方式

考查s[i-1]（记为prev）和s[i]（记为curr），所有的取值为 '*'、'0'~'9'

- 如果prev为 '*'

  - 如果curr为'*'

    分开看对应的解码方式为dp[i-1]*9

    如果组合起来一起看的话，那么只有 prev为 '1'，curr可以为'1'~'9'（此时包含9种），当prev为'2'时，curr可以为'1'~'6'（此时包含6种）合起来可行的解码方式为 dp[i-2] * 15

    因此 dp[i] = dp[i-1] * 9 + dp[i-2] * 15

  - 如果curr为'0'

    此时只能组合起来看，且 prev只能取 '2','1'，因此就2种取法

    dp[i] = dp[i-2] * 2

  - 如果curr为 '1'~'6'，当组合一起看的话，可以有 '11','21'两种，也可以单独看

    dp[i] = dp[i-1] + dp[i-2] * 2

  - 如果curr为'7'~'9'，当组合一起看的话，只有 '17'一种

    dp[i] = dp[i-1] + dp[i-2]

- 如果prev为 '0'

  - 如果curr为'*'

    此时只能分开看，因此dp[i] = dp[i-1] * 9

  - 如果curr为 '1'~'9'，此时也只能分开看，dp[i] = dp[i-1]

  - 如果curr为'0'，此时碰到了两个连续的0，无法进行解码，直接返回0

- 如果prev为'1'

  - 如果curr为'\*'，分开看包含dp[i-1]*9种解码方式，组合一起看包含dp[i-2]\*9，因此

    dp[i] = dp[i-1] * 9 + dp[i-2] * 9

  - 如果curr为'1'~'9'，分开看就是 dp[i-1]中，组合一起看就是 dp[i-2]种

    dp[i] = dp[i-1] + dp[i-2]

  - 如果curr为'0'，此时只能组合一起看

    dp[i] = dp[i-2]

- 如果prev为'2'

  - 如果curr为'\*'，分开看包含dp[i-1]*9种，组合一起看包含dp[i-2]\*6

    dp[i] = dp[i-1]*6+dp[i-2]\*9

  - 如果curr为'1'~'6'，分开看dp[i-1]种，组合一起看dp[i-2]

    dp[i] = dp[i-2] + dp[i-2]

  - 如果curr为 '7' ~ '9'，此时只能分开看

    dp[i] = dp[i-1]

  - 如果curr为'0'，此时只能组合一起看

    dp[i] = dp[i-2]

- 如果prev为其他值'3'~'9'

  - 如果curr为 '*'，只能分开看

    dp[i] = dp[i-1]*9

  - 如果curr为'0'，此时无法进行解码，直接返回0

  - 如果为其他值，也只能分开看

    dp[i] = dp[i-1]

写出了状态转移方程之后，就可以很轻松的写出代码

```java
class Solution {
    private static final int MOD = (int)(1e9+7);
    public int numDecodings(String s) {
        // 动态规划
        int l = s.length();
      	// 此处存储结果的时候必须要使用long，由于乘法计算是有可能超出int的表示范围，此时再对ie9+7取模也是没有用的
        long[] dp = new long[l+1];
        dp[0] = 1;
        char prev = '\0';
        char curr;
        for(int i=1;i<=l;++i){
            // 相乘的时候是有可能溢出的
            curr = s.charAt(i-1);
            if(prev == '*'){
                if(curr == '*'){
                    // **
                    dp[i] = ((dp[i-1]*9)%MOD+(dp[i-2]*15)%MOD)%MOD;
                }else if(curr == '0'){
                    // *0
                    dp[i] = (dp[i-2] * 2) % MOD;
                }else if(curr >= '1' && curr <= '6'){
                    // *1 ～ *6
                    dp[i] = (dp[i-1]+(dp[i-2]*2)%MOD)%MOD;
                }else{
                    // *7 ～ *9
                    dp[i] = (dp[i-1]+dp[i-2]) % MOD;
                }
            }else if(prev == '0'){
                if(curr == '*'){
                    dp[i] = (dp[i-1] * 9) % MOD;
                }else if(curr == '0'){
                    return 0;
                }else{
                    dp[i] = dp[i-1];
                }
            }else if(prev == '1'){
                if(curr == '*'){
                    dp[i] = ((dp[i-1]*9)%MOD+(dp[i-2]*9)%MOD)%MOD;
                }else if(curr == '0'){
                    dp[i] = dp[i-2];
                }else{
                    dp[i] = (dp[i-1] + dp[i-2]) % MOD;
                }
            }else if(prev == '2'){
                if(curr == '*'){
                    dp[i] = ((dp[i-1]*9)%MOD+(dp[i-2]*6)%MOD)%MOD;
                }else if(curr == '0'){
                    dp[i] = dp[i-2];
                }else if(curr >= '1' && curr <= '6'){
                    dp[i] = (dp[i-1] + dp[i-2]) % MOD;
                }else{
                    dp[i] = dp[i-1];
                }
            }else{
                if(curr == '*'){
                    dp[i] = (dp[i-1] * 9) % MOD;
                }else if(curr == '0'){
                    return 0;
                }else{
                    dp[i] = dp[i-1];
                }
            }
            prev = curr;
        }
        return (int)dp[l];
    }
}
```

同样，从状态转移方程中可以看到，dp[i]仅和dp[i-1]和dp[i-2]相关，因此可以只使用两个数，然后不断更新，将空间压缩至o(1)
