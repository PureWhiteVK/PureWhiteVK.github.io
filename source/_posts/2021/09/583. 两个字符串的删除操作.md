---
title: 583. 两个字符串的删除操作
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: a0e8
date: 2021-09-25
---
# 583. 两个字符串的删除操作

给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

> [583. 两个字符串的删除操作 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

<!-- more -->

## 动态规划

这个题实际上是在求两个字符串的最长公共子序列，只需要求出最长公共子序列的长度，就可以直接得出最少的删除次数

dp[i,j]表示word1[0:i-1]的子序列中和word2[0:j-1]的子序列中相同长度最长的，状态转移方程

当 word1[i] == word2[j] 时，就只需要计算dp[i-1,j-1]中最长子序列长度
$$
dp[i,j] = Math.max(dp[i-1,j-1]+1,dp[i,j])
$$
当word1[i] != word2[j] 时，此时最长公共子序列一定在 dp[i,j-1] 和 dp[i-1,j]之中
$$
dp[i,j] = Math.max(dp[i-1,j],dp[i,j-1])
$$

 ```java
 class Solution {
     public int minDistance(String word1, String word2) {
         // 求出两个字符串的最长公共子序列即可
         // dp[i][j]代表word1[0:i-1]中任意长度的子序列和word2[0:j-1]中任意长度的子序列的最长公共子序列长度
         int l1 = word1.length();
         int l2 = word2.length();
         int[][] dp = new int[l1+1][l2+1];
         char[] w1 = word1.toCharArray();
         char[] w2 = word2.toCharArray();
         for(int i=1;i<=l1;++i){
             for(int j=1;j<=l2;++j){
                 if(w1[i-1] == w2[j-1]){
                     dp[i][j] = Math.max(dp[i-1][j-1]+1,dp[i][j]); 
                 }else{
                     dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                 }
             }
         }
       	// 最终word1和word2都需要删除值dp[l1][l2]的长度，那么需要删除的字符数减去即可
         return l1+l2-(dp[l1][l2]<<1);
     }
 }
 ```



