---
title: 673. 最长递增子序列的个数
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 1f1b
date: 2021-09-20
---
# 673. 最长递增子序列的个数

给定一个未排序的整数数组，找到最长递增子序列的个数。

> [673. 最长递增子序列的个数 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

<!-- more -->

## 动态规划

## 300. 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/longest-increasing-subsequence
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

这一题需要计算出数组中最长递增子序列的长度，使用动态规划进行计算，dp[i]表示以nums[i]结尾的最长递增子序列长度
$$
dp[i] = Math.max(dp[j]+1,dp[i])
$$

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        int res = 1;
        dp[0] = 1;
        for(int i=1;i<nums.length;++i){
            // 此处初始化dp[i] = 1是必须的
            dp[i] = 1;
            for(int j=0;j<i;++j){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[j]+1,dp[i]);
                }
            }
            res = Math.max(res,dp[i]);
        }
        return res;
    }
}
```

那么回到这一题，我们需要计算出最长递增子序列的个数，通过前一个算法我们可以计算出最长递增子序列的长度，为计算出所有的个数，我们还需要添加一个数组来计算最长递增子序列的长度，使用count[i]表示以nums[i]即为的最长递增子序列的个数

那么对于counts[i]的状态转移方程

counts[i] = counts[j]  if nums[j] < nums[i] && dp[i] < dp[j] + 1

counts[i] += counts[j] if nums[j] < nums[i] && dp[i] == dp[j] + 1

下面以数组 [1,3,5,4,7 ] 来介绍计算过程

初始化

dp = [0,0,0,0,0]

counts = [0,0,0,0,0]

step1:

i = 0

dp[0] = 1 ,代表子序列 [1]

coutns[0] = 1

step2:

i = 1

nums[i] > nums[i-1]

dp[1] = dp[0] + 1 = 2, 代表子序列 [1,3]

counts[1] = 1

step3:

i = 2

nums[i] > nums[i-1]

dp[2] = dp[1] + 1 = 3, 代表子序列 [1,3,5]

counts[2] = 1

step4:

i = 3

nums[i] < nums[i-1]

dp[3] = dp[1] + 1 = 3 ，代表子序列 [1,3,4]

counts[2] = 1

step5:

i = 4

nums[i] > nums[i-1]

dp[4] = dp[2] + 1 = 4，代表子序列 [1,3,5,7]

counts[4] = 1

此时 dp[4] 同样满足 dp[4] = dp[3] + 1 ，对应子序列 [1,3,4,7]

counts[4] += counts[3]

counts[4] = 2

遍历结束，返回最终结果2

```java
class Solution {
    public int findNumberOfLIS(int[] nums) {
        int n = nums.length;
        // f[i]表示以nums[i]结尾的最长子序列长度
        // g[i]表示以nums[i]结尾的最长子序列个数
        int[] f = new int[n], g = new int[n];
        int max = 1;
        for (int i = 0; i < n; i++) {
            f[i] = g[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    if (f[i] < f[j] + 1) {
                        f[i] = f[j] + 1;
                        g[i] = g[j];
                    } else if (f[i] == f[j] + 1) {
                        g[i] += g[j];
                    }
                }
            }
          	// 记录最长子序列的长度
            max = Math.max(max, f[i]);
        }
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (f[i] == max) ans += g[i];
        }
        return ans;
    }
}
```

