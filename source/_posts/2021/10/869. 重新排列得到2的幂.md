---
title: 869. 重新排列得到2的幂
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 266d
---
# 869. 重新排列得到2的幂

给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。

> 链接：https://leetcode-cn.com/problems/reordered-power-of-2

<!-- more -->

## DFS+剪枝

首先看到题目中提到将数字重新排序，很容易想到将数字转换成字符串，然后求其全排列，判断全排列中是否存在一种排列是二的幂次即可

```java
class Solution {
    private static final Map<Integer,List<String>> map;
    static {
        map = new HashMap<>();
        for(int i=0;i<32;++i){
            int val = 1 << i;
            String valStr = String.valueOf(val);
            int length = valStr.length();
            List<String> list = map.getOrDefault(length,new ArrayList<>());
            list.add(valStr);
            map.put(length,list);
        }
    }

    // 存储二的幂次对应的字符串
    private Set<String> availPowerOf2;
    // 存储每个位置可能的值
    private List<Set<Character>> availNum;
    private boolean[] visited;
    private int l;
    private char[] charArr;
    public boolean reorderedPowerOf2(int n) {
        // 首先将n转换成字符串再说吧
        String num = String.valueOf(n);
        charArr = num.toCharArray();
        l = num.length();
        visited = new boolean[l];
        availPowerOf2 = new HashSet<>();
        availPowerOf2.addAll(map.get(l));
        availNum = new ArrayList<>();
        for(int i=0;i<l;++i){
            Set<Character> set = new HashSet<>();
            for(String s:availPowerOf2){
                set.add(s.charAt(i));
            }
            availNum.add(set);
        }
        return dfs(0,new StringBuilder());
    }

    private boolean dfs(int currIndex,StringBuilder sb){
        // System.out.println(s);
        if(sb.length() == l){
            return availPowerOf2.contains(sb.toString());
        }
        // 开始遍历
        boolean res = false;
        for(int i=0;i<l;++i){
            char ch = charArr[i];
            if(!visited[i] && availNum.get(currIndex).contains(ch)){
                visited[i] = true;
                sb.append(ch);
                if(dfs(currIndex+1,sb)){
                    res = true;
                    break;
                }
                sb.deleteCharAt(currIndex);
                visited[i] = false;
            }
        }
        return res;
    }
}
```



## 词频统计

实际上，如果一个一个数的排列可以变成二的幂次，那么将这两个数中每一位数字出现次数一定是一样的

```java
class Solution {
    private static final Map<Integer,List<int[]>> map;
    static {
        map = new HashMap<>();
        for(int i=0;i<30;++i){
            int val = 1 << i;
            String valStr = String.valueOf(val);
            int length = valStr.length();
            List<int[]> list = map.getOrDefault(length,new ArrayList<>());
            list.add(count(valStr));
            map.put(length,list);
        }
    }

    public boolean reorderedPowerOf2(int n) {
        // 首先将n转换成字符串再说吧
        String num = String.valueOf(n);
        int[] countNum = count(num);
        for(int[] powerOf2 : map.get(num.length())){
            if(check(powerOf2,countNum)) return true;
        }
        return false;
    }

    private static int[] count(String s){
        System.out.println(s);
        int[] res = new int[10];
        for(char ch:s.toCharArray()){
            ++res[ch-'0'];
        }
        return res;
    }

    private static boolean check(int[] a1,int[] a2){
        for(int i=0;i<10;++i){
            if(a1[i] != a2[i]) return false;
        }
        return true;
    }
}
```

