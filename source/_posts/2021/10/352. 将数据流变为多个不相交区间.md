---
title: 352. 将数据流变为多个不相交区间
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: b
---
# 352. 将数据流变为多个不相交区间

 给你一个由非负整数 a1, a2, ..., an 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。

实现 SummaryRanges 类：

- `SummaryRanges()` 使用一个空数据流初始化对象。
- `void addNum(int val)` 向数据流中加入整数 val 。
- `int[][] getIntervals()` 以不相交区间 [starti, endi] 的列表形式返回对数据流中整数的总结。

> 链接：https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals

<!-- more -->

## 二分查找+模拟

首先题目要求是根据输入的整数，将这些整数划分到不同区间内，例如 [1,2,3,5,6,7] 就可以划分为两个区间 [1,3] 和 [5,7]

那么对于下一个待插入的整数，我们可以使用二分查找找到其所在的位置，然后判断其前一个和后一个的区间，然后插入即可

```java
class SummaryRanges {
    List<int[]> list = new ArrayList<>();
    int[] head = new int[]{-10, -10}, tail = new int[]{10010, 10010};
    public SummaryRanges() {
        list.add(head);
        list.add(tail);
    }
    public void addNum(int val) {
        int n = list.size();
        int l = 0, r = n-1;
      	// 注意此处一定 r = n-1，因为我们之后需要读取p对应的下标，如果r == n的话，就会取不到值
        while (l < r) {
            int mid = (l + r + 1) >> 1;
            if (list.get(mid)[0] > val) r = mid-1;
            else l = mid;
        }
        int[] cur = new int[]{val, val};
        int[] prev = list.get(r);
        int[] next = list.get(r+1);
        if ((prev[0] <= val && val <= prev[1]) || (next[0] <= val && val <= next[1])) {
            // pass
        } else if (prev[1] + 1 == val && val == next[0] - 1) {
            prev[1] = next[1];
            list.remove(next);
        } else if (prev[1] + 1 == val) {
            prev[1] = val;
        } else if (next[0] - 1 == val) {
            next[0] = val;
        } else {
            list.add(r + 1, cur);
        }
    }
    public int[][] getIntervals() {
        int n = list.size();
        int[][] ans = new int[n - 2][2];
        int idx = 0;
        for (int i = 1; i < n - 1; i++) ans[idx++] = list.get(i);
        return ans;
    }
}
```

## 并查集

由于数据范围并不大，我们可以使用一个长度为10001的数组，来存储当前数字的右边界，这样我们遍历的时候只需要不断找左右边界即可

下面举例实现，假设我们数据范围就是10

流数据为 [1,5,7,3,2,6]

**初始化**

arr = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]

**step1**:

当前数据为1，且此时 arr[1] = -1，表示其父节点并不存在，那么其右节点就是其本身

更新 arr[1] = 1

arr =  [-1,1,-1,-1,-1,-1,-1,-1,-1,-1]

**step2**:

当前数据为5，且此时 arr[5] = -1，表示其父节点并不存在，那么其右节点就是其本身

更新 arr[5] = 5

arr =  [-1,1,-1,-1,-1,5,-1,-1,-1,-1]

**step3**:

当前数据为7，且此时 arr[7] = -1，表示其父节点并不存在，那么其右节点就是其本身

更新 arr[7] = 7

arr =  [-1,1,-1,-1,-1,5,-1,7,-1,-1]

**step4**:

当前数据为3，且此时 arr[3] = -1，表示其父节点并不存在，那么其右节点就是其本身

更新 arr[3] = 3

arr =  [-1,1,-1,3,-1,5,-1,7,-1,-1]

**step5**:

当前数据为2，且此时 arr[2] = -1，表示其父节点并不存在，那么其右节点就是其本身

更新 arr[2] = 2

arr =  [-1,1,-1,3,-1,5,-1,7,-1,-1]

但此时我们发现可以进行合并

arr = [-1,3,3,3,-1,5,-1,7,-1,-1]

**step6**:

当前数据为6，且此时 arr[6] = -1，表示其父节点并不存在，那么其右节点就是其本身

更新 arr[6] = 6

arr =  [-1,3,3,3,-1,5,6,7,-1,-1]

但此时我们发现可以进行合并

arr = [-1,3,3,3,-1,7,7,7,-1,-1]

// 但是如果此时我们插入一个4的话，数字就变成 1，2，3，4，5，6，7最终数据范围为

这种变化并不是一次就可以完成的，而是在FIND的过程中进行路径压缩后实现的

arr = [-1,7,7,7,7,7,7,7,-1,-1]



### 并查集（普通版）

```java
class SummaryRanges {
    private static final int N = 10010;
    private static final int[] arr = new int[N];
    public SummaryRanges() {
        Arrays.fill(arr,-1);
    }
    
    public void addNum(int val) {
        if(arr[val] == -1){
            arr[val] = val;
          	// 合并连续区间 实际上代表的区间就是 [val,arr[val]] [val+1,arr[val+1]]
          	// 当val+1存在时就可以进行合并
            UNION(val,val+1);
          	// 同理，合并区间
            UNION(val-1,val);
        }
    }

    private int FIND(int val){
        if(arr[val] == -1) return -1; 
        int root = val;
        while(arr[root] != root){
            root = arr[root];
        }
        // 路径压缩
        while(arr[val] != val){
            int next = arr[val];
            arr[val] = root;
            val = next;
        }
        return root;
    }

    private void UNION(int a,int b){
      	// 这里调用的时候一定是 a < b，实际上只需要判断 a是否小于-1即可
        if(a < 0) return;
        int rootA = FIND(a);
        int rootB = FIND(b);
        if(rootA == -1 || rootB == -1) return;
      	// 由于 a < b，那么rootA一定是小于rootB的，只需要更新arr[a]即可
        arr[a] = rootB;
    }
    
    public int[][] getIntervals() {
        List<int[]> list = new ArrayList<>();
        for (int i = 0; i < N;) {
            if (arr[i] != -1) {
                int start = i;
                // 快速找到右边界
                int end = FIND(i);
                list.add(new int[] {start, end});
                i = end + 1;
            } else {
                i++;
            }
        }
        return list.toArray(new int[list.size()][2]);
    }
}

/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges obj = new SummaryRanges();
 * obj.addNum(val);
 * int[][] param_2 = obj.getIntervals();
 */
```

### 并查集+集合

在普通版的并查集中，我们需要遍历可能的左边界来的出最后结果，实际上我们可以使用set来存储左边界，这样就可以快速得出所有区间

```java
class SummaryRanges {
    private static final int N = 10010;
    private static final int[] arr = new int[N];
    private Set<Integer> set;
    public SummaryRanges() {
        Arrays.fill(arr,-1);
        set = new TreeSet<>();
    }
    
    public void addNum(int val) {
        if(arr[val] == -1){
            arr[val] = val;
            set.add(val);
            UNION(val,val+1);
            UNION(val-1,val);
        }
    }

    private int FIND(int val){
        if(arr[val] == -1) return -1; 
        int root = val;
        while(arr[root] != root){
            root = arr[root];
        }
        // update, path compress
        while(arr[val] != val){
            int next = arr[val];
            arr[val] = root;
            val = next;
        }
        return root;
    }

    private void UNION(int a,int b){
        // 此处一定是 a < b，那么rootA 一定小于 rootB
        if(a<0) return;
        int rootA = FIND(a);
        int rootB = FIND(b);
        if(rootA == -1 || rootB == -1) return;
        arr[a] = rootB;
      	// 当a和b可以进行合并的时候，那么a可能是左边界，但是b一定不是左边界
        // 此时b一定不是左边界
        set.remove(b);
    }
    
    public int[][] getIntervals() {
        // System.out.println(set);
        int[][] res = new int[set.size()][2];
        int i = 0;
        for(int start:set){
            res[i] = new int[]{start,FIND(start)};
            ++i;
        }
        return res;
    }
}

/**
 * Your SummaryRanges object will be instantiated and called as such:
 * SummaryRanges obj = new SummaryRanges();
 * obj.addNum(val);
 * int[][] param_2 = obj.getIntervals();
 */
```

