---
title: 282. 给表达式添加运算符
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: ffea
---
# 282. 给表达式添加运算符

给定一个仅包含数字 0-9 的字符串 num 和一个目标值整数 target ，在 num 的数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。

> 链接：https://leetcode-cn.com/problems/expression-add-operators

<!-- more -->

## 暴力

这个题没什么好说的，只能暴力枚举出所有的表达式，然后逐个计算其值是否等于目标值

首先考虑放置符号的位置，设num的长度为n，那么n个数之间共有n-1个位置可以插入运算符，一共有四种可选的运算符，加、减、乘、空（不放置），因此所有可能的表达式的值为 4<sup>n-1</sup>种，那么我们只需要计算出所有表达式即可，这个过程可以使用dfs进行搜索

还有一种思路就是在枚举的过程中计算表达式的值（记忆化搜索思路，加快计算），同时构造表达式的时候需要使用StringBuilder，直接使用String构造字符串效率太低

```java
class Solution {
    private List<String> res;
    private String num;
    private int target;
    private int l;
    public List<String> addOperators(String _num, int _target) {
        // 没什么好说的，这个题就是一个暴力搜索的题，但是需要进行优化
        res = new ArrayList<>();
        num = _num;
        l = num.length();
        target = _target;
        dfs(0,0L,0L,new StringBuilder());
        return res;
    }
	// 同时记录了前一个值和当前表达式的值
    private void dfs(int currPos,long currRes,long prevValue,StringBuilder sb){
        if(currPos == l && currRes == target){
            res.add(sb.toString());
            return;
        }
        // 使用StringBuilder记录，防止频繁进行字符串操作
        int originLength = sb.length();
        if(currPos > 0){
            sb.append('\0');
        }
        long currValue = 0;
        for(int i=currPos;i<l;++i){
            // 对于 05 这种是不行的
            if(i!=currPos && num.charAt(currPos) == '0') return;
            char currChar = num.charAt(i);
            sb.append(currChar);
            currValue = currValue * 10 + (currChar-'0');
            if(currPos==0){
                // 确定第一个数
                dfs(i+1,currValue,currValue,sb);
            }else{
                // 确定之后的数，然后在currPos之间插入运算符
                sb.setCharAt(originLength,'+');
                dfs(i+1,currRes+currValue,currValue,sb);
                sb.setCharAt(originLength,'-');
                dfs(i+1,currRes-currValue,-currValue,sb);
                long mul = prevValue * currValue;
                sb.setCharAt(originLength,'*');
                dfs(i+1,currRes-prevValue+mul,mul,sb);
            }
        }
        sb.setLength(originLength);
    }
}
```

