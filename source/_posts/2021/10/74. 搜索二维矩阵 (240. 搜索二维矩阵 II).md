---
title: 240. 搜索二维矩阵 II
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 3bb7
---
# 240. 搜索二维矩阵 II

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

> 链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii

这题还有一个条件更强的前置题 `74. 搜索二维矩阵`

其每行中的整数从左到右按升序排列，且每行第一个整数大于前一行最后一个整数

<!-- more -->

## 暴力

没什么好说的，直接遍历矩阵中的每一个元素，检查是否相等即可

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // 从右上角开始搜索？
        // 如果直接暴力
        // o(m*n)
        int m = matrix.length;
        int n = matrix[0].length;
        for(int i=0;i<m;++i){
            for(int j=0;j<n;++j){
                if(matrix[i][j] == target) return true;
            }
        }
        return false;
    }
}
```

时间复杂度：o(m*n)

空间复杂度：o(1)

## 暴力+二分查找

由于矩阵按行、按列都是升序排列，很容易想到二分查找，那么我们只需要按行或者含列进行即可

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        for(int[] num:matrix){
            if(binarySearch(num,target)) return true;
        }
        return false;
    }

    private boolean binarySearch(int[] num,int target){
        int l = 0;
        int r = num.length - 1;
        while(l<r){
            int mid = (l+r+1) >> 1;
            if(num[mid] > target){
                r = mid - 1;
            }else{
                l = mid;
            }
        }
        return num[l] == target;
    }
}
```

*注：关于二分查找的边界情况，还需要仔细考虑（否则容易出现死循环）

## 抽象BST

> [【宫水三叶】一题双解 :「二分」&「抽象 BST」 - 搜索二维矩阵 II - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-y1ns/)

可以将矩阵抽象为以右上角为根的二叉搜索树，然后套用二叉树性质进行搜索即可

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;
        int r = 0;
        int c = n-1;
        while(r < m && c > -1){
            // 每次都以当前节点为根节点，判断target位于其左子树还是右子树上
            if(matrix[r][c] == target) return true;
            else if(matrix[r][c] >target) --c;
            else ++r;
        }
        return false;
    }
}
```

