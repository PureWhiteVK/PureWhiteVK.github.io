---
title: 187. 重复的DNA序列
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: de11
date: 2021-10-08
---
# 187. 重复的DNA序列

所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T' 的核苷酸组成，例如："ACGAATTCCG"。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。

编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。

> 链接：https://leetcode-cn.com/problems/repeated-dna-sequences

<!-- more -->

## 解题思路

思路很简单，遍历所有的子串，统计子串出现的次数，将所有出现次数大于1的子串即可

那么现在问题的核心在于，如何确定合适的哈希函数，使得我们能在o(1)时间复杂度内计算出对应字符子串的哈希值

由于本题字符子串的长度并不大，且仅包含四种字符，不难想到两种哈希方式

- 直接使用字符串（使用的实际上是字符串的hashCode()函数）
- 位运算（四种碱基可以使用两位二进制来代替，而目标子串长度为10，只需要20位就可以表示该字符子串，也是可行的

如果目标子串的长度变为100，那么位运算和直接使用字符串来计算哈希值的代价太高，需要使用其他方法

> [【宫水三叶】一题双解 :「滑动窗口」&「字符串哈希」 - 重复的DNA序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/)

其中利用质数幂的性质

子串长度为 10，因此上述解法的计算量为 10^6 

若题目给定的子串长度大于 100 时，加上生成子串和哈希表本身常数操作，那么计算量将超过 10^7会 TLE。

因此一个能够做到严格 O(n) 的做法是使用「字符串哈希 + 前缀和」。

具体做法为，我们使用一个与字符串 s 等长的哈希数组 h[]，以及次方数组 p[]。

由字符串预处理得到这样的哈希数组和次方数组复杂度为 O(n)。当我们需要计算子串 s[i...j]的哈希值，只需要利用前缀和思想 

h[j] - h[i - 1] * p[j - i + 1]

即可在 O(1) 时间内得出哈希值（与子串长度无关）。

作者：AC_OIer
链接：https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 哈希表+滑动窗口

### 字符串直接哈希

```java
class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        // 长度为10^5，肯定不能用暴力
        // 总共子串的长度为 s.length() - 10
        Map<String,Integer> map = new HashMap<>();
        StringBuilder window = new StringBuilder();
        List<String> res = new ArrayList<>();
        int l = s.length();
        if(l < 11) return res;
        window.append(s.substring(0,10));
        map.put(window.toString(),1);
        for(int i=10;i<l;++i){
            // 删除首位
            window.deleteCharAt(0);
            window.append(s.charAt(i));
            String curr = window.toString();
            map.put(curr,map.getOrDefault(curr,0)+1);
        }
        for(Map.Entry<String,Integer> entry :map.entrySet()){
            if(entry.getValue() > 1){
                res.add(entry.getKey());
            }
        }
        return res;
    }
}
```

### 位运算哈希

```java
class Solution {
    // 位运算+哈希表+滑动窗口
    private static final Map<Character,Integer> charMap = new HashMap<>();
    static{
        charMap.put('A',0);
        charMap.put('C',1);
        charMap.put('G',2);
        charMap.put('T',3);
    }
    private static final int MASK = (1<<20) - 1;
    public List<String> findRepeatedDnaSequences(String s) {
        // 使用两位bit表示一个碱基，这样长度为10的子串就可以使用一个int来表示
        Map<Integer,Integer> count = new HashMap<>();
        List<String> res = new ArrayList<>();
        StringBuilder window = new StringBuilder();
        int windowHash = 0;
        int l = s.length();
        if(l < 11) return res;
        int i=0;
        for(;i<10;++i){
            char ch = s.charAt(i);
            window.append(ch);
            windowHash = MASK & (windowHash<<2 | charMap.get(ch));
        }
        count.put(windowHash,1);
        for(;i<l;++i){
            char ch = s.charAt(i);
            window.deleteCharAt(0);
            window.append(ch);
            windowHash = MASK & (windowHash<<2 | charMap.get(ch));
            count.put(windowHash,count.getOrDefault(windowHash,0)+1);
            if(count.get(windowHash) == 2){
                res.add(window.toString());
            }
        }
        return res;
    }
}
```

### 前缀和哈希

```java
class Solution {
    int N = (int)1e5+10, P = 131313;
    int[] h = new int[N], p = new int[N];
    public List<String> findRepeatedDnaSequences(String s) {
        int n = s.length();
        List<String> ans = new ArrayList<>();
        p[0] = 1;
        for (int i = 1; i <= n; i++) {
            h[i] = h[i - 1] * P + s.charAt(i - 1);
            p[i] = p[i - 1] * P; // 对应 p^(i-1)
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 1; i + 10 - 1 <= n; i++) {
            int j = i + 10 - 1;
            int hash = h[j] - h[i - 1] * p[j - i + 1];
            int cnt = map.getOrDefault(hash, 0);
            if (cnt == 1) ans.add(s.substring(i - 1, i + 10 - 1));
            map.put(hash, cnt + 1);
        }
        return ans;
    }
}
```

