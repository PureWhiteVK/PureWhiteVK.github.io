---
title: 301. 删除无效的括号
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '3379'
date: 2021-10-27
---
# 301. 删除无效的括号

给你一个由若干括号和字母组成的字符串 `s` ，删除最小数量的无效括号，使得输入的字符串有效。

返回所有可能的结果。答案可以按 **任意顺序** 返回。

> [301. 删除无效的括号 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/remove-invalid-parentheses/)

<!-- more -->

### DFS+剪枝

> *剪枝的艺术*

看到这个题，要求输出所有可能的结果，那已经是铁铁的暴力搜索了

首先可以遍历一遍字符串计算出需要删除的无效括号的数目，然后得出最终结果的长度

只需要分别统计不匹配的左括号和右括号数目即可，算法很简单

对于字符串 "()())()"

leftCount = 0

rightCount = 0

step1:

leftCount = 1,rightCount = 0

step2:

leftCount = 0,rightCount = 0

step3:

leftCount = 1,rightCount = 0

step4:

leftCount = 0,rightCount = 0

step5:

leftCount = 0,rightCount = 1

step6:

leftCount = 1,rightCount = 1

step7:

leftCount = 0,rightCount = 1

最终不匹配的括号数为 leftCount + rightCount = 1

只需要删除一个右括号就可以使字符串变得有效

对于删除过程，我们可以使用dfs进行删除，对于每一个字符，其都可以选择加入当前构造的字符串或者不加入，

遍历结束时只需要判断当前字符串是否是符合条件即可

```java
class Solution {
    private Set<String> set;
    private int maxScore,length,finalLength;
    private String targetString;
    public List<String> removeInvalidParentheses(String s) {
        // 对于括号匹配题目，可以使用1代表左括号，-1代表右括号
        // 那么对于一个合法的括号对，可以很容易知道，其匹配过程中前缀和一定是正值
        // 且可能的最大值为 min(leftCount,rightCount)
        // 还可以提前计算出匹配串的长度
        int l1=0,l2=0,r1=0,r2=0;
        targetString = s;
        length = s.length();
        set = new HashSet<>();
        for(char ch:s.toCharArray()){
            if(ch == '('){
                ++l1;
                ++l2;
            }else if(ch == ')'){
                ++r1;
                if(l2>0){
                    --l2;
                }else{
                    ++r2;
                }
            }
        }
        finalLength = length - l2 - r2;
        maxScore = Math.min(l1,r1);
        dfs(0,"",l2,r2,0);
        return new ArrayList<>(set);
    }

    private void dfs(int currIndex,String s,int leftCount,int rightCount,int prefixSum){
        // 剪枝代码，很关键
        if(prefixSum < 0 || prefixSum > maxScore || leftCount < 0 || rightCount < 0) return;
        if(currIndex == length){
            if(prefixSum == 0 && s.length() == finalLength){
                set.add(s);
            }
            return;
        }
        char currChar = targetString.charAt(currIndex);
        if(currChar == '('){
            dfs(currIndex+1,s+String.valueOf(currChar),leftCount,rightCount,prefixSum+1);
            dfs(currIndex+1,s,leftCount-1,rightCount,prefixSum);
        }else if(currChar == ')'){
            dfs(currIndex+1,s+String.valueOf(currChar),leftCount,rightCount,prefixSum-1);
            dfs(currIndex+1,s,leftCount,rightCount-1,prefixSum);
        }else{
            dfs(currIndex+1,s+String.valueOf(currChar),leftCount,rightCount,prefixSum);
        }
    }
}
```

其中包含两步剪枝

1. 前缀和剪枝（尽可能保证字符串是有效的，不会出现有未匹配的右括号）
2. 删除个数剪枝，当删除个数达到上限时直接返回，没有必要进一步搜索了