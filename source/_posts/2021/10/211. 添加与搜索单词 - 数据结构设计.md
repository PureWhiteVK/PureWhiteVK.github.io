---
title: 211. 添加与搜索单词 - 数据结构设计
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 362c
---
# 211. 添加与搜索单词 - 数据结构设计

请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 WordDictionary ：

- `WordDictionary() `初始化词典对象
- `void addWord(word)`将 word 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 '.' ，每个 . 都可以表示任何一个字母。

> 链接：https://leetcode-cn.com/problems/design-add-and-search-words-data-structure

<!-- more -->

## Trie（前缀树）

这个题没什么好说，需要检查字符串是否和之前添加的字符串匹配，且需要搜索包含 '.'的，因此这题没什么好说的，一定是一个Tire的题了，关于前缀树的首先实际上我们早就做过，`212. 单词搜索 II` 和 `208. 实现Trie（前缀树）`中都有讲，这里就不说了，只需要讲一下如何实现搜索代码即可

对于一个包含 '.' 的字符串，那么我们需要遍历所有可能，在前缀数中进行匹配，意味着我们需要穷举前缀树的每一个分支，判断是否有可行的，这实际上是一个递归的过程，因此我们需要讲搜索写成递归形式

```java
class WordDictionary {
    private class TrieNode{
        boolean isEnd;
        TrieNode[] next;
        TrieNode(){
            isEnd = false;
            next = new TrieNode[26];
        }
    }

    private TrieNode root;

    public WordDictionary() {
        root = new TrieNode();
    }
    // 插入部分的代码实际上和前缀树的插入一样的
    public void addWord(String word) {
        int l = word.length();
        char[] wordArr = word.toCharArray();
        TrieNode curr = root;
        for(int i=0;i<l;++i){
            int currIndex = wordArr[i]-'a';
            if(curr.next[currIndex] == null){
                curr.next[currIndex] = new TrieNode();
            }
            curr = curr.next[currIndex];
        }
        curr.isEnd = true;
    }
    
    public boolean search(String word) {
        return searchInTrie(0,word.toCharArray(),root);
    }
	// 主要的区别在与前缀树部分，如果仅是普通的删除，那么只需要在前缀树上沿着路径不断进行搜索即可
    // 如果出现了 '.' ，那么就需要遍历所有可能的分支
    private boolean searchInTrie(int currIndex,char[] wordArr,TrieNode currNode){
        if(currNode == null) return false;
        if(currNode.isEnd && currIndex == wordArr.length) return true;
        if(currIndex == wordArr.length) return false;
        boolean res = false;
        if(wordArr[currIndex] == '.'){
            for(int i=0;i<26;++i){
                // 遍历分支
                if(searchInTrie(currIndex+1,wordArr,currNode.next[i])){
                    return true;
                }
            }
        }else{
            // 沿前缀树一路向后走即可
            res = searchInTrie(currIndex+1,wordArr,currNode.next[wordArr[currIndex]-'a']);
        }
        return res;
    }
}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */
```

