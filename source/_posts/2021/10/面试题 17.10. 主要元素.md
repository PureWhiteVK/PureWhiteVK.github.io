---
title: 面试题 17.10. 主要元素
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 5ff6
date: 2021-10-22
---
# 面试题 17.10. 主要元素

数组中占比超过一半的元素称之为主要元素。给你一个整数数组，找出其中的主要元素。若没有，返回-1。请设计时间复杂度为O(N)、空间复杂度为O(1)的解决方案。

> 题目连接：https://leetcode-cn.com/problems/find-majority-element-lcci/

题目乍一看很简单，直接HashMap统计每个数出现的次数，然后找出现次数最多的数判断是不是主要元素即可，但是这个题目要求设计的是空间复杂度为O(1)的解决方案，使用HashMap的空间复杂度为O(n)，并不符合题目要求

<!-- more -->

## Boyer-Moore投票算法

想了半天没想出好的解决方案，看了题解，用了Boyer-Moore投票算法

> Boyer-Moore投票算法
>
> 核心思想是每次在数组中删除两个不同的数，最后剩下的一定是出现次数最多的数

### 模拟算法执行过程

输入数组 nums

暂存数组 temp

考虑测试用例 [1,2,5,9,5,9,5,5,5]

开始遍历数组：

Init:

​	temp: [ ]

​	nums: [ 1,2,5,9,5,9,5,5,5 ]

Iter1:

​	temp: [ 1 ]

​	nums: [ 2,5,9,5,9,5,5,5 ]	

Iter2:

​	temp: [ ]

​	nums: [ 5,9,5,9,5,5,5 ]

Iter3:

​	temp: [ 5 ]

​	nums: [ 9,5,9,5,5,5 ]

Iter4:

​	temp: [ ]

​	nums: [ 5,9,5,5,5 ]

Iter5:

​	temp: [ 5 ]

​	nums: [ 9,5,5,5 ]

Iter6:

​	temp: [ ]

​	nums: [ 5,5,5 ]

Iter7:

​	temp: [ 5 ]

​	nums: [ 5,5 ]

Iter8:

​	temp: [ 5,5 ]

​	nums: [ 5 ]

iter9:

​	temp: [ 5,5,5 ]

​	nums: [ ]

### 算法思想解释

知乎上看到一个解释，解释的十分透彻

核心就是**对拼消耗**。

玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。

那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。

最后能剩下的必定是自己人。



>  作者：知乎用户
> 链接：https://www.zhihu.com/question/49973163/answer/617122734
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### Java实现

```java
class Solution {
    public int majorityElement(int[] nums) {
        // 最简单的思路，直接统计nums中每个数出现的次数，之后给出占比最大的就行，超过一半说明一定是出现次数最多的
        // 但是这样的空间复杂度为O(N)，题目要求空间复杂度为O(1)
        // Boyer-Moore 投票法，将不同的数之间彼此抵消，最后找到剩下的就是主要元素
        // 这也是O(n)时间复杂度，O(1)空间复杂度找众数的算法
        int candidate = -1;
        int count = 0;
        for(int num:nums){
            if(count == 0){
                candidate = num;
            }
            if(num == candidate){
                ++count;
            }else{
                // 碰见不一样的抵消一次计数
                --count;
            }
            // System.out.println("candidate:"+candidate+",count:"+count);
        }
        // 通过上述方法，一定可以找出出现次数最多的元素，最后统计candidate出现的次数
        // 最后找出的candidate一定是众数，但不一定是主要元素，因此还需要进行检验
        count = 0;
        for(int num:nums){
            if(num == candidate){
                ++count;
            }
        }
        // 根据主要元素定义，如果candidate出现次数小于数组长度的一半，不是主要元素
        return count * 2 > nums.length ? candidate : -1;
        // 这一条在数组长度为偶数的时候可以生效，但是奇数的时候不行，因为奇数情况下没有可以抵消的
        // return count == 0? -1 : candidate;
    }
}
```

