---
title: 496. 下一个更大元素 I
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: ab50
---
# 496. 下一个更大元素 I

给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。

请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

> 链接：https://leetcode-cn.com/problems/next-greater-element-i

<!-- more -->

## 模拟

对于nums1中的每一个字符nums1[i]，首先找到nums1[i]在nums2中对应的索引num2Index，然后再在nums2中找到下一个比nums1[i]更大的元素即可

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        // 首先暴力是一定可以的，时间复杂度为 o(nums1.length*nums2.length)
        Map<Integer,Integer> map = new HashMap<>();
        int l1 = nums1.length;
        int l2 = nums2.length;
        for(int i=0;i<l2;++i){
            // 记录nums2中每个数字的索引位置
            map.put(nums2[i],i);
        }
        int[] res = new int[l1];
        int curr = -1;
        for(int num:nums1){
            int nums2Index = map.get(num);
            int nextGreater = -1;
            for(int j=nums2Index+1;j<l2;++j){
                if(nums2[j] > num){
                    nextGreater = nums2[j];
                    break;
                }
            }
            res[++curr] = nextGreater;
        }
        return res;
    }
}
```



## 哈希表+单调栈

由于需要找到nums1上元素在nums2中下一个更大的元素，我们可以先对nums2处理，求出其每一个元素的下一个更大元素并使用哈希表存储下来，这样我们只需要再遍历一次nums1就可以得出结果

那么现在关键就是，如何生成nums2中每一个元素的下一个更大值？实际上这就是一个很经典的单调栈题，只需要维护一个单调递减的栈即可在o(n)时间复杂度内实现这个功能

下面举一个例子实现

**初始化**

nums2 = [1,3,4,2]

monoStack = []

map = {}

**step1**

当前元素1，栈为空，入栈

monoStack = [1]

**step2**

当前元素3，栈顶元素为1，此时就可以知道下一个比1大的元素为3

map = {1:3}

monoStack = [3]

**step3**

当前元素4，栈顶元素为3，此时就可以知道下一个比3大的元素为4

map = {1:3,3:4}

monoStack = [4]

**step4**

当前元素2，栈顶元素为4，直接入栈

monoStack = [4,2]

此时数组遍历完成，此时如果栈中还有剩余元素的话，就说明没有比他更大的值，直接将其所有值设置为-1即可

最终我们可以构造出nums2中所有元素的下一个最大值

map = {1:3,3:4,4:-1,2:-1}

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer,Integer> nextGreaterMap = new HashMap<>();
        Stack<Integer> monoStack = new Stack<>();
        int l2 = nums2.length;
        int l1 = nums1.length;
        // 最后一个元素没有比他更大的
        for(int num:nums2){
            while(!monoStack.isEmpty() && num > monoStack.peek()){
                nextGreaterMap.put(monoStack.pop(),num);
            }
            monoStack.push(num);
        }
        while(!monoStack.isEmpty()){
            nextGreaterMap.put(monoStack.pop(),-1);
        }
        // System.out.println(nextGreaterMap);
        for(int i = 0;i < l1;++i){
            nums1[i] = nextGreaterMap.get(nums1[i]);
        }
        return nums1;
    }
}
```

