---
title: 260. 只出现一次的数字 III
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 4e2f
---
# 260. 只出现一次的数字 III

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

> 链接：https://leetcode-cn.com/problems/single-number-iii

<!-- more -->

## 哈希表

这个题用哈希表面试就别想过了，考察的就是位运算

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i:nums){
            map.put(i,map.getOrDefault(i,0)+1);
        }
        int[] res = new int[2];
        int curr = 0;
        for(int k:map.keySet()){
            if(map.get(k) == 1){
                res[curr] = k;
                ++curr;
            }
        }
        return res;
    }
}
```

## 位运算

看到这种数组中出现多次，一个数字仅出现一次的就容易想到位运算

> a ^ a = 0
>
> a ^ 0 = a
>
> 位运算的性质

使用上面两条性质，对nums做一次异或可以很快的得到 res[0]^res[1] 的值，记为xor

那么我们只需要找到一种方式，使得res[0]和res[1]区分开来即可

此时我们再观察异或的值

>1 ^ 0 = 1

那么对于xor中值为1的，说明res[0]和res[1]是存在不同的，那么通过这个位，我们可以将数组分成两部分，A和B，且A中仅出现res[0]，剩下的数字都出现两次，取一次异或就可以知道res[0]，同理，对于B也是一样

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        // 这种题目感觉大概率是和位运算有关的
        // a^b^c^b^c^d = a^d
        // b^b = 0
        // a^0 = a
        // 最后只可以知道a^d的结果，只要知道其中一个的结果就可以解出两个数了
        // a^(a^d) = d
        // (a^d)^d = a
        // 那么关键就在于，如何找出这个只出现了一次的数呢？
        int xor = 0;
        for(int num:nums){
            xor ^= num;
        }
        // 找到xor中为1的那一位，用来区分res[0]和res[1]
        int lowbit = 0;
        while(((xor >> lowbit) & 1) ==0){
            ++lowbit;
        }
        // 之后可以使用这个和对num进行分组
        int[] res = new int[2];
        for(int num:nums){
            if(((num>>lowbit)&1)==0){
                res[0] ^= num;
            }else{
                res[1] ^= num;
            }
        }
        return res;
    }
}
```

