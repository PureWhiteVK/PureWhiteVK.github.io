---
title: 229. 求众数 II
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 372b
date: 2021-10-22
---
# 229. 求众数 II

给定一个大小为 *n* 的整数数组，找出其中所有出现超过 `⌊ n/3 ⌋` 次的元素。

<!-- more -->

## 摩尔投票法

在 `面试题 17.10. 主要元素` 中，我们求过主要元素（实际上就是出现次数超过`⌊ n/2 ⌋`次的元素，在这一题中我们使用的摩尔投票法同样可以套用到这里

> 摩尔投票法：
>
> 其思路就是对拼消耗，假设我们要选出出现次数大于 n/k 的元素，那么我们最多只有 k-1 个候选元素（这也很好理解，如果出现次数超过 n/k 的有k次，那么所有元素出现次数会超过n
>
> 在这 k-1 个候选元素中，我们套用对拼消耗思想，记录当前候选者及其对应的选票，然后检查当前选票情况，如果当前选票和候选选票不同，此时出现对拼，二者选票都减一，如果当前数已经为0，更新新候选者

了解了这个思路后，我们可以写出求出现次数大于 n/k 次的元素

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        return majorityElementK(nums,3);
    }

    private List<Integer> majorityElementK(int[] nums,int k){
        int l = nums.length / 3;
        int t = k - 1;
        // 求出现次数大于 n/k 的元素
        int[] candidate = new int[t];
        int[] count = new int[t];
        // 对拼阶段
        for(int i : nums){
            // 检查所有选票
            boolean notCandidate = true;
            for(int j=0;j<t;++j){
                // 如果当前数是候选者之一，其计数加一
                if(candidate[j] == i){
                    ++count[j];
                    notCandidate = false;
                    break;
                }
            }
            if(notCandidate){
                // 检查是否需要更新计数
                boolean updateCount = true;
                for(int j=0;j<t;++j){
                    if(count[j] == 0){
                        candidate[j] = i;
                        count[j] = 1;
                        updateCount = false;
                        break;
                    }
                }
                if(updateCount){
                    // 当前所有侯选者计数都不为0，那么所有候选者计数都减一
                    for(int j=0;j<t;++j){
                        --count[j];
                    }
                }
            }
        }
        // 验证阶段
        Arrays.fill(count,0);
        for(int i:nums){
            for(int j=0;j<t;++j){
                if(i == candidate[j]){
                    // 这个计数是互斥的，如果两个值相同的话，也就只会统计一次
                    ++count[j];
                    break;
                }
            }
        }
        List<Integer> res = new ArrayList<>();
        for(int i=0;i<t;++i){
            if(count[i] > l) res.add(candidate[i]);
        }
        return res;
    }
}
```

 

## 暴力（面试必挂法）

暴力属实没什么好说的了，统计每一个数字出现的次数，然后筛选出所有超过 n/3 的元素即可，面试要是问到了这个题，然后给出这个解法，估计是直接没了

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        // 最简单的方法，统计每个数字出现的次数即可
        Map<Integer,Integer> map = new HashMap<>();
        for(int i:nums){
            map.put(i,map.getOrDefault(i,0)+1);
        }
        int threshold = nums.length / 3;
        List<Integer> res = new ArrayList<>();
        for(Map.Entry<Integer,Integer> entry:map.entrySet()){
            if(entry.getValue() > threshold){
                res.add(entry.getKey());
            }
        }
        return res;
    }
}
```

