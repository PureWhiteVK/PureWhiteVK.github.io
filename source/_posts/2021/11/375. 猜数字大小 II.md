---
title: 375. 猜数字大小 II
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 7ea4
date: 2021-11-12
---


# 375. 猜数字大小 II

我们正在玩一个猜数游戏，游戏规则如下：

1. 我从 1 到 n 之间选择一个数字。
2. 你来猜我选了哪个数字。
3. 如果你猜到正确的数字，就会 **赢得游戏** 。
4. 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
5. 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 **输掉游戏** 。

给你一个特定的数字 n ，返回能够 **确保你获胜** 的最小现金数，不管我选择那个数字 。

> 链接：https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii

<!-- more -->

## 动态规划

```
先演示一遍游戏规则：

设 n = 20
目标数字为 8

第一轮猜 4，不对，需要支出4，被告知目标结果比4大
第二轮猜 9，不对，需要支出9，被告知目标结果比9小
第三轮猜 7，不对，需要支出7，被告知目标结果比7大
第四轮猜 8，正确

总共支出为 4+9+7 = 20

本题的目标就是找出所有猜测方案中可以确保获胜的最小现金数（也就是无论目标值是多少，我猜对这个结果所需要支出钱的上限）
```

使用dp[i,j]表示目标数字在[i,j]区间时确保可以获胜的最小现金数，最终目标是求解dp[1,n]

然后考虑状态更新方程，设我们当前猜了[i,j]中的一个值k，考虑最差情况，k值并不是目标值，那么还需要继续猜，由于会告知我们目标值比k大还是比k小，这样可以缩小下一步搜索的范围，最终所需要支出的价格为
$$
k + max(dp[i,k-1],dp[k+1,j])
$$
最终dp[i,j]则为所有情况中的最小值，那么状态更新公式为
$$
dp[i,j] = \min\limits_{i \leq k \leq j}(k+\max(dp[i,k-1],dp[k+1,j]))
$$
然后考虑最终结果，当区间内只包含一个结果时，没有其他可以选，一定猜对，则需要支出价格为0，即dp[i,i] = 0

接下来我们只需要从最小的区间开始，不断扩大区间搜素的范围即可

```java
class Solution {
    public int getMoneyAmount(int n) {
        // 最小化最大问题
        // 对于一个给定的n，在1～n中无论选择了哪一个都可以赢
        int[][] dp = new int[n+1][n+1];
        for(int l=2;l<=n;++l){
            // l代表区间长度，优先遍历长度少的
            int end = n-l+1;
            // System.out.println(end);
            for(int i=1;i<=end;++i){
                int j = i+l-1;
                // System.out.println(i+" "+j);
                dp[i][j] = Integer.MAX_VALUE;
                for(int k=i;k<j;++k){
                    // 这个地方的min max是精髓，需要好好理解一下
                    dp[i][j] = Math.min(dp[i][j],k+Math.max(dp[i][k-1],dp[k+1][j]));
                }
                // System.out.printf("dp[%d][%d]=%d\n",i,j,dp[i][j]);
                // 遍历所有区间
                // 例如长度为2的话
            }
        }
        return dp[1][n];
    }
}
```

