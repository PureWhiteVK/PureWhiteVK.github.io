---
title: 397. 整数替换
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: f3f9
---
# 397. 整数替换

给定一个正整数 n ，你可以做如下操作：

1. 如果 n 是偶数，则用 n / 2替换 n 。
2. 如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。

n 变为 1 所需的最小替换次数是多少？

> 链接：https://leetcode-cn.com/problems/integer-replacement

<!-- more -->

## 记忆化搜索

这个题难度不大，状态转移方程都已经给出来了

使用dp[i]表示将数i替换为1所需要的最小替换次数

if i % 1 == 0 dp[i] = 1 + dp[i/1]

if i % 1 == 1 dp[i] = 1 + max(dp[i+1],dp[i-1])

但是我们可以看到这个状态转移方程中奇数情况涉及了dp[i+1]这个值实际上会比当前求解值更大，

但是此时i为奇数，实际上i+1和i-1一定是偶数，因此状态转移方程可以变成

if i % 1 == 1 dp[i] = 2 + max(dp[(i+1)>>1],dp[(i-1)>>1])

 这样遍历的方向就可以确定了，可以开数组进行计算了

但是本题数据范围很大，最大需要求解 2^31-1的变换次数，动态规划无法开出这么大的空间，考虑搜索吧

```java
class Solution {
    private static Map<Long,Integer> map = new HashMap<>();
    static{
        map.put(1L,0);
    }
    public int integerReplacement(int n) {
        return dfs(n);
    }

    // 记忆化搜索
    // dfs返回的结果就是当前值对应的最小操作次数？
    private int dfs(long v){
        if(map.containsKey(v)) return map.get(v);
        int res;
        if((v & 1) == 0) res = 1 + dfs(v>>1);
        else res = 1 + Math.min(dfs(v+1),dfs(v-1));
        map.put(v,res);
        return res;
    }
}
```

有一个细节需要注意，当v == 2^31-1时，计算过程中有可能越界，因此需要使用long进行运算，还有一种方式就是判断取值，然后做特殊处理



