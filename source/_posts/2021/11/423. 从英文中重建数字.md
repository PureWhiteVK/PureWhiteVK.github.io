---
title: 423. 从英文中重建数字
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: bb5b
---
# 423. 从英文中重建数字

给你一个字符串 `s` ，其中包含字母顺序打乱的用英文单词表示的若干数字（`0-9`）。按 **升序** 返回原始的数字。

> 链接：https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/

<!-- more -->

## 脑筋急转弯

这个题还挺有意思的，需要从打乱的字符串中还原出英文表示的数字

```c++
["zero","one","two","three","four","five","six","seven","eight","nine"]
// 有些字母可以唯一确定一个数字的
// z唯一确定zero、w唯一确定two、u唯一确定four，x唯一确定six，g唯一确定eight，先把这些能确定的先减掉
// 剩下 one,three,five,seven,nine无法确认
// 由于包含s的数字只有six和seven，确定完six的个数之后再根据当前s的值可以确定seven的个数（seven）
// 包含t的有two、three、eight，但是two和eight都已经被确定了，那么根据当前剩下的t值可以计算出three的个数，注意此处3中包含了两个e，减去的时候需要减去两个e（three）
// 包含o的有zero、one、two、four，其他的已经在之前的代码中确定了，剩下的就一定是one的个数（one）
// 包含v的有five和seven，seven的个数已经确定，直接减去即可，剩下的是five的个数（five）
// 最终检查nine的个数即可（看哪一个单词都行，剩下的应该只有满足nine的了）
// 最好是看i或者e要不然容易出毛病呢，因为9中n出现了两次
```

从不同数字的英文表示中可以看出来，有些字母仅在一个单词中出现，那么根据这个字母出现的次数可以唯一确定一个数字，再由给定的字符串一定是有效的，那么有些字母可以代表多个单词，将其他的确定之后，剩下的也就可以确定了

可以看到，首先可以确定[0,2,4,6,8]，因为其包含可以唯一标识的字母

之后再按顺序确定[7,3,1,5,9]即可

```java
class Solution {
    private static final String[] words;
    static{
        words = new String[]{
            "zero","one","two","three","four","five","six","seven","eight","nine"
        };
    }
    public String originalDigits(String s) {
        int[] count = new int[26];
        int[] numberCount = new int[10];
        // 统计每个字母出现的次数
        for(char ch:s.toCharArray()){
            ++count[ch-'a'];
        }
        // 分别开始计算，这一步实际上可以简化为优先在数组中找出对应数字的出现次数
        numberCount[0] = count['z'-'a'];
        subtract(count,words[0],numberCount[0]);
        numberCount[2] = count['w'-'a'];
        subtract(count,words[2],numberCount[2]);
        numberCount[4] = count['u'-'a'];
        subtract(count,words[4],numberCount[4]);
        numberCount[6] = count['x'-'a'];
        subtract(count,words[6],numberCount[6]);
        numberCount[8] = count['g'-'a'];
        subtract(count,words[8],numberCount[8]);
        // 之后可以得出其他的
        numberCount[7] = count['s'-'a'];
        subtract(count,words[7],numberCount[7]);
        numberCount[3] = count['t'-'a'];
        subtract(count,words[3],numberCount[3]);
        numberCount[1] = count['o'-'a'];
        subtract(count,words[1],numberCount[1]);
        numberCount[5] = count['v'-'a'];
        subtract(count,words[5],numberCount[5]);
        numberCount[9] = count['i'-'a'];
        subtract(count,words[9],numberCount[9]);
        // 最后根据计数结果生成升序字符串
        StringBuilder sb = new StringBuilder();
        for(int i=0;i<10;++i){
            for(int j=0;j<numberCount[i];++j){
                sb.append(i);
            }
        }
        return sb.toString();
    }

    private static void subtract(int[] count,String word,int c){
        if(c == 0) return;
        for(char ch:word.toCharArray()){
            count[ch-'a'] -= c;
        }
    }
}
```

