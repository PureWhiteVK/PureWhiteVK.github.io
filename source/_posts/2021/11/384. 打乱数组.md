---
title: 384. 打乱数组
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: c006
---
# 384. 打乱数组

给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。

实现 Solution class:

- Solution(int[] nums) 使用整数数组 nums 初始化对象
- int[] reset() 重设数组到它的初始状态并返回
- int[] shuffle() 返回数组随机打乱后的结果

> 链接：https://leetcode-cn.com/problems/shuffle-an-array

<!-- more -->

## knuth洗牌算法	

写了一个`next_permutation`，好像会检查随机性，直接WA了，没办法，看看题解吧

> 作者：AC_OIer
> 链接：https://leetcode-cn.com/problems/shuffle-an-array/solution/gong-shui-san-xie-xi-pai-suan-fa-yun-yon-0qmy/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

共有 n 个不同的数，根据每个位置能够选择什么数，共有 n! 种组合。

题目要求每次调用 shuffle 时等概率返回某个方案，或者说每个元素都够等概率出现在每个位置中。

我们可以使用 Knuth 洗牌算法，在 O(n) 复杂度内等概率返回某个方案。

具体的，我们从前往后尝试填充 [0, n - 1] 该填入什么数时，通过随机当前下标与（剩余的）哪个下标进行值交换来实现。

对于下标 x 而言，我们从 [x, n - 1] 中随机出一个位置与 x 进行值交换，当所有位置都进行这样的处理后，我们便得到了一个公平的洗牌方案。

对于下标为 0 位置，从 [0, n - 1]随机一个位置进行交换，共有 n 种选择；下标为 1 的位置，从 [1, n - 1]随机一个位置进行交换，共有 n - 1 种选择 ... 且每个位置的随机位置交换过程相互独立。

```java
class Solution {
    private int[] nums;
    private int[] arr;
    private int n;
    private static final Random random = new Random();
    public Solution(int[] _nums) {
        nums = _nums;
        n = nums.length;
        arr = new int[n];
    }
    
    public int[] reset() {
        return nums;
    }
    
    public int[] shuffle() {
        for(int i=0;i<n;++i){
            arr[i] = nums[i];
        }
        // 开始shuffle
        for(int i=0;i<n;++i){
            // 将i和[i,n)内的一个数进行交换
            swap(i,i+random.nextInt(n-i));
        }
        return arr;
    }

    private void swap(int i,int j){
        int t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int[] param_1 = obj.reset();
 * int[] param_2 = obj.shuffle();
 */
```

