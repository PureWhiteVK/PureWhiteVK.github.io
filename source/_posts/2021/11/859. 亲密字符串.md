---
title: 859. 亲密字符串
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 7dee
---
# 859. 亲密字符串

给你两个字符串 s 和 goal ，只要我们可以通过交换 s 中的两个字母得到与 goal 相等的结果，就返回 true ；否则返回 false 。

交换字母的定义是：取两个下标 i 和 j （下标从 0 开始）且满足 i != j ，接着交换 s[i] 和 s[j] 处的字符。

例如，在 "abcd" 中交换下标 0 和下标 2 的元素可以生成 "cbad" 。

> 链接：https://leetcode-cn.com/problems/buddy-strings

<!-- more -->

## 暴力（超时）

这个思路很简单，直接遍历所有可行的交换方案，检查是否相等即可

```java
class Solution {
    public boolean buddyStrings(String s, String goal) {
        // 直接暴力的话，考虑将(i,j)进行交换，然后判断s和goal是否相同？
        if(s.length() != goal.length()) return false;
        char[] a = s.toCharArray();
        char[] b = goal.toCharArray();
        // 尝试交换
        int l = a.length;
        for(int i=0;i<l;++i){
            for(int j=i+1;j<l;++j){
                swap(a,i,j);
                if(check(a,b)) return true;
                swap(a,i,j);
            }
        }
        return false;
    }

    private boolean check(char[] a,char[] b){
        for(int i=0;i<a.length;++i){
            if(a[i] != b[i]) return false;
        }
        return true;
    }

    private void swap(char[] arr,int a,int b){
        char t = arr[a];
        arr[a] = arr[b];
        arr[b] = t;
    }
}
```

对于测试用例

s = "baaaaaaaaaaaaaaaaaaaaaac"

g = "caaaaaaaaaaaaaaaaaaaaaab"

中间部分存在很多不必要的判断，实际上没必要进行检查的

## 暴力（优化）

由于s和g字符串之间存在很多的相同部分，因此我们实际上只需要保存不同的地方即可

使用两个List来保存s[i] != g[i]的部分，然后判断即可

但是题目要求的是字符串s必须经过一次交换操作之后和g相同，那么如果s和g已经相同，且s中不包含重复字符，那么交换之后一定是不同的，也就是说还需要判断是否存在相同字符串

里面存在很多细节，需要多加注意

相同只有两种情况

1. s和g之间包含的字符是相同的，且只有两个位置上的值不一样
2. s和g相同且s存在重复字符（这样可以通过交换重复字符使得s和g一样）

```java
class Solution {
    public boolean buddyStrings(String s, String goal) {
        // 直接暴力的话，考虑将(i,j)进行交换，然后判断s和goal是否相同？
        if(s.length() != goal.length()) return false;
        char[] a = s.toCharArray();
        char[] b = goal.toCharArray();
        int[] c1 = new int[26];
        int[] c2 = new int[26];
        int diffCount = 0;
        // 尝试交换
        int l = a.length;
        for(int i=0;i<l;++i){
            if(a[i] != b[i]){
                ++diffCount;
                if(diffCount > 2) return false;
            }
            ++c1[a[i]-'a'];
            ++c2[b[i]-'a'];
        }
        // 检查两个字符串是否是一样的
        // 当两个字符串本身就是相同的时候，需要判断s是否包含相同字符
        boolean hasSame = false;
        for(int i=0;i<26;++i){
            if(c1[i] != c2[i]) return false;
            if(c1[i] > 1) hasSame = true;
        }   
        // 判断字符串不同位数是不是1
        return (diffCount == 2) || (diffCount == 0 && hasSame);
    }
}
```

