---
title: 594. 最长和谐子序列
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 5f3b
date: 2021-11-20
---
# 594. 最长和谐子序列

和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。

现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。

数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。

> 链接：https://leetcode-cn.com/problems/longest-harmonious-subsequence

<!-- more -->

## 思路

子序列是由数组中任意一些数构成的，其不考虑连续信息。且对于和谐数组，其最大值和最小值之差为1，因此实际上和谐数组中仅包含两个数，最大值和最小值

## 排序+双指针

首先对数组进行排序，然后我们的序列就一定是 [a,a,a,a,a,...,a+1,a+1,...,a+1]这种形式

可以使用双指针进行

```java
class Solution {
    public int findLHS(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length, ans = 0;
        for (int i = 0, j = 0; j < n; j++) {
            while (i < j && nums[j] - nums[i] > 1){
                i++;
                System.out.println(i+" "+j);
            }
            if (nums[j] - nums[i] == 1) ans = Math.max(ans, j - i + 1);
            System.out.println(i+" "+j);
        }
        return ans;
    }
}
```

## 哈希表

```java
class Solution {
    public int findLHS(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i : nums) map.put(i, map.getOrDefault(i, 0) + 1);
        int ans = 0;
        // 遍历所有的最大值、最小值数对
        for (int i : nums) {
            if (map.containsKey(i - 1)) {
                ans = Math.max(ans, map.get(i) + map.get(i - 1));
            }
        }
        return ans;
    }
}
```

