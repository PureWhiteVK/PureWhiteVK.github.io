---
title: 629. K个逆序对数组
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 8d47
---
# 629. K个逆序对数组

给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

> 链接：https://leetcode-cn.com/problems/k-inverse-pairs-array

<!-- more -->

# 动态规划

首先找一个样例来作为测试

当 n = 4时，计算k=4的逆序对数

首先已知 n = 3时，各逆序数情况

dp = [1,2,2,1]

对应的前缀和

sum = [1,3,5,6]

分别对应

0：1 2 3

1：1 3 2 2 1 3

2：2 3 1 3 1 2

3：3 2 1

对于 n = 5的情况，此时计算结果应该是

前一个的逆序对数取值范围为 3*2 / 1 -> [0,3]，取值范围为0，1，2，3

那么至少是3和2才行，也就是res = dp[2] + dp[1]

接下来计算n = 4的情况

target >= length的情况，此时少计算了什么？

假设第一个位置的值为1，那么只需要考虑剩下三个的计算结果，即 2 3 4中逆序数为4的情况

而2 3 4不可能得出逆序数为4的情况，res = 0

假设第一个位置的值为2，那么首先无论后面三个如何排列，一定包含一个逆序对 (2,1)，因此只需要找到逆序对数为3的情况即可

dp[3] = 1，res = 1 ，对应的情况为 (2,4,3,1)

以此类推，当第一个位置的值为3时，无论如何排列都一定包含逆序对 (3,1)和(3,2)，只需要找到逆序对为2的即可

res = res + dp[2] = 3，对应的情况为 (3,2,4,1) 、(3,4,2,1)、(2,4,3,1)

最后，当第一个位置的值为4时，一定包含逆序对(4,1)，(4,2)和(4,3)，找出逆序对为1的情况

res = res + dp[1] = 5，对应的情况为 (4,1,3,2)、(4,2,1,3)、(3,2,4,1) 、(3,4,2,1)、(2,4,3,1)

实际上可以使用前缀和进行优化

res = dp[3] + dp[2] + dp[1]

可以使用前缀和优化

对应n = 3的情况，则是 dp[3] + dp[2] + dp[1] + dp[0] = 6



未使用前缀和优化前的代码

```java
class Solution {
    private static final int MOD = (int)(1e9+7);
    public int kInversePairs(int n, int k) {
        // 找出包含从1到n的数字，恰好包含k个逆序对的不同的数组的个数？
        int[] dp = {1,1};
        int[] sum = {1,2};
        for(int i=3;i<n;++i){
            // 从数组长度为i开始计算
            // res[i]代表当前长度数组中逆序对恰好为i的数组个数
            int[] res = new int[k+1];
            for(int j=0;j<=k;++j){
                res[j] = getTargetInversePairs(dp,i,j);
            }
            // printArr(res);
            dp = res;
        }
        return getTargetInversePairs(dp,n,k);
    }

    private void printArr(int[] arr){
        for(int i:arr){
            System.out.print(i+" ");
        }
        System.out.println();
    }

    private int getTargetInversePairs(int[] dp,int length,int target){
        // 已知长度为length-1的数字中逆序对情况，dp[i]表示逆序对为i对应的种类数
        int res = 0;
        // 这里需要使用前缀和数组进行优化
        for(int i=0;i<length;++i){
            // System.out.println(target+" "+i);
            if(target - i >= dp.length) continue;
            else if(target -i < 0) break;
            res = (res+dp[target-i]) % MOD;
        }
        // System.out.println(length+" "+target+" "+res);
        return res;
    }
}
```

可以看到，在计算的时候需要累加，这个是一个o(n)的时间复杂度，实际上还可以优化
