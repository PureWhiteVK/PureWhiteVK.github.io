---
title: 519. 随机翻转矩阵
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 3ce2
---
# 519. 随机翻转矩阵

给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。

尽量最少调用内置的随机函数，并且优化时间和空间复杂度。

实现 Solution 类：

- Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象
- int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1
- void reset() 将矩阵中所有的值重置为 0

> 链接：https://leetcode-cn.com/problems/random-flip-matrix

<!-- more -->

## 哈希表+shuffle

这一题需要实现随机翻转矩阵，实际上如果将矩阵使用以为数组实现的话，其实现思路和 `384. 打乱数组是一样的了`，首先创建一个大小为m*n的一维数组，数组上每位初始化为对应的索引，表示正常顺序。

生成一维数组之后，由于需要确保所有满足 matrix[i,j] == 0的下标(i,j)被选取的概率均等，最初矩阵全部为0，实际上就需要确定每一对(i,j)出现的概率都是 1/(m*n)，我们只需要生成一维数组对应的排列，再通过公式 (i,j) = (index / n , index % n)得出二维的下标

然后开始flip，具体流程是：

使用curr表示随机排列中的第curr位，由于前面的已经是打乱过的，不需要纳入考虑，第curr位只需要考虑[curr,l-curr)中任意一个即可，使用random生成对应的随机数即可

```java
class Solution {
    private int[] matrix;
    private int m,n;
    private int l;
    private Random random; 
    private int curr;
    public Solution(int _m, int _n) {
        m = _m;
        n = _n;
        l = m * n;
        // 使用一维数组模拟二维即可
        matrix = new int[l];
        for(int i=0;i<l;++i){
            matrix[i] = i;
        }
        random = new Random();
        curr = 0;
    }
    
    public int[] flip() {
        // 返回修改的下标，并使其对应的值变为1
        // 需要确保所有满足matrix[i][j]==0的(i,j)满足的概率均等
        // 之前的一个也是这样，确保概率为1/m*n
        // 如何实现呢？
        // 这个感觉和shuffle有点像，实际上也可以理解为将所有的下标进行一个shuffle
        // 第i次调用flip时记录当前待生成的值的位置，然后在(i,j)的区间内随机生成一个数
        int x = curr + random.nextInt(l-curr);
        int index = matrix[x];
        matrix[x] = matrix[curr];
        ++curr;
        return new int[]{index / n, index % n};
    }
    
    public void reset() { 
        // 将矩阵重新变为0
        for(int i=0;i<l;++i){
            matrix[i] = i;
        }
        curr = 0;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(m, n);
 * int[] param_1 = obj.flip();
 * obj.reset();
 */
```

由于本题数据量1 <= m,n <= 10000，考虑边界情况 m = n = 10000时无法生成这么大的数组，需要优化

我们使用一维数组的目的是生成随机排列，对于每一次的flip，我们用到的数据是 matrix[x]，实际上可以使用哈希表进行存储，减少空间占用

```java
class Solution {
    private Map<Integer,Integer> map;
    private int m,n;
    private int l;
    private Random random; 
    private int curr;
    public Solution(int _m, int _n) {
        m = _m;
        n = _n;
        l = m * n;
        // 使用一维数组模拟二维即可
        map = new HashMap<>();
        random = new Random();
        curr = 0;
    }
    
    public int[] flip() {
        // 返回修改的下标，并使其对应的值变为1
        // 需要确保所有满足matrix[i][j]==0的(i,j)满足的概率均等
        // 之前的一个也是这样，确保概率为1/m*n
        // 如何实现呢？
        // 这个感觉和shuffle有点像，实际上也可以理解为将所有的下标进行一个shuffle
        // 第i次调用flip时记录当前待生成的值的位置，然后在(i,j)的区间内随机生成一个数
        int x = curr + random.nextInt(l-curr);
        // index = matrix[x]
        int index = map.getOrDefault(x,x);
        // swap
        // matrix[x] = matrix[curr];
        map.put(x,map.getOrDefault(curr,curr));
        ++curr;
        return new int[]{index / n, index % n};
    }
    
    public void reset() { 
        // 将矩阵重新变为0
        map.clear();
        curr = 0;
    }
}
```



