---
title: 787. K站中转内最便宜的航班
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 64ef
---
# 787. K站中转内最便宜的航班

有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 toi 抵达 pricei。

现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。

> 链接：https://leetcode-cn.com/problems/cheapest-flights-within-k-stops

<!-- more -->

## BFS+剪枝

这个题是一个限制路径长度的最短路径问题，我们可以遍历所有从src出发到dst的路径，然后找出在k站中转内的最小花费，由于直接搜索太花费时间，需要使用一些剪枝技巧来加快搜素

主要使用的剪枝策略有两个：

- 记录当前节点到各个节点的最小花费，当src到达节点i的花费已经大于目前的最小花费时，就没有必要再次进行搜索了，可以直接跳过
- 记录从src到达dst的最小花费，当src到达节点i的花费已经大于这个最小花费时，没有继续搜素的必要，因为最终到达终点的花费一定会大于当前的最小花费

```java
class Solution {
    private static final ArrayList<int[]> emptyList = new ArrayList<int[]>();
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        Queue<int[]> queue = new LinkedList<>();
        // 找到所有从src开始的
        Map<Integer,List<int[]>> map = new HashMap<>();
        for(int[] flight:flights){
            List<int[]> list = map.getOrDefault(flight[0],new ArrayList<int[]>());
            list.add(new int[]{flight[1],flight[2]});
            map.put(flight[0],list);
        }
        for(int[] p :map.getOrDefault(src,emptyList)){
            queue.offer(p);
        }
       	int minVal = Integer.MAX_VALUE;
        int[] dist = new int[n];
        Arrays.fill(dist,Integer.MAX_VALUE);
        while(queue.size()!=0 && k>-1){
            // k代表的是中转站的数目
            int size = queue.size();
            while(size>0){
                int[] curr = queue.poll();
                --size;
                int mid = curr[0],cost=curr[1];
                // 当可以到达终点的时候进行判断
                if(mid == dst){
                    minVal = Math.min(cost,minVal);
                    continue;
                }
                // 存储当前路径值
                // 当第一访问到节点curr[0]的时候，其cost一定是最小的，当第二次时一定会大于该值，说明就已经访问过了
                // 记录从src到节点curr[0]的cost
                if(cost >= dist[curr[0]]){
                    continue;
                }
                dist[mid] = cost;
                // 很明显这里搜索的时候进行了很多不必要的搜索，完全没有必要走回头路
                for(int[] p:map.getOrDefault(mid,emptyList)){
                    // 还可以进行一波剪枝，当当前花费已经很多的时候，就没有必要进行搜索了，再进行搜索也没有任何意义
                    if(cost + p[1] < minVal){
                        queue.offer(new int[]{p[0],cost+p[1]});
                    }
                }
            }
            --k;
        }
        return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst];
    }
}
```



## DFS+剪枝

DFS的思路和BFS差不多，只是换成递归+回溯

```java
class Solution {
    private static final ArrayList<int[]> emptyList = new ArrayList<>();
    private Map<Integer,List<int[]>> map;
    private boolean[] visited;
    private int minVal,dst;
    public int findCheapestPrice(int n, int[][] flights, int _src, int _dst, int k) {
        map = new HashMap<>();
        for(int[] f:flights){
            List<int[]> list = map.getOrDefault(f[0],new ArrayList<>());
            list.add(new int[]{f[1],f[2]});
            map.put(f[0],list);
        }
        // System.out.println(map);
        visited = new boolean[n];
        dst = _dst;
        minVal = Integer.MAX_VALUE;
        dfs(_src,k,0);
        return minVal == Integer.MAX_VALUE ? -1 : minVal;
    }

    private void dfs(int src,int step,int cost){
        if(src == dst) {
            minVal = Math.min(minVal,cost);
            // System.out.println("reach dst: "+minVal);
            return;
        }
        if(step == -1 || cost >= minVal) return;
        for(int[] p:map.getOrDefault(src,emptyList)){
            // System.out.println(src+" "+p[0]+" "+p[1]);
            if(!visited[p[0]]){
                visited[p[0]] = true;
                dfs(p[0],step-1,cost+p[1]);
                visited[p[0]] = false;
            }
        }
    }
}
```

实际运行效果并不好，会超时

## 动态规划

由于需要在k+1步内找到从src到达dst的最小花费，使用dp[i,j]代表第i步到达j的最小花费，初始时dp[i,j] = INF，dp[0,src] = 0

状态转移方程
$$
dp[i,j] = min(dp[i-1,k]+cost[k,j],dp[i,j])
$$
有了这个，代码写起来就很简单了

```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        int[][] dp = new int[k + 2][n];
        for (int i = 0; i < k + 2; ++i) {
            Arrays.fill(dp[i], 0x7f7f7f7f);
        }
        dp[0][src] = 0;
        for (int t = 1; t <= k + 1; ++t) {
            for (int[] flight : flights) {
                int j = flight[0], i = flight[1], cost = flight[2];
                // 这里是直接加的，因此dp[i][j]初始值不能是Integer.MAX_VALUE，要不然就会溢出
                dp[t][i] = Math.min(dp[t][i], dp[t - 1][j] + cost);
            }
        }
        int res = 0x7f7f7f7f;
        for (int t = 1; t <= k + 1; ++t) {
            res = Math.min(res, dp[t][dst]);
        }
        return res == 0x7f7f7f7f ? -1 : res;
    }
}
```

