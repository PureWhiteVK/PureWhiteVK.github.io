---
title: 313. 超级丑数
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '9689'
---
# 313. 超级丑数

超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。

给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。

题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。

> 链接：https://leetcode-cn.com/problems/super-ugly-number

<!-- more -->

## 最小堆+集合

这一题乍一看有点没搞明白，看了样例就理解了

例如 n = 12，primes = [2,7,13,19]

其要求的一个正整数序列的第n个，这个正整数序列中的每一个正整数的所有质因数都在primes数组中

再看前12个正整数分别是什么

[ 1,2,4,7,8,13,14,16,19,26,28,32 ]

实际上可以看成是

```
[ 1,1*2,2*2,1*7,2*4,1*13,2*7,8*2,1*19,2*13,14*2,16*2 ]
```

也就是将primes中的质数任取几个进行相乘，最终进行排序

那么可以使用最小堆来选择每次需要进行计算的数，同时使用set来去重

```java
class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        long res = 0;
        // 由于在计算可能出现超出2^31-1，需要使用long来存，防止优先队列计算错误
        PriorityQueue<Long> queue = new PriorityQueue<>();
        Set<Long> set = new HashSet<>();
        queue.offer(1L);
        set.add(1L);
        for(int i=0;i<n;++i){
            // 使用优先队列来选择当前最小的，然后使用set来去重
            res = queue.poll();
            // System.out.println(res);
            for(int p:primes){
                long next = res * p;
                // 又可能出现重复的，使用set来去重
                if(!set.contains(next)){
                    // 实际上如果next值大于queue.peek()的话就没有必要加入了？
                    queue.offer(next);
                    set.add(next);
                }
            }
            // 将所有小于val的primes中数组添加到里面？
        }
        return (int)res;
    }
}
```

时间复杂度：o(nmlog(mn))

空间复杂度：o(mn)

其中最外层遍历为n，内部每一次循环都需要遍历primes数组即m，同时每次遍历还需要加入优先队列中，优先队列在运行过程中长度为o(mn)，每次调整时间复杂度为log(mn)，因此整个算法时间复杂度为o(mnlog(mn))



## 动态规划

上一个方法时间复杂度较高，且需要存储大量的超级丑数供下一步计算，使用动态规划可以减少空间复杂度和时间复杂度

使用dp[i]表示第i个超级丑数，dp[0] = 0，此时需要考虑 dp[i]和dp[i-1]之间的状态转移关系，从解法一中给出的样例可以看到，

下一个超级丑数一定是之前的某一个超级丑数和某一个质数的乘积，那么只需要找到距dp[i-1]最接近的那个超级丑数即可

由于dp数组是一个有序的，primes数组也是有序的，那么越靠前的dp[j]乘上越靠前的primes值越小，可以使用一个数组存储当前primes对应想乘的值，当出现重复的时候就将其自增

此时状态转移方程可以描述为 
$$
dp[i] = min(dp[next[j]]*primes[j])
$$


每次循环结束使用当前最小值对next值更新，防止出现重复

if(dp[i] == dp[next[j]]*primes[j]) ++next[j]



下面示范计算过程

n = 12

primes = [2,7,13,19]

**初始化**

dp = [1]

next = [0,0,0,0]

**step1**

dp[1] = min(2,7,13,19) = 2

dp = [1,2]

next = [1,0,0,0]

**step2**

dp[2] = min(4,7,13,19) = 4

dp = [1,2,4]

next = [2,0,0,0]

**step3**

dp[3] = min(8,7,13,19) = 7

dp = [1,2,4,7]

next = [2,1,0,0]

**step4**

dp[4] = min(8,14,13,19) = 8

dp = [1,2,3,7,8]

next = [3,1,0,0]

**step5**

dp[5] = min(14,14,13,19) = 13

dp = [1,2,3,7,8,13]

next = [3,1,1,0]

**step6**

dp[6] = min(14,14,26,19) = 14

dp = [1,2,3,7,8,13,14]

next = [4,2,1,0]

**step7**

dp[7] = min(16,28,26,19) = 16

dp = [1,2,3,7,8,13,14,16]

next = [5,2,1,0]

**step8**

dp[8] = min(26,28,26,19) = 19

dp = [1,2,3,7,8,13,14,16,19]

next = [5,2,1,1]

**step9**

dp[9] = min(26,28,26,38) = 26

dp = [1,2,3,7,8,13,14,16,19,26]

其中dp[next[0]]\*2 == 26，dp[next[2]]\*13 == 26

next  = [6,2,2,1]

**step10**

dp[10] = min(28,28,39,38) = 28

dp = [1,2,3,7,8,13,14,16,19,26,28]

其中dp[next[0]]\*2 == 28，dp[next[1]]*7 == 28

next = [7,3,2,1]

**step11**

dp[11] = min(32,42,39,38) = 32

dp = [1,2,3,7,8,13,14,16,19,28,32]

next = [8,3,2,1]

结束，返回dp[n-1] = 12

思路弄清楚了，代码写起来就很简单了

```java
class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        int[] dp = new int[n];
        int m = primes.length;
        int[] next = new int[m];
        dp[0] = 1;
        for(int i=1;i<n;++i){
            int min = Integer.MAX_VALUE;
          	// 计算当前最小值
            for(int j=0;j<m;++j){
                min = Math.min(min,primes[j]*dp[next[j]]);
            }
            dp[i] = min;
          	// 更新next数组
            for(int j=0;j<m;++j){
                if(min == primes[j]*dp[next[j]]) ++next[j];
            }
        }
        return dp[n-1];
    }
}
```

