---
title: 5844. 数组元素的最小非零乘积
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 6cbc
date: 2021-08-15
---
# 5844. 数组元素的最小非零乘积

给你一个正整数 p 。你有一个下标从 **1** 开始的数组 nums ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 **包含**）。你可以进行以下操作 **任意** 次：

- 从 nums 中选择两个元素 x 和 y  。
- 选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 **相同位置** 的二进制位。
  

比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x = 1111 和 y = 0001 。

请你算出进行以上操作 **任意次** 以后，nums 能得到的 **最小非零** 乘积。将乘积对 10<sup>9</sup> + 7 **取余** 后返回。

注意：答案应为取余 **之前** 的最小值。

> 链接：https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements

<!-- more -->

## 贪心+快速幂

> 对于两个二进制数x，y，如果交换二者对应位置的位，实际上二者的和不会发生变化，但是乘积会变
>
> 证明：
>
> 对于对应位置的位，有两种情况，相同或不同
>
> 相同的时候，交换了之后数字不变，和当然不变
>
> 不同的时候，不妨设x对应位为1，y对应位为0，设对应位的bit序为k，那么x交换之后的值为
>
> x-(1<<k)，而y交换之后的值为y+(1<<k)，这样x+y的和不变，得证
>
> 要使得二者乘积最小，那么就应该尽可能拉大二者距离，这样使得乘积尽可能小

这个题也挺有意思的，数据范围不大，但是算起来很讲究，知道前面几个值如何计算后就可以推出计算公式了

当 p = 1 时，数组 = [1] 

乘积为1

当 p = 2 时，数组 = [01,10,11]

此时无论如何交换值都不会变，乘积为6

当 p = 3 时，数组 = [001,010,011,100,101,110,111]

首先 001 没什么好变的，直接看第二个，由于交换对应位后和不变，那么应该再和不变情况下尽可能多制造1

这样将 010 和 101 交换第一位，变成 110 和 001

对于 011 也是同理，将其和 100 交换第二位，也变成 110和001

此时无法再制造更多1，此时乘积达到最小

乘积为 6\*6\*6\*7 = 6^3*7

当 p = 4 时，数组 = [0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111]

同样的思路，制造更多的1，最终数组可以变成

[0001,0001,0001,0001,0001,0001,0001,1110,1110,1110,1110,1110,1110,1110,1111]

乘积为 14\*14\*14\*14\*14\*14\*14\*15 = 14^7\*15

算完这四个，可以大概最小乘积计算公式
$$
res = (2^p-1)*(2^p-2)^{2^{p-1}-1}
$$
这时候再来看数据范围，p最大可取60

也就是说最大结果需要计算
$$
(2^{60}-1)*(2^{60}-2)^{2^{59}-1}
$$
很明显，如果不使用快速幂计算的话就是一个指数级别的，需要使用快速幂算法将其时间复杂度降为o(p)

这里不赘述快速幂算法，详见 **剑指 Offer 16. 数值的整数次方**

```java
class Solution {
    private static final long modder = (long) 1e9+7;
    public int minNonZeroProduct(int p) {
        // 实际上多推几个就可以找到规律
        // p = 1 res = 1
        // p = 2 res = 6
        // p = 3 res = 6^3*7
        // p = 4 res = 14^7*15
        // p = 5 res = 30^15*31
        // 但是很明显的是，30^15一定会溢出，因此在计算的过程中就需要取模
        // 由于 1<= p <= 60
        long v = (1L << p) - 2L;
        // 必须使用快速幂，否则算不过来
        long n = (1L << (p-1)) - 1L;
        long res = (pow(v,n)*((v+1)%modder))%modder;
        return (int) res;
    }

    public long pow(long x, long n){
        x %= modder;
        long res = 1L;
        while (n > 0){
            if ((n & 1) != 0 ){
                res = (res * x) % modder;
            }
            x = (x * x) % modder;
            n >>= 1;
        }
        return res;
    }
}
```

