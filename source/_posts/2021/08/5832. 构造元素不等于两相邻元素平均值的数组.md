---
title: 5832. 构造元素不等于两相邻元素平均值的数组
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 458d
---
# 5832. 构造元素不等于两相邻元素平均值的数组

给你一个 下标从 0 开始 的数组 nums ，数组由若干 **互不相同的** 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 不等于 其两侧相邻元素的 平均值 。

更公式化的说法是，重新排列的数组应当满足这一属性：对于范围 1 <= i < nums.length - 1 中的每个 i ，(nums[i-1] + nums[i+1]) / 2 不等于 nums[i] 均成立 。

返回满足题意的任一重排结果。

> 链接：https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors

<!-- more -->

## 排序

这个题关键在于思路，如果没有想到很好的构造方法就会卡很久。这个方法也是看题解看到的，如果要使 
$$
\frac{nums[i-1] + nums[i+1]}{2} = nums[i]
$$
则一定有 nums[i-1] < nums[i] < nums[i+1] 或 nums[i+1] < nums[i] < nums[i-1] ，即满足nums[i]两边的数一个比nums[i]大，一个比nums[i]小，那么从这个角度我们就可以想到构造方案了，是否可以使数组中的数其两边值要么都比他大，要么都比他小呢？其实上只需要对nums进行排序，然后预先将奇数索引填上，再填上偶数索引，就一定满足条件。

知道了思路，代码写起来就很简单了

```java
class Solution {
    public int[] rearrangeArray(int[] nums) {
        Arrays.sort(nums);
        int[] res = new int[nums.length];
        int ptr = 1;
        int i = 0;
      	// 填奇数位上的值
        while(ptr < nums.length){
            res[ptr] = nums[i];
            ++i;
            ptr+=2;
        }
        ptr = 0;
      	// 再偶数位上的值
        while(ptr < nums.length){
            res[ptr] = nums[i];
            ++i;
            ptr += 2;
        }
        return res;
    }
}
```

