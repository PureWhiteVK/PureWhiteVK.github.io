---
title: 5840. 使字符串平衡的最小交换次数
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 16f9
---
# 5840. 使字符串平衡的最小交换次数

给你一个字符串 s ，**下标从 0 开始** ，且长度为偶数 n 。字符串 恰好 由 n / 2 个开括号 '[' 和 n / 2 个闭括号 ']' 组成。

只有能满足下述所有条件的字符串才能称为 **平衡字符串** ：

- 字符串是一个空字符串，或者
- 字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者
- 字符串可以写成 [C] ，其中 C 是一个 平衡字符串 。

你可以交换 **任意** 两个下标所对应的括号 **任意** 次数。

返回使 s 变成 **平衡字符串** 所需要的 **最小** 交换次数。

> 链接：https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-string-balanced

<!-- more -->

## 双指针+贪心

从左往右遍历，同时记录括号的嵌套深度，当发现当前嵌套深度为0且为 ] 的时候，就一定要进行交换，那么就从后往前找到第一个'['即可

> 但是这样做为什么一定可以得到最优呢？

```java
class Solution {
    public int minSwaps(String s) {
        int right = s.length()-1;
        char[] charArr = s.toCharArray();
        int depth = 0;
        int cnt = 0;
        for(char ch:charArr){
            if(ch == '['){
                ++depth;
            }else{
                // 碰到了']'
                if(depth == 0){
                    // 需要从右边找一个'['进行交换
                    while(charArr[right] != '['){
                        --right;
                    }
                    charArr[right] = ']';
                    ++cnt;
                    // 交换了之后嵌套深度增加
                    ++depth;
                }else{
                    --depth;
                }
            }
        }
        // 遍历结束后depth一定是0
        return cnt;
    }
}
```

## 数学+栈

可以在遍历时消除匹配的括号对，最后留下的一定是类似于 "]]][["这种形式的字符串，而这种形式实际上转换成平衡的最小次数是有计算公式的

设共包含 k 个 '['

- 当 k 为偶数的时候，例如 "]]]][[[["，此时只需要交换 k/2 次 ，因为这一种和"`[][][][]`"重合的是最多的
- 当 k 为奇数的时候，例如 "]]][[["，此时先交换左右两端的括号，之后中间的k-1对就是偶数，可以按照偶数的计算，最终交换次数为1+(k-1)/2

实际上 k/2 和 1 + (k-1)/2 可以组合起来，就是 Math.floor((k+1)/2)

在遍历过程中将左括号入栈，每碰到一个右括号就将其出栈，当栈为空的时候说明这个一定是不匹配的，最终可以统计出k的长度，然后按公式输出即可（实际上也可以不用栈，用一个数记录当前的嵌套深度，当深度为0且碰到']'是就是不匹配的

```java
class Solution {
    public int minSwaps(String s) {
        char[] charArr = s.toCharArray();
        int cnt = 0;
        for(char ch:charArr){
            if(ch == ']'){
                if(cnt > 0){
                    --cnt;
                }
            }else{
                // 累加 [ 的个数
                ++cnt;
            }
        }
        // 遍历结束后depth一定是0
        // 最后剩下的cnt就代表未能匹配的括号对数
        // System.out.println(cnt);
        // Math.floot((cnt+1)/2)
        return (cnt+1) >> 1;
    }
}
```



