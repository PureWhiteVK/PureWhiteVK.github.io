---
title: 526. 优美的排列
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: d106
date: 2021-08-16
---
# 526. 优美的排列

假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：

- 第 i 位的数字能被 i 整除

- i 能被第 i 位上的数字整除
  

现在给定一个整数 N，请问可以构造多少个优美的排列？

> 链接：https://leetcode-cn.com/problems/beautiful-arrangement

<!-- more -->

## 递归

可以使用递归产生排列的方式，不断生成数组的排列，然后判断是否是一个优美排列

由于本题最多只有15个数子，可以使用位图存储每个对应位置上的数是否已经访问

```java
class Solution {
    private int n,res,endState;
    public int countArrangement(int _n) {
        // 1～N的N个整数，由于n最大只有15，可以用一个二进制的位存储当前的排列
        // 是否需要用这个二进制数来表示当前状态？
        // 这个二进制数只能存储当前已经访问的数，那么还需要存储的是数组第i位上放的是什么？
        n = _n;
        res = 0;
        endState = ((1<<n)-1)<<1;
        // System.out.println(endState);
        // 110
        dfs(0,1);
        return res;
    }

    private void dfs(int state,int currPos){
        // System.out.println(state);
        if(state == endState){
            ++res;
            return;
        }
        for(int i=1;i<=n;++i){
            if((state & (1<<i)) == 0){
                if(i % currPos == 0 || currPos % i ==0){
                    dfs(state|(1<<i),currPos+1);
                }
            }
        }
    }
}
```

优化：实际上可以提前计算出每个位置上可行的数，然后进行填数即可

```java
class Solution {
    private int n,res,endState;
    private List<Integer>[] availNum;
    public int countArrangement(int _n) {
        // 1～N的N个整数，由于n最大只有15，可以用一个二进制的位存储当前的排列
        // 是否需要用这个二进制数来表示当前状态？
        // 这个二进制数只能存储当前已经访问的数，那么还需要存储的是数组第i位上放的是什么？
        n = _n;
        res = 0;
        // 从 1～n对应位上全部都是1
        // 由于下标从1开始，所以需要左移一个位置
        endState = ((1<<n)-1)<<1;
        // System.out.println(endState);
        // 110
        availNum = new List[n+1];
        for(int i=1;i<=n;++i){
            availNum[i] = new ArrayList<>();
            for(int j=1;j<=n;++j){
                if(i%j==0||j%i==0){
                    availNum[i].add(j);
                }
            }
        }
        dfs(0,1);
        return res;
        // 实际上可以提前计算好对应位置上满足条件的数，然后进行搜索，这样可以减少一点没有意义的计算

    }

    private void dfs(int state,int currPos){
        // System.out.println(state);
        if(state == endState){
            ++res;
            return;
        }
        for(int i : availNum[currPos]){
            // 此处的i一定是满足条件的，可以直接拿去计算
            if((state & (1<<i)) == 0){
                dfs(state|(1<<i),currPos+1);
            }
        }
    }
}
```

