---
title: 剑指 Offer 44. 数字序列中的某一位的数字
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 2bc2
date: 2021-08-14
---
# 剑指 Offer 44. 数字序列中的某一位的数字

数字以0，1，2，3，4，5，6，7，8，9，1，0，1，1，1，2，1，3，1，4，1，5…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

> 链接：https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof

<!-- more -->

## 数学

首先看到这个题没看懂题意，看了好半天才知道，就是将非负整数依次添加到序列中，组成序列为{0,1,2,3,4,5,6,7,8,9,1,0,1,1...}，其中1，0实际上是由10拆开得到的，每一个数字占一位，求第n位对应的数字

数字的位数是不断增加的，其中0～9只占一位，下标范围是0～9，10～99占两位，下标范围是10～189，100～999占三位，下标范围190～2889，根据这个可以计算出第n位对应数字所属的实际数字是几位的，知道了实际数字的位数和下标，可以计算出该实际数字是多少，最后根据下标可以计算出对应实际数组的第几位，求出这一位即可

语言表达能力不是很好，下面举个例子来介绍计算方法

假设我们要求第1234位对应的数字

step1：求第1234位对应的数字其所属实际数字A范围

由190（三位数起始下标） < 1234 < 2889（三位数结束下标），说明数A是是一个三位数

step2：根据下标求出实际数字A在三位数中的偏移量

由三位数起始下标可以计算出进入三位数后已经经过了多少个数，1234-190+1 = 1045，而这1045个数字都是类似于1，0，0，1，0，1这样排列起来的，因此实际数字A偏移量为1045/3 = 348（此处是整除），然后1045%3 = 1，说明第1234位数字对应于实际数字A的首位，

> 类似于[1,0,0],[1,0,1],[1] 如果取模值为0，说明是实际数字的最后一位，如果取模值不为0，前 k / mod 个数字都可以表示完，现在实际上对应的是第 k / mod + 1个数字

step3：计算出实际数字A

因为1045 / 3 = 348 且 1045%3 = 1 不为 0，说明前348个数字都可以完整表示，现在正在表示第349个数字，那么从100开始的第349个数字是 349 + 100 - 1 = 448

step4：根据取模值计算对应的数字

由于1045 % 3 = 1，说明表示的是448的最高位，那么可以得到第1234位对应的数字是4 

代码实现

```java
class Solution {
    public int findNthDigit(int n) {
        if(n<10) return n;
        int[] dp = new int[]{9,189,2889,38889,488889,5888889,68888889,788888889,2147483647};
        int[] startVal = new int[]{10,100,1000,10000,100000,1000000,10000000,100000000};
        int pos=-1;
      	// 确定n代表数子所属位数范围，是在几位数字之中
        while(n>dp[pos+1]){
            ++pos;
        }
        // 计算至当前位数的数字开始经过了多少个数字
        int cnt = n-dp[pos];
      	// 位数
        int mod = pos + 2;
      	// 当前数字代表的位数
        int bit = cnt % mod;
      	// 表示的实际数字范围
        int val = cnt / mod + startVal[pos] - 1;
        if(bit>0){
          	// val表示完了，现在表示的是val+1
            ++val;
            // 当bit等于1的时候代表的是最高位，以此类推
          	// 1 2 3 4 0
          	// 9 9 9 9 9
          	// 当bit大于0时，由于是倒着计算位数，需要反转一下
          	// 变成
          	// 4 3 2 1 0
          	// 9 9 9 9 9
            bit = mod - bit;
        }
        while(bit>0){
            val /= 10;
            --bit;
        }
      	// 取val的最低位
        return val % 10;
    }
}
```

