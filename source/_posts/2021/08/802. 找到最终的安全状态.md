---
title: 802. 找到最终的安全状态
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 9b1b
date: 2021-08-05
---
# 802. 找到最终的安全状态

在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。

对于一个起始节点，如果从该节点出发，**无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全** 的。

返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。

该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。

> 链接：https://leetcode-cn.com/problems/find-eventual-safe-states

<!-- more -->

## dfs + 状态标记

如果采用常规的dfs算法，可以枚举图中的所有路径，判断该路径是否为环，如果是环则说明该节点不是安全的，但是这样每次都会进行重复搜索，时间复杂度过高，可以使用剪枝操作减少搜索树大小，使用visited数组来判断是否出现环，同时对于后续节点，可以优先判断其是否是安全节点，可以将结果存储在safe数组中，当再次访问到该节点时就可以直接返回，不需要进行重复判断了

```java
class Solution {
    int[][] graph;
    boolean[] visited;
    boolean[] safe;
    public List<Integer> eventualSafeNodes(int[][] graph) {
        // graph是图的临接表，表示该节点相连的所有节点
        // 题目要求是，从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点
        // 也就是说不能存在环，如果有环则必定不能在有限步内到达终点
        // 找到图中的环，删去所有环上的节点？
        int length = graph.length;
        this.visited = new boolean[length];
        this.safe = new boolean[length];
        this.graph = graph;
        List<Integer> res = new ArrayList<>();
        for(int i=0;i<length;++i){
            if(dfs(i)){
                res.add(i);
            }
        }
        return res;
    }

    private boolean dfs(int node){
      	// 碰到已经访问过的节点，如果是安全节点
        if(visited[node]){
            return safe[node];
        }
        visited[node] = true;
        // 从该节点出发
        // 如果该节点的所有节点都可以到达终点，说明是一个安全节点
        for(int i:graph[node]){
            if(!dfs(i)){
                return false;
            }
        }
        // 此处需要将操作还原
        // 如果此处还原的话，就会产生很多不必要的重复计算，导致超时
        // visited[node] = false;
        safe[node] = true;
        return true;
    }
}
```

​     

写法2：

事实上，上面的safe数组和visited数组用数字状态来表示，共包含三个状态值

- 0：表示该节点未访问
- 1：该节点仍在递归栈中
- 2：该节点是安全节点

```java
class Solution {
    int[][] graph;
    int[] color;
    public List<Integer> eventualSafeNodes(int[][] graph) {
        // graph是图的临接表，表示该节点相连的所有节点
        // 题目要求是，从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点
        // 也就是说不能存在环，如果有环则必定不能在有限步内到达终点
        // 找到图中的环，删去所有环上的节点？
        int length = graph.length;
        this.color = new int[length];
        this.graph = graph;
        List<Integer> res = new ArrayList<>();
        for(int i=0;i<length;++i){
            // Arrays.fill(visited,false);
            if(dfs(i)){
                res.add(i);
            }
        }
        // dfs(1);
        return res;
    }

    private boolean dfs(int node){
        // 当color[node] 大于 0 就说明这个节点已经访问过了，不需要再次访问
        if(color[node] > 0){
            return color[node] == 2;
        }
        // 遍历该节点的所有相邻节点
        color[node] = 1;
        for(int i:graph[node]){
            if(!dfs(i)){
                return false;
            }
        }
        // 当该节点的所有路径都可以到达终点，说明该节点是一个安全节点
        color[node] = 2;
        return true;
    }
}
```

## 反向图+拓扑排序

> [【宫水三叶の相信科学系列】详解何为拓扑排序，以及求拓扑排序方法的正确性证明 - 找到最终的安全状态 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-eventual-safe-states/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-isy6u/)

在图论问题中，一个有向无环图必然存在至少一个拓扑序与之对应，反之亦然。

简单来说，就是将图中的所有节点展开成一维序列，对于序列中任意的节点(u,v)，如果在序列中u在v的前面，则说明图中存在从u到达v的通路，反之亦然

同时，我们需要知道图论中两个基本概念

- 出度：有多少条边直接指向该节点
- 入度：由该节点指出的边有多少条

因此，对于有向图的拓扑排序，我们可以使用如下思路输出拓扑序（BFS方式）

1. 起始时，将所有入度为 0 的节点进行入队（入度为 0，说明没有边指向这些节点，将它们放到拓扑排序的首部，不会违反拓扑序定义）；
2. **从队列中进行节点出队操作，出队序列就是对应我们输出的拓扑序**。
   对于当前弹出的节点 x，遍历 x 的所有出度，即遍历所有由 x 直接指向的节点 y，对 y 做入度减一操作（因为 x 节点已经从队列中弹出，被添加到拓扑序中，等价于从 x 节点从有向图中被移除，相应的由 x 发出的边也应当被删除，带来的影响是与 x 相连的节点 y 的入度减一）；
3. 对 y 进行入度减一之后，检查 y 的入度是否为 0，如果为 0 则将 y 入队（当 y 的入度为 0，说明有向图中在 y 前面的所有的节点均被添加到拓扑序中，此时 y 可以作为拓扑序的某个片段的首部被添加，而不是违反拓扑序的定义）；
4. 循环流程 2、3 直到队列为空。

**证明**：

上述 BFS 方法能够求得「某个有向无环图的拓扑序」的前提是：我们必然能够找到（至少）一个「入度为 0 的点」，在起始时将其入队。

这可以使用反证法进行证明：假设有向无环图的拓扑序不存在入度为 0 的点。

那么从图中的任意节点 x 进行出发，沿着边进行反向检索，由于不存在入度为 0 的节点，因此每个点都能够找到上一个节点。

当我们找到一条长度为 n + 1 的反向路径时，由于我们图中只有 n 个节点，因此必然有至少一个节点在该路径中重复出现，即该反向路径中存在环，与我们「有向无环图」的起始条件冲突。

得证「有向无环图的拓扑序」必然存在（至少）一个「入度为 00 的点」。

即按照上述的 BFS 方法，我们能够按照流程迭代下去，直到将有向无环图的所有节点从队列中弹出。

反之，如果一个图不是「有向无环图」的话，我们是无法将所有节点入队的，因此能够通过入队节点数量是否为 n 来**判断是否为有向无环图**。



那么这一题是如何使用「拓扑排序」解决问题的呢：根据题意，若一个节点没有出边，则该节点是安全的；若一个节点出边相连的点都是安全的，则该节点也是安全的。

因此只需要对该图的反图求一个拓扑排序，不断求出度为0的节点即可

```java
class Solution {
    public List<Integer> eventualSafeNodes(int[][] graph) {
        List<List<Integer>> reverseGraph = new ArrayList<>();
        int length = graph.length;
        for(int i=0;i<length;++i){
            reverseGraph.add(new ArrayList<>());
        }
        int[] inDegree = new int[length];
        Queue<Integer> queue = new LinkedList<>();
        for(int i=0;i<length;++i){
            for(int v:graph[i]){
                // 原本从v到i有一个节点，即存在边 i->v，在反图中就是 v->i
                reverseGraph.get(v).add(i);
            }
            // 可以得到该节点在反图的入度
            inDegree[i] = graph[i].length;
            if(inDegree[i] == 0){
                queue.offer(i);
            }
        }
        List<Integer> res = new ArrayList<>();
        while(queue.size()!=0){
            int curr = queue.poll();
            // res.add(curr);
            for(int i:reverseGraph.get(curr)){
                --inDegree[i];
                if(inDegree[i] == 0){
                    queue.offer(i);
                }
            }
        }
        // 由于最终结果要求是升序排列的，所有不能在遍历队列过程中就直接添加节点
        for(int i=0;i<length;++i){
            if(inDegree[i] == 0){
                res.add(i);
            }
        }
        return res;
    }
}
```



