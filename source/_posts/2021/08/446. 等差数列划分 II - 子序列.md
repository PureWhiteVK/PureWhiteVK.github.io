---
title: 446. 等差数列划分 II - 子序列
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: f020
---
# 446. 等差数列划分 II - 子序列

给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。

如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。

例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。
再例如，[1, 1, 2, 5, 7] 不是等差序列。
数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。

例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。
题目数据保证答案是一个 32-bit 整数。

> 链接：https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence

<!-- more -->

## 动态规划+哈希表

这一题相比前一题 **413. 等差数列划分** 难度更大，需要找到数列子序列（可以不连续）为等差数列

而一个数列的子序列个数为2^n个，显然暴力是不行的，可以用dp[i,k]表示以数字nums[i]结尾的，公差为k的弱等差数列的个数（弱等差数列：数列长度至少为2的等差数列），这样状态转移公式为
$$
dp[i,k] = \sum_{j<i}{dp[j,k]+1}
$$
其中j需要满足 nums[i]-nums[j] == k

也就是说，对于所有的以nums[j]结尾，公差为k的弱等差数列，都可以将nums[i]插入到该弱等差数列末尾，同时nums[i],nums[j]构成了一个新的弱等差数列

而求得弱等差数列个数后，转换为等差数列个数就很简单了，注意到，等差数列个数是弱等差数列中长度大于等于3的，而将nums[i]插入到以nums[j]结尾的弱等差数列时，该弱等差数列的长度一定是大于等于3的，因此只需要统计这一部分的值就行

说上去好像很复杂，下面举例解释

nums = [2,4,5,6,7,8,10]

初始化：

dp是一个二维数组，但由于公差取值范围太大，使用Map存储

step1：以 nums[1] 即 4 结尾的弱等差数列

dp[1,2] = 1，此时代表数列{2,4}

step2：以 nums[2] 即 5 结尾的弱等差数列

dp[2,3] = 1，此时代表数列{2,5}

dp[2,1] = 1，此时代表数列{4,5}

step3：以 nums[3] 即 6 结尾的弱等差数列

dp[3,4] = 1，此时代表数列{2,6}

dp[3,2] = dp[1,2] + 1 = 2，此时代表数列{2,4,6}、{4,6}

由于向数列{2,4}中添加元素6，组成了等差数列，更新res=1

dp[3,1] = dp[2,1] + 1 = 2，此时代表数列{4,5,6} 、{5,6}

由于向数列{4,5}中添加元素6，组成了等差数列，更新res=2

step4：以 nums[4] 即 7 结尾的弱等差数列

dp[4,5] = 1，此时代表数列{2,7}

dp[4,3] = 1，此时代表数列{4,7}

dp[4,2] = 1，此时代表数列{5,7}

dp[4,1] = dp[3,1] + 1 = 3，此时代表数列{4,5,6,7}、{5,6,7}、{6,7}

由于向数列{4,5,6}、{5,6}中添加了元素7，组成了等差数列，更新res=4

step5：以 nums[5] 即 8 结尾的弱等差数列

dp[5,6] = 1，此时代表数列{2,8}

dp[5,4] = 1，此时代表数列{4,8}

dp[5,3] = 1，此时代表数列{5,8}

dp[5,2] = dp[3,2] + 1 = 3，此时代表数列{2,4,6,8}、{4,6,8}、{6,8}

由于向数列{2,4,6}、{4,6}添加了元素8，组成了等差数列，更新res=6

dp[5,1] = dp[4,1] + 1 = 4，此时代表数列{4,5,6,7,8}、{5,6,7,8}、{6,7,8}、{7,8}

由于向数列{4,5,6,7}、{5,6,7}、{6,7}中添加了元素8，组成了等差数列，更新res=9

step6：以 nums[6] 即 10 结尾的弱等差数列

dp[6,8] = 1，此时代表数列{2,10}

dp[6,6] = 1，此时代表数列{4,10}

dp[6,5] = 1，此时代表数列{5,10}

dp[6,4] = 1，此时代表数列{6,10}

dp[6,3] = dp[4,3] + 1 = 2，此时代表数列{4,7,10}、{7,10}

由于向数列{4,7}中添加了元素10，组成了等差数列，更新res=10

dp[6,2] = dp[5,2]+1 = 4，此时代表数列{2,4,6,8,10}、{4,6,8,10}、{6,8,10}、{8,10}

由于向数列{2,4,6,8}、{4,6,8}、{6,8}中添加了元素10，组成了等差数列，更新res=13

遍历结束，最终返回res=13，分别是

{2,4,6}、{4,5,6}、{4,5,6,7}、{5,6,7}、{2,4,6,8}、{4,6,8}、{4,5,6,7,8}、{5,6,7,8}、{6,7,8}、{4,7,10}、{2,4,6,8,10}、{4,6,8,10}、{6,8,10}

代码实现

```java
class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        // 使用dp[i][k]表示公差为k的等差数列，以nums[i]结尾的弱等差数列（包含两个元素）个数
        // 由于dp[i][k]表示的是弱等差数列，因此将i插入到j后面，此时就构成了三个元素，可以算成等差数列
        // 因此可以有状态转移公式 if(nums[i] - nums[j] == k) dp[i][k] = dp[j][k]+1;
        // 第一次进行状态更新的时候构成的时弱等差，但第二次时就是一个包含三个元素的等差数列了，因此可以在统计弱等差数列的时候稍加处理就可以求解等差数列
        int length = nums.length;
        Map<Long,Integer>[] dp = new Map[length];
        for(int i=0;i<length;++i){
            dp[i] = new HashMap<>();
        }
        int res = 0;
        for(int i=0;i<length;++i){
            for(int j=0;j<i;++j){
                long d = (long) nums[i]-nums[j];
                int cnt = dp[j].getOrDefault(d,0);
                res += cnt;
                dp[i].put(d,dp[i].getOrDefault(d,0)+cnt+1);
            }
        }
        // for(int i=0;i<length;++i){
        //     for(long k:dp[i].keySet()){
        //         System.out.println("dp["+i+"]["+k+"]="+dp[i].get(k));
        //     }
        // }
        return res;
    }
}
```

## 序列DP解题思路

> [【宫水三叶】详解如何分析「序列 DP」问题（附序列 DP 问题目录） - 等差数列划分 II - 子序列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/solution/gong-shui-san-xie-xiang-jie-ru-he-fen-xi-ykvk/)

序列DP类的题目一般描述是，对于一个给定的序列，需要找出满足某个条件的所有子序列

对这种类型的题目，最基本的思路使用dp[i]表示满足给定条件的，以nums[i]结尾的子序列，然后枚举0～i-1的所有数，观察是否满足条件，进行状态更新

> **枚举当前位置前面的所有位置的目的，是为了找到当前位置的数，能够接在哪一个位置的后面，形成序列。**

*此处dp[i]不一定就是一个数，也可能是其他数据结构，需要结合具体问题思考

