---
title: 剑指 Offer 64. 求1+2+...+n
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '9336'
---
# 剑指 Offer 64. 求1+2+...+n

求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

> [剑指 Offer 64. 求1+2+…+n - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/qiu-12n-lcof/)

<!-- more -->

## 递归+短路运算

首先1一直加到n，最简单的就是采用循环，但是本题不准使用循环，那么使用递归也可以模拟循环，但是递归一定需要一个终止条件，而本题不允许使用条件判断语句，即if、A?B:C都是不可以用的，那么就只能使用逻辑表达式求值的短路运算了

对于一个逻辑表达式而言，如果运行时已经知道了该表达式的值时，就不会继续求值了，因此可以使用这个方法来结束递归

```java
class Solution {
    public int sumNums(int n) {
      	// 当n为0时，flag的值已经可以确定了，就不会继续执行递归程序，此时就可以终止递归计算，然后返回值
        boolean flag = n!=0 && (n+=sumNums(n-1)) > 0;
        return n;
    }
}
```

## 位运算+循环展开

小学就学过，1+2+...+n = (1+n)\*n/2，对于除二运算只需要向左位移一位即可，那么难点在于如何通过位运算实现两个数的乘法，实际上也是很简单的，

考虑15*7，将其转换成二进制形式

0b0000_1111 * 0b0000_0111

实际上可以将7拆分为(4+2+1)那么就变成 15\*4+15\*2+15*1 ，也即 15 << 2 + 15 << 1 + 15 << 0

因此对于任何一个正整数，只需要将其展开31次，转换成二的幂次相加的形式即可

那么现在的实现目标就是，如何知道数字对应位上是否为1，实际上也很简单

b&(1<<i) == 0，说明数字b的第i位是0，然后同样使用上面的方法执行判断即可

```java
class Solution {
    public int sumNums(int n) {
        return multiply(n+1,n)>>1;
    }

    private int multiply(int a,int b){
        int res = 0;
        boolean bool;
      	// 本来是逐位进行判断的，将其循环展开，由于2^13<10000<2^14，因此只需要判断到13号位即可
        bool = ((b&(1<<0)) != 0) && (res += (a << 0)) > 0;
        bool = ((b&(1<<1)) != 0) && (res += (a << 1)) > 0;
        bool = ((b&(1<<2)) != 0) && (res += (a << 2)) > 0;
        bool = ((b&(1<<3)) != 0) && (res += (a << 3)) > 0;
        bool = ((b&(1<<4)) != 0) && (res += (a << 4)) > 0;
        bool = ((b&(1<<5)) != 0) && (res += (a << 5)) > 0;
        bool = ((b&(1<<6)) != 0) && (res += (a << 6)) > 0;
        bool = ((b&(1<<7)) != 0) && (res += (a << 7)) > 0;
        bool = ((b&(1<<8)) != 0) && (res += (a << 8)) > 0;
        bool = ((b&(1<<9)) != 0) && (res += (a << 9)) > 0;
        bool = ((b&(1<<10)) != 0) && (res += (a << 10)) > 0;
        bool = ((b&(1<<11)) != 0) && (res += (a << 11)) > 0;
        bool = ((b&(1<<12)) != 0) && (res += (a << 12)) > 0;
        bool = ((b&(1<<13)) != 0) && (res += (a << 13)) > 0;
        return res;
    }
}
```



