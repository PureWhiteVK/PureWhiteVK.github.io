---
title: 581. 最短无序连续子数组
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '1722'
date: 2021-08-03
---
# 581. 最短无序连续子数组

给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

请你找出符合题意的 最短 子数组，并输出它的长度。

> 链接：https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray

<!-- more -->

## 双指针+排序

看到整个数组变成升序排列，那么可以直接将数组排序，之后对比两个数组，然后使用双指针找出连续子数组

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int length = nums.length;
        // 只需要将nums中对应的数组变成有序，整个数组就会变成有序
        // 需要找出这个子数组的最短长度
        // [2,6,4,8,10,9,15]
        // [2,4,6,8,9,10,15]
        // 一种可行的思路？先对nums排序，然后找出那些位置不会发生变化的，最后只需要将其变成有序就可以？
        int[] temp = new int[length];
        for(int i=0;i<length;++i){
            temp[i] = nums[i];
        }
        Arrays.sort(temp);
        // 双指针，从数组两端开始，找到不同时就可以结束了
        int l = 0;
        int r = length-1;
        while(l<length){
            if(temp[l] != nums[l]) {
                break;
            }
            ++l;
        }
        if(l == length) return 0;
        while(r>-1){
            if(temp[r] != nums[r]){
                break;
            }
            --r;
        }
        return r-l+1;
    }
}
```

时间复杂度：o(nlogn)

空间复杂度：o(n)

## 双指针+线性扫描

实际上数组nums可以划分成3个子数组[numsA,numsB,numsC]，其中numsA和numsC都是有序的，而numsB是无序的，只需要找到最长的numsA和numsC就可以确定最短的numsB，由于对numsB排序后整个数组为有序的，那么可以很容易知道，对于numsA中任意一个数，都有numsA[i] < [numsB,numsC]，同理对于numsC中任意一个数，都有numsC[i] > [numsA,numsB]

通过这个条件，遍历数组nums，不断更新满足条件的边界值，最后就可以找到numsB的最小左右边界

拿数组 [2,6,4,8,10,9,15] 为例

对于numsA[i]，可以发现到6的时候不满足条件，因为其右边的值比他小，此时l=1

对于numsC[i]，可以发现到9的时候不满足条件，因为其左边的值比他大，此时r=5

最后直接用r-l+1就可以得出numsB的长度

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length;
        int maxn = Integer.MIN_VALUE, right = -1;
        int minn = Integer.MAX_VALUE, left = -1;
        for (int i = 0; i < n; i++) {
            // System.out.println(right+" "+left+" "+maxn+" "+minn);
            // maxn从左边开始找
          	// 从左往右看，发现有maxn大于nums[i]，那么此时对于nums数组而言，是肯定需要交换的，也就是说这个值一定是在numsB范围内
            if (maxn > nums[i]) {
                right = i;
            } else {
                maxn = nums[i];
            }
            // minn从右边开始找
            if (minn < nums[n - i - 1]) {
                left = n - i - 1;
            } else {
                minn = nums[n - i - 1];
            }
        }
        // System.out.println(right+" "+left+" "+maxn+" "+minn);

        return right == -1 ? 0 : right - left + 1;
    }
}
```

以数组 [2,2,2,3,3,3,1,1,1,4,4,4] 为例展示计算过程

初始化 ：

maxn = Integer.MIN_VALUE

minn = Integer.MAX_VALUE

l = -1

r = -1

iter1：

对于maxn，从左往右开始遍历，此时nums[0] = 2 > maxn = Integer.MIN_VALUE

需要更新maxn的值，maxn = 2

对于minn，从右往左开始遍历，此时nums[11] = 4 < minn = Integer.MAX_VALUE

需要更新minn的值，minn=4

iter2：

此时nums[1] = 2 == maxn = 2，维持maxn=2

此时nums[10] = 4 == minn = 4，维持minn=4

iter3：

此时nums[2] = 2 == maxn = 2，维持maxn=2

此时nums[9] = 4 == minn = 4，维持minn=4

iter4：

此时nums[3] = 3 > maxn = 2，更新maxn=3

此时nums[8] = 1 < minn = 4，更新minn=1

iter5：

此时nums[4] = 3 == maxn = 3，维持maxn=3

此时nums[7] = 1 == minn = 1，维持minn=1

iter6：

此时nums[5] = 3 == maxn = 3，维持maxn=3

此时nums[6] = 1 == minn = 1，维持minn=1

iter7：

此时nums[6] = 1 < maxn = 3，更新right=6

此时nums[5] = 3 > minn = 1，更新left=5

iter8：

此时nums[7] = 1 < maxn = 3，更新right=7

此时nums[4] = 3 > minn = 1，更新left=4

iter9：

此时nums[8] = 1 < maxn = 3，更新right=8

此时nums[3] = 3 > minn = 1，更新left=3

iter10:

此时nums[9] = 4 > maxn = 3，更新maxn=4

此时nums[2] = 2 > minn = 1，更新left=2

iter11：

此时nums[10] = 4 > maxn = 3，维持maxn=4

此时nums[1] = 2 > minn = 1，更新left=1

iter12：

此时nums[11] = 4 > maxn = 3，维持maxn=4

此时nums[0] = 2 > minn = 1，更新left=0

最后可以得到left=0，right=8，需要排序的最长连续子序列长度就是right-left+1 = 9



看完计算流程后，其实还是有点蒙，需要再多理解几遍