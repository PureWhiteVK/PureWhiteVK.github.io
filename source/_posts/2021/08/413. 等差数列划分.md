---
title: 413. 等差数列划分
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '1678'
date: 2021-08-10 00:00:00
---
# 413. 等差数列划分

如果一个数列 **至少有三个元素** ，并且任意两个相邻元素之差相同，则称该数列为等差数列。

- 例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。

给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 **子数组** 个数。

**子数组** 是数组中的一个连续序列。

> 链接：https://leetcode-cn.com/problems/arithmetic-slices

<!-- more -->

## 暴力

由于题目数据规模不是很大（最大长度也就1000），可以直接暴力枚举所有的子数组，然后逐个判断是否是等差数列

```java
class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        if(nums.length < 3) return 0;
        int length = nums.length;
        int res = 0;
        for(int i=0;i+2<length;++i){
            int d = nums[i+1]-nums[i];
            if(d != (nums[i+2]-nums[i+1])) continue;
          	// 找到一个以i开始的等差数列
            ++res;
            for(int j=i+3;j<length;++j){
              	// 判断其后续是不是等差数列
                // 当不满足等差数列条件的时候就需要直接退出
                if((nums[j]-nums[j-1]) != d) break;
                ++res;
            }
        }
        return res;
    }
}
```

时间复杂度：o(n^2)

空间复杂度：o(1)



## 双指针

对于一个本来就是等差数列的数组，例如 [1,2,3,4,5,6,7]

由于其本身是一个等差数列，因此其所有长度大于3的子数列都是等差数列，下面列举所有子数列，并找出其中规律

k = 7

[1,2,3,4,5,6,7]

k = 6

[1,2,3,4,5,6],[2,3,4,5,6,7]

k=5

[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7]

k=4

[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7]

k=3

[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7]

可以发现，对于一个长度为k的等差数列，其所有的子数列等差数列和为 1+2+3+...+k-2

可以用等差数列求和公式求出总个数，即
$$
cnt = (1+k-2)*(k-2)/2
$$

```java
class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        int n = nums.length;
        int ans = 0;
        for (int i = 0; i < n - 2; ) {
            int j = i, d = nums[i + 1] - nums[i];
          	// 找到以i开头，最长可到达的等差数列
            while (j + 1 < n && nums[j + 1] - nums[j] == d) j++;
            int len = j - i + 1;
            // a1：长度为 len 的子数组数量；an：长度为 3 的子数组数量
            int a1 = 1, an = len - 3 + 1;
            // 符合条件（长度大于等于3）的子数组的数量为「差值数列求和」结果
          	// 根据这个最长的等差数列，其所有的子数列都是等差数列，因此可以直接通过公式计算个数
            int cnt = (a1 + an) * an / 2;
            ans += cnt;
          	// 接着i可以从j开始找下一个连续的等差数列
            i = j;
        }
        return ans;
    }
}
```

看似包含双重循环，但实际上每个nums仅遍历一次

时间复杂度：o(n)

空间复杂度：o(1)