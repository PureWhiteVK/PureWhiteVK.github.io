---
title: 847. 访问所有节点的最短路径
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 31a4
---
# 847. 访问所有节点的最短路径

存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1 编号。

给你一个数组 graph 表示这个图。其中，graph[i] 是一个列表，由所有与节点 i 直接相连的节点组成。

返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。

> 链接：https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes

<!-- more -->

## 题目理解

这一题的关键在于：

设最短路径为s，那么所有节点的一种全排列一定是s的一个子序列，考虑到这一点，可以使用当前节点+当前节点的排列作为状态标记

那么这样一共包含n*2^n中状态，只需要遍历这些状态，找到其中到达终点距离最短的即可

关键在于如何表示这些状态，题目中n最大为12，可以使用位图来存储排列信息

## BFS+状态压缩

这一题难度为困难，主要难点在于如何存储当前遍历的状态，从而找到最短路径

```java
class Solution {
    public int shortestPathLength(int[][] graph) {
        // 如果使用BFS，那么需要考虑的问题就是可以多次访问节点，重复使用边，如何存储状态
        // int[] = { nodeId,mask }
        // mask实际上也可以用来表示状态，n位，和dp解法中的mask类似，表示关键节点的全排列
        // node就表示在mask状态下最后一个访问的节点
        int length = graph.length;
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[length][1<<length];
        // 由于graph的是12，实际上可以将mask和nodeId放在一起做hash
        // [mask,nodeId]
        // 一共只需要16位
        // 2^(x+4)和 x*2^x
        // 好像还是 x*2^x小一点
        for(int i=0;i<length;++i){
            // 每个节点都有可能作为起点开始搜索
            queue.offer(new int[]{i,1<<i});
            visited[i][1<<i] = true;
        }

        int endState = (1<<length) - 1;
        int res = 0;
        while(queue.size()!=0){
            int currSize = queue.size();
            // 当前队列的dist就是同一个值
            while(currSize > 0){
                int[] state = queue.poll();
                // 到达终止状态
                if(state[1] == endState){
                    // 由于是在两个循环内，一重break还不够，直接返回最好
                    return res;
                }
                // 继续搜索
                for(int i:graph[state[0]]){
                  	// 将 mask的第i位置1
                    int nextState = state[1] | (1<<i); 
                    if(!visited[i][nextState]){
                        queue.offer(new int[]{i,nextState});
                        // 必须要提前进行标记
                        visited[i][nextState] = true;
                    }
                }
                --currSize;
            }
            ++res;
        }
        return 0;
    }
}
```



## Floyd+动态规划+状态压缩

这一题需要找到能够访问所有节点的最短路径长度，设最佳路径为序列s，那么所有节点的一种全排列一定路径序列的一个子序列（可以不连续），因此只需要枚举这些关键点就行，因此所有的状态数为 n*2^n，

使用dp[i,mask]来表示在mask下，最后一个访问的节点是i时经过的路径长度，其中mask记录了当前访问过的所有节点

状态转移方程
$$
dp[i,mask] = min(dp[j,mask \otimes(1<<i)]+dis[j,i],dp[i,mask])
$$
其中
$$
mask\otimes(1<<i)
$$
就表示将mask的第i为置0，即尚未访问到j的最短距离，然后在加上从j到i的最短距离（需要使用BFS或Floyd提前计算，存储到dis矩阵中），在所有可行点中找到最短的作为新值

而当mask是2的幂次时（仅包含一个1时，此时实际上就是开始状态，还没有开始走，因此dp[u,mask] = 0

其中 u 代表 mask上1所在的位置（实际上就代表路径初始节点的选择）

```java
class Solution {
    public int shortestPathLength(int[][] graph) {
        // 需要求出任意两个节点之间的最短路径，然后安排路线？
        int length = graph.length;
        // 存储节点之间的距离
        int[][] dis = new int[length][length];
        // 距离初始化为INF，由于是一个连通且不带权的图，那么节点之间最长距离就是n+1
        for(int i=0;i<length;++i){
            Arrays.fill(dis[i],length+1);
            for(int k:graph[i]){
                dis[i][k] = 1;
            }
        }
        // 从每个节点开始计算
        // 最外层循环是中间节点
        for(int k=0;k<length;++k){
            // 不断调整每个节点之间的距离
            for(int i=0;i<length;++i){
                for(int j=0;j<length;++j){
                    dis[i][j] = Math.min(dis[i][j],dis[i][k]+dis[k][j]);
                }
            }           
        }
        // for(int i=0;i<length;++i){
        //     for(int j=0;j<length;++j){
        //         System.out.print(dis[i][j]+" ");
        //     }
        //     System.out.println();
        // }
        // dis上可以得出每个节点之间的最短距离，之后需要计算访问所有节点的最短路径的长度
        // 由于是连通图，那么从哪个节点出发都是一样的
        // 使用 dp[i][mask]路径中关键节点i（当前路径下的最后一个节点，mask记录了当前访问过的全部节点，
        // 由于节点数最多只有12个，是完全足够存下的，每一位代表当前访问
        // 表示将mask上的第i位置0，^是java中位的异或运算
        // dp[i][mask] = Math.min(dp[j][mask ^ (1<<i)]+dis[i][j],dp[i][mask]);
        int finalState = (1<<length) -1;
        int[][] dp = new int[length][finalState+1];
        for(int i=0;i<length;++i){
            Arrays.fill(dp[i],Integer.MAX_VALUE / 2);
        }
        // 此处枚举了所有状态（实际上就是全排列）
        for(int mask=1;mask<=finalState;++mask){
            // 判断是否是一个数开始
            if((mask & (mask-1)) == 0){
                // 2^n
                // 这时候需要计算出mask上的1在哪一位
                int value = Integer.bitCount((mask&(-mask))-1);
                // System.out.println("1<<"+value+" == "+mask);
                // 使用mask&(-mask) -1可以快速求出这一位位于那一个1上
                dp[value][mask] = 0;
            }else{
              	// 对于每一个mask，都需要对当前状态进行更新
                for(int i=0;i<length;++i){
                    // 此时mask需要i和j都是1
                    if((mask & (1<<i)) != 0){
                        for(int j=0;j<length;++j){
                            if((mask & (1<<j)) !=0 && i!=j){
                                dp[i][mask] = Math.min(dp[i][mask],dp[j][mask ^ (1<<i)]+dis[j][i]);
                            }
                        }
                    }
                }
            }
        }

        int res = Integer.MAX_VALUE;
        for(int i=0;i<length;++i){
            res = Math.min(res,dp[i][finalState]);
        }
        return res;
    }
}
```

