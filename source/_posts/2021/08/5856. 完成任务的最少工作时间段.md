---
title: 5856. 完成任务的最少工作时间段
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: c1af
---
# 5856. 完成任务的最少工作时间段

你被安排了 n 个任务。任务需要花费的时间用长度为 n 的整数数组 tasks 表示，第 i 个任务需要花费 tasks[i] 小时完成。一个 工作时间段 中，你可以 至多 连续工作 sessionTime 个小时，然后休息一会儿。

你需要按照如下条件完成给定任务：

如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。
完成一个任务后，你可以 立马 开始一个新的任务。
你可以按 任意顺序 完成任务。
给你 tasks 和 sessionTime ，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段 。

测试数据保证 sessionTime 大于等于 tasks[i] 中的 最大值 。

提示：

- n == tasks.length
- 1 <= n <= 14
- 1 <= tasks[i] <= 10
- max(tasks[i]) <= sessionTime <= 15

> 链接：https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks

<!-- more -->

## 题目理解

这一题实际也可以理解成背包问题，将tasks看成n个物品，每个物品重量为tasks[i]，背包容量为sessionTime，然后问至少需要多少次才能把这些物品全部拿走

## 状态压缩+动态规划

### 写法1（暴力）

自己在周赛时瞎写的，居然过了，差点超时

思路如下：

使用dp[i,state]表示在第i个工作时间段后能否完成state表示的所有任务，状态转移方程
$$
dp[i,state] = dp[i-1,state/sub] \and sum(sub)<sessionTime
$$
其中sub代表state的一个子集，state/sub表示state除去sub之和剩下的元素，实际也很好理解，假设在第i-1轮时完成了state/sub表示的任务，那么如果sub所表示的任务可以在sessionTime完成，那么dp[i,state]也就可以完成，很明显dp[i]仅依赖于dp[i-1]，可以将空间压缩至o(2^l)

计算时需要从0开始，不断更新，初态dp[0,*] = false

实现代码

```java
class Solution {
    int l;
    int[] tasks;
    int sessionTime;
    public int minSessions(int[] _tasks, int _sessionTime) {
        this.sessionTime = _sessionTime;
        this.tasks = _tasks;
        this.l = tasks.length;
        int endState = (1<<l)-1;
        boolean[] dp = new boolean[endState+1];
      	// 从0开始，生成第一步可行的搬法
        dfs(dp,0);
        // 最多也就l轮
        int round = 1;
        while(!dp[endState]){
            boolean[] temp = new boolean[endState+1];
            // printArr(dp);
            for(int j=1;j<=endState;++j){
                // 前一轮不行的，这一轮当然也不行
                if(!dp[j]) continue;
                // 目前已知state/sub，需要反推state
                dfs(temp,j);
            }
            dp = temp;
            ++round;
        }
        return round;
    }

    private void printArr(boolean[] arr){
        for(boolean b:arr){
            System.out.print(b+"\t");
        }
        System.out.println();
    }

    private void dfs(boolean[] dp,int target){
        // 首先找出target上所有为0的位置
        int[] t = new int[l];
        int size = 0;
        for(int i=0;i<l;++i){
            if((target&(1<<i)) == 0){
                t[size++] = i;
            }
        }
        // 枚举sub的子集
        int end = 1<<size;
        for(int i=1;i<end;++i){
            int cost = 0;
            int mask = target;
            for(int j=0;j<size;++j){
                if((i & (1<<j)) != 0){
                    cost += tasks[t[j]];
                    mask |= 1<<t[j];
                }
            }
        		// 计算sum(sub) , 实际上就是 dp[i,state] = dp[i-1,state/sub] && sum(sub) <= sessionTime
            dp[mask] = dp[mask] || (cost <= sessionTime);
        }
    }
}
```



### 优化

>作者：detachmliu
>链接：https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solution/zhuang-ya-dpshi-shi-hou-xue-xi-yi-xia-li-q4mk/
>来源：力扣（LeetCode）
>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
class Solution {
    public int minSessions(int[] tasks, int sessionTime) {
        int n = tasks.length, m = 1 << n;
        final int INF = 20;
        int[] dp = new int[m];
        Arrays.fill(dp, INF);

        // 预处理每个状态，合法状态预设为 1
        for (int i = 1; i < m; i++) {
            int state = i, idx = 0;
            int spend = 0;
            while (state > 0) {
                int bit = state & 1;
                if (bit == 1) {
                    spend += tasks[idx];
                }
                state >>= 1;
                idx++;
            }
            if (spend <= sessionTime) {
                dp[i] = 1;
            }
        }

        // 对每个状态枚举子集，跳过已经有最优解的状态
        for (int i = 1; i < m; i++) {
            if (dp[i] == 1) {
                continue;
            }
            for (int j = i; j > 0; j = (j - 1) & i) {
                // i 状态的最优解可能由当前子集 j 与子集 j 的补集得来
                dp[i] = Math.min(dp[i], dp[j] + dp[i ^ j]);
            }
        }

        return dp[m - 1];
    }
}
```

