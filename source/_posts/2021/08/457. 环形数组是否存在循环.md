---
title: 457. 环形数组是否存在循环
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '2308'
---
# 457. 环形数组是否存在循环

存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数：

如果 nums[i] 是正数，向前 移动 nums[i] 步
如果 nums[i] 是负数，向后 移动 nums[i] 步
因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。

数组中的 **循环** 由长度为 k 的下标序列 seq ：

遵循上述移动规则将导致重复下标序列 seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...
所有 nums[seq[j]] 应当不是 **全正** 就是 **全负**
k > 1
如果 nums 中存在循环，返回 true ；否则，返回 false 。

> 链接：https://leetcode-cn.com/problems/circular-array-loop

## 题意理解

这个题目的中文翻译有点令人费解，简单来说就是类似于走飞行棋，数组中当前位置上的值代表可以向前（向后）行走的步数，在这样的条件下，可能存在环，但是这个环要求不能走回头路，只能朝着一个方向前进（这也就是为什么要nums[seq[i]]全正或全负）要求从一个方向前进，同时也不能包括自环

<!-- more -->

## 模拟

可以从每一个节点开始，进行遍历，如果行走的过程中发现走了回头路（两次nums[i]的值符号相反）或者在原地踏步，那就说明不是环）判断每一个节点，最后一定可以给出结果

```java
class Solution {
    int[] nums;
    boolean[] visited;
    int length;
    boolean isPositive;

    public boolean circularArrayLoop(int[] nums) {
        // nums[i]表示位于下标i的角色应该向前或向后移动的下标个数
        // >0 向前走nums[i]步，
        // <0 向后走nums[i]步
        this.nums = nums;
        this.length = nums.length;
        this.visited = new boolean[length];
        for(int i=0;i<length;++i){
            Arrays.fill(visited,false);
            if(dfs(i,-1)){
                return true;
            }
        }
        return false;
    }

    public boolean dfs(int index,int prevIndex){
        // System.out.println(index);
        // 当重新访问到一个已经访问过的节点时
        // 要求所有的nums[seq[j]]不是全正就是全负
        if(visited[index]){
            // 如果存在自环，就是错误的
            if(prevIndex == index) return false;
            return true;
        }
        // 当cnt大于
        visited[index] = true;
        // 这时候需要考虑循环终止条件是什么？
        // 在java中，当一个负数对于正数取模的时候，其结果也是一个负数，因此需要加上length将结果恢复到[0,n)内
        int next = ((index + nums[index]) % length + length) % length;
        // 有可能出现不止走一圈的情况，需要多加几次
        // 如果下一步与期望的正负不通，就说明出问题，因为不能走回头路
        if(nums[index] * nums[next] < 0){
            return false;
        }
        return dfs(next,index);
    }
}
```



## 快慢指针

实际上这个题目也可以使用类似链表找环的思路进行求解，采用快慢指针，其中快指针一次走两步，而慢指针一次走一步，如果存在环，那么快慢指针一定会相遇

```java
class Solution {
    public boolean circularArrayLoop(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i++) {
          	// nums[i]已经访问过了，无法进入环，说明不行，直接跳过
            if (nums[i] == 0) {
                continue;
            }
            int slow = i, fast = next(nums, i);
            // 判断非零且方向相同
          	// 这个判断其实很讲究，
          	// 首先判断慢指针是否和快指针（慢指针的下一个）同一方向，如果是的，判断快指针和快指针的下一个是否同一方向
          	// 又因为经过前一次的判断，此时快指针和慢指针是同一方向，只需要判断慢指针和快指针的下一个是否是同一方向即可
          	// 但写的时候写成 nums[slow] * nums[fast] > 0 && nums[fast] * nums[next(nums,fast)] > 0
            // 也是没问题的，实际上还更容易理解
          	// 而且由于之前标记了0，如果碰到0直接退出这一轮循环，进入下一个节点的判断，很妙
            while (nums[slow] * nums[fast] > 0 && nums[slow] * nums[next(nums, fast)] > 0) {
                if (slow == fast) {
                  	// 排除自环
                    if (slow != next(nums, slow)) {
                        return true;
                    } else {
                        break;
                    }
                }
                slow = next(nums, slow);
                fast = next(nums, next(nums, fast));
            }
            int add = i;
          	// 将快慢指针走过的路标记为访问过
            while (nums[add] * nums[next(nums, add)] > 0) {
                int tmp = add;
                add = next(nums, add);
                nums[tmp] = 0;
            }
        }
        return false;
    }

    public int next(int[] nums, int cur) {
        int n = nums.length;
        return ((cur + nums[cur]) % n + n) % n; // 保证返回值在 [0,n) 中
    }
}
```

