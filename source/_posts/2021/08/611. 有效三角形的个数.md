---
title: 611. 有效三角形的个数
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '2669'
---
# 611. 有效三角形的个数

给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

> 链接：https://leetcode-cn.com/problems/valid-triangle-number/

<!-- more -->

## 题目理解

这个题目没什么好说的，在数组中找三个数，使其满足三角形三条边条件（任意两边之和大于第三边）即可

- a+b > c
- a+c > b
- b+c > a

假设a、b、c之间存在偏序关系a<b<c，那么a+c>b和b+c>a是一定满足的，因此只需要将数组排序后寻找所有满足条件的c，满足c>a+b即可，由于数组已是有序，可以使用二分查找找到第一个a+b=c的位置，而在之前的数就都满足这个条件

## 排序+暴力

```java
class Solution {
    public int triangleNumber(int[] nums) {
        int length = nums.length;
        Arrays.sort(nums);
        int res = 0;
        for(int i=0;i<length;++i){
            for(int j=i+1;j<length;++j){
                for(int k=j+1;k<length;++k){
                    if(nums[i] + nums[j] > nums[k]){
                        ++res;
                    }
                }
            }
        }
        return res;
    }
}
```

时间复杂度：o(n^3)

空间复杂度：o(logn)的栈空间

## 排序+二分查找

相对于暴力枚举，只需要遍历k时将线性查找转换为二分查找，快速定位第一个满足条件的k的位置，就可以实现快速统计

```java
class Solution {
    public int triangleNumber(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        int res = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
              	// 原本这里是线性查找，现在优化成二分查找
                int left = j + 1, right = n - 1, k = j;
                int target = nums[i] + nums[j];
                while (left <= right) {
                    int mid = (left + right) / 2;
                    if (nums[mid] < target) {
                        k = mid;
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }
                res += k - j;
            }
        }
        return res;
    }
}
```

时间复杂度：o(n^2*logn)

空间复杂度：o(logn)栈空间

## 排序+双指针

在上述方法中，每次都需要无论是线性查找还是使用二分查找，都是重新在数组中找到满足 nums[k] < nums[i] + nums[j] 的最大数，但是由于nums是一个有序的数组，当i和j在不断增加的过程中，k也一定是不断增加的，因此可以将k和j看成两个同向（递增）移动的指针

```java
class Solution {
    public int triangleNumber(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            int k = i;
            for (int j = i + 1; j < n; ++j) {
                while (k + 1 < n && nums[k + 1] < nums[i] + nums[j]) {
                    ++k;
                }
              	// 有可能出现不存在的情况，此时k就是i，k-j一定小于0，需要排除
                ans += Math.max(k - j, 0);
            }
        }
        return ans;
    }
}
```

这段代码看上有三重循环，但是由于k和j实际上同步增加，因此该算法的时间复杂度为o(n^2)，关键在于利用了数组的有序性，不需要每次从头查找满足条件的值