---
title: 剑指 Offer 31. 栈的压入、弹出序列
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 5f77
date: 2021-08-07
---
# 剑指 Offer 31. 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

> 链接：https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof

<!-- more -->

## 模拟

这一题还挺有意思的，需要判断对一个不包含重复数字的入栈序列，给出的出栈序列是否合法

可以使用栈根据弹出序列来模拟压栈、出栈的实际执行情况，如果可以正确执行，就说明是一个合法的序列，如果不能就说明不是

那么问题来了：如何使用栈进行模拟呢？

首先需要明白，出栈序列的每一个元素都是其出栈那个状态的栈顶元素，如果不满足这个条件，说明不是一个合法的出栈序列

下面拿一个具体的例子如何进行模拟

入栈序列：{1,2,3,4,5}

出栈序列：{4,5,3,2,1}

出栈序列的值包含两种情况，在栈顶或还没进栈

- 下一个出栈值是栈顶元素：直接出栈，进行下一步操作
- 下一个出栈值是还没有进栈，那么就需要将该值放到栈顶，之后再将其出栈，进行下一步操作

因此只需按上面两种情况进行模拟即可

初始状态

stack = []

入栈序列 = {1,2,3,4,5}

出栈序列 = {4,5,3,2,1}

step1：此时模拟栈为空，那么出栈元素只可能在入栈序列中，将其置于栈顶，然后出栈

stack = [1,2,3]

入栈序列 = {5}

出栈序列 = {5,3,2,1}

step2：此时模拟栈的栈顶元素为3，不等于下一个出栈元素，说明结果要么在入栈序列中，如果不在就说明是一个非法的出栈序列，这一步中出栈元素在待入栈序列中，因此将其出栈即可

stack = [1,2,3]

入栈序列 = {}

出栈序列 = {3,2,1}

step3：此时入栈序列已经为空，只需要比较栈顶元素是否等于出栈元素即可

stack = [1,2]

入栈序列 = {}

出栈序列 = {2,1}

step4：

stack = [1]

入栈序列 = {}

出栈序列 = {1}

step5：

stack = []

入栈序列 = {}

出栈序列 = {}

结论：{4,5,3,2,1}是入栈序列{1,2,3,4,5}的一个合法出栈序列

思路弄清楚了之后就可以开始编码

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        // 根据进栈序列，判断是否是合法的出栈序列（出栈序列种数是著名的卡特兰数）
        // pushed中的所有数都是唯一的
        // popped实际上是pushed中的一个排列，可以按照popped对pushed情况进行模拟
        Stack<Integer> stack = new Stack<>();
        int length = pushed.length;
        int i = 0,j=0;
        
        while(j<length){
            // 如果当前没有路可以走了，说明这个排列不对
            if(i==length && stack.peek() != popped[j]) return false;
          	// 出栈值在待入栈序列时
            while(i < length && pushed[i] != popped[j]){
                stack.push(pushed[i]);
                ++i;
            }
            // 此时i自增，j也自增
            if(i<length) ++i;
            ++j;
          	// 出栈值在栈顶时
            while(!stack.empty() && stack.peek() == popped[j]){
                stack.pop();
                ++j;
            }
        }
        return true;
    }
}
```



