---
title: 1953. 你可以工作的最大周数
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 809c
date: 2021-08-12
---
# 1953. 你可以工作的最大周数

给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones ，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。

你可以按下面两个规则参与项目中的工作：

每周，你将会完成 **某一个** 项目中的 **恰好一个** 阶段任务。你每周都 **必须** 工作。
在 **连续的** 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。
一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 **停止工作** 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。

返回在不违反上面规则的情况下你 **最多** 能工作多少周。

> 链接：https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work

<!-- more -->

## 贪心

首先看到这个题目，可以很直观的想到，需要找到一个阶段任务数最大的项目作为主项目，每两周完成一个阶段任务，其他时间来完成剩下的任务。那么现在就要考虑，最大项目的完成周数是否会影响最大工作周数？

实际上，只要满足
$$
longest <= rest + 1
$$
就一定可以完成所有的任务，那么这是为什么呢？

考虑临界情况
$$
longest = rest + 1
$$
以[5,3,1]为例，此时将周期最长的项目先排开，

5｜5｜5｜5｜5

此时全都是相邻的，为了满足条件，需要将其他任务插入到空隙中

5｜3｜5｜3｜5｜3｜5｜1｜5

可以直观的看到，完成longest这个任务，至少需要有longest-1个空白周才能完成，那么这longest-1个空白周就需要用其他任务来填补，当剩下任务周数不足longest-1时，必定完不成这个任务了

但是如果rest > longest - 1的话，时间会充裕很多，就一定能完成任务

以 [5,3,2,1]为例

同样先考虑最难完成的5

5｜5｜5｜5｜5

先插空

5｜3｜5｜3｜5｜3｜5｜1｜5

此时还剩下2，但是由于连续两周之间不会完成同一个项目，此时只需要任意选择位置做项目就行

也就是说，最困难的就是安排做大项目的空隙，如果大项目一定可以完成，那么剩下的空隙是一定够完成其他任务的，因为随着任务的不断安排，可安排的空隙越来越多，就一定可以完成任务

> 周赛的时候，以为是贪心法，就不断的取出最大值，用剩下的值从大到小来消掉最大值，后面发现最后几个case过不了，逻辑是有问题的；看题解，大多数题解只给了公式，并没有很直观的解释，其实这道题就是转化下题意就很好理解了。
>
> 首先，题目要求满足不重复项目的最大的工作周数，我们可以这样理解，将所有项目的任务排成一个任务序列，找到一个前缀最长的相邻元素不重复的序列即可。因此，我们可以首先将任务数最多的项目先排开，然后将其它任务插入到它的间隙中。
> 例如，[1,2,3,5]，最大的项目任务数为5，因此我们先得到项目4的5个任务的序列5 5 5 5 5，我们依次将其它任务插入以保证相邻不重复，依次得到 5 3 5 3 5 3 5 5,不够，再将2插入，得到5 3 5 3 5 3 5 2 5,此时我们已经能保证5的任务不相邻了。而且我们发现，随着插入的任务数越多，可供后面任务插入的空位越多(大于最大项目的任务数)，因此后面的任务只要插入前面序列两个不相邻的任务中间，就不会重复。综上，我们只需要保证任务数最多的项目不重复即可保证所有项目的任务不重复。
>
> 作者：WilsonYIU
> 链接：https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work/solution/ti-yi-zhuan-hua-cha-kong-fa-by-yorwood-bvdv/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

知道思路后，写起来就很简单了

```java
class Solution {
    public long numberOfWeeks(int[] milestones) {
        long sum = 0;
        long max = -1;
        for(int i:milestones){
            sum += i;
            max = Math.max(max,i);
        }
        long rest = sum - max;
        return rest+1>=max?sum:2*rest+1;
    } 
}
```

