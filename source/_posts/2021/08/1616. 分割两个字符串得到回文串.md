---
title: 1616. 分割两个字符串得到回文串
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: d34d
---
# 1616. 分割两个字符串得到回文串

给你两个字符串 a 和 b ，它们长度相同。请你选择一个下标，将两个字符串都在 **相同的下标** 分割开。由 a 可以得到两个字符串： a.prefix 和 a.suffix ，满足 a = a.prefix + a.suffix ，同理，由 b 可以得到两个字符串 b.prefix 和 b.suffix ，满足 b = b.prefix + b.suffix 。请你判断 a.prefix + b.suffix 或者 b.prefix + a.suffix 能否构成回文串。

当你将一个字符串 s 分割成 s.prefix 和 s.suffix 时， s.suffix 或者 s.prefix 可以为空。比方说， s = "abc" 那么 "" + "abc" ， "a" + "bc" ， "ab" + "c" 和 "abc" + "" 都是合法分割。

如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。

注意， x + y 表示连接字符串 x 和 y 。

> 链接：https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome

<!-- more -->

## 暴力

最简单的办法，由于a和b的在相同的下标分割成prefix和suffix两部分，那么可以枚举分割点的位置，逐个进行判断

```java
class Solution {
    public boolean checkPalindromeFormation(String a, String b) {
        int length = a.length();
        for(int i=0;i<=length;++i){
            if(
                checkPalindrome(a.substring(0,i)+b.substring(i)) || 
                checkPalindrome(b.substring(0,i)+a.substring(i))
            ){
                return true;
            }
        }
        return false;
    }

    private boolean checkPalindrome(String s){
        int l = 0;
        int r = s.length()-1;
        while(l<r){
            if(s.charAt(l) == s.charAt(r)){
                ++l;
                --r;
            }else{
                return false;
            }
        }
        return true;
    }
}
```

时间复杂度：o(n^2)

本题字符串长度最大可以到10^5，这个算法会超时

## 贪心

那么暴力不行，就需要提前做一些优化，减少遍历

由于a.prefix需要和b.prefix组合成回文串，或者b.prefix和a.suffix组合成回文串

那么如果a本身不是回文串的情况下，a.prefix和b.suffix之间一定存在重叠字符，之后二者长度较长的剩下一部分就一定是一个回文串

也就是说，二者重叠部分应该是越多越好（贪心）

因此可以先使用双指针找到二者前后缀之前重叠部分，之后判断剩下的是否是一个回文串

例如：

```
a = "pvhmupgqeltozftlmfjjde"
b = "yjgpzbezspnnpszebzmhvp"

其中a和b的重叠部分是 "pvhm"
那么可选的分割点位置有两个，第一个是a.prefix = "pvhm"，第二个是b.suffix = "mhvp"
二者之间的部分就一定有一个回文串，否则这两个字符串就不可能组合成回文串
"upgqeltozftlmf"
"zbezspnnpszebz"
```

那么现在问题来了，为什么分割点的位置一定是两个字符串前后缀最大重叠部分呢？

因为如果用较小的前后缀也能匹配且剩下的中间部分是回文，那么若存在更长的前后缀匹配，其中间部分也必然是回文。因此可以总是用最长的匹配，检查剩余中间部分是否为回文代替。不失一般性。

> 作者：jyj407
> 链接：https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/solution/1616-fen-ge-liang-ge-zi-fu-chuan-de-dao-x82oe/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
class Solution {
    public boolean checkPalindromeFormation(String a, String b) {
        // 只需要a.prefix+b.suffix 或 a.suffix+b.prefix可以构成回文串即可
        return check(a,b) || check(b,a);
    }

    private boolean check(String a,String b){
      	// 检查a.prefix + b.suffix是否可以组成回文串
        int length = a.length();
        int left = 0;
        int right = length-1;
        // 检查a.prefix+b.suffix是否可以构成回文串
        while(left < right && a.charAt(left) == b.charAt(right)){
            ++left;
            --right;
        }
        // System.out.println(left);
        // 检查剩余部分是不是一个回文串
        // 有可能是a前缀包含了很多
        // 假设此处的分割点是left，或length-left
        if(
            checkPalindrome(a.substring(left,length-left)) || 
            checkPalindrome(b.substring(left,length-left))
        ) return true;
        return false;
    }

    private boolean checkPalindrome(String s){
        // System.out.println(s);
        int left = 0;
        int right = s.length()-1;
        while(left < right){
            if(s.charAt(left) == s.charAt(right)){
                ++left;
                --right;
            }else{
                return false;
            }
        }
        return true;
    }
}
```

