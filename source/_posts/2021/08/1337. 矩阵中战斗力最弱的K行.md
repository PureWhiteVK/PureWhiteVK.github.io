---
title: 1337. 矩阵中战斗力最弱的K行
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 1c9b
date: 2021-08-12
---
# 1337. 矩阵中战斗力最弱的K行
给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。

请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。

如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。

军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

>链接：https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix

<!-- more -->

## 二分查找+堆

由于军人总是排在一行中的靠前位置，即matrix中每一行的数组都是有序的，因此可以通过二分查找快速确定0出现的位置（即一行中军人的个数），同时题目要求找出前k个战斗力最弱的，最先考虑到的就是优先队列，由于建堆时间为o(logn)，因此最多只需要o(klogn)时间复杂度就可以找到前k个战斗力最弱的
```java
class  Solution {
	public  int[] kWeakestRows(int[][] mat, int  k) {
		PriorityQueue<int[]> queue = new  PriorityQueue<int[]>((a,b)->a[1]==b[1]?a[0]-b[0]:a[1]-b[1]);
		// 由于此处军人总是排在一行的靠前位置，因此矩阵的每一行都是有序的，可以使用二分查找找到军人的位置
		for(int  i=0;i<mat.length;++i){
			queue.offer(new  int[]{i,lowerBound(mat[i])});
		}
		int[] res = new  int[k];
		for(int  i=0;i<k;++i){
			res[i] = queue.poll()[0];
		}
		return res;
	}

	private  int  lowerBound(int[] nums){
		//只需要找到nums中第一个0出现的位置即可
		int  l = 0;
		int  r = nums.length;
		while(l<r){
			int  mid = (l+r) >> 1;
			if(nums[mid] == 1){
				l = mid + 1;
			}else{
				r = mid;
			}
		}
		return l;
	}
}
```
