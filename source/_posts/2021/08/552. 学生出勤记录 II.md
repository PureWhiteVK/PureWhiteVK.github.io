---
title: 个人博客搭建记录
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '96e0'
date: 2021-08-18
---
# 552. 学生出勤记录 II

可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：

- 'A'：Absent，缺勤
- 'L'：Late，迟到
- 'P'：Present，到场
  

如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：

按 **总出勤** 计，学生缺勤（'A'）**严格** 少于两天。
学生 **不会** 存在 **连续** 3 天或 **连续** 3 天以上的迟到（'L'）记录。
给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 **数量** 。答案可能很大，所以返回对 10<sup>9</sup> + 7 **取余** 的结果。

> 链接：https://leetcode-cn.com/problems/student-attendance-record-ii

<!-- more -->

## 动态规划

该题是个困难题，难点在于如何归纳出状态转移方程，下面简单描述一下如何推倒出状态转移方程

首先依旧从dp[i]出发，设dp[i]表示长度为i的出勤记录中可以获得出勤奖励的记录数，接下来我们就要考虑状态之间的转移关系，

由dp[i-1]推倒出dp[i]

导致学生不能获得出勤奖励的条件有两个，缺勤次数大于1或者连续迟到3天以上，为了完整表示这些状态

- 出勤记录中最后一次出勤情况（缺勤，迟到，到场）
- 当前出勤记录中是否已经有过缺勤
- 出勤记录的最后两次出勤情况是否是迟到

从这三个角度出发，我们可以归纳出所有的状态

- 最后一次出勤情况为缺勤
- 最后两次出勤情况都是迟到，且之前没有过缺勤
- 最后两次出勤情况都是迟到，且之前有过缺勤
- 最后一次出勤情况为迟到，但倒数第二次没有迟到，且之前没有缺勤
- 最后一次出勤情况为迟到，但倒数第二次没有迟到，且之前有过缺勤
- 最后一次出勤情况为到场，且之前没有缺勤
- 最后一次出勤情况为到场，切之前有过缺勤

根据归纳出的状态，就可以写出状态转移方程
$$
\left\{
	\begin{align*}
	& dp[i][0] = dp[i-1][1] + dp[i-1][3] + dp[i-1][5] \\
  & dp[i][1] = dp[i-1][3] \\ 
  & dp[i][2] = dp[i-1][4] \\ 
  & dp[i][3] = dp[i-1][5] \\ 
  & dp[i][4] = dp[i-1][0] + dp[i-1][6] \\ 
  & dp[i][5] = dp[i-1][1] + dp[i-1][3] + dp[i-1][5] \\ 
  & dp[i][6] = dp[i-1][0] + dp[i-1][2] + dp[i-1][4] + dp[i-1][6] \\
	\end{align*}
\right.
$$

初始状态 dp[1,0] = 1, dp[1,3] = 1,dp[1,5] = 1，分别代表A，L，P

### 普通版

```java
class Solution {
    private static final int MOD = (int)1e9+7;
    public int checkRecord(int n) {
        int[][] dp = new int[n+1][7];
        dp[1][0] = 1;
        dp[1][3] = 1;
        dp[1][5] = 1;
        for(int i=2;i<=n;++i){
            dp[i][0] = ((dp[i-1][1]+dp[i-1][3])%MOD+dp[i-1][5])%MOD;
            dp[i][1] = dp[i-1][3];
            dp[i][2] = dp[i-1][4];
            dp[i][3] = dp[i-1][5];
            dp[i][4] = (dp[i-1][6]+dp[i-1][0]) % MOD;
            dp[i][5] = ((dp[i-1][1]+dp[i-1][3])%MOD+dp[i-1][5])%MOD;
            dp[i][6] = (((dp[i-1][0]+dp[i-1][2])%MOD+dp[i-1][4])%MOD+dp[i-1][6])%MOD;
        }
        int res = 0;
        for(int i=0;i<7;++i){
            res = (res + dp[n][i]) % MOD;
        }
        return res;
    }
}
```

### 空间优化版

由于dp[i]仅和dp[i-1]有关，可以直接使用7个数存储状态，然后不断更新即可

```java
class Solution {
    private static final int MOD = (int)1e9+7;
    private static final int[] dp = new int[7];
    private static final int[] t = new int[7];
    public int checkRecord(int n) {   
        for(int i=0;i<7;++i) dp[i] = 0;
        dp[0] = 1;
        dp[3] = 1;
        dp[5] = 1;
        for(int i=2;i<=n;++i){
            t[0] = ((dp[1]+dp[3])%MOD+dp[5])%MOD;
            t[1] = dp[3];
            t[2] = dp[4];
            t[3] = dp[5];
            t[4] = (dp[0]+dp[6]) % MOD;
            t[5] = ((dp[1]+dp[3])%MOD+dp[5])%MOD;
            t[6] = (((dp[0]+dp[2])%MOD+dp[4])%MOD+dp[6])%MOD;
            for(int j=0;j<7;++j) dp[j] = t[j];
        }
        int res = 0;
        for(int i=0;i<7;++i){
            res = (res + dp[i]) % MOD;
        }
        return res;
    }
}
```

### 矩阵快速幂优化

从空间优化版中可以看到，dp[i]仅依赖于dp[i-1]，如果将dp[i]看成一个行向量，根据递推公式，可以转换成矩阵乘法模式
$$
dp[i] = dp[i-1] \cross
\left[
	\begin{matrix}
		0&0&0&1&0&0&0 \\ 
		1&0&0&0&0&1&1 \\
		0&0&0&0&0&0&0 \\
		1&1&0&0&0&1&1 \\
		0&0&1&0&0&0&0 \\
		1&0&0&0&0&1&1 \\
		0&0&0&1&0&0&0 \\ 
	\end{matrix} 
\right]
$$
也即
$$
dp[i] = dp[1] \cross
\left[
	\begin{matrix}
		0&0&0&1&0&0&0 \\ 
		1&0&0&0&0&1&1 \\
		0&0&0&0&0&0&0 \\
		1&1&0&0&0&1&1 \\
		0&0&1&0&0&0&0 \\
		1&0&0&0&0&1&1 \\
		0&0&0&1&0&0&0 \\ 
	\end{matrix} 
\right]^{i-1}
$$
那么就可以使用矩阵快速幂进行计算

```java
class Solution {
    static final int MOD = 1000000007;

    public int checkRecord(int n) {
        long[][] mat = {{1, 1, 0, 1, 0, 0},
                        {1, 0, 1, 1, 0, 0},
                        {1, 0, 0, 1, 0, 0},
                        {0, 0, 0, 1, 1, 0},
                        {0, 0, 0, 1, 0, 1},
                        {0, 0, 0, 1, 0, 0}};
        long[][] res = pow(mat, n);
        long sum = Arrays.stream(res[0]).sum();
        return (int) (sum % MOD);
    }

    public long[][] pow(long[][] mat, int n) {
        long[][] ret = {{1, 0, 0, 0, 0, 0}};
        while (n > 0) {
            if ((n & 1) == 1) {
                ret = multiply(ret, mat);
            }
            n >>= 1;
            mat = multiply(mat, mat);
        }
        return ret;
    }

    public long[][] multiply(long[][] a, long[][] b) {
        int rows = a.length, columns = b[0].length, temp = b.length;
        long[][] c = new long[rows][columns];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns; j++) {
                for (int k = 0; k < temp; k++) {
                    c[i][j] += a[i][k] * b[k][j];
                    c[i][j] %= MOD;
                }
            }
        }
        return c;
    }
}
```

