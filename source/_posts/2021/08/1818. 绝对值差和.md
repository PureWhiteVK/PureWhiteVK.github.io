---
title: 1818. 绝对值差和
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '8083'
---
# 1818. 绝对值差和

给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。

数组 nums1 和 nums2 的 **绝对差值和** 定义为所有 |nums1[i] - nums2[i]|（0 <= i < n）的 总和（下标从 0 开始）。

你可以选用 nums1 中的 **任意一个** 元素来替换 nums1 中的 **至多** 一个元素，以 **最小化** 绝对差值和。

在替换数组 nums1 中最多一个元素 **之后** ，返回最小绝对差值和。因为答案可能很大，所以需要对 10<sup>9</sup> + 7 **取余** 后返回。

|x| 定义为：

如果 x >= 0 ，值为 x ，或者
如果 x <= 0 ，值为 -x

>  链接：https://leetcode-cn.com/problems/minimum-absolute-sum-difference

<!-- more -->

## 暴力求解

暴力的思路很简单，由于可以使用nums1中的任意一个元素来替换nums1中的一个元素，那么可以遍历所有种组合，找到最小的结果

```java
class Solution {
    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        int modder = 1000000007;
        int n = nums1.length;
        int sum = 0;
        for(int i=0;i<n;++i){
            sum = (sum + Math.abs(nums1[i]-nums2[i])) % modder;
        } 
        int res = sum;
   
        for(int i=0;i<n;++i){
            for(int j=0;j<n;++j){
                // 用nums1[j]来替换nums1[i]
                int newAbs = Math.abs(nums1[j]-nums2[i]) % modder;
                int oldAbs = Math.abs(nums1[i]-nums2[i]) % modder;
              	// 计算结果
                res = Math.min(Math.min(sum,sum+newAbs-oldAbs) % modder,res);
            }
        }
        return res;
    }
}
```

由于暴力求解的时间复杂度为o(n2)，本题数据量较大，是一定会超时的，那么有没有更好的解决方案呢？

## 二分查找

从暴力求解的代码可以看出，替换之后结果的大小取决于`newAbs和oldAbs`，只需要找到最小的`newAbs-oldAbs`，就可以使替换之后的绝对值差和最小。

那么如何寻找最小的的这个值呢，可以将nums1进行排序，之后使用二分查找选择最接近nums2[i]的值进行替代，然后计算差值，这样可以将

```java
class Solution {
    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {
        final int MOD = 1000000007;
        int n = nums1.length;
        int[] rec = new int[n];
        System.arraycopy(nums1, 0, rec, 0, n);
        Arrays.sort(rec);
        int sum = 0, maxn = 0;
        for (int i = 0; i < n; i++) {
            int diff = Math.abs(nums1[i] - nums2[i]);
            sum = (sum + diff) % MOD;
          	// 找到最接近nums2[i]的值的下标，由于目标是找到｜nums1[j]-nums2[i]｜最小的，
          	// 因此需要判断两个值，可能大于nums2[i]，也可能小于nums2[i]，
            int j = binarySearch(rec, nums2[i]);
            if (j < n) {
                maxn = Math.max(maxn, diff - (rec[j] - nums2[i]));
            }
            if (j > 0) {
                maxn = Math.max(maxn, diff - (nums2[i] - rec[j - 1]));
            }
        }
        return (sum - maxn + MOD) % MOD;
    }
		
  	// 此处binarySearch返回值目标是找到第一个值比target大的下标
  	// 实际上就是lower_bound
    public int binarySearch(int[] rec, int target) {
        int low = 0, high = rec.length - 1;
        if (rec[high] < target) {
            return high + 1;
        }
        while (low < high) {
            int mid = (high - low) / 2 + low;
            if (rec[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }
}
```

