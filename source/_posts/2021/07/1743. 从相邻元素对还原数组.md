---
title: 1743. 从相邻元素对还原数组
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: a947
date: 2021-07-25
---
# 1743. 从相邻元素对还原数组

存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。

给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。

题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 **按任意顺序** 出现。

返回 **原始数组** nums 。如果存在多种解答，返回 其中任意一个 即可。

> 链接：https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs

<!-- more -->

## 哈希表+dfs

首先看到这个题目的时候还没有什么想法，后面看了眼提示，可以将pairs看成边，这样就变成了包含n个节点，n-1条边的图，且已知节点之间的关联关系，只需要执行一遍dfs就可以找出一条连接所有节点的路径（此时就可以还原出数组了）

```java
class Solution {
    public int[] restoreArray(int[][] adjacentPairs) {
        // 每一个数字可以看成图的节点，pairs表示边（无向边）
        // map{2=[1,3],1=[2],3=[4,2],4=[3]}
        // start = 1
        int n = adjacentPairs.length + 1;
      	// 建立临接表
        Map<Integer,List<Integer>> map = new HashMap<>();
        for(int[] pair : adjacentPairs){
            Integer nodeA = pair[0];
            Integer nodeB = pair[1];
            List<Integer> edgeA = map.getOrDefault(nodeA,new ArrayList<Integer>());
            List<Integer> edgeB = map.getOrDefault(nodeB,new ArrayList<Integer>());
            edgeA.add(nodeB);
            edgeB.add(nodeA);
            map.put(nodeA,edgeA);
            map.put(nodeB,edgeB);
        }
        // 找到开始节点
        int startNode = -1;
        for(Map.Entry<Integer,List<Integer>> entry:map.entrySet()){
            if(entry.getValue().size() == 1){
                // 说明该节点仅与一个节点相邻，是开始节点
                startNode = entry.getKey();
                break;
            }
        }
        // System.out.println("startNode:"+startNode);
        // 开始dfs
        int[] path = new int[n];
        // 实际上由于每一个节点相邻节点最多为2，实际上可以将递归函数转换成迭代形式
        path[0] = startNode;
        path[1] = map.get(startNode).get(0);
        for(int i=2;i<n;++i){
            // 当一个节点被选中后，那就选择另外一个即可
            int nodeA = map.get(path[i-1]).get(0);
            int nodeB = map.get(path[i-1]).get(1);
            path[i] = path[i-2] == nodeA ? nodeB : nodeA; 
        }
        return path;
    }
}
```

