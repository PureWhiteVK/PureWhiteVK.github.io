---
title: 1893. 检查是否区域内所有整数都被覆盖
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '2828'
date: 2021-07-23
---
# 1893. 检查是否区域内所有整数都被覆盖

给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。

如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。

已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti <= x <= endi ，那么我们称整数x 被覆盖了。

>  链接：https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered

<!-- more -->

## 暴力（1）

最容易想到的就是，对于 [left,right] 区间内的每一个整数，逐个判断其是否再区间即可

```java
class Solution {
    public boolean isCovered(int[][] ranges, int left, int right) {
        // 依次检查left到right中的每一个数是否在ranges中？
        for(int i=left;i<=right;++i){
            boolean notIn = true;
            for(int[] range:ranges){
                if(i>=range[0] && i <= range[1]){
                    notIn = false;
                    break;
                }
            }
            if(notIn) return false;
        }
        return true;
    }
}
```

明显，这个算法的时间复杂度为o(n^2)，空间复杂度为o(1)，还可以进一步优化

## 暴力（2）

由于题设中给出了数据的取值范围

- 1 <= ranges.length <= 50
- 1 <= start[i] <= end[i] <= 50
- 1 <= left <= right <= 50

可以使用一个数组nums，其包含1～50内所有的整数，首先遍历一遍ranges中范围，标记，之后再遍历一遍left到right的整数，判断是否在范围内即可

```java
class Solution{
  public boolean isCovered(int[][] ranges,int left,int right){
    boolean[] isIn = new boolean[51];
    for(int[] range:ranges){
      for(int i=range[0];i<=range[1];++i){
        isIn[i] = true;
      }
    }
    for(int i=left;i<=right;++i){
      if(!isIn[i]) return false;
    }
    return true;
  }
}
```

该算法时间复杂度也是o(n^2)，且空间复杂度为o(n)

## 优化

对于暴力（2）解法，实际上只需要判断区间[left,right]之间的整数即可，因此在遍历ranges中的范围时，可以先判断 [ left,right ] 和 [ start[i],end[i] ]是否相交，之后再遍历相交部分，将其标记为可行，最后再遍历一次 [left,right]之间的所有整数，判断其是否被标记即可

```java
class Solution{
  public boolean isCovered(int[][] ranges,int left,int right){
    boolean[] isIn = new boolean[51];
    for(int[] range:ranges){
      int L = Math.max(left,range[0]);
      int R = Math.min(right,range[1]);
      for(int i=L;i<=R;++i){
        isIn[i] = true;
      }
    }
    for(int i=left;i<=right;++i){
      if(!isIn[i]){
        return false;
      }
    }
    return true;
  }
}
```

从结果上进行分析，如果 区间 [left,right] 和 [ range[0],range[1] ]不相交，并不会遍历区间，时间复杂度为o(n*(right-left+1))，空间复杂度为o(n)

## 差分数组+前缀和

最后一种解法是看题解种看到的，使用差分数组 diff 表示相邻格之间，是否被覆盖的变化量

对于区间 [left,right] ，其diff数组中 diff[left]++ ，diff[right+1]--

之后再对diff数组求前缀和，可以发现sum[left]~sum[right]都是1，到了sum[right+1]就变成了0，因此使用差分数组+前缀和可以快速标记区间内的数组，因此对于ranges中的所有范围，只需要标记一遍差分数组，再计算前缀和就可以得出每个数组是否再范围内，同时还可以给出对于数组被标记了几次【这个思路属实牛批】

```java
class Solution{
  public boolean isCovered(int[][] ranges,int left,int right){
    // 由于需要标记到diff[right+1]，而right最大值为50，因此此处数组长度为52
    int[] diff = new int[52];
    int[] sum = new int[52];
    for(int[] range:ranges){
      ++diff[range[0]];
      --diff[range[1]+1];
    }
    // 计算前缀和
    for(int i=1;i<52;++i){
      sum[i] = sum[i-1]+diff[i];
    }
    // 判断区间
    for(int i=left;i<=right;++i){
      if(sum[i] <= 0) return false;
    }
    return true;
  }
}
```

这个算法的时间复杂度为o(n)，空间复杂度为o(n)