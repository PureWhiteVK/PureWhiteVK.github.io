---
title: 218. 天际线问题
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: f720
---
# 218. 天际线问题

城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 **天际线** 。

每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] = [lefti, righti, heighti] 表示：

- lefti 是第 i 座建筑物左边缘的 x 坐标。

- righti 是第 i 座建筑物右边缘的 x 坐标。

- heighti 是第 i 座建筑物的高度。

**天际线** 应该表示为由 “关键点” 组成的列表，格式 [[x1,y1],[x2,y2],...] ，并按 **x 坐标** 进行 **排序** 。**关键点是水平线段的左端点**。列表中最后一个点是最右侧建筑物的终点，y 坐标始终为 0 ，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。

**注意**：输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]

> 链接：https://leetcode-cn.com/problems/the-skyline-problem
> 
>解题思路参考：https://briangordon.github.io/2014/08/the-skyline-problem.html
> 
>作者为了讲解方便，进行图形化展示，便于理解

<!-- more -->

## 暴力解法1（不可行）

首先看题目，可以想到的最简单的思路就是，建立一个数轴，遍历所有的矩形，存储每一个单位上高度变化，之后遍历数轴，找到所有高度发生突变的点就是天际线的关键点

```java
class Solution {
    public List<List<Integer>> getSkyline(int[][] buildings) {
        int n = buildings.length;
        int r = buildings[n-1][1];
        int[] heightMap = new int[r+1];
        for(int[] build :buildings){
            // 按照关键点的定义，此处必须是左闭右开
            for(int i=build[0];i<build[1];++i){
                heightMap[i] = Math.max(heightMap[i],build[2]);
            }
        }
        List<List<Integer>> res = new ArrayList<>();
        // 遍历数轴
        for(int i=1;i<=r;++i){
          	// 找到高度突变的点
            if(heightMap[i] != heightMap[i-1]){
                res.add(List.of(i,heightMap[i]));
            }
        }
        return res;
    }
}
```

分析：这个方法看上去可行，但实际上碰到极端情况是不行的，例如[[1,2^31-1,2^31-1]]，此时需要新建一个长度为2^31的数组，计算下来内存占用非常大，且没有意义，算法运行时间复杂度为o(n*m)，空间复杂度为o(m)，其中m为building的最右端点



## 扫描线

### 暴力解法2

从暴力解法1的执行过程和关键点的选取中可以看出，实际上所有关键点出现的位置要么位于建筑的边界点，要么位于两个建筑相交处，因此存储所有的边界信息，之后遍历边界信息来寻找关键点

[2,3,7,9,12,15,19,20,24]

[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]

在[2,3)区间内，包含建筑[2,9,10]，高度最高的为10，此时记录边界点(2,10)，而在[3,7)区间，包含建筑 [2,9,10]、[3,7,15]、[5,12,12]，高度最高为15，此时记录边界点(3,15)，之后边界点的计算以此类推，同时注意到，使用了prevHeight来保存前一个高度值，只有高度值发生变化时才是一个关键点，如果两个边界间的关键点高度一致是不计算关键点的

```java
class Solution {
    public List<List<Integer>> getSkyline(int[][] buildings) {
        List<Integer> boundry = new ArrayList<>();
        for(int[] building:buildings){
            boundry.add(building[0]);
            boundry.add(building[1]);
        }
        // 之后对boundry进行排序
        Collections.sort(boundry);
        int prev = boundry.get(0),maxHeight = 0,prevHeight = 0;
        List<List<Integer>> res = new ArrayList<>();
        for(int i=1;i<boundry.size();++i){
            int b = boundry.get(i);
            maxHeight = 0;
            // System.out.println("current interval: ["+prev+","+b+")");
            for(int[] build:buildings){
                // 判断建筑是否位于这个区间内 [prev,b)
                if(build[0] <= prev && build[1] >= b){
                    // System.out.println("["+build[0]+","+build[1]+","+build[2]+"]");
                    maxHeight = Math.max(maxHeight,build[2]);
                }
            }
            // System.out.println("maxHeight:"+maxHeight);
            // 仅在高度发生变化时记录
            if(maxHeight != prevHeight){
                res.add(List.of(prev,maxHeight));
            }
            prevHeight = maxHeight;
            prev = b;
        }
        // 最后插入列表中最后一个点
        res.add(List.of(boundry.get(boundry.size()-1),0));
        return res;
    }
}
```

### 优先队列优化

观察暴力解法2的代码，可以发现主要时间都花在寻找区间内高度最高的值，对于每一个区间都需要遍历buildings数组，找到在该区间内的高度最大值，实际上可以使用优先队列存储高度和右边界值，每次插入在区间内的值，可以快速找到最大值，同时注意删除不在区间内不的值即可

```java
class Solution {
    public List<List<Integer>> getSkyline(int[][] buildings) {
        List<Integer> boundry = new ArrayList<>();
        for(int[] building:buildings){
            boundry.add(building[0]);
            boundry.add(building[1]);
        }
        // 之后对boundry进行排序
        Collections.sort(boundry);
        int prev = boundry.get(0),maxHeight = 0,prevHeight = 0,idx=0,n=buildings.length;
        // 存储building信息
        PriorityQueue<int[]> queue = new PriorityQueue<>((a,b)->b[2]-a[2]); 
        List<List<Integer>> res = new ArrayList<>();
        for(int i=1;i<boundry.size();++i){
            int b = boundry.get(i);
            while(idx < n && buildings[idx][0] <= prev && buildings[idx][1] >= b){
                queue.add(buildings[idx]);
                ++idx;
            }

            // 删除堆中不在区间内的值
            while(!queue.isEmpty() && (queue.peek()[0] > prev || queue.peek()[1] < b)){
                queue.poll();
            }
            
            // 仅在高度发生变化时记录
            if(queue.isEmpty()){
                maxHeight = 0;
            }else{
                maxHeight = queue.peek()[2];
            }
						
            if(maxHeight != prevHeight){
                res.add(List.of(prev,maxHeight));
            }
            prevHeight = maxHeight;
            prev = b;
        }
        // 最后插入列表中最后一个点
        res.add(List.of(boundry.get(boundry.size()-1),0));
        return res;
    }
}
```

