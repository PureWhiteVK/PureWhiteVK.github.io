---
title: 863. 二叉树中所有距离为K的结点
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: b96b
date: 2021-07-28
---
# 863. 二叉树中所有距离为K的结点

给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。

返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。

> 链接：https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree

<!-- more -->

## dfs

题目要求找到所有距离目标结点k的所有节点

<img src="863. 二叉树中所有距离为K的结点/binary-tree-distance.png" alt="binary-tree-distance" style="zoom:50%;" />

如上图所示，目标结点为4，需要找到距离它3的所有节点

首先需要找到根节点到目标结点上的路径，之后寻找路径各个结点到距离为k-i的所有节点（但是不用进行重复搜索）这样就可以找到所有距离它为distance节点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<Integer> res;
    List<TreeNode> path;
    Map<TreeNode,Boolean> visitied;

    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        // 首先再怎么样还是需要先找到target所在的节点吧？
        // 同时计算根节点到target的距离m，找到所有距离根节点为k-m的节点？此处好像会出现重复？那要怎么办？
        // 然后以target为根节点，找到所有距离为k的
        // 一种比较蠢的办法就是遍历所有节点，计算target和节点之间的距离，之后选出距离为k的即可
        // System.out.println(distance(root,target));
        res = new ArrayList<>();
        path = new ArrayList<>();
        visitied = new HashMap<>();
        // dfs(target,2,0);
        // 首先计算出
        getPath(root,target);
        // printPath();
        for(int i=0;i<path.size();++i){
            dfs(path.get(i),k-i,0);
        }
        return res;
    }

    private void printPath(){
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for(TreeNode node :path){
            sb.append(node.val).append(',');
        }
        sb.deleteCharAt(sb.length()-1);
        sb.append(']');
        System.out.println(sb);
    }

    // 计算两个节点之间的距离
    private boolean getPath(TreeNode root,TreeNode target){
        if(root == null) return false;
        if(root == target || getPath(root.left,target) || getPath(root.right,target)){
            path.add(root);
            return true;
        }
        return false;
    }

    // dfs，查找距离当前节点为distance的所有节点，必须要求是以target节点之内的
    private void dfs(TreeNode root,int distance,int curr){
        if(root == null || visitied.getOrDefault(root,false)) return;
        visitied.put(root,true);
        if(curr == distance){
            res.add(root.val);
            return;
        }
        dfs(root.left,distance,1+curr);
        dfs(root.right,distance,1+curr);
    }
}
```

