---
title: 并查集
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: f171
date: 2021-07-10
---
# 并查集

> 父指针表示法
>
> 或许实现树的最简单方法就是对每个结点只保存一个指针域，指向其父节点，这种实现方法称为父指针（parent pointer）表示法。很明显，这种实现方法并非处于一般性的目的，因为它对诸如找到一个结点的最左子节点或右兄弟节点这样的重要操作是不够的。那么用这种方法来实现树看来没有什么价值。然而，父指针表示法精确地保存了用于解答下面这个有用问题所需要的信息：“给出两个节点，它们是否在同一棵树中？”为了解答这个问题，只需要顺着节点的父指针链一直追溯到相应的根节点。如果两个节点到达同一个根节点，它们一定在同一棵树中。如果找到的根节点不同，那么这两个节点就不在同一棵树中。

## 并查集基本操作

- 合并（UNION）
- 查找根节点（FIND）
- 判断是否在同一个集合中（differ）

<!-- more -->

## 代码实现（基础版）

```java
package tree.unionfind;

public class BasicArrayUnionFind implements UnionFind {
    private final int[] arr;

    // 实际上创建了11独立节点
    public BasicArrayUnionFind(int length){
        this.arr = new int[length];
        for(int i=0;i<length;++i){
            arr[i] = i;
        }
    }

    @Override
    public int FIND(int index) {
        while(arr[index] != index){
            index = arr[index];
        }
        return index;
    }

    @Override
    public void UNION(int index1, int index2) {
        int r1 = FIND(index1);
        int r2 = FIND(index2);
        if(r1 == r2){
            return;
        }
        arr[r1] = arr[r2];
    }

    @Override
    public boolean differ(int index1, int index2) {
        return FIND(index1) == FIND(index2);
    }
}

```

## 路径压缩优化版

```java
package tree.unionfind;

public class CompressArrayUnionFind implements UnionFind {
    private final int[] arr;

    public CompressArrayUnionFind(int length){
        this.arr = new int[length];
        for(int i=0;i<length;++i){
            arr[i] = i;
        }
    }

    @Override
    public int FIND(int index) {
        int root = index;
        while(arr[root] != root){
            root = arr[root];
        }
        // path compress, all nodes just store root pointer
        while(arr[index] != root){
            int next = arr[index];
            arr[index] = root;
            index = next;
        }
        return root;
    }

    @Override
    public void UNION(int index1, int index2) {
        int r1 = FIND(index1);
        int r2 = FIND(index2);
        if(r1 == r2){
            return;
        }
        arr[r1] = arr[r2];
    }

    @Override
    public boolean differ(int index1, int index2) {
        return FIND(index1) == FIND(index2);
    }
}

```

## 低秩优化版

```java
package tree.unionfind;

public class RankArrayUnionFind implements UnionFind{
    private final int[] arr;
    // 记录树的深度
    private final int[] rank;

    public RankArrayUnionFind(int length){
        this.arr = new int[length];
        this.rank = new int[length];
        for(int i=0;i<length;++i){
            arr[i] = i;
            rank[i] = 1;
        }
    }

    @Override
    public int FIND(int index) {
        while(arr[index] != index){
            index = arr[index];
        }
        return index;
    }

    @Override
    public void UNION(int index1, int index2) {
        int r1 = FIND(index1);
        int r2 = FIND(index2);
        if(r1 == r2){
            return;
        }
        // 低秩优化，近可能保持较低的树深度
        if(rank[r1] > rank[r2]){
            arr[r2] = r1;
        }else{
            arr[r1] = r2;
            if(rank[r1] == rank[r2]){
                ++rank[r2];
            }
        }
    }

    @Override
    public boolean differ(int index1, int index2) {
        return FIND(index1) == FIND(index2);
    }
}

```

## 最终强化版

```java
package tree.unionfind;

public class ArrayUnionFind implements UnionFind{

    private final int[] arr;
    // 记录树的深度
    private final int[] rank;

    public ArrayUnionFind(int length){
        this.arr = new int[length];
        this.rank = new int[length];
        for(int i=0;i<length;++i){
            arr[i] = i;
            rank[i] = 1;
        }
    }


    @Override
    public int FIND(int index) {
        int root = index;
        while(arr[root] != root){
            root = arr[root];
        }
        // path compress, all nodes just store root pointer
        while(arr[index] != root){
            int next = arr[index];
            arr[index] = root;
            index = next;
        }
        return root;
    }

    @Override
    public void UNION(int index1, int index2) {
        int r1 = FIND(index1);
        int r2 = FIND(index2);
        if(r1 == r2){
            return;
        }
        // 低秩优化，近可能保持较低的树深度
        if(rank[r1] > rank[r2]){
            arr[r2] = r1;
        }else{
            arr[r1] = r2;
            if(rank[r1] == rank[r2]){
                ++rank[r2];
            }
        }
    }

    @Override
    public boolean differ(int index1, int index2) {
        return FIND(index1) == FIND(index2);
    }
}

```

