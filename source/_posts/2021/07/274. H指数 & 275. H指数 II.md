---
title: 274. H指数 & 275. H指数 II
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 1aa2
date: 2021-07-17
---
# 274. H指数

给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。

h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。

例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。

> 链接：https://leetcode-cn.com/problems/h-index

<!-- more -->

## 暴力解法

从hIndex的定义中可以看出，h指数的范围在[0,N]区间内，那么只需遍历这个区间的所有值，就可以得出最大的可行hIndex

取0的情况，发表的所有论文引用次数都是0

取N的情况，发表的所有论文引用次数都大于或等于发表论文数，例如

[3,3,3]

```java
class Solution{
  public int hIndex(int[] cs){
    int n = cs.length;
    int maxHIndex = 0;
    // 注意次数，遍历的是所有可行的hIndex值，而不是数组
    for(int i=0;i<=n;++i){
      if(check(cs,i)){
        maxHIndex = Math.max(maxHIndex,i);
      }
    }
  }
  
  public boolean check(int[] cs,int hIndex){
    int refCount = 0;
  	for(int i:cs){
      if(i>=hIndex){
        // 引用次数大于refCount的论文数
        ++refCount;
      }
    }
    // 如果论文数大于hIndex数，说明满足条件，是一个可行的h指数
    return refCount >= hIndex;
  }
}
```

# 二分解法

基于上述暴力解法，可以发现实际上是满足二分查找条件的

1. 首先二分区间是[0,N]，且为有序区间

2. 设[0,N]中一个整数X不为hIndex，那么X+1也必定不是hIndex，但X-1有可能是

```java
class Solution{
  public int hIndex(int[] cs){
    int n = cs.length;
    int l = 0;
    int r = n;
    while(l < r){
      // mid = (l+r-1) / 2; 采用位运算更快
      int mid = l + r + 1 >> 1;
      if(check(cs,mid)){
        // 当mid满足hIndex条件时，可以向右方搜索
        l = mid;
      }else{
        // 不满足时，向左方搜索
        r = mid - 1;
      }
    }
    return r;
  }
  
  // 从定义角度检查给定的值是不是hIndex
  public boolean check(int[] cs,int hIndex){
    int refCount = 0;
  	for(int i:cs){
      if(i>=hIndex){
        // 引用次数大于refCount的论文数
        ++refCount;
      }
    }
    // 如果论文数大于hIndex数，说明满足条件，是一个可行的h指数
    return refCount >= hIndex;
  }
}
```

## 排序解法

### 直接排序

首先考虑对发表的论文进行排序

以[3,0,6,1,5]为例，排序后为[0,1,3,5,6]

之后设hIndex为0，从后向前遍历hIndex

当有arr[i] > hIndex满足hIndex定义，此时hIndex可以自增，

（当前hIndex标明至少有hIndex篇论文的引用次数大于hIndex，此时找到了一篇引用次数大于hIndex，说明至少是hIndex+1，此时hIndex便可以自增了）

```java
class Solution{
  public int hIndex(int[] citations){
    int n = citations.length;
    Arrays.sort(citations);
    int h = 0;
    int i = n-1;
    while(i >= 0 && citations[i] > h ){
      ++h;
      --i;
    }
    return h;
  }
}
```

### 计数排序

由于hIndex的取值范围在[0,N]，因此可以将所有大于N的论文的固定为N（这样并不会影响hIndex的计算），从而可以使用一个counter数组来对论文引用次数进行排序，之后再按照上述排序的选择思路确定hIndex的值即可

例如：[ 6,6,6,3,3,3,4,4,4,5,5,5,0,1,2,3 ]

其对应的counter数组：[ 1,1,1,4,3,3,3,0,0,0,0,0,0,0,0,0,0 ]

此时假设hIndex保持最大值为n，然后测试其是否为可行值，不行就递减然后再次进行测试

```java
class Solution{
  public int hIndex(int[] citations){
    int n = citations.length;
    int[] counter = new int[n+1];
    for(int i:citations){
      ++counter[Math.min(n,i)];
    }
    int total = 0;
    // 从后向前遍历hIndex，不断减少hIndex，直到找到一个合适的值
    for(int i=n;i>=0;--i){
      total += counter[i];
      if(total >= i){
        // 最差情况就是全都是0的情况
        return i;
      }
    }
    // 作用是给出函数返回值，没有其他作用
    return 0;
  }
}
```

# H指数II

> https://leetcode-cn.com/problems/h-index-ii/

在H指数I的基础上，添加一个条件，使得输入的论文引用数为有序序列，要求给出一个O(logn)的算法

## O(n)解法

回想之前对于无序情况的解法，有一种解法是先对无序的进行排序，之后再选择hIndex，那么这一题就可以省略排序，直接开始选择

写法一

```java
class Solution{
  public int hIndex(int[] citations){
    int n = citations.length;
    int h = 0,i=n-1;
    while(i >= 0 && citations[i] > h){
      ++h;
      --i;
    }
    return h;
  }
}
```

写法二

```java
class Solution{
  public int hIndex(int[] citations){
    int n = citations.length,i=0;
    for(int c:citations){
      if(c >= n-i){
        return n-i;
      }
      ++i;
    }
  }
}
```

## O(logn)解法

看到logn复杂度，首先就应该想到二分查找，此处citations数组已经是有序的，看上去应该是可以使用二分查找了，带查找的目标就是
$$
citations[i] >= n-i
$$
满足上述公式的i了，其中n-i表示发表论文引用数大于第i篇论文的论文数，而citations[i]表示第i篇论文的引用数，当引用数大于等于论文篇数的时候，说明此时n-i就是一个满足hIndex定义的值，接下来要做的就是使用二分查找尽快找到这个值

```java
class Solution {
    public int hIndex(int[] citations) {
        // 由于citations是有序的，可以进行二分查找
        int n = citations.length;
      	int l = 0,r = n - 1;
        while(l<=r){
            int mid = (l+r) >> 1;
            if(citations[mid] == n - mid){
                return n - mid;
            }else if(citations[mid] < n - mid){
                // 说明mid是符合hIndex定义的，继续寻找更好的
                l = mid + 1;
            }else{
                r = mid - 1;
            }
        }
        return n - l;
    }
}
```



