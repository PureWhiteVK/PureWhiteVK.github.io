---
title: 1104. 二叉树寻路
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: '3770'
date: 2021-07-29
---
# 1104. 二叉树寻路

在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。

如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；

而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。

给你树上某一个节点的标号 `label`，请你返回从根节点到该标号为 `label` 节点的路径，该路径是由途经的节点标号所组成的。

> 链接：https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree

<!-- more -->

## 数学

这题没什么好说，一个完全二叉树，其父节点值可以直接通过计算得出

相对于正常的二叉树，其奇数行进行了反转，因此需要特别处理一下，考虑到反转前和反转后值的变化情况

4，5，6，7

7，6，5，4

可以发现反转前后两数之和为固定值，因此只需要计算出这个固定值，然后相减就可以变成完全二叉树父节点求法

```java
class Solution {

    static final double log2 = Math.log(2);

    public List<Integer> pathInZigZagTree(int label) {
        List<Integer> path = new ArrayList<>();
      	// 由于此时找到的结果是从下至上的，还需要进行反转
        while(label != 1){
            path.add(label);
            label = getParent(label);
        }
        path.add(1);
        Collections.reverse(path);
        return path;
    }

    private int getParent(int label){
        // 首先计算节点高度
        int level = (int) Math.floor(Math.log(label) / log2);
				// 计算反转前后两数和
        int sum = (int) (Math.pow(2,level)+Math.pow(2,level+1)) - 1;
        int parentSum = (int) (Math.pow(2,level-1)+Math.pow(2,level)) -1;
        // System.out.println(sum);
        // 和是一致的，那其父节点对应值就是
        // 4 5 6 7
        // 7 6 5 4
        // 最后还需要对父节点进行处理
      	// 计算父节点值
        if((level & 1) == 0){
            return parentSum - (label >> 1);
        }
        return (sum-label) >> 1;
    }
}
```

