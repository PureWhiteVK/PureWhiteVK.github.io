---
title: 987. 二叉树的垂序遍历
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 14f9
---
# 987. 二叉树的垂序遍历

给你二叉树的根结点 root ，请你设计算法计算二叉树的 **垂序遍历** 序列。

对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。

二叉树的 **垂序遍历** 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。

返回二叉树的 **垂序遍历** 序列。

> 链接：https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree

<!-- more -->

## 模拟（TreeMap）

解题的关键在题目中已经告知了

> 对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。

只需要使用Map存储对应row和col上的节点值，最后将其输出成二维数组形式即可

注：采用row/col作为键，最好使用TreeMap来确保有序性，使用HashMap还需要对Key进行排序，非常麻烦

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Map<Integer,Map<Integer,List<Integer>>> map;
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        // 对于位于(row,col)的每个节点，其左右子节点分别位于(row+1,col-1)和(row+1,col+1)，树的根节点位于(0,0)
        // 为确保键的有序性，必须使用TreeMap，此处的索引为row和col，都是有序的，因此使用TreeMap会比HashMap更好
        map = new TreeMap<>();
        List<List<Integer>> res = new ArrayList<>();
        traverse(root,0,0);
        // System.out.println(map);
        for(Map<Integer,List<Integer>> col:map.values()){
            List<Integer> r = new ArrayList<>();
            for(List<Integer> l:col.values()){
                // 对于同一个位置的进行排序
                Collections.sort(l);
                r.addAll(l);
            }
            res.add(r);
        }
        // 对key进行排序
        return res;
    }

    private void traverse(TreeNode root,int row,int col){
        if(root == null) return;
        Map<Integer,List<Integer>> column = map.getOrDefault(col,new TreeMap<>());
        // 之前的顺序都需要保留，只有可能同一行出现重复，也就是其前面一个值，需要比较一下
        List<Integer> currRow = column.getOrDefault(row,new ArrayList<>());
        // 实际上可以使用插入排序？
        currRow.add(root.val);
        column.put(row,currRow);
        map.put(col,column);
        traverse(root.left,row+1,col-1);
        traverse(root.right,row+1,col+1);
    }
}
```



## 自定义排序

实际上没有必要使用Map来存储（大材小用），只需要保存每个节点的三个关键信息值(row,col,val)，之后再定义排序信息

以 [1,2,3,4,5,6,7] 为例

```
各个节点对应信息      垂序遍历结果
(0,0,1)            (2,-2,4)
(1,-1,2)           (1,-1,2)
(1,1,3)            (0,0,1)
(2,-2,4)      -->  (2,0,5)
(2,0,5)            (2,0,6)
(2,0,6)            (1,1,3)
(2,2,7)            (2,2,7)
```

从上面这个例子可以找到规律，首先按照col大小升序排列，之后再按照row的大小升序，最后同一位置的按照val大小升序，因此首先计算出各个节点的三个信息值保存在List中再进行排序即可

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<int[]> info;
    int minCol = Integer.MAX_VALUE;
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        info = new ArrayList<>();
        traverse(root,0,0);
        // lambda表达式实现自定义比较函数
        Collections.sort(info,(a,b)->a[1] == b[1] ? 
                              (a[0] == b[0] ? a[2] - b[2] : a[0] - b[0]) 
                              : a[1] - b[1]);
        List<List<Integer>> res = new ArrayList<>();
        int currCol = Integer.MIN_VALUE;
        int size = 0;
        for(int[] i:info){
            if(i[1] != currCol){
                currCol = i[1];
                res.add(new ArrayList<>());
                ++size;
            }
            res.get(size-1).add(i[2]);
        }
        return res;
    }

    private void traverse(TreeNode root,int row,int col){
        if(root == null) return;
        minCol = Math.min(col,minCol);
        info.add(new int[]{row,col,root.val});
        traverse(root.left,row+1,col-1);
        traverse(root.right,row+1,col+1);
    }
}
```

