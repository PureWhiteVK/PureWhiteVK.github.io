---
title: 300. 最长递增子序列
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: ee44
date: 2021-07-26
---
# 300. 最长递增子序列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

> 链接：https://leetcode-cn.com/problems/longest-increasing-subsequence

<!-- more -->

## 动态规划

这一题是很经典的动态规划题

使用dp[i]表示在位置i时的最长递增子序列值，初始时dp[i]值为1（因为至少子序列可以包含自身，即长度为1），然后更新时，需要遍历所有的小于nums[j]的，如果nums[i]小于nums[j]，说明可以继续组成递增子序列，之后便可以求出当前下标最大的递增子序列

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0) return 0;
        int[] dp = new int[nums.length];
        int res = 1;
        dp[0] = 1;
        for(int i=1;i<nums.length;++i){
            dp[i] = 1;
            for(int j=0;j<i;++j){
                if(nums[i] > nums[j]){
                    dp[i] = Math.max(dp[j]+1,dp[i]);
                }
            }
            res = Math.max(res,dp[i]);
        }
        return res;
    }
}
```

算法的时间复杂度为o(n^2)，空间复杂度为o(n)，其实还可以进一步优化

## 贪心+二分查找

从动态规划的执行过程中可以看到，其中计算每一个dp[i]所需的o(n)是无法忽略的，但是更新dp[i]的过程实际上遍历了dp[i]前面的所有值，这一部分时间复杂度为o(n)，如果可以将这一部分优化至o(logn)，这样整个算法的时间复杂度就可以降为o(nlogn)

定义一个新的状态变量tail[i]，其存储了长度为i的递增序列末尾值，且需要保持该值最小，且tail数组一定是递增的

> tail数组递增证明（反证法）：
>
> 假设长度为i的递增序列末尾值为b，即tail[i] = b，假设此时tail[i-1] = a，且有a>b，对于长度为i且末尾值为b的那一个子序列subArr，则一定有
>
> subArr[i-1] < b < a，那么此时以a结尾的长度为i-1的递增子序列就不是末尾值最小的（因为subArr[i-1] < a，这个子序列才是），同tail[i-1]的定义矛盾
>
> 因此tail数组一定是递增的，那么可以使用二分查找来更新tail数组的值，且tail数组的长度就是最长递增子序列的长度

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = 1, n = nums.length;
        if (n == 0) {
            return 0;
        }
        int[] d = new int[n + 1];
        // 长度为1的递增子序列末尾值
        d[len] = nums[0];
        for (int i = 1; i < n; ++i) {
            if (nums[i] > d[len]) {
                // 找到了长度更长的子序列
                d[++len] = nums[i];
            } else {
                // 二分查找更新值，lower_bound
                int l = 1, r = len, pos = 0; 
                // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (d[mid] < nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
            }
        }
        return len;
    }
}
```



# 变种：1713. 得到子序列的最少操作数

给你一个数组 target ，包含若干 **互不相同** 的整数，以及另一个整数数组 arr ，arr **可能** 包含重复元素。

每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr = [1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2] 。你可以在数组最开始或最后面添加整数。

请你返回 **最少** 操作次数，使得 target 成为 arr 的一个子序列。

一个数组的 **子序列** 指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。

> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 题目理解

向arr中插入整数，使得target成为arr的子序列，返回所需最少的操作数

target [6,4,8,1,3,2]

arr [4,7,6,2,3,8,6,1]

arr -> [4,7,6,2,3,4,8,6,1,3,2]，插入了4、3、2

可以理解为找到arr和target的最长公共子序列，然后将最长公共子序列填充至target就是所需最少操作次数

那么现在问题在于，如何寻找target和arr的最长公共子序列？

## 最长公共子序列（动态规划）

寻找最长公共子序列也是一类经典的动态规划题，用一个二维数组存储状态，dp[i,j]表示串A长度为i时和串B长度为j时的最长公共子序列

状态更新方程

dp[i,j] = dp[i-1,j-1] if A[i] == B[j]

dp[i,j] = max(dp[i-1,j],dp[i,j-1]) if A[i] != B[j]

```java
class Solution {
    public int minOperations(int[] target, int[] arr) {
        int m = target.length,n=arr.length;
        int[][] dp = new int[m+1][n+1];
        for(int i=1;i<=m;++i){
            for(int j=1;j<=n;++j){
                if(target[i-1] == arr[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return target.length - dp[m][n];
    }
}
```

该算法时间复杂度为o(mn)，空间复杂度为o(mn)，由于本题数组长度较大，使用动态规划会超时，同时也开不出那么大的数组

## 最长递增子序列（贪心+二分查找）

根据官方提示2&3：由于target数组不包含重复数字，可以把target理解成这些数字的一个排列，然后将arr中这些数字出现的位置替换成这些数字在target中的下标，由于下标是有序的，那么只需要在arr中找到一个最长递增子序列即可，计算出最长公共子序列长度，然后得出最小操作数

【这波替换下标转换成最长递增子序列真的绝了，难怪题设给了一个target数组不包含重复数字】

之后就按照最长递增子序列求解方式求即可

```java
class Solution {
    public int minOperations(int[] target, int[] arr) {
        Map<Integer,Integer> map = new HashMap<>();
        // 建立target中数字和下标的映射关系
        for(int i=0;i<target.length;++i){
            map.put(target[i],i);
        }
        List<Integer> newArr = new ArrayList<>();
        // 将arr中数字替换成下标
        for(int i=0;i<arr.length;++i){
            if(map.containsKey(arr[i])){
                newArr.add(map.get(arr[i]));
            }
        }
        // 二者没有重复的部分，说明需要全部填充
        if(newArr.size() == 0) return target.length;
        // 查找最长递增子序列
        int n = newArr.size(),len=1;
        int[] tail = new int[n+1];
        tail[len] = newArr.get(0);
        for(int i=1;i<n;++i){
            // 子序列长度+1情况
            int targetVal = newArr.get(i);
            if(targetVal > tail[len]){
                tail[++len] = targetVal;
            }else{
                // 当前值比末尾值还小，需要进行更新，开始二分查找
                int l = 1,r = len;
                while(l<r){
                    int mid = (l+r) >> 1;
                    if(tail[mid] < targetVal){
                        l = mid + 1;
                    }else{
                        r = mid;
                    }
                }
                tail[l] = targetVal;
            }
        }
        return target.length - len;
    }
}
```

