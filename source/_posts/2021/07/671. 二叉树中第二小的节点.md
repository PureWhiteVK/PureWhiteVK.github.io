---
title: 671. 二叉树中第二小的节点
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 16f7
date: 2021-07-27
---
# 671. 二叉树中第二小的节点

给定一个非空特殊的二叉树，每个节点都是正数，并且**每个节点的子节点数量只能为 2 或 0**。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

更正式地说，**root.val = min(root.left.val, root.right.val)** 总成立。

给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。

> 链接：https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree

<!-- more -->

## 暴力

如果用暴力，那这个题没什么好说的，节点数也不多，就25个，只需要把所有节点的值都给弄出来，找到第二个就行，稍微用优先队列优化一下

但是这个解法肯定面试的时候不行，没有用到题设的关键信息

1. 每个节点的子节点数为0或2
2. root.val = min(root.left.val,root.right.val) 

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int findSecondMinimumValue(TreeNode root) {
        if(root == null) return -1;
        // 由于root.val = min(root.left.val,root.right.vaål)
        // 且每个节点的子节点数量只能为2或0
        // 首先找到最左端的？
        // 最简单的，直接把所有节点的值都给搞出来
        // 稍微蠢一点的办法，遍历了之后用优先队列存着，但是这样的解法属于暴力
        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->a-b);
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode curr = queue.poll();
            pq.offer(curr.val);
            if(curr.left != null){
                queue.offer(curr.left);
            }
            if(curr.right != null){
                queue.offer(curr.right);
            }
        }
        int val = pq.peek();
        pq.poll();
        while(!pq.isEmpty() && val == pq.peek()){
            pq.poll();
        }
        if(pq.isEmpty()){
            return -1;
        }
        return pq.poll();
    }
}
```

## 正经解法

从题设条件中可知，父节点的值是两个子节点值中的较小值，且每个节点的子节点数为2或0，那么根节点一定是最小值，要找到第二小的值，只需要找到第一个和根节点不同的值就行

### BFS

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int rootVal;
    public int findSecondMinimumValue(TreeNode root) {
        if(root == null || root.left == null) return -1;
        // 如果最小值就是Integer.MAX_VALUE，那真是绝了
        int res = -1;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode curr = queue.poll();
            // System.out.println(res);
            // 找到值不等于root.val的，实际上是肯定大于root.val的
            if(curr.val != root.val){
                
                // 在候选结果中找最小的就是第二小的值
                res =  res == -1 ? curr.val : Math.min(curr.val,res);
            }
            if(curr.left != null){
                // 由于该二叉树的子节点数要么为0要么为2
                queue.offer(curr.left);
                queue.offer(curr.right);
            }
        }

        return res;
    }
}
```

### 递归（dfs）

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int rootVal;
    public int findSecondMinimumValue(TreeNode root) {
        if(root == null || root.left == null) return -1;
        // 找到两颗子树的最小值
        int leftTreeMinVal = root.val == root.left.val ? findSecondMinimumValue(root.left) : root.left.val;
        int rightTreeMinVal = root.val == root.right.val ? findSecondMinimumValue(root.right) : root.right.val;
        // 当有一个为-1的时候说明这一课树上的值都一样，
        int min = Math.min(leftTreeMinVal,rightTreeMinVal);
        return min > 0 ? min : Math.max(leftTreeMinVal,rightTreeMinVal);

    }
}
```







