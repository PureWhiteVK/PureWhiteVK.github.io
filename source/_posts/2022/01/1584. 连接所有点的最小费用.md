---
title: 1584. 连接所有点的最小费用
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 5bac
---
# 1584. 连接所有点的最小费用

给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。

连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。

请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。

> 链接：https://leetcode-cn.com/problems/min-cost-to-connect-all-points

<!-- more -->

## 最小生成树

### Kruskal+优先队列+并查集

```java
class Solution {
    private static final int[] arr = new int[1000];
    private static final int[] rank = new int[1000];
    class Edge{
        int target;
        int source;
        int weight;

        Edge(int t,int s,int w){
            target = t;
            source = s;
            weight = w;
        }
    }
    public int minCostConnectPoints(int[][] points) {
        int n = points.length;
        for(int i=0;i<n;++i){
            arr[i] = i;
            rank[i] = 1;
        }
        PriorityQueue<Edge> queue = new PriorityQueue<>((a,b)->a.weight-b.weight);
        for(int i=0;i<n;++i){
            for(int j=i+1;j<n;++j){
                queue.offer(new Edge(i,j,dist(points[i],points[j])));
            }
        }
        int res = 0;
        while(!queue.isEmpty()){
            Edge edge = queue.poll();
            int v0 = edge.source;
            int v1 = edge.target;
            if(FIND(v0) != FIND(v1)){
                res += edge.weight;
                UNION(v0,v1);
            }
        }
        return res;
    }

    private void UNION(int index1,int index2){
        int r1 = FIND(index1);
        int r2 = FIND(index2);
        if(r1 == r2){
            return;
        }
        if(rank[r1] > rank[r2]){
            arr[r2] = r1;
        }else{
            arr[r1] = r2;
            if(rank[r1] == rank[r2]){
                ++rank[r2];
            }
        }
    }

    private int FIND(int index){
        int root = index;
        while(arr[root] != root){
            root = arr[root];
        }
        while(arr[index] != root){
            int next = arr[index];
            arr[index] = root;
            index = next;
        }
        return root;
    }

    private int dist(int[] a,int [] b){
        return Math.abs(a[0]-b[0]) + Math.abs(a[1]-b[1]);
    }
}
```

### Prim+优先队列

prim算法的基本思想是从一个根节点开始，找到其连接的边，每次将最小边权加入到树中，直到所有节点连通

```java
class Solution {
    private static final boolean[] visited = new boolean[1000];
    public int minCostConnectPoints(int[][] points) {
        // prim算法
        int n = points.length;
        // int[] is [weight,target]
        PriorityQueue<int[]> queue = new PriorityQueue<>((a,b)->a[0]-b[0]);
        for(int j=1;j<n;++j){
            visited[j] = false;
            queue.offer(new int[]{dist(points[0],points[j]),j});
        }
        visited[0] = true;
        int res = 0;
        while(!queue.isEmpty()){
            int[] edge = queue.poll();
            int weight = edge[0];
            int next = edge[1];
            if(!visited[next]){
                res += weight;
                for(int i=0;i<n;++i){
                    // 计算每个节点距离当前生成树的最小距离
                    if(!visited[i] && i != next){
                        // 存在重复计算
                        queue.offer(new int[]{dist(points[next],points[i]),i});
                    }
                }
                visited[next] = true;
            }
        }
        return res;
    }

    private int dist(int[] a,int[] b){
        return Math.abs(a[0]-b[0]) + Math.abs(a[1]-b[1]);
    }
}
```

