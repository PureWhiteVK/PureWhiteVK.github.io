---
title: 212. 单词搜索
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: b08e
---
# 212. 单词搜索

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

提示：

- m == board.length
- n == board[i].length
- 1 <= m, n <= 12
- board\[i\]\[j\] 是一个小写英文字母
- 1 <= words.length <= 3 * 10<sup>4</sup>
- 1 <= words[i].length <= 10
- words[i] 由小写英文字母组成
- words 中的所有字符串互不相同

> 链接：https://leetcode-cn.com/problems/word-search-ii

<!-- more -->

## dfs

最简单的方式，直接判断每一个字符串是否在board中存在路径即可

```java
class Solution {
    private char[][] board;
    private boolean[][] visited;
    private int m,n;
    private static final int[][] dir = new int[][]{{1,0,-1,0},{0,1,0,-1}};
    public List<String> findWords(char[][] _board, String[] words) {
        // 感觉直接暴力会超时
        // 如果words中存在一些重复的部分，是否可以减少搜索的时间？
        // 是否可以将路径记录一下（String代表路径）然后只需要判断word是否出现在路径中即可
        board = _board;
        m = _board.length;
        n = _board[0].length;
        visited = new boolean[m][n];
        // 同一个单元格内的字母再一个单词中不允许被重复使用
        // dfs?寻找路径
        // 如果直接暴力？
        // 遍历words，然后逐个判断每个单词是否可以在单词中出现
        List<String> res = new ArrayList<>();
        for(String word:words){
            boolean notIn = true;
            for(int i=0;i<m && notIn;++i){
                for(int j=0;j<n && notIn;++j){
                    // 只需要找到一条路径即可
                    if(board[i][j] == word.charAt(0) && dfs(word,0,i,j)){
                        res.add(word);
                        notIn = false;
                    }
                }
            }
        }
        return res;
    }

    // 判断棋盘当前位置是否出现在 word[idx]
    private boolean dfs(String word,int idx,int x,int y){
        if(word.charAt(idx) != board[x][y]) return false;
        if(idx == word.length()-1) return true;
        visited[x][y] = true;
        boolean res = false;
        for(int i=0;i<4;++i){
            int nextX = x + dir[0][i];
            int nextY = y + dir[1][i];
            if(nextX > -1 && nextX < m && nextY > -1 && nextY < n && !visited[nextX][nextY]){
                res |= dfs(word,idx+1,nextX,nextY);
            }
        }
        visited[x][y] = false;
        return res;
    }
}
```

还有一种写法，直接记录路径，然后判断路径所对应的字符串是否出现在字典中即可

```java
class Solution {
    Set<String> set = new HashSet<>();
    List<String> ans = new ArrayList<>();
    char[][] board;
    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    int n, m;
    boolean[][] vis = new boolean[15][15];
    public List<String> findWords(char[][] _board, String[] words) {
        board = _board;
        m = board.length; n = board[0].length;
        for (String w : words) set.add(w);
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                vis[i][j] = true;
                sb.append(board[i][j]);
                dfs(i, j, sb);
                vis[i][j] = false;
                sb.deleteCharAt(sb.length() - 1);
            }
        }
        return ans;
    }
  
    void dfs(int i, int j, StringBuilder sb) {
      	// 由于字典中的字符串长度不会超过10，这里进行剪枝
        if (sb.length() > 10) return ;
        if (set.contains(sb.toString())) {
            ans.add(sb.toString());
            set.remove(sb.toString());
        }
        for (int[] d : dirs) {
            int dx = i + d[0], dy = j + d[1];
            if (dx < 0 || dx >= m || dy < 0 || dy >= n) continue;
            if (vis[dx][dy]) continue;
            vis[dx][dy] = true;
            sb.append(board[dx][dy]);
            dfs(dx, dy, sb);
            vis[dx][dy] = false;
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}
```

## trie

> 关于 trie 这个数据结构，LeetCode上也有对应的数据结构设计题：
>
> [208. 实现 Trie (前缀树) - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)
>
> Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
>
> 主要包含的操作有：
>
> - Trie()
>
>   初始化前缀树对象
>
> - void insert(String word)
>
>   向前缀树中插入字符串word
>
> - boolean search(String word)
>
>   检索word是否出现在前缀树中
>
> - boolean startsWith(String prefix)
>
>   检索已经插入的字符串中是否有前缀为prefix的（可以实现自动补全）
>
> 其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。

![](Image/trie.webp)

### 二维数组实现

对于trie中的每一个节点，存储其对应于字符集的每一个输入情况的下一个节点索引信息（通过数组实现树），然后查询的时候只需要沿着链不断向后查找，直到结束

```java
class Trie {
    private List<int[]> trie;
    private Set<Integer> endSet;
    private int index;
    /** Initialize your data structure here. */
    public Trie() {
        // 使用二维数组形式实现trie
        trie = new ArrayList<>();
        endSet = new HashSet<>();
        index = 0;
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        int l = word.length();
        int ptr = 0;
        for(char ch:word.toCharArray()){
            if(ptr >= trie.size()){
                trie.add(new int[26]);
            }
            int[] currSet = trie.get(ptr);
            int p = ch-'a';
            if(currSet[p] == 0){
                trie.add(new int[26]);
                currSet[p] = ++index;
            }
            ptr = currSet[p];
        }
        endSet.add(ptr);
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        int l = word.length();
        int ptr = 0;
        for(char ch:word.toCharArray()){
            if(ptr >= trie.size()) return false;
            int[] currSet = trie.get(ptr);
            int p = ch-'a';
            if(currSet[p] == 0){
                return false;
            }
            ptr = currSet[p];
        }
        return endSet.contains(ptr);
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        int l = prefix.length();
        int ptr = 0;
        for(char ch:prefix.toCharArray()){
            if(ptr >= trie.size()) return false;
            int[] currSet = trie.get(ptr);
            int p = ch-'a';
            if(currSet[p] == 0){
                return false;
            }
            ptr = currSet[p];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```



### TrieNode（树节点）实现

这种方式和实现n叉树类似，每一个节点会存储对应每一个输入的下一个节点指针，且在写法上相比数组实现方式更为简单

```java
class Trie {
    private class TrieNode{
        TrieNode[] next;
        boolean isEnd;
        TrieNode(){
            next = new TrieNode[26];
            isEnd = false;
        }
    }

    private TrieNode root;
    /** Initialize your data structure here. */
    public Trie() {
        root = new TrieNode();
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        TrieNode ptr = root;
        for(char ch:word.toCharArray()){
            int p = ch - 'a';
            if(ptr.next[p] == null){
                ptr.next[p] = new TrieNode();
            }
            ptr = ptr.next[p];
        }
        ptr.isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        TrieNode ptr = root;
        for(char ch:word.toCharArray()){
            int p = ch-'a';
            if(ptr.next[p] == null) return false;
            ptr = ptr.next[p];
        }
        return ptr.isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        TrieNode ptr = root;
        for(char ch:prefix.toCharArray()){
            int p = ch - 'a';
            if(ptr.next[p] == null) return false;
            ptr = ptr.next[p];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

## 本题解法

使用前缀树来辅助剪枝，这样可以提高搜索销量

```java
class Solution {
    class TrieNode{
        TrieNode[] next;
        String s;
        // 如果其是结束节点，存储对应的字符串
        TrieNode(){
            next = new TrieNode[26];
            s = null;
        }
    }

    private TrieNode root;

    private void insert(String s){
        TrieNode ptr = root;
        for(char ch:s.toCharArray()){
            int p = ch - 'a';
            if(ptr.next[p] == null){
                ptr.next[p] = new TrieNode();
            }
            ptr = ptr.next[p];
        }
        ptr.s = s;
    }

    private int m,n;
    private char[][] board;
    private Set<String> set;
    private boolean[][] visited;
    private static final int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};

    public List<String> findWords(char[][] _board, String[] words) {
        root = new TrieNode();
        board = _board;
        m = _board.length;
        n = _board[0].length;
        set = new HashSet<>();
        visited = new boolean[m][n];
        for(String word:words){
            insert(word);
        }
        for(int i=0;i<m;++i){
            for(int j=0;j<n;++j){
                int p = board[i][j] - 'a';
                if(root.next[p] != null){
                    visited[i][j] = true;
                    dfs(i,j,root.next[p]);
                    visited[i][j] = false;
                }
            }
        }
        List<String> res = new ArrayList<>();
        for(String s:set){
            res.add(s);
        }
        return res;
    }

    private void dfs(int x,int y,TrieNode root){
        if(root.s != null) {
          	// 使用set去重，有可能两条路都能走出同一个单词来
            set.add(root.s);
        }
        for(int[] dir:dirs){
            int nextX = x + dir[0];
            int nextY = y + dir[1];
            if(nextX < 0 || nextX >= m || nextY < 0 || nextY >= n || visited[nextX][nextY]) continue;
            int p = board[nextX][nextY] - 'a';
            // 使用前缀树进行剪枝，提高效率
            if(root.next[p] != null){
                visited[nextX][nextY] = true;
                dfs(nextX,nextY,root.next[p]);
                visited[nextX][nextY] = false;
            }
        }
    }
}
```

