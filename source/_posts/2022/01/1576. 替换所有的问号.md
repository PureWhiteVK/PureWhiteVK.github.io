---
title: 1576. 替换所有的问号
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 93bb
---
# 1576. 替换所有的问号

给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。

注意：你 不能 修改非 '?' 字符。

题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。

在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。

> 链接：https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters

<!-- more -->

## 模拟

对于一个需要的替换的问号，我们只需要考虑其前一个字符和后一个字符，然后选择与这两个都不同的即可

下面介绍思路：

前一个字符为prev，后一个字符为next

使用一个数组存储a-z，之后我们分别将prev和next交换至数组末尾，然后在数组中选择第0号元素即可（实际上前24个都是与prev、next不同的）

```java
class Solution {
    private static final char[] candidate = new char[26];
    private static final int[] candidatePos = new int[26];
    private static final Random random = new Random(1313L);
    static {
        for(int i=0;i<26;++i){
            // 记录每一个字母所在的位置
            // 当筛选出两个不需要的单词之后我们就随机生成一个[0,23] or [0,24]的数，之后找出
            candidate[i] = (char)(i+'a');
            candidatePos[i] = i;
        }
    }
    public String modifyString(String s) {
        // 需要将问号替换为不包含连续重复的字符
        // 对于每一个'?'的位置i，只需要找到s.charAt(i-1)和s.charAt(i+1)两个值
        char[] arr = s.toCharArray();
        char next,prev,curr;
        int last;
        int l = arr.length;
        for(int i=0;i<l;++i){
            curr = arr[i];
            if(curr == '?'){
                last = 25;
                // 需要排除两个字母
                prev = (i == 0) ? '?' : arr[i-1];
                next = (i + 1 == l) ? '?' : arr[i+1];
                if(prev != '?'){
                    swap(prev,last);
                    --last;
                }
                if(next != '?'){
                    swap(next,last);
                }
                // 实际上只用到了candidate上面的三个值
                // 此时arr[i]一定和next与last不一样
                // 此处也可以使用random，但是也不是很需要了
                // 这样的结果也是随机的
                arr[i] = candidate[0];
            }
        }
        return String.valueOf(arr);
    }

    private void swap(char originCh,int targetPos){
        // 将字符ch交换至pos位置上
        int originPos = candidatePos[originCh-'a'];
        char targetCh = candidate[targetPos];
        // 交换
        candidate[targetPos] = originCh;
        candidate[originPos] = targetCh;
        // 修改candidatePos
        candidatePos[originCh-'a'] = targetPos;
        candidatePos[targetCh-'a'] = originPos;
    }
}
```

