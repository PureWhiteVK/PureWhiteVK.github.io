---
title: 1220. 统计元音字母序列的数目
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 6a2e
---
# 1220. 统计元音字母序列的数目

给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：

- 字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'）
- 每个元音 'a' 后面都只能跟着 'e'
- 每个元音 'e' 后面只能跟着 'a' 或者是 'i'
- 每个元音 'i' 后面 不能 再跟着另一个 'i'
- 每个元音 'o' 后面只能跟着 'i' 或者是 'u'
- 每个元音 'u' 后面只能跟着 'a'
  

由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。

> 链接：https://leetcode-cn.com/problems/count-vowels-permutation

<!-- more -->

## 动态规划（普通版）

看到这种统计次数的题目，基本就是一个动态规划

很容易想到状态定义为`dp[l][k]`，表示长度为l且以k结尾的字母序列数目，其中k为(a,e,i,o,u)中的一个

题目中也很明确的给出了状态转移的关系（由于动态规划是从下至上进行求解，我们需要对题目的条件进行翻译），实际上就是找出一个字母可以跟在哪些字母后面

- a可以跟在 e，i，u后面
- e可以跟在a，i后面
- i可以跟在e，o后面
- o可以跟在i后面
- u可以跟在i，o后面

可以写出状态转移方程
$$
\begin{cases}
dp[l+1][a] = dp[l][e] + dp[l][i] + dp[l][u] \\
dp[l+1][e] = dp[l][a] + dp[l][i] \\
dp[l+1][i] = dp[l][e] + dp[l][o] \\
dp[l+1][o] = dp[l][i] \\
dp[l+1][u] = dp[l][i] + dp[l][o]
\end{cases}
$$
可以看到长度为l+1的状态只依赖于长度为l的状态，因此可以将空间压缩至o(1)

```java
class Solution {
    private static int[] dp = new int[5];
    private static int[] temp = new int[5];
    private static int MOD = (int)(1e9+7);
    public int countVowelPermutation(int n) {
        // dp[l][k] 表示以k结尾的长度为l的字母序列个数，其中k为a、e、i、o、u中的一个
        // dp[1][k] = 1
        // 考虑a可以跟在哪些字符串的后面
        // e，i，u
        // 则有dp[l+1][a] = dp[l][e] + dp[l][i] + dp[l][u]
        // e 可以在 a、i后面
        // dp[l+1][e] = dp[l][a] + dp[l][i]
        // i 可以在 e、o后面
        // dp[l+1][i] = dp[l][e] + dp[l][o]
        // o 可以在 i后面
        // dp[l+1][o] = dp[l][i]
        // u 可以在 i、o后面
        // dp[l+1][u] = dp[l][i] + dp[l][o]
        // 可以看到，第l+1的仅依赖于第l次的
        Arrays.fill(dp,1);
        // a,e,i,o,u
        // 0,1,2,3,4
        for(int i=2;i<=n;++i){
            temp[0] = ((dp[1] + dp[2]) % MOD + dp[4]) % MOD;
            temp[1] = (dp[0] + dp[2]) % MOD;
            temp[2] = (dp[1] + dp[3]) % MOD;
            temp[3] = dp[2] % MOD;
            temp[4] = (dp[2] + dp[3]) % MOD;
            for(int k=0;k<5;++k){
                dp[k] = temp[k];
            }
        }
        int res = 0;
        for(int i=0;i<5;++i){
            res = (res + dp[i]) % MOD;
        }
        return res;
    }
}
```

## 动态规划（矩阵快速幂）

从状态转移方程中可以看到，长度为l+1的状态仅依赖于长度为l的状态，如果我们将所有长度为l的状态看成一个向量的话，则有
$$
\begin{align}
\left[
\begin{matrix}
dp[l+1][a] \\
dp[l+1][e] \\
dp[l+1][i] \\
dp[l+1][o] \\
dp[l+1][u] \\
\end{matrix}
\right] ^T
& =
\left[
\begin{matrix}
0 & 1 & 1 & 0 & 1 \\
1 & 0 & 1 & 0 & 0 \\
0 & 1 & 0 & 1 & 0 \\
0 & 0 & 1 & 0 & 0 \\
0 & 0 & 1 & 1 & 0
\end{matrix}
\right]
\times
\left[
\begin{matrix}
dp[l][a] \\
dp[l][e] \\
dp[l][i] \\
dp[l][o] \\
dp[l][u] \\
\end{matrix}
\right] ^T \\
 (n,1)  & = (n,n)  \times  (n,1)
\end{align}
$$
通过这个我们可以求解dp[n]
$$
\left[
\begin{matrix}
dp[n][a] \\
dp[n][e] \\
dp[n][i] \\
dp[n][o] \\
dp[n][u] \\
\end{matrix} 
\right]^ T
=
\left[
\begin{matrix}
0 & 1 & 1 & 0 & 1 \\
1 & 0 & 1 & 0 & 0 \\
0 & 1 & 0 & 1 & 0 \\
0 & 0 & 1 & 0 & 0 \\
0 & 0 & 1 & 1 & 0
\end{matrix}
\right] ^ {n-1}
& \times &
\left[
\begin{matrix}
dp[1][a] \\
dp[1][e] \\
dp[1][i] \\
dp[1][o] \\
dp[1][u] \\
\end{matrix}
\right]^ T
$$
只要我们通过矩阵快速幂算法求出变换矩阵的n次方即可（有一说一矩阵快速幂写起来真麻烦，超级码力奥了属于是）



