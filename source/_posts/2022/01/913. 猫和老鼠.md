---
title: 913. 猫和老鼠
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 2d0f
---
# 913. 猫和老鼠

两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。

图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。

老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。

在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。

此外，猫无法移动到洞中（节点 0）。

然后，游戏在出现以下三种情形之一时结束：

如果猫和老鼠出现在同一个节点，猫获胜。
如果老鼠到达洞中，老鼠获胜。
如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。
给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：

如果老鼠获胜，则返回 1；
如果猫获胜，则返回 2；
如果平局，则返回 0 。

> 链接：https://leetcode-cn.com/problems/cat-and-mouse

<!-- more -->

## 动态规划+博弈论

这题是个困难题，关键在于如何定义最佳状态进行搜索

同时还需要联想到动态规划

对于当前棋盘的状态，我们可以分为三种

1. 必胜状态
2. 必输状态
3. 必和状态

而玩家的最佳状态就是：

优先选择能使自己进入最佳必胜状态的路径，实在不行选择必和状态也行（至少不能让对面赢），最后实在没办法了就投降（怎么选都是一个输）

然后还有两个细节

1. 猫不可以进入老鼠洞，即当猫走的时候不可以进入0节点
2. 当猫和老鼠处于同一个位置的时候一定是平局

```java
class Solution {
    private int n;
    private int[][] graph;
    private static final int N = 55;
    // dp[i][j][turns]
    // 为什么turns的总数为2*N*N
    private static int[][][] dp = new int[N][N][2*N];
    public int catMouseGame(int[][] graph) {
        // 博弈论，老鼠位于节点1，猫位于节点2
        // 本题关键在于如何对问题进行建模
        // 如何定义最佳状态？
        // 这个涉及到博弈问题的三种状态：
        // 必胜状态
        // 必输状态
        // 必和状态
        // 选择最佳策略就是：优先选择进入必胜状态，实在不行的时候进入必和状态，当无法进入的时候就只能进入必输状态了
        // 因此我们需要从起始位置开始
        // 对于当前状态，需要遍历所有相邻的边
        // 初始化dp
        this.graph = graph;
        this.n = graph.length;
        for(int i=0;i<n;++i){
            for(int j=0;j<n;++j){
                Arrays.fill(dp[i][j],-1);
            }
        }
        return dfs(0,2,1);
    }

    private int dfs(int turn,int catPos,int mousePos){
        // catPos == mousePos, cat win
        // mousePos == 0, mouse Win
        // turn > 2*n*n, game draw
        // 首先判断当前状态
        int currState = dp[catPos][mousePos][turn];
        if(mousePos == 0){
            currState = 1;
        }else if(mousePos == catPos){
            currState = 2;
        }else if(turn >= 2*n){
            // 此处控制递归深度，原本最大状态数为 2*n*n
            // 但可以证明这个深度可以降低至 2*n
            // 即猫、老鼠经过的状态数总和（超过这个值后就一定会出现重合）
            currState = 0;
        }else if(currState ==-1){
            // 对于当前状态开始计算
            // 判断是哪一个开始走
            // mouse先走，那么mouse对应的turn一定是偶数，则cat对应的turn一定是奇数
            if((turn&1) == 1){
                boolean win = false;
                boolean draw = false;
                //cat move
                for(int nextPos : graph[catPos]){
                    // 这里有个细节，猫不可以进入0，因为0是老鼠洞来的
                    if(nextPos == 0) continue;
                    int nextState = dfs(turn+1,nextPos,mousePos);
                    if(nextState == 2){
                        win = true;
                        break;
                    }else if(nextState == 0){
                        draw = true;
                    }
                }
                if(win) currState = 2;
                else if(draw) currState = 0;
                else currState = 1;
            }else{
                boolean win = false;
                boolean draw = false;
                // mouse move
                for(int nextPos : graph[mousePos]){
                    int nextState = dfs(turn+1,catPos,nextPos);
                    if(nextState == 1){
                        win = true;
                        break;
                    }else if(nextState == 0){
                        draw = true;
                    }
                }
                if(win) currState = 1;
                else if(draw) currState = 0;
                else currState = 2;
            }
        }
        dp[catPos][mousePos][turn] = currState;
        return currState;
    }
}
```

