---
title: 390. 消除游戏
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: efc8
---
# 390. 消除游戏

列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：

从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
给你整数 n ，返回 arr 最后剩下的数字。

> 链接：https://leetcode-cn.com/problems/elimination-game

<!-- more -->

## 找规律+递归

这个题还挺有意思的，一开始没什么想法，拿一个数出来找找规律吧

假设 n = 40

首先进行直接模拟的看看

```
直接模拟计算
n = 10
1,2,3,4,5,6,7,8,9,10
从左向右删除 
2,4,6,8,10 -> 2*[1,2,3,4,5]
从右向左删除
4,8 -> 2*2*[1,2]
从左向右删除
8 -> 2*2*2
```



step1. 从[1,40]内从左向右删除第一个数字，然后每隔一个删除一个，直到到达列表末尾，实际上就是删除[1,40]内的所有奇数，那么剩下的结果为[1,40]内的所有偶数，也就是
$$
2,4,6,8,10,...,40
$$
那么实际上他可以化简为
$$
2\times[1,20]
$$
step2. 从[1,20]内从右向左删除第一个数字，然后每隔一个删除一个，直到到达列表末尾，实际上就是删除[1,20]内的所有偶数，那么剩下的结果为[1,20]内的所有奇数，也就是
$$
2 \times [1,3,5,7,9,...,19]
$$
那么实际上可以化简为
$$
2\times(2\times[1,10]-1)
$$
step3. 从[1,10]内从左向右删除，接下来我们重复删除操作，从左到右进行删除，实际上删除了[1,10]内所有偶数，也就是
$$
2\times(2\times[1,3,5,7,9]-1)
$$
转换成连续区间形式为（任意一个奇数都可以表示为2*k-1）
$$
2\times(2\times(2\times[1,5])-1)
$$
step4. 从[1,5]内从右向左删除，实际上就是删除了[1,5]内的所有奇数，也就是
$$
2\times(2\times(2\times[2，4])-1)
$$
转换一下可以得到
$$
2\times(2\times(2\times(2\times[1，2]))-1)
$$
step5. 从[1,2]内从左向右删除，这就很简单了，删除1，那么可以得到最后剩下的值
$$
2\times(2\times(2\times(2\times2))-1) = 30
$$
因此最终剩下的值是30

从分析的过程可以很清晰的看到，这是一个递归结构，每一步删除都可以转换为一个规模更小的子问题，因此可以写出递归求解方程

```java
class Solution {
    public int lastRemaining(int n) {
        // 1 < n < 10^9
        // 数学
        // 实际上可以转换为一个递归问题
        return dfs(n,true);
    }


    private int dfs(int n,boolean leftToRight){
        // 终止条件
        if(n == 1) return 1;
        if(leftToRight){
            // 删除所有奇数
            return 2 * dfs(n/2,!leftToRight);
        }else{
            if((n & 1)!=1){
                // 从右向左且长度为偶数，那么等价于删除数组上所有的偶数
                return 2 * dfs(n/2,!leftToRight) - 1;
            }else{
                // 删除了所有的奇数
                return 2 * dfs(n/2,!leftToRight);
            }
        }
    }
} 
```



