---
title: 219. 存在重复元素 II
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: eb26
date: 2022-01-19
---
# 219. 存在重复元素 II

给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。

> 链接：https://leetcode-cn.com/problems/contains-duplicate-ii

<!-- more -->

## 哈希表

对于当前遍历的元素`nums[i]`，我们可以使用一个哈希表来记录`nums[i]`最后一次出现的索引`j`，如果`j-i < k`就可以直接返回true，如果所有都不存在则返回false

```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        // 直接暴力搜索
        // 对于每个元素，从i-k一直到i+k
        // 哈希表吧，记录每一个出现位置，辅助二分查找
        int l = nums.length;
        // 记录该数的最后一次出现位置
        Map<Integer,Integer> map = new HashMap<>();
        for(int i=0;i<l;++i){
            int lastPos = map.getOrDefault(nums[i],-1);
            map.put(nums[i],i);
            if(lastPos != -1 && i-lastPos<=k){
                return true;
            }
        }
        return false;
    }
}
```

## 滑动窗口

还有一种做法，维护一个长度为k+1的滑动窗口（确保窗口两端的元素下标差j-i等于k），在每次插入新元素之前判断是否已经出现过，如果有就可以直接返回true，没有就加入继续判断

```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        int n = nums.length;
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < n; i++) {
            // 移除窗口的最左端元素
            if (i > k) set.remove(nums[i - k - 1]);
            if (set.contains(nums[i])) return true;
            set.add(nums[i]);
        }
        return false;
    }
}
```





