---
title: 89. 格雷编码
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: c1bb
date: 2022-01-08
---
# 89. 格雷编码

n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：

- 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
- 第一个整数是 0
- 一个整数在序列中出现 不超过一次
- 每对 相邻 整数的二进制表示 恰好一位不同 ，且
- 第一个 和 最后一个 整数的二进制表示 恰好一位不同

给你一个整数 n ，返回任一有效的 n 位格雷码序列 。

> 链接：https://leetcode-cn.com/problems/gray-code

<!-- more -->

## 暴力

最简单的方式就是从0开始，每次反转当前数的1位，然后判断这个数是否已经加入序列中，如果没有就继续进行这一操作，直到序列长度为2^n

```java
class Solution {
    private static final boolean[] visited = new boolean[1<<17];
    public List<Integer> grayCode(int n) {
        Arrays.fill(visited,false);
        List<Integer> res = new ArrayList<>();
        int N = 1 << n;
        int curr = 0;
        for(int i=0;i<N;++i){
            res.add(curr);
            visited[curr] = true;
            // 开始变换
            int next;
            int j = 0;
            do{
                // 由于异或运算的性质，将一个数的某位取反可以写成异或的形式
                // a ^ 0 = a
                // a ^ 1 = ~a
                // 下面这个式子就是将curr的第j位取反
                next = curr ^ (1<<j);
                ++j;
            }while(visited[next]);
            curr = next;
        }
        return res;
    }
}
```

时间复杂度：o(2^n)

空间复杂度：o(2^n)

可以看到这种暴力方法的空间复杂度为o(2^n)，效率太低，实际上是有空间复杂度为o(1)的解法

## 对称构造

直接用语言描述有点难度，直接给一个构造的例子吧

2位的格雷码序列（G_2）

```
00,01,11,10
```

如果此时我们将2位格雷码序列进行翻转，得到的序列记为（G_2_prime）

```
10,11,01,00
```

可以看到其同样满足格雷码定义

此时我们再将G_2_prime最高位变为1（也就是第3位置为1）

```
110,111,101,100
```

然后将G_2_prime和G_2拼接起来

```
000,001,011,010,110,111,101,100
```

这样就构造出了3位的格雷码，因此这是一个递归的过程，我们只需要求出n-1位的格雷码，通过下面的构造方法就可以构造出n位的格雷码

1. 翻转2位格雷码
2. 将每个数的第n-1位置为1

```java
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> res = new ArrayList<>();
        construct(res,n);
        return res;
    }

    private void construct(List<Integer> list,int n){
        if(n == 1){
            list.add(0);
            list.add(1);
            return;
        }
        construct(list,n-1);
        // 此时n-1位的格雷码已经构建完成，开始构建第n层的格雷码
        // 否则利用list构建长度为n的格雷码
        int N = 1 << (n-1);
        for(int i=N-1;i>-1;--i){
            // 末位且第n位置1
            list.add(list.get(i)|N);
        }
    }
}
```

这样我们就不需要额外的visited输出判断修改是否已经存在了