---
title: 382. 链表随机节点
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: a0a6
date: 2022-01-16
---
# 382. 链表随机节点

给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。

实现 Solution 类：

- Solution(ListNode head) 使用整数数组初始化对象。
- int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。

提示：

- 链表中的节点数在范围 [1, 10<sup>4</sup>] 内
- -10<sup>4</sup> <= Node.val <= 10<sup>4</sup>
- 至多调用 getRandom 方法 10<sup>4</sup> 次


进阶：

- 如果链表非常大且长度未知，该怎么处理？
- 你能否在不使用额外空间的情况下解决此问题？

> 链接：https://leetcode-cn.com/problems/linked-list-random-node

<!-- more -->

## 简单随机

数据量不大，可以开一个数组把所有的链表项都存起来，当需要随机访问的时候就生成一个[0,end]的随机数，返回即可

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
private:
    std::vector<ListNode*> list;
    std::uniform_int_distribution<int> u;
    std::default_random_engine e;
public:
    Solution(ListNode* head) {
        // 链表并不支持随机访问
        // 一个很简单的思路就是
        ListNode* curr = head;
        while(curr != nullptr){
            list.emplace_back(curr);
            curr = curr->next;
        }
        u = std::uniform_int_distribution<int>(0,list.size()-1);
    }
    
    int getRandom() {
        return list[u(e)]->val;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(head);
 * int param_1 = obj->getRandom();
 */
```

## 蓄水池采样（进阶）

当我们遍历第i个数的时候，先从[0,i)中随机生成一个数（均匀分布），当这个数等于0时将i作为最终随机选择的结果，不为0则保留原来的结果，那么最终遍历完结果为i的概率：
第i次[0,i)抽样结果为0 且 后面的 n-i 次抽样结果都不为0
$$
P(i) = \frac{1}{i} \cdot \frac{i}{i+1} \cdot \frac{i+1}{i+2} \cdots \frac{n-1}{n} = \frac{1}{n}
$$
真是非常巧妙的一种方法

知道原理之后实现起来就非常容易了

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
private:
    ListNode* head = nullptr;
    std::default_random_engine random_engine;
public:
    Solution(ListNode* _head) {
        head = _head;
    }
    
    int getRandom() {
        int res = 0;
        int index = 0;
        for(ListNode* curr = head;curr != nullptr; curr = curr->next){
            std::uniform_int_distribution<int> uniform(0,index++);
            if(uniform(random_engine) == 0){
                res = curr->val;
            }
        }
        return res;
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(head);
 * int param_1 = obj->getRandom();
 */
```





