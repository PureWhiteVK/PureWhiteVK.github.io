---
title: 373. 查找和最小的K对数字
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 78d8
date: 2022-01-14
---
# 373. 查找和最小的K对数字

给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。

> 链接：https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums

<!-- more -->

## 找规律+优先队列

本题要求我们找出两个有序数组中和最小的前k对数，最容易想到的就是先生成所有的可能对（m*n），之后进行排序或者使用TopK就可以找出和最小的前k对数，这种方法时间复杂度为o(mn log(mn))，先不说是否会超时，我们是开不出这么大的数组的，那么是否还有其他解决方案呢？

实际上是有的，为了更好的阐述这个题目的思想，我们拿一个例子来说明

nums1 = [1,2,3,4]

nums2 = [5,6,7]

对于这两个数组我们可以枚举出所有的pair

```
(0,0) (0,1) (0,2)
(1,0) (1,1) (1,2)
(2,0) (2,1) (2,2)
(3,0) (3,1) (3,2)

再将其和写出来

6	7	8
7	8	9
8	9	10
9	10	11
```

从这个矩阵中我们可以看到，该矩阵每一行、每一列都是有序的，因此我们要找的TopK就有很明显的特征了

如果将这个矩阵的右边节点和下边节点看成子节点，可以连接成以下图

```
6
|\
7-7
|\|\
8-8-8
|\|\|
9-9-9
 \|\|
 10-10 
   \|
    11
```

那么TopK就一定是按这个顺序排列的，使用优先队列，从根节点开始，每次添加两个节点(i+1,j)和(i,j+1)，但是这样会出现重复，且堆很容易满，为了确保不重复添加，我们可先将所有的右节点添加进去，

对于上图，我们优先队列中包含 {6,7,8}，这样当我们需要添加新节点的时候只需要添加一边即可

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        PriorityQueue<int[]> queue = new PriorityQueue<>(k, (o1, o2)->{
            return nums1[o1[0]] + nums2[o1[1]] - nums1[o2[0]] - nums2[o2[1]];
        });
        List<List<Integer>> ans = new ArrayList<>();
        int m = nums1.length;
        int n = nums2.length;
        boolean axis = false;
        if(m>n){
            for(int i=0;i<n;++i){
                queue.offer(new int[]{0,i});
            }
            axis = true;
        }else{
            for(int i=0;i<m;++i){
            // 这一步很关键，去重
                queue.offer(new int[]{i,0});
            }
            axis = false;
        }
        while (k-- > 0 && !queue.isEmpty()) {
            int[] currPair = queue.poll();
            int i = currPair[0];
            int j = currPair[1];
            List<Integer> list = new ArrayList<>();
            list.add(nums1[i]);
            list.add(nums2[j]);
            ans.add(list);
            if(axis){
                if(i+1 < m){
                    queue.offer(new int[]{i+1,j});
                }
            }else{
                if(j+1 < n){
                    queue.offer(new int[]{i,j+1});
                }
            }
        }
        return ans;
    }
}
```



