---
title: 215. 数组中的第K个最大元素
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: 6b1a
---
# 215. 数组中的第K个最大元素

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

<!-- more -->

## 暴力

没什么好说的，直接暴力搜索吧 o(n^2)

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        for(int i=0;i<k;++i){
            // 每次不断找寻数组中的最大值，然后将最大值放在数组的最前面
            // 然后缩小数组的范围（这样就可以不搜索最大值了）
            int index = findLargest(nums,i);
            // 将最大值放在数组的前面
            swap(nums,index,i);
        }
        return nums[k-1];
    }

    private int findLargest(int[] nums,int begin){
        int index = begin;
        int max = nums[begin];
        for(int i=begin;i<nums.length;++i){
            if(nums[i] > max){
                index = i;
                max = nums[i];
            }
        }
        return index;
    }

    private void swap(int[] nums,int a,int b){
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
}
```

## 排序

找第k大的元素，直接排序

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length-k];
    }
}
```

## !!! 快速排序应用+分治

```java
class Solution {
    private static final Random random = new Random();
    public int findKthLargest(int[] nums, int k) {
        return nth_element(nums,k,0,nums.length-1);
    }

    private int nth_element(int[] nums, int n, int begin, int end) {
        // 假如n的范围是0~nums.length-1
        // 那么需要调整一下
        if (begin == end) return nums[begin];
        int pivot_index = partition(nums, begin, end);
//        if(pivot_pos == n) return nums[pivot_pos];
        // 划分成了两个区间 begin,k和end,k+1
        // 计算pivot_pos在[begin,end]内子数组的一个偏移量
        int local_index = pivot_index - begin + 1;
        if (n <= local_index) {
            return nth_element(nums, n, begin, pivot_index);
        }
        // 当要找的元素比pivot_pos更大时
        // [begin,pivot_pos] [pivot_pos+1,end]
        return nth_element(nums, n - local_index, pivot_index + 1, end);
    }

    private int partition(int arr[], int begin, int end) {
        // 这里采用随机数进行优化，相比固定值可以大幅提升效果
        int pivotIndex = begin + random.nextInt(end - begin + 1);
        // int pivotIndex = (begin + end) >> 1;
        // int pivotIndex = begin;
        swap(arr, pivotIndex, end);

        int left = begin;
        int right = end;

        while (left < right) {
            // 因为把pivot放在了最后，所以low指针先走
            while (left < right && arr[left] > arr[end]) left++;
            // 这里必须是互斥的，否则出现相等时会出现问题
            while (left < right && arr[right] <= arr[end]) right--;
            if (left < right) swap(arr, left, right);
        }

        swap(arr, left, end);
        return left;
    }

    private void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
}
```

## 优先队列

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> queue = new PriorityQueue<>((a,b)->b-a);
        for(int i:nums){
            queue.offer(i);
        }
        while(k>1){
            queue.poll();
            --k;
        }
        return queue.poll();
    }
}
```



