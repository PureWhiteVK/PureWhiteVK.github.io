---
title: 743. 网络延迟时间
mathjax: true
tags:
  - 算法
category: LeetCode刷题记录
abbrlink: ca48
date: 2022-02-12
---
# 743. 网络延迟时间

有 n 个网络节点，标记为 1 到 n。

给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

> 链接：https://leetcode-cn.com/problems/network-delay-time

<!-- more -->

## 单源最短路径（Dijkastra）

这个题是一个很经典的单源最短路径题，主要考察Dijkstra算法（本质贪心）

简要介绍Dijkstra算法：

> 当图中各边的权（本题中指的是节点之间的网络时延）不相等时，用固定的顺序对定点进行处理。把顶点依次记为v0到vn-1，并记s=v0.当处理顶点v1时，取连接顶点v0和顶点v1的边。当处理顶点v2时，考虑从顶点v0到顶点v2的最短距离，并把它与从顶点v0到顶点v1再到顶点v2的最短距离进行比较，取较小者为顶点v0到顶点v2之间的最短路径长度。当处理顶点vi时，利用已经处理过的从顶点v0到顶点vi-1的最短路径长度。但是这样可能会产生问题：也许从v0到vi的真正最短路径会经过顶点vj，而j>i使用这个算法会遗漏这种路径。不过，如果以从顶点S出发所到达的顶点的距离（递增）为顺序对各个节点进行处理，就能避免这个问题了。现在假设已经处理了从顶点S出发所到达的距离最小的前i-1个顶点，称这些顶点的集合为集合S。现在准备按照这个顺序处理第i个顶点，称之为顶点X，则从顶点S到顶点X的最短路径中的倒数第二个顶点一定在集合S中。因此有
> $$
> d(S,X) = min(d(S,U)+w(U,X))
> $$
> 也就是说，从顶点S到顶点X的最短路径长度为：从集合S中任取顶点U，都有一条从顶点S到顶点U的路径，在从顶点U到顶点X的边，计算从所有顶点U产生的路径中的最小值。
>
> 这个方法通常称为Dijkstra算法。它的技巧在于为V中所有的顶点X维护一个路径长度估计值D(X)。D中的元素初始化为INF，并且按照从顶点S出发所到达顶点的距离（递增顺序）处理各个顶点。每当处理一个顶点V时，它的任意一个相邻顶点X的D(X)值都可能随之改变。

文字上的描述有点抽象，下面拿一个例子来展示Dijkstra算法过程

![](Image/dijkstra.png)

如上图所示，求节点1到其他的节点的最短路径

首先初始化距离数组d = [0,INF,INF,INF,INF,INF,INF]

其次初始化访问标记数组visited = [false,false,false,false,false,false]

step1：找到从节点1可直接到达的节点，并记录其距离数组d

可以发现，从1节点可以直达的节点有[2,3,4]

更新距离数组d

[0,2,3,6,INF,INF]

visited[0] = true

step2：选择距离1节点最近的节点2开始计算，同时更新距离值

从节点2可以直达的节点有[1,5,6]，由于节点1已经访问过了，就不需要重新访问了

更新距离数组d

[0,2,3,6,6,8]

visited[1] = true

step3：选择未访问过且距离节点1最小的节点作为下一个访问节点（节点3），更新距离值

更新距离数组d

可以观察到，通过节点3到达节点4的距离会比直接到达节点4要短（2+3<6)

[0,2,3,5,6,8]

visited[2] = true

step4：选择节点4进行更新

距离数组

[0,2,3,5,6,8]

visited[3] = true

step5：选择节点5进行更新

距离数组

[0,2,3,5,6,8]

visited[4] = true

step6：选择节点6进行更新

距离数组

[0,2,3,5,6,8]

visited[5] = true

至此所有节点都已经遍历完成，从节点1到达所有节点的最短路径也求解完成



代码实现（遍历）

```java
class Solution {
    private static final int INF = Integer.MAX_VALUE / 2;
    public int networkDelayTime(int[][] times, int n, int k) {
        int[][] matrix = new int[n][n];
        for(int i=0;i<n;++i){
            Arrays.fill(matrix[i],INF);
        }
        for(int[] t:times){
            matrix[t[0]-1][t[1]-1] = t[2];
        }
        boolean[] visited = new boolean[n];
        // 单源最短路径
        int[] d = new int[n];
        Arrays.fill(d,INF);
        d[k-1] = 0;
        for(int i=0;i<n;++i){
            // 找到未访问节点中距离最短的
            int minIndex = -1;
            for(int j=0;j<n;++j){
                if(!visited[j] && (minIndex == -1 || d[minIndex] > d[j])){
                    minIndex = j;
                }
            }
            visited[minIndex] = true;
            // 更新
            for(int j=0;j<n;++j){
                d[j] = Math.min(d[j],d[minIndex] + matrix[minIndex][j]);
            }
        }
        // 遍历找最大
        int maxD = 0;
        for(int i:d){
            maxD = Math.max(i,maxD);
        }
        return maxD == INF ? -1 : maxD;
    }
}
```

从求解过程中可以看到，每一步都需要遍历距离数组D找到距离当前节点最近的节点进行更新，实际上可以使用优先队列进行优化

```java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        final int INF = Integer.MAX_VALUE / 2;
        List<int[]>[] g = new List[n];
        for (int i = 0; i < n; ++i) {
            g[i] = new ArrayList<int[]>();
        }
        // 临接表
        for (int[] t : times) {
            int x = t[0] - 1, y = t[1] - 1;
            g[x].add(new int[]{y, t[2]});
        }

        int[] dist = new int[n];
        Arrays.fill(dist, INF);
        dist[k - 1] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);
        pq.offer(new int[]{0, k - 1});
        while (!pq.isEmpty()) {
            int[] p = pq.poll();
            int time = p[0], x = p[1];
            if (dist[x] < time) {
                continue;
            }
            // g[x]代表从x直接相邻的节点
            for (int[] e : g[x]) {
                int y = e[0], d = dist[x] + e[1];
                if (d < dist[y]) {
                    dist[y] = d;
                    pq.offer(new int[]{d, y});
                }
            }
        }

        int res = 0;
        for(int i:dist){
            res = Math.max(res,i);
        }
        return res == INF ? -1 : res;
    }
}
```

