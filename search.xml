<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>401. 二进制手表</title>
    <url>/posts/96e0/</url>
    <content><![CDATA[<h1 id="401-二进制手表">401. 二进制手表</h1>
<blockquote>
<p>链接：<a href="https://leetcode-cn.com/problems/binary-watch/">401.
二进制手表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<p>题意：</p>
<p>有一种手表用二进制来表示时间，小时包含4位（使用0-11），分钟包含6位（0-59），使用10个LED灯就可以表示时间，题目输入打开的LED灯数，给出所有可表示的时间</p>
<p>思路：仅包含小时和分钟，因此直接穷举所有的时间，判断其打开的LED灯数，给出时间表示即可</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] binaryCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">60</span>];</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 为了避免多次计算，第一次运行的时候把表打好，之后直接返回结果就行了</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>;++i)&#123;</span><br><span class="line">            binaryCount[i] = getBinaryCount(i);</span><br><span class="line">            <span class="comment">// System.out.println(&quot;binaryCount[&quot;+i+&quot;] = &quot;+binaryCount[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">0</span>;h&lt;<span class="number">12</span>;++h)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hourCount</span> <span class="operator">=</span> binaryCount[h];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;<span class="number">60</span>;++m)&#123;</span><br><span class="line">                <span class="comment">// 注意输出时间格式要求，小时不要求前导0，但是分钟前面必须有前导0</span></span><br><span class="line">                res.get(hourCount + binaryCount[m]).add(String.format(<span class="string">&quot;%d:%02d&quot;</span>,h,m));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">readBinaryWatch</span><span class="params">(<span class="type">int</span> turnedOn)</span> &#123;</span><br><span class="line">        <span class="comment">// 总共有10个LED灯表示时间</span></span><br><span class="line">        <span class="comment">// 对于给出亮起的LED灯数，需要输出所有可行的表示时间结果</span></span><br><span class="line">        <span class="comment">// 一种思路是穷举所有LED表示时间的可能性，然后存储到结果中，直接返回即可，这个速度是最快的</span></span><br><span class="line">        <span class="comment">// 表示的时间范围 0-11h 0-59m</span></span><br><span class="line">        <span class="comment">// 总共包含12*60 个即 720个时间 从0:00 -&gt; 11:59</span></span><br><span class="line">        <span class="comment">// 最简单的就是直接遍历720中可能性，计算其二进制表示所需的LED灯数，然后统计LED数是否等于turnedOn即可        </span></span><br><span class="line">        <span class="keyword">return</span> res.get(turnedOn);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 这里是自己写的bitCount，属实丑了点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getBinaryCount</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="comment">// 统计一个数字的二进制中1出现的次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 思路也很简单，遍历int的每一位，判断其是否是1，最后给出1的个数即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((number &gt;&gt; i) &amp; <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完之后看官方题解，才发现JDK中是直接包含了求二进制中1的个数的，这里重复造轮子了，而且造出来的还是三角形的轮子</p>
<h1 id="jdk-integerbitcount函数理解">JDK Integer.bitCount函数理解</h1>
<blockquote>
<p>这个在LeetCode上也有题目：<a
href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指
Offer 15. 二进制中1的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<blockquote>
<p>java中<code>&gt;&gt;&gt;</code>运算符表示无符号右移，即移出的部分前面补充0，这样是不会改变二进制中1的个数的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of one-bits in the two&#x27;s complement binary</span></span><br><span class="line"><span class="comment"> * representation of the specified &#123;<span class="doctag">@code</span> int&#125; value.  This function is</span></span><br><span class="line"><span class="comment"> * sometimes referred to as the &lt;i&gt;population count&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i the value whose bits are to be counted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of one-bits in the two&#x27;s complement binary</span></span><br><span class="line"><span class="comment"> *     representation of the specified &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bitCount</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Figure 5-2</span></span><br><span class="line">    i = i - ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    i = (i + (i &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i &amp; <span class="number">0x3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行结果解析">执行结果解析</h2>
<p>假设输入的i是 <code>0x12345678</code>，即</p>
<p><code>0b 0001 0010 0011 0100 0101 0110 0111 1000</code></p>
<p>如果将i每位上1理解成该位上1出现的次数，可以写成下面数组形式</p>
<p><code>0 0 0 1 0 0 1 0 0 0 1 1 0 1 0 0 0 1 0 1 0 1 1 0 0 1 1 1 1 0 0 0 </code></p>
<p>经过第一步计算结果为<code>0x11245564</code>，即</p>
<p><code>0b 0001 0001 0010 0100 0101 0101 0110 0100</code></p>
<p>如果将结果每两位进行观察，可以发现，这一步计算的结果刚好代表输入i上每两位所包含的1的个数</p>
<p><code>0b 00 01 00 01 00 10 01 00 01 01 01 01 01 10 01 00</code></p>
<p><code>0 1 0 1 0 2 1 0 1 1 1 1 1 2 1 0</code></p>
<p>经过第二步计算结果为<code>0x11212231</code>，即</p>
<p><code>0b 0001 0001 0010 0001 0010 0010 0011 0001</code></p>
<p>此时将结果每四位进行观察，可以发现，这一步计算的结果刚好代表输入i上每四位所包含的1的个数</p>
<p><code>0b 0001 0001 0010 0001 0010 0010 0011 0001</code></p>
<p><code>1 1 2 1 2 2 3 1</code></p>
<p>从这两步的结算结果不难想到，下一步应该就是计算每八位上包含的1的个数，实际上就是将结果中两两相加</p>
<p><code>0b 00000010 00000011 00000100 00000100</code></p>
<p><code>2 3 4 4</code></p>
<p>下一步计算每16位上包含的1的个数</p>
<p>本来这里代码应该写成<code>i = (i + (i &gt;&gt;&gt; 8)) &amp; 0x00ff00ff; </code></p>
<p>才可以刚好得到理想结果（前十六位代表前十六中1的个数，后十六位代表后十六位的个数）</p>
<p><code>0b 0000000000000101 0000000000001000</code></p>
<p><code>5 8</code></p>
<p>最后就可以得到32位上包含的1的个数</p>
<p>代码也应该写成<code>i = (i + (i &gt;&gt;&gt; 16)) &amp; 0x0000ffff</code></p>
<p><code>0b 0000 0000 0000 0000 0000 0000 0000 1101</code></p>
<p><code>13</code></p>
<p>不过在上述源码的执行过程中后两部没有抹去计算中前面十六位计算的结果，而是在最后一步直接通过<code>i &amp; 0x3f</code>得到最终结果，如此减少了一次<code>&amp;</code>运算，加快计算</p>
<p>从该算法的执行过程也可以看出，是一个不断归并的过程，从统计1位到2位，再到4位、8位，16位，最后统计32位的1的个数</p>
<h1 id="jdk-longbitcount函数">JDK Long.bitCount函数</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the number of one-bits in the two&#x27;s complement binary</span></span><br><span class="line"><span class="comment"> * representation of the specified &#123;<span class="doctag">@code</span> long&#125; value.  This function is</span></span><br><span class="line"><span class="comment"> * sometimes referred to as the &lt;i&gt;population count&lt;/i&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i the value whose bits are to be counted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the number of one-bits in the two&#x27;s complement binary</span></span><br><span class="line"><span class="comment"> *     representation of the specified &#123;<span class="doctag">@code</span> long&#125; value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bitCount</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// HD, Figure 5-2</span></span><br><span class="line">    i = i - ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555L</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x3333333333333333L</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333L</span>);</span><br><span class="line">    i = (i + (i &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f0f0f0f0fL</span>;</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)i &amp; <span class="number">0x7f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看懂了Integer.bitCount的执行过程后，对于Long的求解思路也是一样，通过分治思想，并行求取多位上1个个数，再将结果不断累加，最终可得该数中1的个数</p>
<p>执行结果抽象如下：</p>
<p>对于输入i</p>
<ol type="1">
<li>将i的每2位相加</li>
<li>将i的每4位相加</li>
<li>将i的每8位相加</li>
<li>将i的每16位相加</li>
<li>将i的每32位相加（即该数二进制中包含的1的个数）</li>
</ol>
<p>最原始的执行过程应该是</p>
<p>i = 0x1234</p>
<p><code>0b 0001 0010 0011 0100</code></p>
<p>第一步执行结果</p>
<p><code>0b 00 01 00 01 00 10 01 00</code></p>
<p>第二步执行结果</p>
<p><code>0b 0001 0001 0010 0001  </code></p>
<p>第三步执行结果</p>
<p><code>0b 0000 0010 0000 0011</code></p>
<p>第四步执行结果</p>
<p><code>0b 0000 0000 0000 0101 </code></p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1104. 二叉树寻路</title>
    <url>/posts/3770/</url>
    <content><![CDATA[<h1 id="1104-二叉树寻路">1104. 二叉树寻路</h1>
<p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按
“之” 字形进行标记。</p>
<p>如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；</p>
<p>而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。</p>
<p>给你树上某一个节点的标号
<code>label</code>，请你返回从根节点到该标号为 <code>label</code>
节点的路径，该路径是由途经的节点标号所组成的。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree">https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree</a></p>
</blockquote>
<span id="more"></span>

<h2 id="数学">数学</h2>
<p>这题没什么好说，一个完全二叉树，其父节点值可以直接通过计算得出</p>
<p>相对于正常的二叉树，其奇数行进行了反转，因此需要特别处理一下，考虑到反转前和反转后值的变化情况</p>
<p>4，5，6，7</p>
<p>7，6，5，4</p>
<p>可以发现反转前后两数之和为固定值，因此只需要计算出这个固定值，然后相减就可以变成完全二叉树父节点求法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">log2</span> <span class="operator">=</span> Math.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">pathInZigZagTree</span><span class="params">(<span class="type">int</span> label)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      	<span class="comment">// 由于此时找到的结果是从下至上的，还需要进行反转</span></span><br><span class="line">        <span class="keyword">while</span>(label != <span class="number">1</span>)&#123;</span><br><span class="line">            path.add(label);</span><br><span class="line">            label = getParent(label);</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(<span class="number">1</span>);</span><br><span class="line">        Collections.reverse(path);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getParent</span><span class="params">(<span class="type">int</span> label)</span>&#123;</span><br><span class="line">        <span class="comment">// 首先计算节点高度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(Math.log(label) / log2);</span><br><span class="line">				<span class="comment">// 计算反转前后两数和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.pow(<span class="number">2</span>,level)+Math.pow(<span class="number">2</span>,level+<span class="number">1</span>)) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parentSum</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.pow(<span class="number">2</span>,level-<span class="number">1</span>)+Math.pow(<span class="number">2</span>,level)) -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// System.out.println(sum);</span></span><br><span class="line">        <span class="comment">// 和是一致的，那其父节点对应值就是</span></span><br><span class="line">        <span class="comment">// 4 5 6 7</span></span><br><span class="line">        <span class="comment">// 7 6 5 4</span></span><br><span class="line">        <span class="comment">// 最后还需要对父节点进行处理</span></span><br><span class="line">      	<span class="comment">// 计算父节点值</span></span><br><span class="line">        <span class="keyword">if</span>((level &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> parentSum - (label &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum-label) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1143. 最长公共子序列</title>
    <url>/posts/2927/</url>
    <content><![CDATA[<h1 id="1143-最长公共子序列">1143. 最长公共子序列</h1>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列
的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列
是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/longest-common-subsequence">https://leetcode-cn.com/problems/longest-common-subsequence</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>寻找最长公共子序列也是一类经典的动态规划题，用一个二维数组存储状态，dp[i,j]表示串A长度为i时和串B长度为j时的最长公共子序列</p>
<p>状态更新方程</p>
<p>dp[i,j] = dp[i-1,j-1] if A[i] == B[j]</p>
<p>dp[i,j] = max(dp[i-1,j],dp[i,j-1]) if A[i] != B[j]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> text1.length(),n=text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];å</span><br><span class="line">        <span class="title function_">for</span><span class="params">(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>138. 复制带随机指针的链表</title>
    <url>/posts/6fad/</url>
    <content><![CDATA[<h1 id="138-复制带随机指针的链表">138. 复制带随机指针的链表</h1>
<p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random
，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 n 个
<strong>全新</strong>
节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next
指针和 random
指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong>
。</p>
<p>例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&gt; Y
。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&gt; y
。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个
[val, random_index] 表示：</p>
<p>val：一个表示 Node.val 的整数。
random_index：随机指针指向的节点索引（范围从 0 到
n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点
head 作为传入参数。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/copy-list-with-random-pointer">https://leetcode-cn.com/problems/copy-list-with-random-pointer</a></p>
</blockquote>
<span id="more"></span>

<h2 id="map解法">Map解法</h2>
<p>看到这个题目呢，可以很容易的想到，使用一个Map，存储新旧节点之间的映射关系，之后再遍历一次旧节点，复制结点之间的指向关系即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 最简单的思路，建立旧结点和新结点之间的映射关系，之后逐一复制关系即可</span></span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 创建映射关系</span></span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(curr,<span class="keyword">new</span> <span class="title class_">Node</span>(curr.val));</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制节点间关系</span></span><br><span class="line">        curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> map.get(curr);</span><br><span class="line">            newNode.next = map.get(curr.next);</span><br><span class="line">            newNode.random = map.get(curr.random);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样算法的时间复杂度为o(n)，空间复杂度为o(n)，实际上可以继续优化成空间复杂度为o(1)，省去map</p>
<h2 id="优化map解法">优化Map解法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// step1，新建复制结点</span></span><br><span class="line">   	<span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; </span><br><span class="line">         node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">    	<span class="type">Node</span> <span class="variable">nodeNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val);</span><br><span class="line">      nodeNew.next = node.next;</span><br><span class="line">      node.next = nodeNew;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// step2，复制链接关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; </span><br><span class="line">         node != <span class="literal">null</span>; node = node.next.next) &#123;</span><br><span class="line">    	<span class="type">Node</span> <span class="variable">nodeNew</span> <span class="operator">=</span> node.next;</span><br><span class="line">      nodeNew.random = </span><br><span class="line">        (node.random != <span class="literal">null</span>) ? node.random.next : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// step3，分离新旧链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">headNew</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; </span><br><span class="line">         node != <span class="literal">null</span>; node = node.next) &#123;</span><br><span class="line">    	<span class="type">Node</span> <span class="variable">nodeNew</span> <span class="operator">=</span> node.next;</span><br><span class="line">      node.next = node.next.next;</span><br><span class="line">      nodeNew.next = </span><br><span class="line">        (nodeNew.next != <span class="literal">null</span>) ? nodeNew.next.next : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1743. 从相邻元素对还原数组</title>
    <url>/posts/a947/</url>
    <content><![CDATA[<h1 id="1743-从相邻元素对还原数组">1743. 从相邻元素对还原数组</h1>
<p>存在一个由 n 个不同元素组成的整数数组 nums
，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。</p>
<p>给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个
adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。</p>
<p>题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于
adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是
[nums[i+1], nums[i]] 。这些相邻元素对可以 <strong>按任意顺序</strong>
出现。</p>
<p>返回 <strong>原始数组</strong> nums 。如果存在多种解答，返回
其中任意一个 即可。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs">https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs</a></p>
</blockquote>
<span id="more"></span>

<h2 id="哈希表dfs">哈希表+dfs</h2>
<p>首先看到这个题目的时候还没有什么想法，后面看了眼提示，可以将pairs看成边，这样就变成了包含n个节点，n-1条边的图，且已知节点之间的关联关系，只需要执行一遍dfs就可以找出一条连接所有节点的路径（此时就可以还原出数组了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] restoreArray(<span class="type">int</span>[][] adjacentPairs) &#123;</span><br><span class="line">        <span class="comment">// 每一个数字可以看成图的节点，pairs表示边（无向边）</span></span><br><span class="line">        <span class="comment">// map&#123;2=[1,3],1=[2],3=[4,2],4=[3]&#125;</span></span><br><span class="line">        <span class="comment">// start = 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> adjacentPairs.length + <span class="number">1</span>;</span><br><span class="line">      	<span class="comment">// 建立临接表</span></span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] pair : adjacentPairs)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">nodeA</span> <span class="operator">=</span> pair[<span class="number">0</span>];</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">nodeB</span> <span class="operator">=</span> pair[<span class="number">1</span>];</span><br><span class="line">            List&lt;Integer&gt; edgeA = map.getOrDefault(nodeA,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">            List&lt;Integer&gt; edgeB = map.getOrDefault(nodeB,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">            edgeA.add(nodeB);</span><br><span class="line">            edgeB.add(nodeA);</span><br><span class="line">            map.put(nodeA,edgeA);</span><br><span class="line">            map.put(nodeB,edgeB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到开始节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">startNode</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,List&lt;Integer&gt;&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue().size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 说明该节点仅与一个节点相邻，是开始节点</span></span><br><span class="line">                startNode = entry.getKey();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;startNode:&quot;+startNode);</span></span><br><span class="line">        <span class="comment">// 开始dfs</span></span><br><span class="line">        <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 实际上由于每一个节点相邻节点最多为2，实际上可以将递归函数转换成迭代形式</span></span><br><span class="line">        path[<span class="number">0</span>] = startNode;</span><br><span class="line">        path[<span class="number">1</span>] = map.get(startNode).get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">// 当一个节点被选中后，那就选择另外一个即可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nodeA</span> <span class="operator">=</span> map.get(path[i-<span class="number">1</span>]).get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">nodeB</span> <span class="operator">=</span> map.get(path[i-<span class="number">1</span>]).get(<span class="number">1</span>);</span><br><span class="line">            path[i] = path[i-<span class="number">2</span>] == nodeA ? nodeB : nodeA; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1838. 最高频元素的频数</title>
    <url>/posts/fac5/</url>
    <content><![CDATA[<h1 id="1838-最高频元素的频数">1838. 最高频元素的频数</h1>
<p>元素的 <strong>频数</strong> 是该元素在一个数组中出现的次数。</p>
<p>给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums
的一个下标，并将该下标对应元素的值增加 1 。</p>
<p>执行最多 k 次操作后，返回数组中最高频元素的
<strong>最大可能频数</strong> 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element">https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力解法">暴力解法</h2>
<p>暴力流的思路就是假设nums[i]作为数组中最高频元素，然后执行若干次自增操作后统计该元素出现的频数，由于数组中最大可能频数一定是数组中的元素值，因此采用暴力是一定可以找到结果的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxFrequency</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> k;</span><br><span class="line">          	<span class="comment">// 排序之后，nums[j]一定是小于nums[i]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">                temp -= (nums[i]-nums[j]);</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(cnt,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法时间复杂度为o(n^2)，空间复杂度o(1)，但是会超时</p>
<h2 id="二分查找滑动窗口排序前缀和">二分查找+滑动窗口+排序+前缀和</h2>
<p>说实话这个题一开始只想得到暴力，但是写完之后发现超时了（囧）</p>
<p>没办法看了大佬的题解，看了许久终于看懂了</p>
<p>首先需要识别出这个frequency实际上搜索的区间是[0,n]，且满足有序性，此时就可以使用二分查找进行搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, sum;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxFrequency</span><span class="params">(<span class="type">int</span>[] _nums, <span class="type">int</span> _k)</span> &#123;</span><br><span class="line">        nums = _nums;</span><br><span class="line">        k = _k;</span><br><span class="line">        n = nums.length;</span><br><span class="line">      	<span class="comment">// 对nums进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">      	<span class="comment">// 计算前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n;</span><br><span class="line">      	<span class="comment">// 二分查找滑动窗口的长度，通过check函数判断其是否满足条件，从而可以计算出最优值</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 判断当前len值是否符合</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">      	<span class="comment">// 这里开始遍历所有的可行右边界，将右边界作为基准值，然后判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l + len - <span class="number">1</span> &lt; n; l++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + len - <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">// 计算区间内的和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> sum[r + <span class="number">1</span>] - sum[l];</span><br><span class="line">          	<span class="comment">// 将区间内所有值都转换成nums[r]之后的总和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[r] * len;</span><br><span class="line">          	<span class="comment">// 通过转换之后区间内的和减去原有区间内的和就是需要进行增加的次数，判断是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (t - cur &lt;= k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1877. 数组中最大数对和的最小值</title>
    <url>/posts/63b1/</url>
    <content><![CDATA[<h1 id="1877-数组中最大数对和的最小值">1877.
数组中最大数对和的最小值</h1>
<p>一个数对 (a,b) 的 <strong>数对和</strong> 等于 a + b
。<strong>最大数对和</strong> 是一个数对数组中最大的
<strong>数对和</strong> 。</p>
<p>比方说，如果我们有数对 (1,5) ，(2,3) 和
(4,4)，<strong>最大数对和</strong> 为 max(1+5, 2+3, 4+4) = max(6, 5, 8)
= 8 。 给你一个长度为 <strong>偶数</strong> n 的数组 nums ，请你将 nums
中的元素分成 n / 2 个数对，使得：</p>
<p>nums 中每个元素 <strong>恰好</strong> 在 一个 数对中，且
<strong>最大数对和</strong> 的值 <strong>最小</strong> 。
请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong>
。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array">https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array</a></p>
</blockquote>
<span id="more"></span>

<h2 id="贪心">贪心</h2>
<p>看到题目首先想暴力解法，最简单的，直接遍历所有的可行划分，之后找出值最小的最大数对和就是答案，但是这样首先需要计算可行划分数目</p>
<h3 id="可行划分数目计算">可行划分数目计算</h3>
<p>n=2，如 [1,2]</p>
<p>划分数1</p>
<p>n=4，如 [1,2,3,4]</p>
<p>首先考虑第一对的选择，剩下的自然组成一对，那么第一对共有3种</p>
<p>[1,2] [3,4]</p>
<p>[1,3] [2,4]</p>
<p>[1,4] [2,3]</p>
<p>n=6，如 [1,2,3,4,5,6]</p>
<p>同样先考虑第一对的划分，确定好第一对之后剩下的四个元素的组合数之前计算过，可以直接相乘</p>
<p>那么第一对可选择共7种，则总共的划分数为 5*3 = 15</p>
<p>[1,2] [3,4] [5,6]</p>
<p>​ [3,5] [4,6]</p>
<p>​ [3,6] [4,5]</p>
<p>[1,3] [2,4] [5,6]</p>
<p>​ [2,5] [4,6]</p>
<p>​ [2,6] [4,5]</p>
<p>...</p>
<p>从前三个n的计算可以看出，这是一个递归的计算过程，只要确定当前组合数之后就可以将问题规模缩小，最终得到确定解</p>
<p>递推公式，设num[i]代表数组长度为i时的划分总数，其中n为偶数</p>
<p>num[n] = num[n-2] * (n-1)</p>
<p>num[n-2] = num[n-4]*(n-3)</p>
<p>num[n] = num[n-4]*(n-1)*(n-3)</p>
<p>可见，此时可行的划分数目明显不是一个o(n)级别的，因此暴力枚举是没有用的</p>
<h2 id="代码">代码</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPairSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            res = Math.max(nums[l]+nums[r],res);</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际代码很简单，关键在于为什么可以使用贪心算法？（即首尾各取一个为什么一定可以得到最小值）</p>
<h3 id="贪心证明">贪心证明</h3>
<p>直观的想，每次选择数组中最大和最小的数进行组合，这样每次生成的数对都是最小的，从而使得最终结果最平均，问题在于，是否一定会导致最终结果也是最小的</p>
<p>LeetCode官方题解给出的证明</p>
<blockquote>
<p>我们可对数组中的所有数建立全序关系，即 <span class="math display">\[
x_1 \le \cdots \le x_n
\]</span></p>
<p>我们需要证明，任意的拆分方法得到的最大数对和一定大于等于给定的拆分方法得到的最大数对和。我们可以考虑上述命题的充分条件：假设给定拆分方法中的数对和
<span class="math display">\[
x_{k}+x_{n+1-k}
\]</span> 在 k = k' 时最大，那么对于任意的拆分方法，都存在一组 u,v 使得
<span class="math display">\[
x_u + x_v \ge x_{k&#39;} + x_{n+1-k&#39;}
\]</span> 我们可以用反证法证明。不妨设 u&lt;v，那么使得</p>
<p><span class="math display">\[
x_v \ge x_{n+1-k&#39;}
\]</span> 的 v 的取值一共有 k' 种。即闭区间 [n+1-k',n]
中的所有整数。对于这些 v 组成的数对，如果想使得 <span
class="math display">\[
x_u + x_v &lt; x_{k&#39;} + x_{n+1-k&#39;}
\]</span> 恒成立，必须要 <span class="math display">\[
x_u &lt; x_{k&#39;}
\]</span> 此时需要有 k' 个不同的 u 的取值，但只有闭区间 [1,k'-1] 中的
k'-1个整数满足 <span class="math display">\[
x_u &lt; x_{k&#39;}
\]</span></p>
<p>的条件，这就产生了矛盾。</p>
<p>因此，一定存在一组 u, v 使得 <span class="math display">\[
x_u + x_v \ge x_{k&#39;} + x_{n+1-k&#39;}
\]</span></p>
</blockquote>
<p>看了半天似懂非懂，好像是这么回事（😓）</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1893. 检查是否区域内所有整数都被覆盖</title>
    <url>/posts/2828/</url>
    <content><![CDATA[<h1 id="1893-检查是否区域内所有整数都被覆盖">1893.
检查是否区域内所有整数都被覆盖</h1>
<p>给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i]
= [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。</p>
<p>如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个
区间覆盖，那么请你返回 true ，否则返回 false 。</p>
<p>已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti &lt;= x
&lt;= endi ，那么我们称整数x 被覆盖了。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered">https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力1">暴力（1）</h2>
<p>最容易想到的就是，对于 [left,right]
区间内的每一个整数，逐个判断其是否再区间即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCovered</span><span class="params">(<span class="type">int</span>[][] ranges, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 依次检查left到right中的每一个数是否在ranges中？</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;++i)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">notIn</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] range:ranges)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=range[<span class="number">0</span>] &amp;&amp; i &lt;= range[<span class="number">1</span>])&#123;</span><br><span class="line">                    notIn = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(notIn) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明显，这个算法的时间复杂度为o(n^2)，空间复杂度为o(1)，还可以进一步优化</p>
<h2 id="暴力2">暴力（2）</h2>
<p>由于题设中给出了数据的取值范围</p>
<ul>
<li>1 &lt;= ranges.length &lt;= 50</li>
<li>1 &lt;= start[i] &lt;= end[i] &lt;= 50</li>
<li>1 &lt;= left &lt;= right &lt;= 50</li>
</ul>
<p>可以使用一个数组nums，其包含1～50内所有的整数，首先遍历一遍ranges中范围，标记，之后再遍历一遍left到right的整数，判断是否在范围内即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCovered</span><span class="params">(<span class="type">int</span>[][] ranges,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">boolean</span>[] isIn = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">51</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] range:ranges)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=range[<span class="number">0</span>];i&lt;=range[<span class="number">1</span>];++i)&#123;</span><br><span class="line">        isIn[i] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!isIn[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法时间复杂度也是o(n^2)，且空间复杂度为o(n)</p>
<h2 id="优化">优化</h2>
<p>对于暴力（2）解法，实际上只需要判断区间[left,right]之间的整数即可，因此在遍历ranges中的范围时，可以先判断
[ left,right ] 和 [ start[i],end[i]
]是否相交，之后再遍历相交部分，将其标记为可行，最后再遍历一次
[left,right]之间的所有整数，判断其是否被标记即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCovered</span><span class="params">(<span class="type">int</span>[][] ranges,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="type">boolean</span>[] isIn = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">51</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] range:ranges)&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> Math.max(left,range[<span class="number">0</span>]);</span><br><span class="line">      <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> Math.min(right,range[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=L;i&lt;=R;++i)&#123;</span><br><span class="line">        isIn[i] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!isIn[i])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果上进行分析，如果 区间 [left,right] 和 [ range[0],range[1]
]不相交，并不会遍历区间，时间复杂度为o(n*(right-left+1))，空间复杂度为o(n)</p>
<h2 id="差分数组前缀和">差分数组+前缀和</h2>
<p>最后一种解法是看题解种看到的，使用差分数组 diff
表示相邻格之间，是否被覆盖的变化量</p>
<p>对于区间 [left,right] ，其diff数组中 diff[left]++
，diff[right+1]--</p>
<p>之后再对diff数组求前缀和，可以发现sum[left]~sum[right]都是1，到了sum[right+1]就变成了0，因此使用差分数组+前缀和可以快速标记区间内的数组，因此对于ranges中的所有范围，只需要标记一遍差分数组，再计算前缀和就可以得出每个数组是否再范围内，同时还可以给出对于数组被标记了几次【这个思路属实牛批】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCovered</span><span class="params">(<span class="type">int</span>[][] ranges,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">// 由于需要标记到diff[right+1]，而right最大值为50，因此此处数组长度为52</span></span><br><span class="line">    <span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">52</span>];</span><br><span class="line">    <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">52</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] range:ranges)&#123;</span><br><span class="line">      ++diff[range[<span class="number">0</span>]];</span><br><span class="line">      --diff[range[<span class="number">1</span>]+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">52</span>;++i)&#123;</span><br><span class="line">      sum[i] = sum[i-<span class="number">1</span>]+diff[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断区间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(sum[i] &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法的时间复杂度为o(n)，空间复杂度为o(n)</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>218. 天际线问题</title>
    <url>/posts/f720/</url>
    <content><![CDATA[<h1 id="218-天际线问题">218. 天际线问题</h1>
<p>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的
<strong>天际线</strong> 。</p>
<p>每个建筑物的几何信息由数组 buildings 表示，其中三元组 buildings[i] =
[lefti, righti, heighti] 表示：</p>
<ul>
<li><p>lefti 是第 i 座建筑物左边缘的 x 坐标。</p></li>
<li><p>righti 是第 i 座建筑物右边缘的 x 坐标。</p></li>
<li><p>heighti 是第 i 座建筑物的高度。</p></li>
</ul>
<p><strong>天际线</strong> 应该表示为由 “关键点” 组成的列表，格式
[[x1,y1],[x2,y2],...] ，并按 <strong>x 坐标</strong> 进行
<strong>排序</strong>
。<strong>关键点是水平线段的左端点</strong>。列表中最后一个点是最右侧建筑物的终点，y
坐标始终为 0
，仅用于标记天际线的终点。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。</p>
<p><strong>注意</strong>：输出天际线中不得有连续的相同高度的水平线。例如
[...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5
的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/the-skyline-problem">https://leetcode-cn.com/problems/the-skyline-problem</a></p>
<p>解题思路参考：<a
href="https://briangordon.github.io/2014/08/the-skyline-problem.html">https://briangordon.github.io/2014/08/the-skyline-problem.html</a></p>
<p>作者为了讲解方便，进行图形化展示，便于理解</p>
</blockquote>
<span id="more"></span>

<h2 id="暴力解法1不可行">暴力解法1（不可行）</h2>
<p>首先看题目，可以想到的最简单的思路就是，建立一个数轴，遍历所有的矩形，存储每一个单位上高度变化，之后遍历数轴，找到所有高度发生突变的点就是天际线的关键点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getSkyline</span><span class="params">(<span class="type">int</span>[][] buildings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> buildings.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> buildings[n-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] heightMap = <span class="keyword">new</span> <span class="title class_">int</span>[r+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] build :buildings)&#123;</span><br><span class="line">            <span class="comment">// 按照关键点的定义，此处必须是左闭右开</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=build[<span class="number">0</span>];i&lt;build[<span class="number">1</span>];++i)&#123;</span><br><span class="line">                heightMap[i] = Math.max(heightMap[i],build[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历数轴</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;++i)&#123;</span><br><span class="line">          	<span class="comment">// 找到高度突变的点</span></span><br><span class="line">            <span class="keyword">if</span>(heightMap[i] != heightMap[i-<span class="number">1</span>])&#123;</span><br><span class="line">                res.add(List.of(i,heightMap[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：这个方法看上去可行，但实际上碰到极端情况是不行的，例如[[1,2^31-1,2^31-1]]，此时需要新建一个长度为2^31的数组，计算下来内存占用非常大，且没有意义，算法运行时间复杂度为o(n*m)，空间复杂度为o(m)，其中m为building的最右端点</p>
<h2 id="扫描线">扫描线</h2>
<h3 id="暴力解法2">暴力解法2</h3>
<p>从暴力解法1的执行过程和关键点的选取中可以看出，实际上所有关键点出现的位置要么位于建筑的边界点，要么位于两个建筑相交处，因此存储所有的边界信息，之后遍历边界信息来寻找关键点</p>
<p>[2,3,7,9,12,15,19,20,24]</p>
<p>[[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]</p>
<p>在[2,3)区间内，包含建筑[2,9,10]，高度最高的为10，此时记录边界点(2,10)，而在[3,7)区间，包含建筑
[2,9,10]、[3,7,15]、[5,12,12]，高度最高为15，此时记录边界点(3,15)，之后边界点的计算以此类推，同时注意到，使用了prevHeight来保存前一个高度值，只有高度值发生变化时才是一个关键点，如果两个边界间的关键点高度一致是不计算关键点的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getSkyline</span><span class="params">(<span class="type">int</span>[][] buildings)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; boundry = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] building:buildings)&#123;</span><br><span class="line">            boundry.add(building[<span class="number">0</span>]);</span><br><span class="line">            boundry.add(building[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后对boundry进行排序</span></span><br><span class="line">        Collections.sort(boundry);</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> boundry.get(<span class="number">0</span>),maxHeight = <span class="number">0</span>,prevHeight = <span class="number">0</span>;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;boundry.size();++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> boundry.get(i);</span><br><span class="line">            maxHeight = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// System.out.println(&quot;current interval: [&quot;+prev+&quot;,&quot;+b+&quot;)&quot;);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] build:buildings)&#123;</span><br><span class="line">                <span class="comment">// 判断建筑是否位于这个区间内 [prev,b)</span></span><br><span class="line">                <span class="keyword">if</span>(build[<span class="number">0</span>] &lt;= prev &amp;&amp; build[<span class="number">1</span>] &gt;= b)&#123;</span><br><span class="line">                    <span class="comment">// System.out.println(&quot;[&quot;+build[0]+&quot;,&quot;+build[1]+&quot;,&quot;+build[2]+&quot;]&quot;);</span></span><br><span class="line">                    maxHeight = Math.max(maxHeight,build[<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println(&quot;maxHeight:&quot;+maxHeight);</span></span><br><span class="line">            <span class="comment">// 仅在高度发生变化时记录</span></span><br><span class="line">            <span class="keyword">if</span>(maxHeight != prevHeight)&#123;</span><br><span class="line">                res.add(List.of(prev,maxHeight));</span><br><span class="line">            &#125;</span><br><span class="line">            prevHeight = maxHeight;</span><br><span class="line">            prev = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后插入列表中最后一个点</span></span><br><span class="line">        res.add(List.of(boundry.get(boundry.size()-<span class="number">1</span>),<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优先队列优化">优先队列优化</h3>
<p>观察暴力解法2的代码，可以发现主要时间都花在寻找区间内高度最高的值，对于每一个区间都需要遍历buildings数组，找到在该区间内的高度最大值，实际上可以使用优先队列存储高度和右边界值，每次插入在区间内的值，可以快速找到最大值，同时注意删除不在区间内不的值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">getSkyline</span><span class="params">(<span class="type">int</span>[][] buildings)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; boundry = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] building:buildings)&#123;</span><br><span class="line">            boundry.add(building[<span class="number">0</span>]);</span><br><span class="line">            boundry.add(building[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后对boundry进行排序</span></span><br><span class="line">        Collections.sort(boundry);</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> boundry.get(<span class="number">0</span>),maxHeight = <span class="number">0</span>,prevHeight = <span class="number">0</span>,idx=<span class="number">0</span>,n=buildings.length;</span><br><span class="line">        <span class="comment">// 存储building信息</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b[<span class="number">2</span>]-a[<span class="number">2</span>]); </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;boundry.size();++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> boundry.get(i);</span><br><span class="line">            <span class="keyword">while</span>(idx &lt; n &amp;&amp; buildings[idx][<span class="number">0</span>] &lt;= prev &amp;&amp; buildings[idx][<span class="number">1</span>] &gt;= b)&#123;</span><br><span class="line">                queue.add(buildings[idx]);</span><br><span class="line">                ++idx;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除堆中不在区间内的值</span></span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; (queue.peek()[<span class="number">0</span>] &gt; prev || queue.peek()[<span class="number">1</span>] &lt; b))&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 仅在高度发生变化时记录</span></span><br><span class="line">            <span class="keyword">if</span>(queue.isEmpty())&#123;</span><br><span class="line">                maxHeight = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxHeight = queue.peek()[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">						</span><br><span class="line">            <span class="keyword">if</span>(maxHeight != prevHeight)&#123;</span><br><span class="line">                res.add(List.of(prev,maxHeight));</span><br><span class="line">            &#125;</span><br><span class="line">            prevHeight = maxHeight;</span><br><span class="line">            prev = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后插入列表中最后一个点</span></span><br><span class="line">        res.add(List.of(boundry.get(boundry.size()-<span class="number">1</span>),<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>274. H指数 &amp; 275. H指数 II</title>
    <url>/posts/1aa2/</url>
    <content><![CDATA[<h1 id="274-h指数">274. H指数</h1>
<p>给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的
h 指数。</p>
<p>h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h
指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引用了至少 h
次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。</p>
<p>例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20
次的论文总共有 20 篇。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/h-index">https://leetcode-cn.com/problems/h-index</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力解法">暴力解法</h2>
<p>从hIndex的定义中可以看出，h指数的范围在[0,N]区间内，那么只需遍历这个区间的所有值，就可以得出最大的可行hIndex</p>
<p>取0的情况，发表的所有论文引用次数都是0</p>
<p>取N的情况，发表的所有论文引用次数都大于或等于发表论文数，例如</p>
<p>[3,3,3]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] cs)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cs.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxHIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 注意次数，遍历的是所有可行的hIndex值，而不是数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(check(cs,i))&#123;</span><br><span class="line">        maxHIndex = Math.max(maxHIndex,i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] cs,<span class="type">int</span> hIndex)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">refCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i:cs)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&gt;=hIndex)&#123;</span><br><span class="line">        <span class="comment">// 引用次数大于refCount的论文数</span></span><br><span class="line">        ++refCount;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果论文数大于hIndex数，说明满足条件，是一个可行的h指数</span></span><br><span class="line">    <span class="keyword">return</span> refCount &gt;= hIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分解法">二分解法</h1>
<p>基于上述暴力解法，可以发现实际上是满足二分查找条件的</p>
<ol type="1">
<li><p>首先二分区间是[0,N]，且为有序区间</p></li>
<li><p>设[0,N]中一个整数X不为hIndex，那么X+1也必定不是hIndex，但X-1有可能是</p></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] cs)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cs.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">      <span class="comment">// mid = (l+r-1) / 2; 采用位运算更快</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(check(cs,mid))&#123;</span><br><span class="line">        <span class="comment">// 当mid满足hIndex条件时，可以向右方搜索</span></span><br><span class="line">        l = mid;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 不满足时，向左方搜索</span></span><br><span class="line">        r = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 从定义角度检查给定的值是不是hIndex</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] cs,<span class="type">int</span> hIndex)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">refCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i:cs)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&gt;=hIndex)&#123;</span><br><span class="line">        <span class="comment">// 引用次数大于refCount的论文数</span></span><br><span class="line">        ++refCount;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果论文数大于hIndex数，说明满足条件，是一个可行的h指数</span></span><br><span class="line">    <span class="keyword">return</span> refCount &gt;= hIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序解法">排序解法</h2>
<h3 id="直接排序">直接排序</h3>
<p>首先考虑对发表的论文进行排序</p>
<p>以[3,0,6,1,5]为例，排序后为[0,1,3,5,6]</p>
<p>之后设hIndex为0，从后向前遍历hIndex</p>
<p>当有arr[i] &gt; hIndex满足hIndex定义，此时hIndex可以自增，</p>
<p>（当前hIndex标明至少有hIndex篇论文的引用次数大于hIndex，此时找到了一篇引用次数大于hIndex，说明至少是hIndex+1，此时hIndex便可以自增了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">    Arrays.sort(citations);</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; citations[i] &gt; h )&#123;</span><br><span class="line">      ++h;</span><br><span class="line">      --i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数排序">计数排序</h3>
<p>由于hIndex的取值范围在[0,N]，因此可以将所有大于N的论文的固定为N（这样并不会影响hIndex的计算），从而可以使用一个counter数组来对论文引用次数进行排序，之后再按照上述排序的选择思路确定hIndex的值即可</p>
<p>例如：[ 6,6,6,3,3,3,4,4,4,5,5,5,0,1,2,3 ]</p>
<p>其对应的counter数组：[ 1,1,1,4,3,3,3,0,0,0,0,0,0,0,0,0,0 ]</p>
<p>此时假设hIndex保持最大值为n，然后测试其是否为可行值，不行就递减然后再次进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">    <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:citations)&#123;</span><br><span class="line">      ++counter[Math.min(n,i)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从后向前遍历hIndex，不断减少hIndex，直到找到一个合适的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">      total += counter[i];</span><br><span class="line">      <span class="keyword">if</span>(total &gt;= i)&#123;</span><br><span class="line">        <span class="comment">// 最差情况就是全都是0的情况</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 作用是给出函数返回值，没有其他作用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="h指数ii">H指数II</h1>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/h-index-ii/">https://leetcode-cn.com/problems/h-index-ii/</a></p>
</blockquote>
<p>在H指数I的基础上，添加一个条件，使得输入的论文引用数为有序序列，要求给出一个O(logn)的算法</p>
<h2 id="on解法">O(n)解法</h2>
<p>回想之前对于无序情况的解法，有一种解法是先对无序的进行排序，之后再选择hIndex，那么这一题就可以省略排序，直接开始选择</p>
<p>写法一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>,i=n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; citations[i] &gt; h)&#123;</span><br><span class="line">      ++h;</span><br><span class="line">      --i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c:citations)&#123;</span><br><span class="line">      <span class="keyword">if</span>(c &gt;= n-i)&#123;</span><br><span class="line">        <span class="keyword">return</span> n-i;</span><br><span class="line">      &#125;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ologn解法">O(logn)解法</h2>
<p>看到logn复杂度，首先就应该想到二分查找，此处citations数组已经是有序的，看上去应该是可以使用二分查找了，带查找的目标就是
<span class="math display">\[
citations[i] &gt;= n-i
\]</span>
满足上述公式的i了，其中n-i表示发表论文引用数大于第i篇论文的论文数，而citations[i]表示第i篇论文的引用数，当引用数大于等于论文篇数的时候，说明此时n-i就是一个满足hIndex定义的值，接下来要做的就是使用二分查找尽快找到这个值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hIndex</span><span class="params">(<span class="type">int</span>[] citations)</span> &#123;</span><br><span class="line">        <span class="comment">// 由于citations是有序的，可以进行二分查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> citations.length;</span><br><span class="line">      	<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(citations[mid] == n - mid)&#123;</span><br><span class="line">                <span class="keyword">return</span> n - mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(citations[mid] &lt; n - mid)&#123;</span><br><span class="line">                <span class="comment">// 说明mid是符合hIndex定义的，继续寻找更好的</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>300. 最长递增子序列</title>
    <url>/posts/ee44/</url>
    <content><![CDATA[<h1 id="300-最长递增子序列">300. 最长递增子序列</h1>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7]
是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>这一题是很经典的动态规划题</p>
<p>使用dp[i]表示在位置i时的最长递增子序列值，初始时dp[i]值为1（因为至少子序列可以包含自身，即长度为1），然后更新时，需要遍历所有的小于nums[j]的，如果nums[i]小于nums[j]，说明可以继续组成递增子序列，之后便可以求出当前下标最大的递增子序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法的时间复杂度为o(n^2)，空间复杂度为o(n)，其实还可以进一步优化</p>
<h2 id="贪心二分查找">贪心+二分查找</h2>
<p>从动态规划的执行过程中可以看到，其中计算每一个dp[i]所需的o(n)是无法忽略的，但是更新dp[i]的过程实际上遍历了dp[i]前面的所有值，这一部分时间复杂度为o(n)，如果可以将这一部分优化至o(logn)，这样整个算法的时间复杂度就可以降为o(nlogn)</p>
<p>定义一个新的状态变量tail[i]，其存储了长度为i的递增序列末尾值，且需要保持该值最小，且tail数组一定是递增的</p>
<blockquote>
<p>tail数组递增证明（反证法）：</p>
<p>假设长度为i的递增序列末尾值为b，即tail[i] = b，假设此时tail[i-1] =
a，且有a&gt;b，对于长度为i且末尾值为b的那一个子序列subArr，则一定有</p>
<p>subArr[i-1] &lt; b &lt;
a，那么此时以a结尾的长度为i-1的递增子序列就不是末尾值最小的（因为subArr[i-1]
&lt; a，这个子序列才是），同tail[i-1]的定义矛盾</p>
<p>因此tail数组一定是递增的，那么可以使用二分查找来更新tail数组的值，且tail数组的长度就是最长递增子序列的长度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>, n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 长度为1的递增子序列末尾值</span></span><br><span class="line">        d[len] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; d[len]) &#123;</span><br><span class="line">                <span class="comment">// 找到了长度更长的子序列</span></span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 二分查找更新值，lower_bound</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = len, pos = <span class="number">0</span>; </span><br><span class="line">                <span class="comment">// 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span></span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        r = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + <span class="number">1</span>] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="变种1713-得到子序列的最少操作数">变种：1713.
得到子序列的最少操作数</h1>
<p>给你一个数组 target ，包含若干 <strong>互不相同</strong>
的整数，以及另一个整数数组 arr ，arr <strong>可能</strong>
包含重复元素。</p>
<p>每一次操作中，你可以在 arr 的任意位置插入任一整数。比方说，如果 arr =
[1,4,1,2] ，那么你可以在中间添加 3 得到 [1,4,3,1,2]
。你可以在数组最开始或最后面添加整数。</p>
<p>请你返回 <strong>最少</strong> 操作次数，使得 target 成为 arr
的一个子序列。</p>
<p>一个数组的 <strong>子序列</strong>
指的是删除原数组的某些元素（可能一个元素都不删除），同时不改变其余元素的相对顺序得到的数组。比方说，[2,7,4]
是 [4,2,3,7,2,1,4] 的子序列（加粗元素），但 [2,4,2] 不是子序列。</p>
<blockquote>
<p>来源：力扣（LeetCode） 链接：<a
href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence">https://leetcode-cn.com/problems/minimum-operations-to-make-a-subsequence</a>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="题目理解">题目理解</h2>
<p>向arr中插入整数，使得target成为arr的子序列，返回所需最少的操作数</p>
<p>target [6,4,8,1,3,2]</p>
<p>arr [4,7,6,2,3,8,6,1]</p>
<p>arr -&gt; [4,7,6,2,3,4,8,6,1,3,2]，插入了4、3、2</p>
<p>可以理解为找到arr和target的最长公共子序列，然后将最长公共子序列填充至target就是所需最少操作次数</p>
<p>那么现在问题在于，如何寻找target和arr的最长公共子序列？</p>
<h2 id="最长公共子序列动态规划">最长公共子序列（动态规划）</h2>
<p>寻找最长公共子序列也是一类经典的动态规划题，用一个二维数组存储状态，dp[i,j]表示串A长度为i时和串B长度为j时的最长公共子序列</p>
<p>状态更新方程</p>
<p>dp[i,j] = dp[i-1,j-1] if A[i] == B[j]</p>
<p>dp[i,j] = max(dp[i-1,j],dp[i,j-1]) if A[i] != B[j]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] target, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> target.length,n=arr.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(target[i-<span class="number">1</span>] == arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target.length - dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法时间复杂度为o(mn)，空间复杂度为o(mn)，由于本题数组长度较大，使用动态规划会超时，同时也开不出那么大的数组</p>
<h2 id="最长递增子序列贪心二分查找">最长递增子序列（贪心+二分查找）</h2>
<p>根据官方提示2&amp;3：由于target数组不包含重复数字，可以把target理解成这些数字的一个排列，然后将arr中这些数字出现的位置替换成这些数字在target中的下标，由于下标是有序的，那么只需要在arr中找到一个最长递增子序列即可，计算出最长公共子序列长度，然后得出最小操作数</p>
<p>【这波替换下标转换成最长递增子序列真的绝了，难怪题设给了一个target数组不包含重复数字】</p>
<p>之后就按照最长递增子序列求解方式求即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] target, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 建立target中数字和下标的映射关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;target.length;++i)&#123;</span><br><span class="line">            map.put(target[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; newArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 将arr中数字替换成下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(arr[i]))&#123;</span><br><span class="line">                newArr.add(map.get(arr[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二者没有重复的部分，说明需要全部填充</span></span><br><span class="line">        <span class="keyword">if</span>(newArr.size() == <span class="number">0</span>) <span class="keyword">return</span> target.length;</span><br><span class="line">        <span class="comment">// 查找最长递增子序列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> newArr.size(),len=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] tail = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        tail[len] = newArr.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">// 子序列长度+1情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">targetVal</span> <span class="operator">=</span> newArr.get(i);</span><br><span class="line">            <span class="keyword">if</span>(targetVal &gt; tail[len])&#123;</span><br><span class="line">                tail[++len] = targetVal;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 当前值比末尾值还小，需要进行更新，开始二分查找</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>,r = len;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(tail[mid] &lt; targetVal)&#123;</span><br><span class="line">                        l = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        r = mid;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tail[l] = targetVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target.length - len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>671. 二叉树中第二小的节点</title>
    <url>/posts/16f7/</url>
    <content><![CDATA[<h1 id="671-二叉树中第二小的节点">671. 二叉树中第二小的节点</h1>
<p>给定一个非空特殊的二叉树，每个节点都是正数，并且<strong>每个节点的子节点数量只能为
2 或
0</strong>。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>
<p>更正式地说，<strong>root.val = min(root.left.val,
root.right.val)</strong> 总成立。</p>
<p>给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出
-1 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree">https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>如果用暴力，那这个题没什么好说的，节点数也不多，就25个，只需要把所有节点的值都给弄出来，找到第二个就行，稍微用优先队列优化一下</p>
<p>但是这个解法肯定面试的时候不行，没有用到题设的关键信息</p>
<ol type="1">
<li>每个节点的子节点数为0或2</li>
<li>root.val = min(root.left.val,root.right.val)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 由于root.val = min(root.left.val,root.right.vaål)</span></span><br><span class="line">        <span class="comment">// 且每个节点的子节点数量只能为2或0</span></span><br><span class="line">        <span class="comment">// 首先找到最左端的？</span></span><br><span class="line">        <span class="comment">// 最简单的，直接把所有节点的值都给搞出来</span></span><br><span class="line">        <span class="comment">// 稍微蠢一点的办法，遍历了之后用优先队列存着，但是这样的解法属于暴力</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a-b);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            pq.offer(curr.val);</span><br><span class="line">            <span class="keyword">if</span>(curr.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(curr.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(curr.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> pq.peek();</span><br><span class="line">        pq.poll();</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty() &amp;&amp; val == pq.peek())&#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pq.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正经解法">正经解法</h2>
<p>从题设条件中可知，父节点的值是两个子节点值中的较小值，且每个节点的子节点数为2或0，那么根节点一定是最小值，要找到第二小的值，只需要找到第一个和根节点不同的值就行</p>
<h3 id="bfs">BFS</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootVal;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.left == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果最小值就是Integer.MAX_VALUE，那真是绝了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// System.out.println(res);</span></span><br><span class="line">            <span class="comment">// 找到值不等于root.val的，实际上是肯定大于root.val的</span></span><br><span class="line">            <span class="keyword">if</span>(curr.val != root.val)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 在候选结果中找最小的就是第二小的值</span></span><br><span class="line">                res =  res == -<span class="number">1</span> ? curr.val : Math.min(curr.val,res);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 由于该二叉树的子节点数要么为0要么为2</span></span><br><span class="line">                queue.offer(curr.left);</span><br><span class="line">                queue.offer(curr.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归dfs">递归（dfs）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> rootVal;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root.left == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到两颗子树的最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftTreeMinVal</span> <span class="operator">=</span> root.val == root.left.val ? findSecondMinimumValue(root.left) : root.left.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightTreeMinVal</span> <span class="operator">=</span> root.val == root.right.val ? findSecondMinimumValue(root.right) : root.right.val;</span><br><span class="line">        <span class="comment">// 当有一个为-1的时候说明这一课树上的值都一样，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(leftTreeMinVal,rightTreeMinVal);</span><br><span class="line">        <span class="keyword">return</span> min &gt; <span class="number">0</span> ? min : Math.max(leftTreeMinVal,rightTreeMinVal);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>863. 二叉树中所有距离为K的结点</title>
    <url>/posts/b96b/</url>
    <content><![CDATA[<h1 id="863-二叉树中所有距离为k的结点">863.
二叉树中所有距离为K的结点</h1>
<p>给定一个二叉树（具有根结点 root）， 一个目标结点 target
，和一个整数值 K 。</p>
<p>返回到目标结点 target 距离为 K 的所有结点的值的列表。
答案可以以任何顺序返回。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree">https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree</a></p>
</blockquote>
<span id="more"></span>

<h2 id="dfs">dfs</h2>
<p>题目要求找到所有距离目标结点k的所有节点</p>
<p><img data-src="863.%20二叉树中所有距离为K的结点/binary-tree-distance.png"
style="zoom:50%;" /></p>
<p>如上图所示，目标结点为4，需要找到距离它3的所有节点</p>
<p>首先需要找到根节点到目标结点上的路径，之后寻找路径各个结点到距离为k-i的所有节点（但是不用进行重复搜索）这样就可以找到所有距离它为distance节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res;</span><br><span class="line">    List&lt;TreeNode&gt; path;</span><br><span class="line">    Map&lt;TreeNode,Boolean&gt; visitied;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先再怎么样还是需要先找到target所在的节点吧？</span></span><br><span class="line">        <span class="comment">// 同时计算根节点到target的距离m，找到所有距离根节点为k-m的节点？此处好像会出现重复？那要怎么办？</span></span><br><span class="line">        <span class="comment">// 然后以target为根节点，找到所有距离为k的</span></span><br><span class="line">        <span class="comment">// 一种比较蠢的办法就是遍历所有节点，计算target和节点之间的距离，之后选出距离为k的即可</span></span><br><span class="line">        <span class="comment">// System.out.println(distance(root,target));</span></span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        visitied = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// dfs(target,2,0);</span></span><br><span class="line">        <span class="comment">// 首先计算出</span></span><br><span class="line">        getPath(root,target);</span><br><span class="line">        <span class="comment">// printPath();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size();++i)&#123;</span><br><span class="line">            dfs(path.get(i),k-i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printPath</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(TreeNode node :path)&#123;</span><br><span class="line">            sb.append(node.val).append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算两个节点之间的距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">getPath</span><span class="params">(TreeNode root,TreeNode target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == target || getPath(root.left,target) || getPath(root.right,target))&#123;</span><br><span class="line">            path.add(root);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs，查找距离当前节点为distance的所有节点，必须要求是以target节点之内的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> distance,<span class="type">int</span> curr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || visitied.getOrDefault(root,<span class="literal">false</span>)) <span class="keyword">return</span>;</span><br><span class="line">        visitied.put(root,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(curr == distance)&#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,distance,<span class="number">1</span>+curr);</span><br><span class="line">        dfs(root.right,distance,<span class="number">1</span>+curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>987. 二叉树的垂序遍历</title>
    <url>/posts/14f9/</url>
    <content><![CDATA[<h1 id="987-二叉树的垂序遍历">987. 二叉树的垂序遍历</h1>
<p>给你二叉树的根结点 root ，请你设计算法计算二叉树的
<strong>垂序遍历</strong> 序列。</p>
<p>对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col
- 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。</p>
<p>二叉树的 <strong>垂序遍历</strong>
从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。</p>
<p>返回二叉树的 <strong>垂序遍历</strong> 序列。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree">https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree</a></p>
</blockquote>
<span id="more"></span>

<h2 id="模拟treemap">模拟（TreeMap）</h2>
<p>解题的关键在题目中已经告知了</p>
<blockquote>
<p>对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col
- 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。</p>
</blockquote>
<p>只需要使用Map存储对应row和col上的节点值，最后将其输出成二维数组形式即可</p>
<p>注：采用row/col作为键，最好使用TreeMap来确保有序性，使用HashMap还需要对Key进行排序，非常麻烦</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Map&lt;Integer,List&lt;Integer&gt;&gt;&gt; map;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">verticalTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 对于位于(row,col)的每个节点，其左右子节点分别位于(row+1,col-1)和(row+1,col+1)，树的根节点位于(0,0)</span></span><br><span class="line">        <span class="comment">// 为确保键的有序性，必须使用TreeMap，此处的索引为row和col，都是有序的，因此使用TreeMap会比HashMap更好</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        traverse(root,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// System.out.println(map);</span></span><br><span class="line">        <span class="keyword">for</span>(Map&lt;Integer,List&lt;Integer&gt;&gt; col:map.values())&#123;</span><br><span class="line">            List&lt;Integer&gt; r = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(List&lt;Integer&gt; l:col.values())&#123;</span><br><span class="line">                <span class="comment">// 对于同一个位置的进行排序</span></span><br><span class="line">                Collections.sort(l);</span><br><span class="line">                r.addAll(l);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对key进行排序</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; column = map.getOrDefault(col,<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 之前的顺序都需要保留，只有可能同一行出现重复，也就是其前面一个值，需要比较一下</span></span><br><span class="line">        List&lt;Integer&gt; currRow = column.getOrDefault(row,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="comment">// 实际上可以使用插入排序？</span></span><br><span class="line">        currRow.add(root.val);</span><br><span class="line">        column.put(row,currRow);</span><br><span class="line">        map.put(col,column);</span><br><span class="line">        traverse(root.left,row+<span class="number">1</span>,col-<span class="number">1</span>);</span><br><span class="line">        traverse(root.right,row+<span class="number">1</span>,col+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义排序">自定义排序</h2>
<p>实际上没有必要使用Map来存储（大材小用），只需要保存每个节点的三个关键信息值(row,col,val)，之后再定义排序信息</p>
<p>以 [1,2,3,4,5,6,7] 为例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">各个节点对应信息      垂序遍历结果</span><br><span class="line">(0,0,1)            (2,-2,4)</span><br><span class="line">(1,-1,2)           (1,-1,2)</span><br><span class="line">(1,1,3)            (0,0,1)</span><br><span class="line">(2,-2,4)      --&gt;  (2,0,5)</span><br><span class="line">(2,0,5)            (2,0,6)</span><br><span class="line">(2,0,6)            (1,1,3)</span><br><span class="line">(2,2,7)            (2,2,7)</span><br></pre></td></tr></table></figure>

<p>从上面这个例子可以找到规律，首先按照col大小升序排列，之后再按照row的大小升序，最后同一位置的按照val大小升序，因此首先计算出各个节点的三个信息值保存在List中再进行排序即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; info;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minCol</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">verticalTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        info = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        traverse(root,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// lambda表达式实现自定义比较函数</span></span><br><span class="line">        Collections.sort(info,(a,b)-&gt;a[<span class="number">1</span>] == b[<span class="number">1</span>] ? </span><br><span class="line">                              (a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">2</span>] - b[<span class="number">2</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>]) </span><br><span class="line">                              : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">currCol</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] i:info)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i[<span class="number">1</span>] != currCol)&#123;</span><br><span class="line">                currCol = i[<span class="number">1</span>];</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                ++size;</span><br><span class="line">            &#125;</span><br><span class="line">            res.get(size-<span class="number">1</span>).add(i[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root,<span class="type">int</span> row,<span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        minCol = Math.min(col,minCol);</span><br><span class="line">        info.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;row,col,root.val&#125;);</span><br><span class="line">        traverse(root.left,row+<span class="number">1</span>,col-<span class="number">1</span>);</span><br><span class="line">        traverse(root.right,row+<span class="number">1</span>,col+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LCP 07. 传递信息</title>
    <url>/posts/1a91/</url>
    <content><![CDATA[<h1 id="lcp-07-传递信息">LCP 07. 传递信息</h1>
<p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p>
<p>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如
A 可以向 B 传信息，但 B 不能向 A 传信息）。
每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数
n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组
relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1
的小伙伴处的方案数；若不能到达，返回 0。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/chuan-di-xin-xi">https://leetcode-cn.com/problems/chuan-di-xin-xi</a></p>
</blockquote>
<span id="more"></span>

<h2 id="dfs">DFS</h2>
<p>经典图论题，没什么好说的，直接暴力，遍历所有可行的路径然后开始走，同时记录步数，当步数等于k且终止节点是n-1时将结果加1，最后返回总个数就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res,k,n;</span><br><span class="line">    Map&lt;Integer,List&lt;Integer&gt;&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] relation, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] r:relation)&#123;</span><br><span class="line">            List&lt;Integer&gt; l = map.getOrDefault(r[<span class="number">0</span>],<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            l.add(r[<span class="number">1</span>]);</span><br><span class="line">            map.put(r[<span class="number">0</span>],l);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> step)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(step == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node == n-<span class="number">1</span>)&#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v:map.getOrDefault(node,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()))&#123;</span><br><span class="line">            dfs(v,step+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bfs">BFS</h2>
<p>可以用dfs，那么bfs也同样适用，思路和dfs一致，使用队列进行，同时注意记录当前step数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] relation, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] r:relation)&#123;</span><br><span class="line">            List&lt;Integer&gt; l = map.getOrDefault(r[<span class="number">0</span>],<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            l.add(r[<span class="number">1</span>]);</span><br><span class="line">            map.put(r[<span class="number">0</span>],l);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">// queue的前size个元素是当前层的，剩下的都是下一层新增加的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;++j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">currNode</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v:map.getOrDefault(currNode,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()))&#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.poll() == n-<span class="number">1</span>)&#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后统计里面有多少个是4就行了</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划">动态规划</h2>
<p>除了暴力之外，这个题还可以使用动态规划来做，使用dp[i,j]存储第i步时可到达结点j的方案数，初始条件dp[0,0]为1，之后遍历所有边数，状态转移方程：
<span class="math display">\[
dp[i,j] = dp[i,j] + \sum ^{n} _{k=1} dp[i-1,k]
\]</span> 其中k为所有可达j的结点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] relation, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 图论问题+动态规划</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>][n];</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] r:relation)&#123;</span><br><span class="line">            <span class="comment">// 存储能到达该节点的所有节点</span></span><br><span class="line">            List&lt;Integer&gt; l = map.getOrDefault(r[<span class="number">1</span>],<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            l.add(r[<span class="number">0</span>]);</span><br><span class="line">            map.put(r[<span class="number">1</span>],l);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 输出临接表</span></span><br><span class="line">        <span class="comment">// System.out.println(map);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;++i)&#123;</span><br><span class="line">            <span class="comment">// dp[i][j]代表第i步到达节点j的次数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v:map.getOrDefault(j,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()))&#123;</span><br><span class="line">                    dp[i][j] += dp[i-<span class="number">1</span>][v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划优化状态压缩">动态规划优化（状态压缩）</h2>
<p>从状态转移方程中可以很明显的发现，dp[i,j]仅与前一个状态dp[i-1,k]有关，因此可以只使用一个一维数组进行更新，从而节省空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] relation, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 图论问题+动态规划</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Map&lt;Integer,List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] r:relation)&#123;</span><br><span class="line">            <span class="comment">// 存储能到达该节点的所有节点</span></span><br><span class="line">            List&lt;Integer&gt; l = map.getOrDefault(r[<span class="number">1</span>],<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            l.add(r[<span class="number">0</span>]);</span><br><span class="line">            map.put(r[<span class="number">1</span>],l);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 输出临接表</span></span><br><span class="line">        <span class="comment">// System.out.println(map);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">            <span class="comment">// dp[i][j]代表第i步到达节点j的次数</span></span><br><span class="line">          	<span class="comment">// 由于在更新的时候会使用原来的dp数组，因此遍历边的过程中不能改变原有的dp数组，需要新建一个数组来存储更新值，这个地方需要额外注意</span></span><br><span class="line">            <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> v:map.getOrDefault(j,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()))&#123;</span><br><span class="line">                    next[j] += dp[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后记">后记</h2>
<p>这一题很经典，包含了图论和动态规划，但LeetCode将其难度划为简单，也说明这个题是程序员的基本功，需要掌握扎实</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <url>/posts/c7a8/</url>
    <content><![CDATA[<h1 id="剑指-offer-03-数组中重复的数字">剑指 Offer 03.
数组中重复的数字</h1>
<p>找出数组中重复的数字。</p>
<p><strong>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1
的范围内</strong>。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="hashset">HashSet</h2>
<p>这题很简单，也没什么好说的，使用set存储元素，每碰到一个新元素就判断其是否在set中出现过，如果没有就加入，出现过就可以直接返回了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法时间复杂度o(n)，空间复杂度o(n)</p>
<h2 id="索引">索引</h2>
<p>使用set解决该问题时，实际上并没有使用上述的一个条件，"长度为n的数组nums里的所有数字都在0～n-1范围内"</p>
<p>这个条件说明，nums数组中的数的索引和数字实际上可以做到一一对应，如果发现有重复的，直接返回即可【这个思路还挺好的，把题设条件都用到了】</p>
<p>[2,3,1,0,2,5,3]</p>
<p>iter1:</p>
<p>swap(nums[0],nums[nums[0]])</p>
<p>[1,3,2,0,2,5,3]</p>
<p>iter2:</p>
<p>swap(nums[0],nums[nums[0]])</p>
<p>[3,1,2,0,2,5,3]</p>
<p>iter3:</p>
<p>swap(nums[0],nums[nums[0]])</p>
<p>[0,1,2,3,2,5,3]</p>
<p>iter4:</p>
<p>nums[0] == 0</p>
<p>i = 1</p>
<p>iter5:</p>
<p>nums[1] = 1</p>
<p>i = 2</p>
<p>iter6:</p>
<p>nums[2] = 2</p>
<p>i = 3</p>
<p>iter6:</p>
<p>nums[3] = 3</p>
<p>i = 4</p>
<p>iter7:</p>
<p>nums[4] = 2</p>
<p>nums[2] = 2</p>
<p>collision -&gt; 2 is redundant</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]] == nums[i]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            nums[i] = nums[tmp];</span><br><span class="line">            nums[tmp] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <url>/posts/adae/</url>
    <content><![CDATA[<h1 id="剑指-offer-04-二维数组中的查找">剑指 Offer 04.
二维数组中的查找</h1>
<p>在一个 n * m
的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>没什么好说的，就嗯搜呗，遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">      	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      	<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找">二分查找</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 每一行从左到右都是递增，每列从上至下递增</span></span><br><span class="line">        <span class="comment">// o(nlogn)吧</span></span><br><span class="line">        <span class="comment">// 直接每行做一次二分查找</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isIn</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            isIn = isIn || binarySearch(matrix[i],target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isIn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> ||target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length-<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r=nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度o(m*logn)</p>
<h2 id="暴力优化">暴力优化</h2>
<p>由于matrix从左至右有序，从上至下有序，可以从matrix的右上角开始搜索，当前值小于target值时，就只能向下走，因为当前值左边的都是小于target值的，当前值大于target值时，就只能向左走，因为当前值下方的都是大于target值的【实在是太巧妙了】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">      	<span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      	<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">      	<span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="number">0</span>,startY = m - <span class="number">1</span>;</span><br><span class="line">      	<span class="keyword">while</span>(startX &lt; n &amp;&amp; startY &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[startX][startY] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[startX][startY] &gt; target) --startY;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[startX][startY] &lt; target) ++startX;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度o(m+n)</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 14-I. 剪绳子 &amp; II. 剪绳子II</title>
    <url>/posts/904c/</url>
    <content><![CDATA[<h1 id="剑指-offer-14-i-剪绳子">剑指 Offer 14-I. 剪绳子</h1>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m
段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为
k[0],k[1]...k[m-1] 。请问 k[0]<em>k[1]</em>...*k[m-1]
可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划二维dp">动态规划（二维DP）</h2>
<p>看到这个题，有长度和分段数，首先想到用dp[i,j]来表示长度为i时分段数为j时的最优解，初态
dp[i,1] = i，状态转移方程 <span class="math display">\[
dp[i,j] = max(dp[i,j],dp[k,j-1]*(i-k))
\]</span> 其中k取值范围为[1,i)</p>
<p>最终最佳划分值为max(dp[n,i])，长度为n的所有划分情况下的最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=i;++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;i;++k)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j],dp[k][j-<span class="number">1</span>] * (i-k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            res = Math.max(res,dp[n][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^3)</p>
<p>空间复杂度：o(n^2)</p>
<h2 id="动态规划一维dp">动态规划（一维DP）</h2>
<p>这个题采用二维动态规划有些浪费，实际上可以使用一维动态规划实现，使用dp[i]代表长度为i的绳子进行划分为m段时的最大值，且dp[1]
= 1，状态转移方程 <span class="math display">\[
dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))
\]</span> 理解起来也很简单，对于一段长度为i的绳子，有三种操作方式</p>
<ol type="1">
<li>不进行划分</li>
<li>划分成j之后不再进行划分</li>
<li>划分成j之后继续进行划分（此时便将问题规模缩小，且之前已经求解过了）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;++j)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^2)</p>
<p>空间复杂度：o(n)</p>
<h2 id="数学">数学</h2>
<p>由算术几何均值不等式可知， <span class="math display">\[
\frac{n_1+n_2+...+n_a}{a} \ge \sqrt[a]{n_1n_2...n_a}
\]</span>
当n1...na相等时取得等号，因此划分时应尽可能保持划分的长度相同</p>
<p>假设划分成a分，则有 <span class="math display">\[
n = ax
\]</span> 且乘积为 <span class="math display">\[
y = x^a = x^{\frac{n}{x}}=(x^{\frac{1}{x}})^n
\]</span> 由于n为常数，要使乘积最大即求函数 <span
class="math display">\[
y=x^{\frac{1}{x}}
\]</span>
的极大值，这个函数高数中也介绍过，很经典，其极大值在x=e处取的，且由于要求划分的长度为整数，可得当x=3时y更大
<span class="math display">\[
3^{\frac{1}{3}} &gt; 2^{\frac{1}{2}}
\]</span> 则需要尽可能将切割的长度保持3，此时考虑划分方式</p>
<p>对于长度为i的绳子，其对3取余</p>
<ul>
<li>0时说明刚好整除，3^(i/3)即为最大值</li>
<li>1时说明最后一个划分长度为1，当i为4时最优划分不是（3+1）而是（2+2），因此只需要拿出一个3和最后剩下的1组合成4，使最后的结果最大，结果为3^(i/3-1)*4</li>
<li>2时就是3^(i/3)*2</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> n % <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> d == <span class="number">0</span> ? (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a) </span><br><span class="line">                      : (d == <span class="number">1</span> ? (<span class="type">int</span>)(Math.pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">4</span>) </span><br><span class="line">                                : (<span class="type">int</span>)(Math.pow(<span class="number">3</span>,a)*<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指-offer-14-ii-剪绳子ii">剑指 Offer 14-II. 剪绳子II</h1>
<p>这一题的题目并没有发生变化，只是数据规模变大，且还需要对1e9+7取模，直接使用max也无法比较大小了（意味着DP无法使用，或者使用BigInteger，但是写起来比较麻烦），且由于最大n可到1000，需要计算3^300的幂，计算过程中需要对幂次取余</p>
<p>幂次求余有两种方式</p>
<ul>
<li>循环取余法o(n)</li>
<li>快速幂取余法o(logn)</li>
</ul>
<h2 id="循环取余">循环取余</h2>
<p><span class="math display">\[
(a*b)\% c = ((a \% c) * (b \% c))\%c
\]</span></p>
<p>例如：(12*15)%3 =((12%3)*(15%3))%3=2</p>
<p>因此，对于x^n，可以在循环过程中不断计算x^1、x^2、...、x^n的余数 <span
class="math display">\[
x^n \% c = ((x^{n-1} \% c) *(x \% c)) \% c
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    res = (res * v) % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂取余">快速幂取余</h2>
<p><span class="math display">\[
x^n \% c = (x^{2})^{\frac{a}{2}} \% c = ((x^2\%c)^{\frac{a}{2}})\%c
\]</span></p>
<p>因此可以在一次循环中将运算降至n//2，最终只需要循环log(n)次即可，可以在o(logn)时间复杂度下成幂次取余运算</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/307759581">快速幂求余 - 知乎
(zhihu.com)</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">myPow</span><span class="params">(<span class="type">long</span> base, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((num &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">      res = res * base % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意此处一定是 base = base * base % mod;</span></span><br><span class="line">    <span class="comment">// 因为当num为偶数的时候</span></span><br><span class="line">    <span class="comment">// x^11 = x^10 * x = (x^2)^5*x</span></span><br><span class="line">    base = base * base % mod;</span><br><span class="line">    num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 38. 字符串的排列</title>
    <url>/posts/2fdd/</url>
    <content><![CDATA[<h1 id="剑指-offer-38-字符串的排列">剑指 Offer 38. 字符串的排列</h1>
<p>题意：</p>
<p>输入一个字符串，打印出该字符串中字符的所有排列。</p>
<p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p>
<p>思路：</p>
<p>这题是个很常规的题目，面试时也会经常问道，对于排列组合类的题目，首先想到的思路就是DFS，通过回溯找到所有的解。这一题除了输出所有的排列外，还给出了一个新的要求，不能包含重复元素</p>
<span id="more"></span>

<p>例如输入<code>aab</code>，三位的全排列应该是6个，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a1 a2 b</span><br><span class="line">a1 b a2</span><br><span class="line">a2 a1 b</span><br><span class="line">a2 b a1</span><br><span class="line">b a1 a2</span><br><span class="line">b a2 a1</span><br></pre></td></tr></table></figure>

<p>但由于此时字符串中a1和a2是相同字符，因此去除重复元素之后仅包含三种排列，即</p>
<p>![search-tree](剑指 Offer 38.
字符串的排列/search-tree-8999807.jpg)</p>
<p>aab</p>
<p>aba</p>
<p>baa</p>
<p>因此这题的思路也非常清晰了，下面给出两种解法</p>
<p>思路1：</p>
<p>找出包含重复的全部排列，再使用Set进行去重</p>
<p>思路2：</p>
<p>在查找时进行剪枝，不进行重复的搜索</p>
<p>常规的全排列算法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(StringBuilder sb,String s,List&lt;String&gt; res,<span class="type">boolean</span>[] visited,<span class="type">int</span> n,<span class="type">int</span> p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == n)&#123;</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">			sb.append(s.charAt(j));</span><br><span class="line">            visited[j] = <span class="literal">true</span>;</span><br><span class="line">            dfs(sb,s,res,visited,n,p+<span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(s.length()-<span class="number">1</span>);</span><br><span class="line">            visited[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可绘制搜索树如下：</p>
<p><img data-src="剑指%20Offer%2038.%20字符串的排列/search-tree.jpg" /></p>
<p>对于解法1而言，只需要将存储结果的List转换成Set，就可以实现去重，但是算法本身会进行很多重复搜索，从而降低算法效率，使用Set只是治标不治本</p>
<p>解法一代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(StringBuilder sb,String s,Set&lt;String&gt; res,<span class="type">boolean</span>[] visited,<span class="type">int</span> n,<span class="type">int</span> p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == n)&#123;</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[j])&#123;</span><br><span class="line">			sb.append(s.charAt(j));</span><br><span class="line">            visited[j] = <span class="literal">true</span>;</span><br><span class="line">            dfs(sb,s,res,visited,n,p+<span class="number">1</span>);</span><br><span class="line">            sb.deleteCharAt(s.length()-<span class="number">1</span>);</span><br><span class="line">            visited[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从搜索树中可以看到，只要字符串中存在相同的字符，就一定会进行重复搜索，因此需要剪枝</p>
<p>解法二代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 还需要提前对s进行排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(StringBuilder sb,String s,List&lt;String&gt; res,<span class="type">boolean</span>[] visited,<span class="type">int</span> n,<span class="type">int</span> p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == n)&#123;</span><br><span class="line">        res.add(sb.toString());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[j] || (j&gt;<span class="number">0</span> &amp;&amp; !visited[j-<span class="number">1</span>] &amp;&amp; s.charAt(j-<span class="number">1</span>) == s.charAt(j)))&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(s.charAt(j));</span><br><span class="line">        visited[j] = <span class="literal">true</span>;</span><br><span class="line">        dfs(sb,s,res,visited,n,p+<span class="number">1</span>);</span><br><span class="line">        sb.deleteCharAt(s.length()-<span class="number">1</span>);</span><br><span class="line">        visited[j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剪枝代码：<code>visited[j] || (j&gt;0 &amp;&amp; !visited[j-1] &amp;&amp; s.charAt(j-1) == s.charAt(j))</code></p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 42. 连续子数组的最大和</title>
    <url>/posts/a314/</url>
    <content><![CDATA[<h1 id="剑指-offer-42-连续子数组的最大和">剑指 Offer 42.
连续子数组的最大和</h1>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力解法超时">暴力解法（超时）</h2>
<p>首先考虑暴力吧，自数组就是数组一个子区间内所有数组的和，这样只需要遍历所有的子数组的和，求其最大即可，首先需要计算前缀和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] sums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            sums[i] = nums[i] + sums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于arr.length是10^5，如果使用暴力应该是会超时的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> sums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            maxSum = Math.max(maxSum,sums[i]);</span><br><span class="line">            <span class="comment">// j一定是大于i的哈</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                maxSum = Math.max(maxSum,sums[j]-sums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划">动态规划</h2>
<p>考虑动态规划的三个满足条件：</p>
<ol type="1">
<li>重叠子问题</li>
<li>最优子结构</li>
<li>无后效性</li>
</ol>
<p>观察这个问题</p>
<p>所有的子序列和都满足 <span class="math display">\[
sums[i,j] = sums[i,j-1] + nums[j]
\]</span>
本题目标是求解最大子序列和，，用<code>dp[i,j]</code>代表最大子序列和，则一定有
<span class="math display">\[
dp[i,j] = max(dp[i,j-1]+nums[j],nums[j])
\]</span> 考虑数组[-2,1,-3,4,-1,2,1,-5,4]</p>
<p>首先考虑维优化空间的时候，状态存储为</p>
<p><code>int[][] dp = new int[n][n]</code></p>
<p><code>dp[0][0] = nums[0]</code></p>
<p>之后不断遍历，填入dp可得</p>
<table>
<thead>
<tr class="header">
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-2</td>
<td>1</td>
<td>-2</td>
<td>4</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>1</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>本来需要o(n^2)的空间，但是由于dp[i,j]仅与其前一个dp[i,j-1]有关，因此可以将其降维成o(1)，只使用一个值pre保存dp[i,j-1]的值，并在遍历的过程中将新的dp[i,j]更新至dp[i,j-1]上即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">dpIJ</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;</span><br><span class="line">            dpIJ = Math.max(dpIJ+i,i);</span><br><span class="line">            res = Math.max(dpIJ,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
    <url>/posts/f7a3/</url>
    <content><![CDATA[<h1 id="剑指-offer-52-两个链表的第一个公共节点">剑指 Offer 52.
两个链表的第一个公共节点</h1>
<p>输入两个链表，找出它们的第一个公共节点</p>
<span id="more"></span>

<h2 id="哈希集合解法">哈希集合解法</h2>
<p>首先比较简单的解法就是遍历一遍A和B，统计其中节点出现的次数，第一个发现出现过的节点就是公共节点了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">// 思路一：统计每个Node出现的次数，如果遍历过程中发现有一个节点已经出现过了，说明重复，该节点就是重复节点</span></span><br><span class="line">        Map&lt;ListNode,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA,b=headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="literal">null</span>)&#123;</span><br><span class="line">            map.put(a,map.getOrDefault(a,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            a = a.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(b,<span class="number">0</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> b;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(b,map.getOrDefault(b,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍微优化一点的就是使用集合(set)而不是映射（map）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA,b=headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="literal">null</span>)&#123;</span><br><span class="line">            set.add(a);</span><br><span class="line">            a = a.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(b))&#123;</span><br><span class="line">                <span class="keyword">return</span> b;</span><br><span class="line">            &#125;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用哈希计数的方式时间复杂度为o(m+n)，空间复杂度也为o(m+n)，其实还有空间复杂度为o(1)的算法</p>
<h2 id="双指针">双指针</h2>
<p>假设两个链表l1和l2，不妨设l1的长度大于l2，在遍历的过程</p>
<p>例如</p>
<p>​ 4-&gt;1</p>
<p>​ -&gt;8-&gt;4-&gt;5</p>
<p>5-&gt;0-&gt;1</p>
<p>可以发现l1的长度是小于l2，此时使用双指针分别指向l1和l2的开始，二者同步运行，那么必定有一个会预先到达null，此时先到的说明已经遍历完短边，再切换成长边时两个指针就会有一个速度差，此时二者一定会相遇，就可以找到相交的部分（因为两个指针走过的距离是一致的）</p>
<p>l1的指针路径</p>
<p>4-&gt;1-&gt;8-&gt;4-&gt;5-&gt;5-&gt;0-&gt;1-&gt;8-&gt;4-&gt;5</p>
<p>l2的指针路径</p>
<p>5-&gt;0-&gt;1-&gt;8-&gt;4-&gt;5-&gt;4-&gt;1-&gt;8-&gt;4-&gt;5</p>
<p>可以发现，二者路径上是一定会重合的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA,b=headB;</span><br><span class="line">        <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">            a = a == <span class="literal">null</span> ? headB : a.next;</span><br><span class="line">            b = b == <span class="literal">null</span> ? headA : b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/posts/f171/</url>
    <content><![CDATA[<h1 id="并查集">并查集</h1>
<blockquote>
<p>父指针表示法</p>
<p>或许实现树的最简单方法就是对每个结点只保存一个指针域，指向其父节点，这种实现方法称为父指针（parent
pointer）表示法。很明显，这种实现方法并非处于一般性的目的，因为它对诸如找到一个结点的最左子节点或右兄弟节点这样的重要操作是不够的。那么用这种方法来实现树看来没有什么价值。然而，父指针表示法精确地保存了用于解答下面这个有用问题所需要的信息：“给出两个节点，它们是否在同一棵树中？”为了解答这个问题，只需要顺着节点的父指针链一直追溯到相应的根节点。如果两个节点到达同一个根节点，它们一定在同一棵树中。如果找到的根节点不同，那么这两个节点就不在同一棵树中。</p>
</blockquote>
<h2 id="并查集基本操作">并查集基本操作</h2>
<ul>
<li>合并（UNION）</li>
<li>查找根节点（FIND）</li>
<li>判断是否在同一个集合中（differ）</li>
</ul>
<span id="more"></span>

<h2 id="代码实现基础版">代码实现（基础版）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tree.unionfind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicArrayUnionFind</span> <span class="keyword">implements</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际上创建了11独立节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BasicArrayUnionFind</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FIND</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[index] != index)&#123;</span><br><span class="line">            index = arr[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">UNION</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> FIND(index1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> FIND(index2);</span><br><span class="line">        <span class="keyword">if</span>(r1 == r2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[r1] = arr[r2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">differ</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FIND(index1) == FIND(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="路径压缩优化版">路径压缩优化版</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tree.unionfind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompressArrayUnionFind</span> <span class="keyword">implements</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CompressArrayUnionFind</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FIND</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">while</span>(arr[root] != root)&#123;</span><br><span class="line">            root = arr[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// path compress, all nodes just store root pointer</span></span><br><span class="line">        <span class="keyword">while</span>(arr[index] != root)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> arr[index];</span><br><span class="line">            arr[index] = root;</span><br><span class="line">            index = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">UNION</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> FIND(index1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> FIND(index2);</span><br><span class="line">        <span class="keyword">if</span>(r1 == r2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[r1] = arr[r2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">differ</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FIND(index1) == FIND(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="低秩优化版">低秩优化版</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tree.unionfind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RankArrayUnionFind</span> <span class="keyword">implements</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="comment">// 记录树的深度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RankArrayUnionFind</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="built_in">this</span>.rank = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FIND</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[index] != index)&#123;</span><br><span class="line">            index = arr[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">UNION</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> FIND(index1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> FIND(index2);</span><br><span class="line">        <span class="keyword">if</span>(r1 == r2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 低秩优化，近可能保持较低的树深度</span></span><br><span class="line">        <span class="keyword">if</span>(rank[r1] &gt; rank[r2])&#123;</span><br><span class="line">            arr[r2] = r1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[r1] = r2;</span><br><span class="line">            <span class="keyword">if</span>(rank[r1] == rank[r2])&#123;</span><br><span class="line">                ++rank[r2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">differ</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FIND(index1) == FIND(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最终强化版">最终强化版</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tree.unionfind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayUnionFind</span> <span class="keyword">implements</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="comment">// 记录树的深度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayUnionFind</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="built_in">this</span>.rank = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FIND</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">while</span>(arr[root] != root)&#123;</span><br><span class="line">            root = arr[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// path compress, all nodes just store root pointer</span></span><br><span class="line">        <span class="keyword">while</span>(arr[index] != root)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> arr[index];</span><br><span class="line">            arr[index] = root;</span><br><span class="line">            index = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">UNION</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> FIND(index1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> FIND(index2);</span><br><span class="line">        <span class="keyword">if</span>(r1 == r2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 低秩优化，近可能保持较低的树深度</span></span><br><span class="line">        <span class="keyword">if</span>(rank[r1] &gt; rank[r2])&#123;</span><br><span class="line">            arr[r2] = r1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[r1] = r2;</span><br><span class="line">            <span class="keyword">if</span>(rank[r1] == rank[r2])&#123;</span><br><span class="line">                ++rank[r2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">differ</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> FIND(index1) == FIND(index2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1337. 矩阵中战斗力最弱的K行</title>
    <url>/posts/1c9b/</url>
    <content><![CDATA[<h1 id="1337-矩阵中战斗力最弱的k行">1337. 矩阵中战斗力最弱的K行</h1>
<p>给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1
和 0 表示。</p>
<p>请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。</p>
<p>如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于
j，那么我们认为第 i 行的战斗力比第 j 行弱。</p>
<p>军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix">https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix</a></p>
</blockquote>
<span id="more"></span>

<h2 id="二分查找堆">二分查找+堆</h2>
<p>由于军人总是排在一行中的靠前位置，即matrix中每一行的数组都是有序的，因此可以通过二分查找快速确定0出现的位置（即一行中军人的个数），同时题目要求找出前k个战斗力最弱的，最先考虑到的就是优先队列，由于建堆时间为o(logn)，因此最多只需要o(klogn)时间复杂度就可以找到前k个战斗力最弱的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>  <span class="type">int</span>[] kWeakestRows(<span class="type">int</span>[][] mat, <span class="type">int</span>  k) &#123;</span><br><span class="line">		PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span>  <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;((a,b)-&gt;a[<span class="number">1</span>]==b[<span class="number">1</span>]?a[<span class="number">0</span>]-b[<span class="number">0</span>]:a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">		<span class="comment">// 由于此处军人总是排在一行的靠前位置，因此矩阵的每一行都是有序的，可以使用二分查找找到军人的位置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;mat.length;++i)&#123;</span><br><span class="line">			queue.offer(<span class="keyword">new</span>  <span class="title class_">int</span>[]&#123;i,lowerBound(mat[i])&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span>[] res = <span class="keyword">new</span>  <span class="title class_">int</span>[k];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">			res[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>  <span class="type">int</span>  <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">		<span class="comment">//只需要找到nums中第一个0出现的位置即可</span></span><br><span class="line">		<span class="type">int</span>  <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span>  <span class="variable">r</span> <span class="operator">=</span> nums.length;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">			<span class="type">int</span>  <span class="variable">mid</span> <span class="operator">=</span> (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(nums[mid] == <span class="number">1</span>)&#123;</span><br><span class="line">				l = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				r = mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> l;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1616. 分割两个字符串得到回文串</title>
    <url>/posts/d34d/</url>
    <content><![CDATA[<h1 id="1616-分割两个字符串得到回文串">1616.
分割两个字符串得到回文串</h1>
<p>给你两个字符串 a 和 b
，它们长度相同。请你选择一个下标，将两个字符串都在
<strong>相同的下标</strong> 分割开。由 a 可以得到两个字符串： a.prefix
和 a.suffix ，满足 a = a.prefix + a.suffix ，同理，由 b
可以得到两个字符串 b.prefix 和 b.suffix ，满足 b = b.prefix + b.suffix
。请你判断 a.prefix + b.suffix 或者 b.prefix + a.suffix
能否构成回文串。</p>
<p>当你将一个字符串 s 分割成 s.prefix 和 s.suffix 时， s.suffix 或者
s.prefix 可以为空。比方说， s = "abc" 那么 "" + "abc" ， "a" + "bc" ，
"ab" + "c" 和 "abc" + "" 都是合法分割。</p>
<p>如果 能构成回文字符串 ，那么请返回 true，否则返回 false 。</p>
<p>注意， x + y 表示连接字符串 x 和 y 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome">https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>最简单的办法，由于a和b的在相同的下标分割成prefix和suffix两部分，那么可以枚举分割点的位置，逐个进行判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPalindromeFormation</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> a.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(</span><br><span class="line">                checkPalindrome(a.substring(<span class="number">0</span>,i)+b.substring(i)) || </span><br><span class="line">                checkPalindrome(b.substring(<span class="number">0</span>,i)+a.substring(i))</span><br><span class="line">            )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPalindrome</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(l) == s.charAt(r))&#123;</span><br><span class="line">                ++l;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^2)</p>
<p>本题字符串长度最大可以到10^5，这个算法会超时</p>
<h2 id="贪心">贪心</h2>
<p>那么暴力不行，就需要提前做一些优化，减少遍历</p>
<p>由于a.prefix需要和b.prefix组合成回文串，或者b.prefix和a.suffix组合成回文串</p>
<p>那么如果a本身不是回文串的情况下，a.prefix和b.suffix之间一定存在重叠字符，之后二者长度较长的剩下一部分就一定是一个回文串</p>
<p>也就是说，二者重叠部分应该是越多越好（贪心）</p>
<p>因此可以先使用双指针找到二者前后缀之前重叠部分，之后判断剩下的是否是一个回文串</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &quot;pvhmupgqeltozftlmfjjde&quot;</span><br><span class="line">b = &quot;yjgpzbezspnnpszebzmhvp&quot;</span><br><span class="line"></span><br><span class="line">其中a和b的重叠部分是 &quot;pvhm&quot;</span><br><span class="line">那么可选的分割点位置有两个，第一个是a.prefix = &quot;pvhm&quot;，第二个是b.suffix = &quot;mhvp&quot;</span><br><span class="line">二者之间的部分就一定有一个回文串，否则这两个字符串就不可能组合成回文串</span><br><span class="line">&quot;upgqeltozftlmf&quot;</span><br><span class="line">&quot;zbezspnnpszebz&quot;</span><br></pre></td></tr></table></figure>

<p>那么现在问题来了，为什么分割点的位置一定是两个字符串前后缀最大重叠部分呢？</p>
<p>因为如果用较小的前后缀也能匹配且剩下的中间部分是回文，那么若存在更长的前后缀匹配，其中间部分也必然是回文。因此可以总是用最长的匹配，检查剩余中间部分是否为回文代替。不失一般性。</p>
<blockquote>
<p>作者：jyj407 链接：<a
href="https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/solution/1616-fen-ge-liang-ge-zi-fu-chuan-de-dao-x82oe/">https://leetcode-cn.com/problems/split-two-strings-to-make-palindrome/solution/1616-fen-ge-liang-ge-zi-fu-chuan-de-dao-x82oe/</a>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPalindromeFormation</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="comment">// 只需要a.prefix+b.suffix 或 a.suffix+b.prefix可以构成回文串即可</span></span><br><span class="line">        <span class="keyword">return</span> check(a,b) || check(b,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String a,String b)</span>&#123;</span><br><span class="line">      	<span class="comment">// 检查a.prefix + b.suffix是否可以组成回文串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> a.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 检查a.prefix+b.suffix是否可以构成回文串</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; a.charAt(left) == b.charAt(right))&#123;</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(left);</span></span><br><span class="line">        <span class="comment">// 检查剩余部分是不是一个回文串</span></span><br><span class="line">        <span class="comment">// 有可能是a前缀包含了很多</span></span><br><span class="line">        <span class="comment">// 假设此处的分割点是left，或length-left</span></span><br><span class="line">        <span class="keyword">if</span>(</span><br><span class="line">            checkPalindrome(a.substring(left,length-left)) || </span><br><span class="line">            checkPalindrome(b.substring(left,length-left))</span><br><span class="line">        ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkPalindrome</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(s);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                ++left;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1818. 绝对值差和</title>
    <url>/posts/8083/</url>
    <content><![CDATA[<h1 id="1818-绝对值差和">1818. 绝对值差和</h1>
<p>给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。</p>
<p>数组 nums1 和 nums2 的 <strong>绝对差值和</strong> 定义为所有
|nums1[i] - nums2[i]|（0 &lt;= i &lt; n）的 总和（下标从 0 开始）。</p>
<p>你可以选用 nums1 中的 <strong>任意一个</strong> 元素来替换 nums1 中的
<strong>至多</strong> 一个元素，以 <strong>最小化</strong>
绝对差值和。</p>
<p>在替换数组 nums1 中最多一个元素 <strong>之后</strong>
，返回最小绝对差值和。因为答案可能很大，所以需要对 10<sup>9</sup> + 7
<strong>取余</strong> 后返回。</p>
<p>|x| 定义为：</p>
<p>如果 x &gt;= 0 ，值为 x ，或者 如果 x &lt;= 0 ，值为 -x</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference">https://leetcode-cn.com/problems/minimum-absolute-sum-difference</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力求解">暴力求解</h2>
<p>暴力的思路很简单，由于可以使用nums1中的任意一个元素来替换nums1中的一个元素，那么可以遍历所有种组合，找到最小的结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minAbsoluteSumDiff</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">modder</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            sum = (sum + Math.abs(nums1[i]-nums2[i])) % modder;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> sum;</span><br><span class="line">   </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="comment">// 用nums1[j]来替换nums1[i]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">newAbs</span> <span class="operator">=</span> Math.abs(nums1[j]-nums2[i]) % modder;</span><br><span class="line">                <span class="type">int</span> <span class="variable">oldAbs</span> <span class="operator">=</span> Math.abs(nums1[i]-nums2[i]) % modder;</span><br><span class="line">              	<span class="comment">// 计算结果</span></span><br><span class="line">                res = Math.min(Math.min(sum,sum+newAbs-oldAbs) % modder,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于暴力求解的时间复杂度为o(n2)，本题数据量较大，是一定会超时的，那么有没有更好的解决方案呢？</p>
<h2 id="二分查找">二分查找</h2>
<p>从暴力求解的代码可以看出，替换之后结果的大小取决于<code>newAbs和oldAbs</code>，只需要找到最小的<code>newAbs-oldAbs</code>，就可以使替换之后的绝对值差和最小。</p>
<p>那么如何寻找最小的的这个值呢，可以将nums1进行排序，之后使用二分查找选择最接近nums2[i]的值进行替代，然后计算差值，这样可以将</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minAbsoluteSumDiff</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span>[] rec = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.arraycopy(nums1, <span class="number">0</span>, rec, <span class="number">0</span>, n);</span><br><span class="line">        Arrays.sort(rec);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>, maxn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> Math.abs(nums1[i] - nums2[i]);</span><br><span class="line">            sum = (sum + diff) % MOD;</span><br><span class="line">          	<span class="comment">// 找到最接近nums2[i]的值的下标，由于目标是找到｜nums1[j]-nums2[i]｜最小的，</span></span><br><span class="line">          	<span class="comment">// 因此需要判断两个值，可能大于nums2[i]，也可能小于nums2[i]，</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> binarySearch(rec, nums2[i]);</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n) &#123;</span><br><span class="line">                maxn = Math.max(maxn, diff - (rec[j] - nums2[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                maxn = Math.max(maxn, diff - (nums2[i] - rec[j - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum - maxn + MOD) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">// 此处binarySearch返回值目标是找到第一个值比target大的下标</span></span><br><span class="line">  	<span class="comment">// 实际上就是lower_bound</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] rec, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = rec.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (rec[high] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> high + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="keyword">if</span> (rec[mid] &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1953. 你可以工作的最大周数</title>
    <url>/posts/809c/</url>
    <content><![CDATA[<h1 id="1953-你可以工作的最大周数">1953. 你可以工作的最大周数</h1>
<p>给你 n 个项目，编号从 0 到 n - 1 。同时给你一个整数数组 milestones
，其中每个 milestones[i] 表示第 i 个项目中的阶段任务数量。</p>
<p>你可以按下面两个规则参与项目中的工作：</p>
<p>每周，你将会完成 <strong>某一个</strong> 项目中的
<strong>恰好一个</strong> 阶段任务。你每周都 <strong>必须</strong>
工作。 在 <strong>连续的</strong> 两周中，你 不能
参与并完成同一个项目中的两个阶段任务。
一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将
<strong>停止工作</strong>
。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</p>
<p>返回在不违反上面规则的情况下你 <strong>最多</strong>
能工作多少周。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work">https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work</a></p>
</blockquote>
<span id="more"></span>

<h2 id="贪心">贪心</h2>
<p>首先看到这个题目，可以很直观的想到，需要找到一个阶段任务数最大的项目作为主项目，每两周完成一个阶段任务，其他时间来完成剩下的任务。那么现在就要考虑，最大项目的完成周数是否会影响最大工作周数？</p>
<p>实际上，只要满足 <span class="math display">\[
longest &lt;= rest + 1
\]</span> 就一定可以完成所有的任务，那么这是为什么呢？</p>
<p>考虑临界情况 <span class="math display">\[
longest = rest + 1
\]</span> 以[5,3,1]为例，此时将周期最长的项目先排开，</p>
<p>5｜5｜5｜5｜5</p>
<p>此时全都是相邻的，为了满足条件，需要将其他任务插入到空隙中</p>
<p>5｜3｜5｜3｜5｜3｜5｜1｜5</p>
<p>可以直观的看到，完成longest这个任务，至少需要有longest-1个空白周才能完成，那么这longest-1个空白周就需要用其他任务来填补，当剩下任务周数不足longest-1时，必定完不成这个任务了</p>
<p>但是如果rest &gt; longest -
1的话，时间会充裕很多，就一定能完成任务</p>
<p>以 [5,3,2,1]为例</p>
<p>同样先考虑最难完成的5</p>
<p>5｜5｜5｜5｜5</p>
<p>先插空</p>
<p>5｜3｜5｜3｜5｜3｜5｜1｜5</p>
<p>此时还剩下2，但是由于连续两周之间不会完成同一个项目，此时只需要任意选择位置做项目就行</p>
<p>也就是说，最困难的就是安排做大项目的空隙，如果大项目一定可以完成，那么剩下的空隙是一定够完成其他任务的，因为随着任务的不断安排，可安排的空隙越来越多，就一定可以完成任务</p>
<blockquote>
<p>周赛的时候，以为是贪心法，就不断的取出最大值，用剩下的值从大到小来消掉最大值，后面发现最后几个case过不了，逻辑是有问题的；看题解，大多数题解只给了公式，并没有很直观的解释，其实这道题就是转化下题意就很好理解了。</p>
<p>首先，题目要求满足不重复项目的最大的工作周数，我们可以这样理解，将所有项目的任务排成一个任务序列，找到一个前缀最长的相邻元素不重复的序列即可。因此，我们可以首先将任务数最多的项目先排开，然后将其它任务插入到它的间隙中。
例如，[1,2,3,5]，最大的项目任务数为5，因此我们先得到项目4的5个任务的序列5
5 5 5 5，我们依次将其它任务插入以保证相邻不重复，依次得到 5 3 5 3 5 3 5
5,不够，再将2插入，得到5 3 5 3 5 3 5 2
5,此时我们已经能保证5的任务不相邻了。而且我们发现，随着插入的任务数越多，可供后面任务插入的空位越多(大于最大项目的任务数)，因此后面的任务只要插入前面序列两个不相邻的任务中间，就不会重复。综上，我们只需要保证任务数最多的项目不重复即可保证所有项目的任务不重复。</p>
<p>作者：WilsonYIU 链接：<a
href="https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work/solution/ti-yi-zhuan-hua-cha-kong-fa-by-yorwood-bvdv/">https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work/solution/ti-yi-zhuan-hua-cha-kong-fa-by-yorwood-bvdv/</a>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>知道思路后，写起来就很简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">numberOfWeeks</span><span class="params">(<span class="type">int</span>[] milestones)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:milestones)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            max = Math.max(max,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">rest</span> <span class="operator">=</span> sum - max;</span><br><span class="line">        <span class="keyword">return</span> rest+<span class="number">1</span>&gt;=max?sum:<span class="number">2</span>*rest+<span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>233. 数字1的个数</title>
    <url>/posts/a953/</url>
    <content><![CDATA[<h1 id="233-数字1的个数">233. 数字1的个数</h1>
<p>给定一个整数 <code>n</code>，计算所有小于等于 <code>n</code>
的非负整数中数字 <code>1</code> 出现的个数。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/number-of-digit-one/">233.
数字 1 的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="数学">数学</h2>
<p>这题还挺有意思的，可以按数字n上每一位的1出现次数来统计</p>
<p>我们首先计算出0～9、0～99、0～999上的数字1出现的次数，然后可以得到递推公式进行计算</p>
<p>0～9很简单，就一个1出现</p>
<p>0～99的话，首先不管十位是什么，个位上一定会有一个1，那么就会有10个1，再看十位，从10～19上所有数字的十位都是1，那么0～99就一共包含20个1</p>
<p>0～999的话，也是一样，由于已经知道了0～99中包含的1的个数，可以使用之前计算的结果，首先不管百位上包含的数字是什么，0～99中一定有20个1，那么就会有10*20
=
200个1，再看百位，从100～199上所有数字的百位都是1，那么0～999就一共包含300个1</p>
<p>尝试计算了0～9、0～99、0～999上的1的个数后，可以很明显的找到规律，设dp[i]表示10^i-1内1的个数</p>
<p>那么有一下递推公式 <span class="math display">\[
dp[i] = dp[i-1]*10+10^{i-1}
\]</span>
然后我们再来考虑1234这种一般情况，同上面描述的计算方式一致，可以先从个位开始计算，4&gt;1，则包含1的个数就是1，再看十位3，由于十位是3，那么只看个位就一定有3*dp[1]
=
3个1，再考虑十位，当十位是1的时候10～19全部都是1，因此再加上10，那么此时总共包含14个1，再看百位，计算思路一致，此时总共包含2*dp[2]+100+14
=
154，最后看千位，由于千位上刚好是1，我们可以分两步计算，先计算0～999的1的个数再加上1000～1234的，其中1000～1234的由于0～234中1的个数已经计算过了，只需要再加上235即可，最终计算结果就是300+154+235
= 689个</p>
<p>根据这个思路，就可以很简单的写出代码了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      	<span class="comment">// 分别计算0～9、0～99、0～999...的1的数目</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">            dp[i] = p+<span class="number">10</span>*dp[i-<span class="number">1</span>];</span><br><span class="line">            p*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 0 &lt;= n &lt;= 2*10^9</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curr;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            curr = n%<span class="number">10</span>;</span><br><span class="line">            val = curr*p+val;</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 0~999 + 1234-1000 + count(234)</span></span><br><span class="line">                res += (val - p + <span class="number">1</span> + dp[ptr]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res += (p + curr * dp[ptr]);</span><br><span class="line">            &#125;</span><br><span class="line">            ++ptr;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">            p*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>313. 超级丑数</title>
    <url>/posts/9689/</url>
    <content><![CDATA[<h1 id="313-超级丑数">313. 超级丑数</h1>
<p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes
中。</p>
<p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p>
<p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/super-ugly-number">https://leetcode-cn.com/problems/super-ugly-number</a></p>
</blockquote>
<span id="more"></span>

<h2 id="最小堆集合">最小堆+集合</h2>
<p>这一题乍一看有点没搞明白，看了样例就理解了</p>
<p>例如 n = 12，primes = [2,7,13,19]</p>
<p>其要求的一个正整数序列的第n个，这个正整数序列中的每一个正整数的所有质因数都在primes数组中</p>
<p>再看前12个正整数分别是什么</p>
<p>[ 1,2,4,7,8,13,14,16,19,26,28,32 ]</p>
<p>实际上可以看成是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ 1,1*2,2*2,1*7,2*4,1*13,2*7,8*2,1*19,2*13,14*2,16*2 ]</span><br></pre></td></tr></table></figure>

<p>也就是将primes中的质数任取几个进行相乘，最终进行排序</p>
<p>那么可以使用最小堆来选择每次需要进行计算的数，同时使用set来去重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthSuperUglyNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] primes)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 由于在计算可能出现超出2^31-1，需要使用long来存，防止优先队列计算错误</span></span><br><span class="line">        PriorityQueue&lt;Long&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Long&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="number">1L</span>);</span><br><span class="line">        set.add(<span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">// 使用优先队列来选择当前最小的，然后使用set来去重</span></span><br><span class="line">            res = queue.poll();</span><br><span class="line">            <span class="comment">// System.out.println(res);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p:primes)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> res * p;</span><br><span class="line">                <span class="comment">// 又可能出现重复的，使用set来去重</span></span><br><span class="line">                <span class="keyword">if</span>(!set.contains(next))&#123;</span><br><span class="line">                    <span class="comment">// 实际上如果next值大于queue.peek()的话就没有必要加入了？</span></span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                    set.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将所有小于val的primes中数组添加到里面？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(nmlog(mn))</p>
<p>空间复杂度：o(mn)</p>
<p>其中最外层遍历为n，内部每一次循环都需要遍历primes数组即m，同时每次遍历还需要加入优先队列中，优先队列在运行过程中长度为o(mn)，每次调整时间复杂度为log(mn)，因此整个算法时间复杂度为o(mnlog(mn))</p>
<h2 id="动态规划">动态规划</h2>
<p>上一个方法时间复杂度较高，且需要存储大量的超级丑数供下一步计算，使用动态规划可以减少空间复杂度和时间复杂度</p>
<p>使用dp[i]表示第i个超级丑数，dp[0] = 0，此时需要考虑
dp[i]和dp[i-1]之间的状态转移关系，从解法一中给出的样例可以看到，</p>
<p>下一个超级丑数一定是之前的某一个超级丑数和某一个质数的乘积，那么只需要找到距dp[i-1]最接近的那个超级丑数即可</p>
<p>由于dp数组是一个有序的，primes数组也是有序的，那么越靠前的dp[j]乘上越靠前的primes值越小，可以使用一个数组存储当前primes对应想乘的值，当出现重复的时候就将其自增</p>
<p>此时状态转移方程可以描述为 <span class="math display">\[
dp[i] = min(dp[next[j]]*primes[j])
\]</span></p>
<p>每次循环结束使用当前最小值对next值更新，防止出现重复</p>
<p>if(dp[i] == dp[next[j]]*primes[j]) ++next[j]</p>
<p>下面示范计算过程</p>
<p>n = 12</p>
<p>primes = [2,7,13,19]</p>
<p><strong>初始化</strong></p>
<p>dp = [1]</p>
<p>next = [0,0,0,0]</p>
<p><strong>step1</strong></p>
<p>dp[1] = min(2,7,13,19) = 2</p>
<p>dp = [1,2]</p>
<p>next = [1,0,0,0]</p>
<p><strong>step2</strong></p>
<p>dp[2] = min(4,7,13,19) = 4</p>
<p>dp = [1,2,4]</p>
<p>next = [2,0,0,0]</p>
<p><strong>step3</strong></p>
<p>dp[3] = min(8,7,13,19) = 7</p>
<p>dp = [1,2,4,7]</p>
<p>next = [2,1,0,0]</p>
<p><strong>step4</strong></p>
<p>dp[4] = min(8,14,13,19) = 8</p>
<p>dp = [1,2,3,7,8]</p>
<p>next = [3,1,0,0]</p>
<p><strong>step5</strong></p>
<p>dp[5] = min(14,14,13,19) = 13</p>
<p>dp = [1,2,3,7,8,13]</p>
<p>next = [3,1,1,0]</p>
<p><strong>step6</strong></p>
<p>dp[6] = min(14,14,26,19) = 14</p>
<p>dp = [1,2,3,7,8,13,14]</p>
<p>next = [4,2,1,0]</p>
<p><strong>step7</strong></p>
<p>dp[7] = min(16,28,26,19) = 16</p>
<p>dp = [1,2,3,7,8,13,14,16]</p>
<p>next = [5,2,1,0]</p>
<p><strong>step8</strong></p>
<p>dp[8] = min(26,28,26,19) = 19</p>
<p>dp = [1,2,3,7,8,13,14,16,19]</p>
<p>next = [5,2,1,1]</p>
<p><strong>step9</strong></p>
<p>dp[9] = min(26,28,26,38) = 26</p>
<p>dp = [1,2,3,7,8,13,14,16,19,26]</p>
<p>其中dp[next[0]]*2 == 26，dp[next[2]]*13 == 26</p>
<p>next = [6,2,2,1]</p>
<p><strong>step10</strong></p>
<p>dp[10] = min(28,28,39,38) = 28</p>
<p>dp = [1,2,3,7,8,13,14,16,19,26,28]</p>
<p>其中dp[next[0]]*2 == 28，dp[next[1]]*7 == 28</p>
<p>next = [7,3,2,1]</p>
<p><strong>step11</strong></p>
<p>dp[11] = min(32,42,39,38) = 32</p>
<p>dp = [1,2,3,7,8,13,14,16,19,28,32]</p>
<p>next = [8,3,2,1]</p>
<p>结束，返回dp[n-1] = 12</p>
<p>思路弄清楚了，代码写起来就很简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthSuperUglyNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] primes)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> primes.length;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">          	<span class="comment">// 计算当前最小值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                min = Math.min(min,primes[j]*dp[next[j]]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min;</span><br><span class="line">          	<span class="comment">// 更新next数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min == primes[j]*dp[next[j]]) ++next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建记录</title>
    <url>/posts/96e0/</url>
    <content><![CDATA[<h1 id="413-等差数列划分">413. 等差数列划分</h1>
<p>如果一个数列 <strong>至少有三个元素</strong>
，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<ul>
<li>例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。</li>
</ul>
<p>给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的
<strong>子数组</strong> 个数。</p>
<p><strong>子数组</strong> 是数组中的一个连续序列。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/arithmetic-slices">https://leetcode-cn.com/problems/arithmetic-slices</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>由于题目数据规模不是很大（最大长度也就1000），可以直接暴力枚举所有的子数组，然后逐个判断是否是等差数列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+<span class="number">2</span>&lt;length;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> nums[i+<span class="number">1</span>]-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(d != (nums[i+<span class="number">2</span>]-nums[i+<span class="number">1</span>])) <span class="keyword">continue</span>;</span><br><span class="line">          	<span class="comment">// 找到一个以i开始的等差数列</span></span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">3</span>;j&lt;length;++j)&#123;</span><br><span class="line">              	<span class="comment">// 判断其后续是不是等差数列</span></span><br><span class="line">                <span class="comment">// 当不满足等差数列条件的时候就需要直接退出</span></span><br><span class="line">                <span class="keyword">if</span>((nums[j]-nums[j-<span class="number">1</span>]) != d) <span class="keyword">break</span>;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^2)</p>
<p>空间复杂度：o(1)</p>
<h2 id="双指针">双指针</h2>
<p>对于一个本来就是等差数列的数组，例如 [1,2,3,4,5,6,7]</p>
<p>由于其本身是一个等差数列，因此其所有长度大于3的子数列都是等差数列，下面列举所有子数列，并找出其中规律</p>
<p>k = 7</p>
<p>[1,2,3,4,5,6,7]</p>
<p>k = 6</p>
<p>[1,2,3,4,5,6],[2,3,4,5,6,7]</p>
<p>k=5</p>
<p>[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7]</p>
<p>k=4</p>
<p>[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7]</p>
<p>k=3</p>
<p>[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7]</p>
<p>可以发现，对于一个长度为k的等差数列，其所有的子数列等差数列和为
1+2+3+...+k-2</p>
<p>可以用等差数列求和公式求出总个数，即 <span class="math display">\[
cnt = (1+k-2)*(k-2)/2
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, d = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">          	<span class="comment">// 找到以i开头，最长可到达的等差数列</span></span><br><span class="line">            <span class="keyword">while</span> (j + <span class="number">1</span> &lt; n &amp;&amp; nums[j + <span class="number">1</span>] - nums[j] == d) j++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> j - i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// a1：长度为 len 的子数组数量；an：长度为 3 的子数组数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">1</span>, an = len - <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 符合条件（长度大于等于3）的子数组的数量为「差值数列求和」结果</span></span><br><span class="line">          	<span class="comment">// 根据这个最长的等差数列，其所有的子数列都是等差数列，因此可以直接通过公式计算个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> (a1 + an) * an / <span class="number">2</span>;</span><br><span class="line">            ans += cnt;</span><br><span class="line">          	<span class="comment">// 接着i可以从j开始找下一个连续的等差数列</span></span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看似包含双重循环，但实际上每个nums仅遍历一次</p>
<p>时间复杂度：o(n)</p>
<p>空间复杂度：o(1)</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>446. 等差数列划分 II - 子序列</title>
    <url>/posts/f020/</url>
    <content><![CDATA[<h1 id="446-等差数列划分-ii---子序列">446. 等差数列划分 II - 子序列</h1>
<p>给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。</p>
<p>如果一个序列中 至少有三个元素
，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p>
<p>例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。
再例如，[1, 1, 2, 5, 7] 不是等差序列。
数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p>
<p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。
题目数据保证答案是一个 32-bit 整数。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence">https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划哈希表">动态规划+哈希表</h2>
<p>这一题相比前一题 <strong>413. 等差数列划分</strong>
难度更大，需要找到数列子序列（可以不连续）为等差数列</p>
<p>而一个数列的子序列个数为2^n个，显然暴力是不行的，可以用dp[i,k]表示以数字nums[i]结尾的，公差为k的弱等差数列的个数（弱等差数列：数列长度至少为2的等差数列），这样状态转移公式为
<span class="math display">\[
dp[i,k] = \sum_{j&lt;i}{dp[j,k]+1}
\]</span> 其中j需要满足 nums[i]-nums[j] == k</p>
<p>也就是说，对于所有的以nums[j]结尾，公差为k的弱等差数列，都可以将nums[i]插入到该弱等差数列末尾，同时nums[i],nums[j]构成了一个新的弱等差数列</p>
<p>而求得弱等差数列个数后，转换为等差数列个数就很简单了，注意到，等差数列个数是弱等差数列中长度大于等于3的，而将nums[i]插入到以nums[j]结尾的弱等差数列时，该弱等差数列的长度一定是大于等于3的，因此只需要统计这一部分的值就行</p>
<p>说上去好像很复杂，下面举例解释</p>
<p>nums = [2,4,5,6,7,8,10]</p>
<p>初始化：</p>
<p>dp是一个二维数组，但由于公差取值范围太大，使用Map存储</p>
<p>step1：以 nums[1] 即 4 结尾的弱等差数列</p>
<p>dp[1,2] = 1，此时代表数列{2,4}</p>
<p>step2：以 nums[2] 即 5 结尾的弱等差数列</p>
<p>dp[2,3] = 1，此时代表数列{2,5}</p>
<p>dp[2,1] = 1，此时代表数列{4,5}</p>
<p>step3：以 nums[3] 即 6 结尾的弱等差数列</p>
<p>dp[3,4] = 1，此时代表数列{2,6}</p>
<p>dp[3,2] = dp[1,2] + 1 = 2，此时代表数列{2,4,6}、{4,6}</p>
<p>由于向数列{2,4}中添加元素6，组成了等差数列，更新res=1</p>
<p>dp[3,1] = dp[2,1] + 1 = 2，此时代表数列{4,5,6} 、{5,6}</p>
<p>由于向数列{4,5}中添加元素6，组成了等差数列，更新res=2</p>
<p>step4：以 nums[4] 即 7 结尾的弱等差数列</p>
<p>dp[4,5] = 1，此时代表数列{2,7}</p>
<p>dp[4,3] = 1，此时代表数列{4,7}</p>
<p>dp[4,2] = 1，此时代表数列{5,7}</p>
<p>dp[4,1] = dp[3,1] + 1 = 3，此时代表数列{4,5,6,7}、{5,6,7}、{6,7}</p>
<p>由于向数列{4,5,6}、{5,6}中添加了元素7，组成了等差数列，更新res=4</p>
<p>step5：以 nums[5] 即 8 结尾的弱等差数列</p>
<p>dp[5,6] = 1，此时代表数列{2,8}</p>
<p>dp[5,4] = 1，此时代表数列{4,8}</p>
<p>dp[5,3] = 1，此时代表数列{5,8}</p>
<p>dp[5,2] = dp[3,2] + 1 = 3，此时代表数列{2,4,6,8}、{4,6,8}、{6,8}</p>
<p>由于向数列{2,4,6}、{4,6}添加了元素8，组成了等差数列，更新res=6</p>
<p>dp[5,1] = dp[4,1] + 1 =
4，此时代表数列{4,5,6,7,8}、{5,6,7,8}、{6,7,8}、{7,8}</p>
<p>由于向数列{4,5,6,7}、{5,6,7}、{6,7}中添加了元素8，组成了等差数列，更新res=9</p>
<p>step6：以 nums[6] 即 10 结尾的弱等差数列</p>
<p>dp[6,8] = 1，此时代表数列{2,10}</p>
<p>dp[6,6] = 1，此时代表数列{4,10}</p>
<p>dp[6,5] = 1，此时代表数列{5,10}</p>
<p>dp[6,4] = 1，此时代表数列{6,10}</p>
<p>dp[6,3] = dp[4,3] + 1 = 2，此时代表数列{4,7,10}、{7,10}</p>
<p>由于向数列{4,7}中添加了元素10，组成了等差数列，更新res=10</p>
<p>dp[6,2] = dp[5,2]+1 =
4，此时代表数列{2,4,6,8,10}、{4,6,8,10}、{6,8,10}、{8,10}</p>
<p>由于向数列{2,4,6,8}、{4,6,8}、{6,8}中添加了元素10，组成了等差数列，更新res=13</p>
<p>遍历结束，最终返回res=13，分别是</p>
<p>{2,4,6}、{4,5,6}、{4,5,6,7}、{5,6,7}、{2,4,6,8}、{4,6,8}、{4,5,6,7,8}、{5,6,7,8}、{6,7,8}、{4,7,10}、{2,4,6,8,10}、{4,6,8,10}、{6,8,10}</p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用dp[i][k]表示公差为k的等差数列，以nums[i]结尾的弱等差数列（包含两个元素）个数</span></span><br><span class="line">        <span class="comment">// 由于dp[i][k]表示的是弱等差数列，因此将i插入到j后面，此时就构成了三个元素，可以算成等差数列</span></span><br><span class="line">        <span class="comment">// 因此可以有状态转移公式 if(nums[i] - nums[j] == k) dp[i][k] = dp[j][k]+1;</span></span><br><span class="line">        <span class="comment">// 第一次进行状态更新的时候构成的时弱等差，但第二次时就是一个包含三个元素的等差数列了，因此可以在统计弱等差数列的时候稍加处理就可以求解等差数列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Map&lt;Long,Integer&gt;[] dp = <span class="keyword">new</span> <span class="title class_">Map</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i]-nums[j];</span><br><span class="line">                <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> dp[j].getOrDefault(d,<span class="number">0</span>);</span><br><span class="line">                res += cnt;</span><br><span class="line">                dp[i].put(d,dp[i].getOrDefault(d,<span class="number">0</span>)+cnt+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;length;++i)&#123;</span></span><br><span class="line">        <span class="comment">//     for(long k:dp[i].keySet())&#123;</span></span><br><span class="line">        <span class="comment">//         System.out.println(&quot;dp[&quot;+i+&quot;][&quot;+k+&quot;]=&quot;+dp[i].get(k));</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="序列dp解题思路">序列DP解题思路</h2>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/solution/gong-shui-san-xie-xiang-jie-ru-he-fen-xi-ykvk/">【宫水三叶】详解如何分析「序列
DP」问题（附序列 DP 问题目录） - 等差数列划分 II - 子序列 -
力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<p>序列DP类的题目一般描述是，对于一个给定的序列，需要找出满足某个条件的所有子序列</p>
<p>对这种类型的题目，最基本的思路使用dp[i]表示满足给定条件的，以nums[i]结尾的子序列，然后枚举0～i-1的所有数，观察是否满足条件，进行状态更新</p>
<blockquote>
<p><strong>枚举当前位置前面的所有位置的目的，是为了找到当前位置的数，能够接在哪一个位置的后面，形成序列。</strong></p>
</blockquote>
<p>*此处dp[i]不一定就是一个数，也可能是其他数据结构，需要结合具体问题思考</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>457. 环形数组是否存在循环</title>
    <url>/posts/2308/</url>
    <content><![CDATA[<h1 id="457-环形数组是否存在循环">457. 环形数组是否存在循环</h1>
<p>存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i
的角色应该向前或向后移动的下标个数：</p>
<p>如果 nums[i] 是正数，向前 移动 nums[i] 步 如果 nums[i] 是负数，向后
移动 nums[i] 步 因为数组是 环形
的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p>
<p>数组中的 <strong>循环</strong> 由长度为 k 的下标序列 seq ：</p>
<p>遵循上述移动规则将导致重复下标序列 seq[0] -&gt; seq[1] -&gt; ...
-&gt; seq[k - 1] -&gt; seq[0] -&gt; ... 所有 nums[seq[j]] 应当不是
<strong>全正</strong> 就是 <strong>全负</strong> k &gt; 1 如果 nums
中存在循环，返回 true ；否则，返回 false 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/circular-array-loop">https://leetcode-cn.com/problems/circular-array-loop</a></p>
</blockquote>
<h2 id="题意理解">题意理解</h2>
<p>这个题目的中文翻译有点令人费解，简单来说就是类似于走飞行棋，数组中当前位置上的值代表可以向前（向后）行走的步数，在这样的条件下，可能存在环，但是这个环要求不能走回头路，只能朝着一个方向前进（这也就是为什么要nums[seq[i]]全正或全负）要求从一个方向前进，同时也不能包括自环</p>
<span id="more"></span>

<h2 id="模拟">模拟</h2>
<p>可以从每一个节点开始，进行遍历，如果行走的过程中发现走了回头路（两次nums[i]的值符号相反）或者在原地踏步，那就说明不是环）判断每一个节点，最后一定可以给出结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">boolean</span> isPositive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">circularArrayLoop</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// nums[i]表示位于下标i的角色应该向前或向后移动的下标个数</span></span><br><span class="line">        <span class="comment">// &gt;0 向前走nums[i]步，</span></span><br><span class="line">        <span class="comment">// &lt;0 向后走nums[i]步</span></span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="built_in">this</span>.length = nums.length;</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            Arrays.fill(visited,<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">if</span>(dfs(i,-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> prevIndex)</span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(index);</span></span><br><span class="line">        <span class="comment">// 当重新访问到一个已经访问过的节点时</span></span><br><span class="line">        <span class="comment">// 要求所有的nums[seq[j]]不是全正就是全负</span></span><br><span class="line">        <span class="keyword">if</span>(visited[index])&#123;</span><br><span class="line">            <span class="comment">// 如果存在自环，就是错误的</span></span><br><span class="line">            <span class="keyword">if</span>(prevIndex == index) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当cnt大于</span></span><br><span class="line">        visited[index] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 这时候需要考虑循环终止条件是什么？</span></span><br><span class="line">        <span class="comment">// 在java中，当一个负数对于正数取模的时候，其结果也是一个负数，因此需要加上length将结果恢复到[0,n)内</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> ((index + nums[index]) % length + length) % length;</span><br><span class="line">        <span class="comment">// 有可能出现不止走一圈的情况，需要多加几次</span></span><br><span class="line">        <span class="comment">// 如果下一步与期望的正负不通，就说明出问题，因为不能走回头路</span></span><br><span class="line">        <span class="keyword">if</span>(nums[index] * nums[next] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(next,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针">快慢指针</h2>
<p>实际上这个题目也可以使用类似链表找环的思路进行求解，采用快慢指针，其中快指针一次走两步，而慢指针一次走一步，如果存在环，那么快慢指针一定会相遇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">circularArrayLoop</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          	<span class="comment">// nums[i]已经访问过了，无法进入环，说明不行，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> i, fast = next(nums, i);</span><br><span class="line">            <span class="comment">// 判断非零且方向相同</span></span><br><span class="line">          	<span class="comment">// 这个判断其实很讲究，</span></span><br><span class="line">          	<span class="comment">// 首先判断慢指针是否和快指针（慢指针的下一个）同一方向，如果是的，判断快指针和快指针的下一个是否同一方向</span></span><br><span class="line">          	<span class="comment">// 又因为经过前一次的判断，此时快指针和慢指针是同一方向，只需要判断慢指针和快指针的下一个是否是同一方向即可</span></span><br><span class="line">          	<span class="comment">// 但写的时候写成 nums[slow] * nums[fast] &gt; 0 &amp;&amp; nums[fast] * nums[next(nums,fast)] &gt; 0</span></span><br><span class="line">            <span class="comment">// 也是没问题的，实际上还更容易理解</span></span><br><span class="line">          	<span class="comment">// 而且由于之前标记了0，如果碰到0直接退出这一轮循环，进入下一个节点的判断，很妙</span></span><br><span class="line">            <span class="keyword">while</span> (nums[slow] * nums[fast] &gt; <span class="number">0</span> &amp;&amp; nums[slow] * nums[next(nums, fast)] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                  	<span class="comment">// 排除自环</span></span><br><span class="line">                    <span class="keyword">if</span> (slow != next(nums, slow)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                slow = next(nums, slow);</span><br><span class="line">                fast = next(nums, next(nums, fast));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> i;</span><br><span class="line">          	<span class="comment">// 将快慢指针走过的路标记为访问过</span></span><br><span class="line">            <span class="keyword">while</span> (nums[add] * nums[next(nums, add)] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> add;</span><br><span class="line">                add = next(nums, add);</span><br><span class="line">                nums[tmp] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> cur)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">return</span> ((cur + nums[cur]) % n + n) % n; <span class="comment">// 保证返回值在 [0,n) 中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>526. 优美的排列</title>
    <url>/posts/d106/</url>
    <content><![CDATA[<h1 id="526-优美的排列">526. 优美的排列</h1>
<p>假设有从 1 到 N 的 N 个整数，如果从这 N
个数字中成功构造出一个数组，使得数组的第 i 位 (1 &lt;= i &lt;= N)
满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：</p>
<ul>
<li><p>第 i 位的数字能被 i 整除</p></li>
<li><p>i 能被第 i 位上的数字整除</p></li>
</ul>
<p>现在给定一个整数 N，请问可以构造多少个优美的排列？</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/beautiful-arrangement">https://leetcode-cn.com/problems/beautiful-arrangement</a></p>
</blockquote>
<span id="more"></span>

<h2 id="递归">递归</h2>
<p>可以使用递归产生排列的方式，不断生成数组的排列，然后判断是否是一个优美排列</p>
<p>由于本题最多只有15个数子，可以使用位图存储每个对应位置上的数是否已经访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n,res,endState;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countArrangement</span><span class="params">(<span class="type">int</span> _n)</span> &#123;</span><br><span class="line">        <span class="comment">// 1～N的N个整数，由于n最大只有15，可以用一个二进制的位存储当前的排列</span></span><br><span class="line">        <span class="comment">// 是否需要用这个二进制数来表示当前状态？</span></span><br><span class="line">        <span class="comment">// 这个二进制数只能存储当前已经访问的数，那么还需要存储的是数组第i位上放的是什么？</span></span><br><span class="line">        n = _n;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        endState = ((<span class="number">1</span>&lt;&lt;n)-<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// System.out.println(endState);</span></span><br><span class="line">        <span class="comment">// 110</span></span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> state,<span class="type">int</span> currPos)</span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(state);</span></span><br><span class="line">        <span class="keyword">if</span>(state == endState)&#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((state &amp; (<span class="number">1</span>&lt;&lt;i)) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i % currPos == <span class="number">0</span> || currPos % i ==<span class="number">0</span>)&#123;</span><br><span class="line">                    dfs(state|(<span class="number">1</span>&lt;&lt;i),currPos+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化：实际上可以提前计算出每个位置上可行的数，然后进行填数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n,res,endState;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt;[] availNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countArrangement</span><span class="params">(<span class="type">int</span> _n)</span> &#123;</span><br><span class="line">        <span class="comment">// 1～N的N个整数，由于n最大只有15，可以用一个二进制的位存储当前的排列</span></span><br><span class="line">        <span class="comment">// 是否需要用这个二进制数来表示当前状态？</span></span><br><span class="line">        <span class="comment">// 这个二进制数只能存储当前已经访问的数，那么还需要存储的是数组第i位上放的是什么？</span></span><br><span class="line">        n = _n;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从 1～n对应位上全部都是1</span></span><br><span class="line">        <span class="comment">// 由于下标从1开始，所以需要左移一个位置</span></span><br><span class="line">        endState = ((<span class="number">1</span>&lt;&lt;n)-<span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// System.out.println(endState);</span></span><br><span class="line">        <span class="comment">// 110</span></span><br><span class="line">        availNum = <span class="keyword">new</span> <span class="title class_">List</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            availNum[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>||j%i==<span class="number">0</span>)&#123;</span><br><span class="line">                    availNum[i].add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 实际上可以提前计算好对应位置上满足条件的数，然后进行搜索，这样可以减少一点没有意义的计算</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> state,<span class="type">int</span> currPos)</span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(state);</span></span><br><span class="line">        <span class="keyword">if</span>(state == endState)&#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : availNum[currPos])&#123;</span><br><span class="line">            <span class="comment">// 此处的i一定是满足条件的，可以直接拿去计算</span></span><br><span class="line">            <span class="keyword">if</span>((state &amp; (<span class="number">1</span>&lt;&lt;i)) == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(state|(<span class="number">1</span>&lt;&lt;i),currPos+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建记录</title>
    <url>/posts/96e0/</url>
    <content><![CDATA[<h1 id="552-学生出勤记录-ii">552. 学生出勤记录 II</h1>
<p>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：</p>
<ul>
<li>'A'：Absent，缺勤</li>
<li>'L'：Late，迟到</li>
<li>'P'：Present，到场</li>
</ul>
<p>如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：</p>
<p>按 <strong>总出勤</strong> 计，学生缺勤（'A'）<strong>严格</strong>
少于两天。 学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或
<strong>连续</strong> 3 天以上的迟到（'L'）记录。 给你一个整数 n
，表示出勤记录的长度（次数）。请你返回记录长度为 n
时，可能获得出勤奖励的记录情况 <strong>数量</strong>
。答案可能很大，所以返回对 10<sup>9</sup> + 7 <strong>取余</strong>
的结果。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/student-attendance-record-ii">https://leetcode-cn.com/problems/student-attendance-record-ii</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>该题是个困难题，难点在于如何归纳出状态转移方程，下面简单描述一下如何推倒出状态转移方程</p>
<p>首先依旧从dp[i]出发，设dp[i]表示长度为i的出勤记录中可以获得出勤奖励的记录数，接下来我们就要考虑状态之间的转移关系，</p>
<p>由dp[i-1]推倒出dp[i]</p>
<p>导致学生不能获得出勤奖励的条件有两个，缺勤次数大于1或者连续迟到3天以上，为了完整表示这些状态</p>
<ul>
<li>出勤记录中最后一次出勤情况（缺勤，迟到，到场）</li>
<li>当前出勤记录中是否已经有过缺勤</li>
<li>出勤记录的最后两次出勤情况是否是迟到</li>
</ul>
<p>从这三个角度出发，我们可以归纳出所有的状态</p>
<ul>
<li>最后一次出勤情况为缺勤</li>
<li>最后两次出勤情况都是迟到，且之前没有过缺勤</li>
<li>最后两次出勤情况都是迟到，且之前有过缺勤</li>
<li>最后一次出勤情况为迟到，但倒数第二次没有迟到，且之前没有缺勤</li>
<li>最后一次出勤情况为迟到，但倒数第二次没有迟到，且之前有过缺勤</li>
<li>最后一次出勤情况为到场，且之前没有缺勤</li>
<li>最后一次出勤情况为到场，切之前有过缺勤</li>
</ul>
<p>根据归纳出的状态，就可以写出状态转移方程 <span
class="math display">\[
\left\{
\begin{align*}
&amp; dp[i][0] = dp[i-1][1] + dp[i-1][3] + dp[i-1][5] \\
&amp; dp[i][1] = dp[i-1][3] \\
&amp; dp[i][2] = dp[i-1][4] \\
&amp; dp[i][3] = dp[i-1][5] \\
&amp; dp[i][4] = dp[i-1][0] + dp[i-1][6] \\
&amp; dp[i][5] = dp[i-1][1] + dp[i-1][3] + dp[i-1][5] \\
&amp; dp[i][6] = dp[i-1][0] + dp[i-1][2] + dp[i-1][4] + dp[i-1][6] \\
\end{align*}
\right.
\]</span></p>
<p>初始状态 dp[1,0] = 1, dp[1,3] = 1,dp[1,5] = 1，分别代表A，L，P</p>
<h3 id="普通版">普通版</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">checkRecord</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][<span class="number">7</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = ((dp[i-<span class="number">1</span>][<span class="number">1</span>]+dp[i-<span class="number">1</span>][<span class="number">3</span>])%MOD+dp[i-<span class="number">1</span>][<span class="number">5</span>])%MOD;</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i-<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i-<span class="number">1</span>][<span class="number">5</span>];</span><br><span class="line">            dp[i][<span class="number">4</span>] = (dp[i-<span class="number">1</span>][<span class="number">6</span>]+dp[i-<span class="number">1</span>][<span class="number">0</span>]) % MOD;</span><br><span class="line">            dp[i][<span class="number">5</span>] = ((dp[i-<span class="number">1</span>][<span class="number">1</span>]+dp[i-<span class="number">1</span>][<span class="number">3</span>])%MOD+dp[i-<span class="number">1</span>][<span class="number">5</span>])%MOD;</span><br><span class="line">            dp[i][<span class="number">6</span>] = (((dp[i-<span class="number">1</span>][<span class="number">0</span>]+dp[i-<span class="number">1</span>][<span class="number">2</span>])%MOD+dp[i-<span class="number">1</span>][<span class="number">4</span>])%MOD+dp[i-<span class="number">1</span>][<span class="number">6</span>])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">            res = (res + dp[n][i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间优化版">空间优化版</h3>
<p>由于dp[i]仅和dp[i-1]有关，可以直接使用7个数存储状态，然后不断更新即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] t = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">checkRecord</span><span class="params">(<span class="type">int</span> n)</span> &#123;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i) dp[i] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">5</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            t[<span class="number">0</span>] = ((dp[<span class="number">1</span>]+dp[<span class="number">3</span>])%MOD+dp[<span class="number">5</span>])%MOD;</span><br><span class="line">            t[<span class="number">1</span>] = dp[<span class="number">3</span>];</span><br><span class="line">            t[<span class="number">2</span>] = dp[<span class="number">4</span>];</span><br><span class="line">            t[<span class="number">3</span>] = dp[<span class="number">5</span>];</span><br><span class="line">            t[<span class="number">4</span>] = (dp[<span class="number">0</span>]+dp[<span class="number">6</span>]) % MOD;</span><br><span class="line">            t[<span class="number">5</span>] = ((dp[<span class="number">1</span>]+dp[<span class="number">3</span>])%MOD+dp[<span class="number">5</span>])%MOD;</span><br><span class="line">            t[<span class="number">6</span>] = (((dp[<span class="number">0</span>]+dp[<span class="number">2</span>])%MOD+dp[<span class="number">4</span>])%MOD+dp[<span class="number">6</span>])%MOD;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">7</span>;++j) dp[j] = t[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;++i)&#123;</span><br><span class="line">            res = (res + dp[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="矩阵快速幂优化">矩阵快速幂优化</h3>
<p>从空间优化版中可以看到，dp[i]仅依赖于dp[i-1]，如果将dp[i]看成一个行向量，根据递推公式，可以转换成矩阵乘法模式
<span class="math display">\[
dp[i] = dp[i-1] \cross
\left[
\begin{matrix}
0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0 \\
1&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1 \\
0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0 \\
1&amp;1&amp;0&amp;0&amp;0&amp;1&amp;1 \\
0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0 \\
1&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1 \\
0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0 \\
\end{matrix}
\right]
\]</span> 也即 <span class="math display">\[
dp[i] = dp[1] \cross
\left[
\begin{matrix}
0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0 \\
1&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1 \\
0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0 \\
1&amp;1&amp;0&amp;0&amp;0&amp;1&amp;1 \\
0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0 \\
1&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1 \\
0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0 \\
\end{matrix}
\right]^{i-1}
\]</span> 那么就可以使用矩阵快速幂进行计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">checkRecord</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span>[][] mat = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">long</span>[][] res = pow(mat, n);</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(res[<span class="number">0</span>]).sum();</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (sum % MOD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span>[][] pow(<span class="type">long</span>[][] mat, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">long</span>[][] ret = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ret = multiply(ret, mat);</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            mat = multiply(mat, mat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span>[][] multiply(<span class="type">long</span>[][] a, <span class="type">long</span>[][] b) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> a.length, columns = b[<span class="number">0</span>].length, temp = b.length;</span><br><span class="line">        <span class="type">long</span>[][] c = <span class="keyword">new</span> <span class="title class_">long</span>[rows][columns];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; temp; k++) &#123;</span><br><span class="line">                    c[i][j] += a[i][k] * b[k][j];</span><br><span class="line">                    c[i][j] %= MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>576. 出界的路径数</title>
    <url>/posts/318f/</url>
    <content><![CDATA[<h1 id="576-出界的路径数">576. 出界的路径数</h1>
<p>给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow,
startColumn]
。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你
<strong>最多</strong> 可以移动 maxMove 次球。</p>
<p>给你五个整数 m、n、maxMove、startRow 以及 startColumn
，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 +
7 取余 后的结果。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/out-of-boundary-paths">https://leetcode-cn.com/problems/out-of-boundary-paths</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>本题限制了球可以行走的最大步数，因此除了当前位置之外，当前所走过的步数也是状态的一部分，使用dp[x,y,s]来代表第s步时，球在(x,y)位置所有的出界路径数，那么，假设(x,y)为网格内部的一个点，那么其第s步时可以出界的总路径数为
<span class="math display">\[
dp[x,y,s] = dp[x-1,y,s-1]+dp[x+1,y,s-1]+dp[x,y-1,s-1]+dp[x,y+1,s-1]
\]</span> 也就是可到达(x,y)的所有坐标出界路径数之和</p>
<p>接下来考虑初始状态，对于网格的边界，可以一步就出界，因此只需要统计其出界次数即可，对于任何一个步骤，只要其在边界就可以直接出去</p>
<p>$$</p>
<p>$$</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>581. 最短无序连续子数组</title>
    <url>/posts/1722/</url>
    <content><![CDATA[<h1 id="581-最短无序连续子数组">581. 最短无序连续子数组</h1>
<p>给你一个整数数组 nums ，你需要找出一个 连续子数组
，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>请你找出符合题意的 最短 子数组，并输出它的长度。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray</a></p>
</blockquote>
<span id="more"></span>

<h2 id="双指针排序">双指针+排序</h2>
<p>看到整个数组变成升序排列，那么可以直接将数组排序，之后对比两个数组，然后使用双指针找出连续子数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 只需要将nums中对应的数组变成有序，整个数组就会变成有序</span></span><br><span class="line">        <span class="comment">// 需要找出这个子数组的最短长度</span></span><br><span class="line">        <span class="comment">// [2,6,4,8,10,9,15]</span></span><br><span class="line">        <span class="comment">// [2,4,6,8,9,10,15]</span></span><br><span class="line">        <span class="comment">// 一种可行的思路？先对nums排序，然后找出那些位置不会发生变化的，最后只需要将其变成有序就可以？</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(temp);</span><br><span class="line">        <span class="comment">// 双指针，从数组两端开始，找到不同时就可以结束了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[l] != nums[l]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[r] != nums[r])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r-l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(nlogn)</p>
<p>空间复杂度：o(n)</p>
<h2 id="双指针线性扫描">双指针+线性扫描</h2>
<p>实际上数组nums可以划分成3个子数组[numsA,numsB,numsC]，其中numsA和numsC都是有序的，而numsB是无序的，只需要找到最长的numsA和numsC就可以确定最短的numsB，由于对numsB排序后整个数组为有序的，那么可以很容易知道，对于numsA中任意一个数，都有numsA[i]
&lt; [numsB,numsC]，同理对于numsC中任意一个数，都有numsC[i] &gt;
[numsA,numsB]</p>
<p>通过这个条件，遍历数组nums，不断更新满足条件的边界值，最后就可以找到numsB的最小左右边界</p>
<p>拿数组 [2,6,4,8,10,9,15] 为例</p>
<p>对于numsA[i]，可以发现到6的时候不满足条件，因为其右边的值比他小，此时l=1</p>
<p>对于numsC[i]，可以发现到9的时候不满足条件，因为其左边的值比他大，此时r=5</p>
<p>最后直接用r-l+1就可以得出numsB的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxn</span> <span class="operator">=</span> Integer.MIN_VALUE, right = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minn</span> <span class="operator">=</span> Integer.MAX_VALUE, left = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(right+&quot; &quot;+left+&quot; &quot;+maxn+&quot; &quot;+minn);</span></span><br><span class="line">            <span class="comment">// maxn从左边开始找</span></span><br><span class="line">          	<span class="comment">// 从左往右看，发现有maxn大于nums[i]，那么此时对于nums数组而言，是肯定需要交换的，也就是说这个值一定是在numsB范围内</span></span><br><span class="line">            <span class="keyword">if</span> (maxn &gt; nums[i]) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// minn从右边开始找</span></span><br><span class="line">            <span class="keyword">if</span> (minn &lt; nums[n - i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left = n - i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                minn = nums[n - i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(right+&quot; &quot;+left+&quot; &quot;+maxn+&quot; &quot;+minn);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right == -<span class="number">1</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以数组 [2,2,2,3,3,3,1,1,1,4,4,4] 为例展示计算过程</p>
<p>初始化 ：</p>
<p>maxn = Integer.MIN_VALUE</p>
<p>minn = Integer.MAX_VALUE</p>
<p>l = -1</p>
<p>r = -1</p>
<p>iter1：</p>
<p>对于maxn，从左往右开始遍历，此时nums[0] = 2 &gt; maxn =
Integer.MIN_VALUE</p>
<p>需要更新maxn的值，maxn = 2</p>
<p>对于minn，从右往左开始遍历，此时nums[11] = 4 &lt; minn =
Integer.MAX_VALUE</p>
<p>需要更新minn的值，minn=4</p>
<p>iter2：</p>
<p>此时nums[1] = 2 == maxn = 2，维持maxn=2</p>
<p>此时nums[10] = 4 == minn = 4，维持minn=4</p>
<p>iter3：</p>
<p>此时nums[2] = 2 == maxn = 2，维持maxn=2</p>
<p>此时nums[9] = 4 == minn = 4，维持minn=4</p>
<p>iter4：</p>
<p>此时nums[3] = 3 &gt; maxn = 2，更新maxn=3</p>
<p>此时nums[8] = 1 &lt; minn = 4，更新minn=1</p>
<p>iter5：</p>
<p>此时nums[4] = 3 == maxn = 3，维持maxn=3</p>
<p>此时nums[7] = 1 == minn = 1，维持minn=1</p>
<p>iter6：</p>
<p>此时nums[5] = 3 == maxn = 3，维持maxn=3</p>
<p>此时nums[6] = 1 == minn = 1，维持minn=1</p>
<p>iter7：</p>
<p>此时nums[6] = 1 &lt; maxn = 3，更新right=6</p>
<p>此时nums[5] = 3 &gt; minn = 1，更新left=5</p>
<p>iter8：</p>
<p>此时nums[7] = 1 &lt; maxn = 3，更新right=7</p>
<p>此时nums[4] = 3 &gt; minn = 1，更新left=4</p>
<p>iter9：</p>
<p>此时nums[8] = 1 &lt; maxn = 3，更新right=8</p>
<p>此时nums[3] = 3 &gt; minn = 1，更新left=3</p>
<p>iter10:</p>
<p>此时nums[9] = 4 &gt; maxn = 3，更新maxn=4</p>
<p>此时nums[2] = 2 &gt; minn = 1，更新left=2</p>
<p>iter11：</p>
<p>此时nums[10] = 4 &gt; maxn = 3，维持maxn=4</p>
<p>此时nums[1] = 2 &gt; minn = 1，更新left=1</p>
<p>iter12：</p>
<p>此时nums[11] = 4 &gt; maxn = 3，维持maxn=4</p>
<p>此时nums[0] = 2 &gt; minn = 1，更新left=0</p>
<p>最后可以得到left=0，right=8，需要排序的最长连续子序列长度就是right-left+1
= 9</p>
<p>看完计算流程后，其实还是有点蒙，需要再多理解几遍</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>5832. 构造元素不等于两相邻元素平均值的数组</title>
    <url>/posts/458d/</url>
    <content><![CDATA[<h1 id="5832-构造元素不等于两相邻元素平均值的数组">5832.
构造元素不等于两相邻元素平均值的数组</h1>
<p>给你一个 下标从 0 开始 的数组 nums ，数组由若干
<strong>互不相同的</strong>
整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都
不等于 其两侧相邻元素的 平均值 。</p>
<p>更公式化的说法是，重新排列的数组应当满足这一属性：对于范围 1 &lt;= i
&lt; nums.length - 1 中的每个 i ，(nums[i-1] + nums[i+1]) / 2 不等于
nums[i] 均成立 。</p>
<p>返回满足题意的任一重排结果。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors">https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors</a></p>
</blockquote>
<span id="more"></span>

<h2 id="排序">排序</h2>
<p>这个题关键在于思路，如果没有想到很好的构造方法就会卡很久。这个方法也是看题解看到的，如果要使
<span class="math display">\[
\frac{nums[i-1] + nums[i+1]}{2} = nums[i]
\]</span> 则一定有 nums[i-1] &lt; nums[i] &lt; nums[i+1] 或 nums[i+1]
&lt; nums[i] &lt; nums[i-1]
，即满足nums[i]两边的数一个比nums[i]大，一个比nums[i]小，那么从这个角度我们就可以想到构造方案了，是否可以使数组中的数其两边值要么都比他大，要么都比他小呢？其实上只需要对nums进行排序，然后预先将奇数索引填上，再填上偶数索引，就一定满足条件。</p>
<p>知道了思路，代码写起来就很简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] rearrangeArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ptr</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">// 填奇数位上的值</span></span><br><span class="line">        <span class="keyword">while</span>(ptr &lt; nums.length)&#123;</span><br><span class="line">            res[ptr] = nums[i];</span><br><span class="line">            ++i;</span><br><span class="line">            ptr+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr = <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">// 再偶数位上的值</span></span><br><span class="line">        <span class="keyword">while</span>(ptr &lt; nums.length)&#123;</span><br><span class="line">            res[ptr] = nums[i];</span><br><span class="line">            ++i;</span><br><span class="line">            ptr += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>5840. 使字符串平衡的最小交换次数</title>
    <url>/posts/16f9/</url>
    <content><![CDATA[<h1 id="5840-使字符串平衡的最小交换次数">5840.
使字符串平衡的最小交换次数</h1>
<p>给你一个字符串 s ，<strong>下标从 0 开始</strong> ，且长度为偶数 n
。字符串 恰好 由 n / 2 个开括号 '[' 和 n / 2 个闭括号 ']' 组成。</p>
<p>只有能满足下述所有条件的字符串才能称为 <strong>平衡字符串</strong>
：</p>
<ul>
<li>字符串是一个空字符串，或者</li>
<li>字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者</li>
<li>字符串可以写成 [C] ，其中 C 是一个 平衡字符串 。</li>
</ul>
<p>你可以交换 <strong>任意</strong> 两个下标所对应的括号
<strong>任意</strong> 次数。</p>
<p>返回使 s 变成 <strong>平衡字符串</strong> 所需要的
<strong>最小</strong> 交换次数。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-string-balanced">https://leetcode-cn.com/problems/minimum-number-of-swaps-to-make-the-string-balanced</a></p>
</blockquote>
<span id="more"></span>

<h2 id="双指针贪心">双指针+贪心</h2>
<p>从左往右遍历，同时记录括号的嵌套深度，当发现当前嵌套深度为0且为 ]
的时候，就一定要进行交换，那么就从后往前找到第一个'['即可</p>
<blockquote>
<p>但是这样做为什么一定可以得到最优呢？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwaps</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] charArr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:charArr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                ++depth;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 碰到了&#x27;]&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(depth == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 需要从右边找一个&#x27;[&#x27;进行交换</span></span><br><span class="line">                    <span class="keyword">while</span>(charArr[right] != <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                        --right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    charArr[right] = <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                    <span class="comment">// 交换了之后嵌套深度增加</span></span><br><span class="line">                    ++depth;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    --depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历结束后depth一定是0</span></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学栈">数学+栈</h2>
<p>可以在遍历时消除匹配的括号对，最后留下的一定是类似于
"]]][["这种形式的字符串，而这种形式实际上转换成平衡的最小次数是有计算公式的</p>
<p>设共包含 k 个 '['</p>
<ul>
<li>当 k 为偶数的时候，例如 "]]]][[[["，此时只需要交换 k/2 次
，因为这一种和"<code>[][][][]</code>"重合的是最多的</li>
<li>当 k 为奇数的时候，例如
"]]][[["，此时先交换左右两端的括号，之后中间的k-1对就是偶数，可以按照偶数的计算，最终交换次数为1+(k-1)/2</li>
</ul>
<p>实际上 k/2 和 1 + (k-1)/2 可以组合起来，就是 Math.floor((k+1)/2)</p>
<p>在遍历过程中将左括号入栈，每碰到一个右括号就将其出栈，当栈为空的时候说明这个一定是不匹配的，最终可以统计出k的长度，然后按公式输出即可（实际上也可以不用栈，用一个数记录当前的嵌套深度，当深度为0且碰到']'是就是不匹配的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwaps</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] charArr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:charArr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 累加 [ 的个数</span></span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历结束后depth一定是0</span></span><br><span class="line">        <span class="comment">// 最后剩下的cnt就代表未能匹配的括号对数</span></span><br><span class="line">        <span class="comment">// System.out.println(cnt);</span></span><br><span class="line">        <span class="comment">// Math.floot((cnt+1)/2)</span></span><br><span class="line">        <span class="keyword">return</span> (cnt+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>5844. 数组元素的最小非零乘积</title>
    <url>/posts/6cbc/</url>
    <content><![CDATA[<h1 id="5844-数组元素的最小非零乘积">5844. 数组元素的最小非零乘积</h1>
<p>给你一个正整数 p 。你有一个下标从 <strong>1</strong> 开始的数组 nums
，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都
<strong>包含</strong>）。你可以进行以下操作 <strong>任意</strong>
次：</p>
<ul>
<li>从 nums 中选择两个元素 x 和 y 。</li>
<li>选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数
<strong>相同位置</strong> 的二进制位。</li>
</ul>
<p>比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x
= 1111 和 y = 0001 。</p>
<p>请你算出进行以上操作 <strong>任意次</strong> 以后，nums 能得到的
<strong>最小非零</strong> 乘积。将乘积对 10<sup>9</sup> + 7
<strong>取余</strong> 后返回。</p>
<p>注意：答案应为取余 <strong>之前</strong> 的最小值。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements">https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements</a></p>
</blockquote>
<span id="more"></span>

<h2 id="贪心快速幂">贪心+快速幂</h2>
<blockquote>
<p>对于两个二进制数x，y，如果交换二者对应位置的位，实际上二者的和不会发生变化，但是乘积会变</p>
<p>证明：</p>
<p>对于对应位置的位，有两种情况，相同或不同</p>
<p>相同的时候，交换了之后数字不变，和当然不变</p>
<p>不同的时候，不妨设x对应位为1，y对应位为0，设对应位的bit序为k，那么x交换之后的值为</p>
<p>x-(1&lt;&lt;k)，而y交换之后的值为y+(1&lt;&lt;k)，这样x+y的和不变，得证</p>
<p>要使得二者乘积最小，那么就应该尽可能拉大二者距离，这样使得乘积尽可能小</p>
</blockquote>
<p>这个题也挺有意思的，数据范围不大，但是算起来很讲究，知道前面几个值如何计算后就可以推出计算公式了</p>
<p>当 p = 1 时，数组 = [1]</p>
<p>乘积为1</p>
<p>当 p = 2 时，数组 = [01,10,11]</p>
<p>此时无论如何交换值都不会变，乘积为6</p>
<p>当 p = 3 时，数组 = [001,010,011,100,101,110,111]</p>
<p>首先 001
没什么好变的，直接看第二个，由于交换对应位后和不变，那么应该再和不变情况下尽可能多制造1</p>
<p>这样将 010 和 101 交换第一位，变成 110 和 001</p>
<p>对于 011 也是同理，将其和 100 交换第二位，也变成 110和001</p>
<p>此时无法再制造更多1，此时乘积达到最小</p>
<p>乘积为 6*6*6*7 = 6^3*7</p>
<p>当 p = 4 时，数组 =
[0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111]</p>
<p>同样的思路，制造更多的1，最终数组可以变成</p>
<p>[0001,0001,0001,0001,0001,0001,0001,1110,1110,1110,1110,1110,1110,1110,1111]</p>
<p>乘积为 14*14*14*14*14*14*14*15 = 14^7*15</p>
<p>算完这四个，可以大概最小乘积计算公式 <span class="math display">\[
res = (2^p-1)*(2^p-2)^{2^{p-1}-1}
\]</span> 这时候再来看数据范围，p最大可取60</p>
<p>也就是说最大结果需要计算 <span class="math display">\[
(2^{60}-1)*(2^{60}-2)^{2^{59}-1}
\]</span>
很明显，如果不使用快速幂计算的话就是一个指数级别的，需要使用快速幂算法将其时间复杂度降为o(p)</p>
<p>这里不赘述快速幂算法，详见 <strong>剑指 Offer 16.
数值的整数次方</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">modder</span> <span class="operator">=</span> (<span class="type">long</span>) <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minNonZeroProduct</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="comment">// 实际上多推几个就可以找到规律</span></span><br><span class="line">        <span class="comment">// p = 1 res = 1</span></span><br><span class="line">        <span class="comment">// p = 2 res = 6</span></span><br><span class="line">        <span class="comment">// p = 3 res = 6^3*7</span></span><br><span class="line">        <span class="comment">// p = 4 res = 14^7*15</span></span><br><span class="line">        <span class="comment">// p = 5 res = 30^15*31</span></span><br><span class="line">        <span class="comment">// 但是很明显的是，30^15一定会溢出，因此在计算的过程中就需要取模</span></span><br><span class="line">        <span class="comment">// 由于 1&lt;= p &lt;= 60</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">v</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; p) - <span class="number">2L</span>;</span><br><span class="line">        <span class="comment">// 必须使用快速幂，否则算不过来</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; (p-<span class="number">1</span>)) - <span class="number">1L</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> (pow(v,n)*((v+<span class="number">1</span>)%modder))%modder;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">pow</span><span class="params">(<span class="type">long</span> x, <span class="type">long</span> n)</span>&#123;</span><br><span class="line">        x %= modder;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span> )&#123;</span><br><span class="line">                res = (res * x) % modder;</span><br><span class="line">            &#125;</span><br><span class="line">            x = (x * x) % modder;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>5856. 完成任务的最少工作时间段</title>
    <url>/posts/c1af/</url>
    <content><![CDATA[<h1 id="5856-完成任务的最少工作时间段">5856.
完成任务的最少工作时间段</h1>
<p>你被安排了 n 个任务。任务需要花费的时间用长度为 n 的整数数组 tasks
表示，第 i 个任务需要花费 tasks[i] 小时完成。一个 工作时间段 中，你可以
至多 连续工作 sessionTime 个小时，然后休息一会儿。</p>
<p>你需要按照如下条件完成给定任务：</p>
<p>如果你在某一个时间段开始一个任务，你需要在 同一个 时间段完成它。
完成一个任务后，你可以 立马 开始一个新的任务。 你可以按 任意顺序
完成任务。 给你 tasks 和 sessionTime
，请你按照上述要求，返回完成所有任务所需要的 最少 数目的 工作时间段
。</p>
<p>测试数据保证 sessionTime 大于等于 tasks[i] 中的 最大值 。</p>
<p>提示：</p>
<ul>
<li>n == tasks.length</li>
<li>1 &lt;= n &lt;= 14</li>
<li>1 &lt;= tasks[i] &lt;= 10</li>
<li>max(tasks[i]) &lt;= sessionTime &lt;= 15</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks">https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks</a></p>
</blockquote>
<span id="more"></span>

<h2 id="题目理解">题目理解</h2>
<p>这一题实际也可以理解成背包问题，将tasks看成n个物品，每个物品重量为tasks[i]，背包容量为sessionTime，然后问至少需要多少次才能把这些物品全部拿走</p>
<h2 id="状态压缩动态规划">状态压缩+动态规划</h2>
<h3 id="写法1暴力">写法1（暴力）</h3>
<p>自己在周赛时瞎写的，居然过了，差点超时</p>
<p>思路如下：</p>
<p>使用dp[i,state]表示在第i个工作时间段后能否完成state表示的所有任务，状态转移方程
<span class="math display">\[
dp[i,state] = dp[i-1,state/sub] \and sum(sub)&lt;sessionTime
\]</span>
其中sub代表state的一个子集，state/sub表示state除去sub之和剩下的元素，实际也很好理解，假设在第i-1轮时完成了state/sub表示的任务，那么如果sub所表示的任务可以在sessionTime完成，那么dp[i,state]也就可以完成，很明显dp[i]仅依赖于dp[i-1]，可以将空间压缩至o(2^l)</p>
<p>计算时需要从0开始，不断更新，初态dp[0,*] = false</p>
<p>实现代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">int</span>[] tasks;</span><br><span class="line">    <span class="type">int</span> sessionTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSessions</span><span class="params">(<span class="type">int</span>[] _tasks, <span class="type">int</span> _sessionTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sessionTime = _sessionTime;</span><br><span class="line">        <span class="built_in">this</span>.tasks = _tasks;</span><br><span class="line">        <span class="built_in">this</span>.l = tasks.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">endState</span> <span class="operator">=</span> (<span class="number">1</span>&lt;&lt;l)-<span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[endState+<span class="number">1</span>];</span><br><span class="line">      	<span class="comment">// 从0开始，生成第一步可行的搬法</span></span><br><span class="line">        dfs(dp,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 最多也就l轮</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">round</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!dp[endState])&#123;</span><br><span class="line">            <span class="type">boolean</span>[] temp = <span class="keyword">new</span> <span class="title class_">boolean</span>[endState+<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// printArr(dp);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=endState;++j)&#123;</span><br><span class="line">                <span class="comment">// 前一轮不行的，这一轮当然也不行</span></span><br><span class="line">                <span class="keyword">if</span>(!dp[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 目前已知state/sub，需要反推state</span></span><br><span class="line">                dfs(temp,j);</span><br><span class="line">            &#125;</span><br><span class="line">            dp = temp;</span><br><span class="line">            ++round;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> round;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printArr</span><span class="params">(<span class="type">boolean</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">boolean</span> b:arr)&#123;</span><br><span class="line">            System.out.print(b+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">boolean</span>[] dp,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="comment">// 首先找出target上所有为0的位置</span></span><br><span class="line">        <span class="type">int</span>[] t = <span class="keyword">new</span> <span class="title class_">int</span>[l];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((target&amp;(<span class="number">1</span>&lt;&lt;i)) == <span class="number">0</span>)&#123;</span><br><span class="line">                t[size++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举sub的子集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>&lt;&lt;size;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;end;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> target;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i &amp; (<span class="number">1</span>&lt;&lt;j)) != <span class="number">0</span>)&#123;</span><br><span class="line">                    cost += tasks[t[j]];</span><br><span class="line">                    mask |= <span class="number">1</span>&lt;&lt;t[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        		<span class="comment">// 计算sum(sub) , 实际上就是 dp[i,state] = dp[i-1,state/sub] &amp;&amp; sum(sub) &lt;= sessionTime</span></span><br><span class="line">            dp[mask] = dp[mask] || (cost &lt;= sessionTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化">优化</h3>
<blockquote>
<p>作者：detachmliu 链接：<a
href="https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solution/zhuang-ya-dpshi-shi-hou-xue-xi-yi-xia-li-q4mk/">https://leetcode-cn.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solution/zhuang-ya-dpshi-shi-hou-xue-xi-yi-xia-li-q4mk/</a>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSessions</span><span class="params">(<span class="type">int</span>[] tasks, <span class="type">int</span> sessionTime)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tasks.length, m = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        Arrays.fill(dp, INF);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预处理每个状态，合法状态预设为 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> i, idx = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">spend</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (state &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> state &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (bit == <span class="number">1</span>) &#123;</span><br><span class="line">                    spend += tasks[idx];</span><br><span class="line">                &#125;</span><br><span class="line">                state &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (spend &lt;= sessionTime) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对每个状态枚举子集，跳过已经有最优解的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span>; j = (j - <span class="number">1</span>) &amp; i) &#123;</span><br><span class="line">                <span class="comment">// i 状态的最优解可能由当前子集 j 与子集 j 的补集得来</span></span><br><span class="line">                dp[i] = Math.min(dp[i], dp[j] + dp[i ^ j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>611. 有效三角形的个数</title>
    <url>/posts/2669/</url>
    <content><![CDATA[<h1 id="611-有效三角形的个数">611. 有效三角形的个数</h1>
<p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/valid-triangle-number/">https://leetcode-cn.com/problems/valid-triangle-number/</a></p>
</blockquote>
<span id="more"></span>

<h2 id="题目理解">题目理解</h2>
<p>这个题目没什么好说的，在数组中找三个数，使其满足三角形三条边条件（任意两边之和大于第三边）即可</p>
<ul>
<li>a+b &gt; c</li>
<li>a+c &gt; b</li>
<li>b+c &gt; a</li>
</ul>
<p>假设a、b、c之间存在偏序关系a&lt;b&lt;c，那么a+c&gt;b和b+c&gt;a是一定满足的，因此只需要将数组排序后寻找所有满足条件的c，满足c&gt;a+b即可，由于数组已是有序，可以使用二分查找找到第一个a+b=c的位置，而在之前的数就都满足这个条件</p>
<h2 id="排序暴力">排序+暴力</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">triangleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;length;++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;length;++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i] + nums[j] &gt; nums[k])&#123;</span><br><span class="line">                        ++res;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^3)</p>
<p>空间复杂度：o(logn)的栈空间</p>
<h2 id="排序二分查找">排序+二分查找</h2>
<p>相对于暴力枚举，只需要遍历k时将线性查找转换为二分查找，快速定位第一个满足条件的k的位置，就可以实现快速统计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">triangleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">              	<span class="comment">// 原本这里是线性查找，现在优化成二分查找</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = n - <span class="number">1</span>, k = j;</span><br><span class="line">                <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> nums[i] + nums[j];</span><br><span class="line">                <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                        k = mid;</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right = mid - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res += k - j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^2*logn)</p>
<p>空间复杂度：o(logn)栈空间</p>
<h2 id="排序双指针">排序+双指针</h2>
<p>在上述方法中，每次都需要无论是线性查找还是使用二分查找，都是重新在数组中找到满足
nums[k] &lt; nums[i] + nums[j]
的最大数，但是由于nums是一个有序的数组，当i和j在不断增加的过程中，k也一定是不断增加的，因此可以将k和j看成两个同向（递增）移动的指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">triangleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (k + <span class="number">1</span> &lt; n &amp;&amp; nums[k + <span class="number">1</span>] &lt; nums[i] + nums[j]) &#123;</span><br><span class="line">                    ++k;</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">// 有可能出现不存在的情况，此时k就是i，k-j一定小于0，需要排除</span></span><br><span class="line">                ans += Math.max(k - j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看上有三重循环，但是由于k和j实际上同步增加，因此该算法的时间复杂度为o(n^2)，关键在于利用了数组的有序性，不需要每次从头查找满足条件的值</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>787. K站中转内最便宜的航班</title>
    <url>/posts/64ef/</url>
    <content><![CDATA[<h1 id="787-k站中转内最便宜的航班">787. K站中转内最便宜的航班</h1>
<p>有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] =
[fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 toi 抵达
pricei。</p>
<p>现在给定所有的城市和航班，以及出发城市 src 和目的地
dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的
价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops">https://leetcode-cn.com/problems/cheapest-flights-within-k-stops</a></p>
</blockquote>
<span id="more"></span>

<h2 id="bfs剪枝">BFS+剪枝</h2>
<p>这个题是一个限制路径长度的最短路径问题，我们可以遍历所有从src出发到dst的路径，然后找出在k站中转内的最小花费，由于直接搜索太花费时间，需要使用一些剪枝技巧来加快搜素</p>
<p>主要使用的剪枝策略有两个：</p>
<ul>
<li>记录当前节点到各个节点的最小花费，当src到达节点i的花费已经大于目前的最小花费时，就没有必要再次进行搜索了，可以直接跳过</li>
<li>记录从src到达dst的最小花费，当src到达节点i的花费已经大于这个最小花费时，没有继续搜素的必要，因为最终到达终点的花费一定会大于当前的最小花费</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;<span class="type">int</span>[]&gt; emptyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 找到所有从src开始的</span></span><br><span class="line">        Map&lt;Integer,List&lt;<span class="type">int</span>[]&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] flight:flights)&#123;</span><br><span class="line">            List&lt;<span class="type">int</span>[]&gt; list = map.getOrDefault(flight[<span class="number">0</span>],<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;());</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;flight[<span class="number">1</span>],flight[<span class="number">2</span>]&#125;);</span><br><span class="line">            map.put(flight[<span class="number">0</span>],list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] p :map.getOrDefault(src,emptyList))&#123;</span><br><span class="line">            queue.offer(p);</span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dist,Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span> &amp;&amp; k&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// k代表的是中转站的数目</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span>[] curr = queue.poll();</span><br><span class="line">                --size;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> curr[<span class="number">0</span>],cost=curr[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 当可以到达终点的时候进行判断</span></span><br><span class="line">                <span class="keyword">if</span>(mid == dst)&#123;</span><br><span class="line">                    minVal = Math.min(cost,minVal);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 存储当前路径值</span></span><br><span class="line">                <span class="comment">// 当第一访问到节点curr[0]的时候，其cost一定是最小的，当第二次时一定会大于该值，说明就已经访问过了</span></span><br><span class="line">                <span class="comment">// 记录从src到节点curr[0]的cost</span></span><br><span class="line">                <span class="keyword">if</span>(cost &gt;= dist[curr[<span class="number">0</span>]])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dist[mid] = cost;</span><br><span class="line">                <span class="comment">// 很明显这里搜索的时候进行了很多不必要的搜索，完全没有必要走回头路</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span>[] p:map.getOrDefault(mid,emptyList))&#123;</span><br><span class="line">                    <span class="comment">// 还可以进行一波剪枝，当当前花费已经很多的时候，就没有必要进行搜索了，再进行搜索也没有任何意义</span></span><br><span class="line">                    <span class="keyword">if</span>(cost + p[<span class="number">1</span>] &lt; minVal)&#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;p[<span class="number">0</span>],cost+p[<span class="number">1</span>]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[dst] == Integer.MAX_VALUE ? -<span class="number">1</span> : dist[dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dfs剪枝">DFS+剪枝</h2>
<p>DFS的思路和BFS差不多，只是换成递归+回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;<span class="type">int</span>[]&gt; emptyList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,List&lt;<span class="type">int</span>[]&gt;&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> minVal,dst;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] flights, <span class="type">int</span> _src, <span class="type">int</span> _dst, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] f:flights)&#123;</span><br><span class="line">            List&lt;<span class="type">int</span>[]&gt; list = map.getOrDefault(f[<span class="number">0</span>],<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;f[<span class="number">1</span>],f[<span class="number">2</span>]&#125;);</span><br><span class="line">            map.put(f[<span class="number">0</span>],list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(map);</span></span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        dst = _dst;</span><br><span class="line">        minVal = Integer.MAX_VALUE;</span><br><span class="line">        dfs(_src,k,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> minVal == Integer.MAX_VALUE ? -<span class="number">1</span> : minVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> src,<span class="type">int</span> step,<span class="type">int</span> cost)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(src == dst) &#123;</span><br><span class="line">            minVal = Math.min(minVal,cost);</span><br><span class="line">            <span class="comment">// System.out.println(&quot;reach dst: &quot;+minVal);</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(step == -<span class="number">1</span> || cost &gt;= minVal) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] p:map.getOrDefault(src,emptyList))&#123;</span><br><span class="line">            <span class="comment">// System.out.println(src+&quot; &quot;+p[0]+&quot; &quot;+p[1]);</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[p[<span class="number">0</span>]])&#123;</span><br><span class="line">                visited[p[<span class="number">0</span>]] = <span class="literal">true</span>;</span><br><span class="line">                dfs(p[<span class="number">0</span>],step-<span class="number">1</span>,cost+p[<span class="number">1</span>]);</span><br><span class="line">                visited[p[<span class="number">0</span>]] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际运行效果并不好，会超时</p>
<h2 id="动态规划">动态规划</h2>
<p>由于需要在k+1步内找到从src到达dst的最小花费，使用dp[i,j]代表第i步到达j的最小花费，初始时dp[i,j]
= INF，dp[0,src] = 0</p>
<p>状态转移方程 <span class="math display">\[
dp[i,j] = min(dp[i-1,k]+cost[k,j],dp[i,j])
\]</span> 有了这个，代码写起来就很简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">2</span>][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k + <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="number">0x7f7f7f7f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][src] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1</span>; t &lt;= k + <span class="number">1</span>; ++t) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] flight : flights) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> flight[<span class="number">0</span>], i = flight[<span class="number">1</span>], cost = flight[<span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 这里是直接加的，因此dp[i][j]初始值不能是Integer.MAX_VALUE，要不然就会溢出</span></span><br><span class="line">                dp[t][i] = Math.min(dp[t][i], dp[t - <span class="number">1</span>][j] + cost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1</span>; t &lt;= k + <span class="number">1</span>; ++t) &#123;</span><br><span class="line">            res = Math.min(res, dp[t][dst]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">0x7f7f7f7f</span> ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>802. 找到最终的安全状态</title>
    <url>/posts/9b1b/</url>
    <content><![CDATA[<h1 id="802-找到最终的安全状态">802. 找到最终的安全状态</h1>
<p>在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。</p>
<p>对于一个起始节点，如果从该节点出发，<strong>无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是
安全</strong> 的。</p>
<p>返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按
升序 排列。</p>
<p>该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph
的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i,
j) 是图的一条有向边。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/find-eventual-safe-states">https://leetcode-cn.com/problems/find-eventual-safe-states</a></p>
</blockquote>
<span id="more"></span>

<h2 id="dfs--状态标记">dfs + 状态标记</h2>
<p>如果采用常规的dfs算法，可以枚举图中的所有路径，判断该路径是否为环，如果是环则说明该节点不是安全的，但是这样每次都会进行重复搜索，时间复杂度过高，可以使用剪枝操作减少搜索树大小，使用visited数组来判断是否出现环，同时对于后续节点，可以优先判断其是否是安全节点，可以将结果存储在safe数组中，当再次访问到该节点时就可以直接返回，不需要进行重复判断了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] graph;</span><br><span class="line">    <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="type">boolean</span>[] safe;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">eventualSafeNodes</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="comment">// graph是图的临接表，表示该节点相连的所有节点</span></span><br><span class="line">        <span class="comment">// 题目要求是，从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点</span></span><br><span class="line">        <span class="comment">// 也就是说不能存在环，如果有环则必定不能在有限步内到达终点</span></span><br><span class="line">        <span class="comment">// 找到图中的环，删去所有环上的节点？</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[length];</span><br><span class="line">        <span class="built_in">this</span>.safe = <span class="keyword">new</span> <span class="title class_">boolean</span>[length];</span><br><span class="line">        <span class="built_in">this</span>.graph = graph;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(i))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node)</span>&#123;</span><br><span class="line">      	<span class="comment">// 碰到已经访问过的节点，如果是安全节点</span></span><br><span class="line">        <span class="keyword">if</span>(visited[node])&#123;</span><br><span class="line">            <span class="keyword">return</span> safe[node];</span><br><span class="line">        &#125;</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 从该节点出发</span></span><br><span class="line">        <span class="comment">// 如果该节点的所有节点都可以到达终点，说明是一个安全节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:graph[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处需要将操作还原</span></span><br><span class="line">        <span class="comment">// 如果此处还原的话，就会产生很多不必要的重复计算，导致超时</span></span><br><span class="line">        <span class="comment">// visited[node] = false;</span></span><br><span class="line">        safe[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
<p>写法2：</p>
<p>事实上，上面的safe数组和visited数组用数字状态来表示，共包含三个状态值</p>
<ul>
<li>0：表示该节点未访问</li>
<li>1：该节点仍在递归栈中</li>
<li>2：该节点是安全节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] graph;</span><br><span class="line">    <span class="type">int</span>[] color;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">eventualSafeNodes</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="comment">// graph是图的临接表，表示该节点相连的所有节点</span></span><br><span class="line">        <span class="comment">// 题目要求是，从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点</span></span><br><span class="line">        <span class="comment">// 也就是说不能存在环，如果有环则必定不能在有限步内到达终点</span></span><br><span class="line">        <span class="comment">// 找到图中的环，删去所有环上的节点？</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="built_in">this</span>.color = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="built_in">this</span>.graph = graph;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="comment">// Arrays.fill(visited,false);</span></span><br><span class="line">            <span class="keyword">if</span>(dfs(i))&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs(1);</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node)</span>&#123;</span><br><span class="line">        <span class="comment">// 当color[node] 大于 0 就说明这个节点已经访问过了，不需要再次访问</span></span><br><span class="line">        <span class="keyword">if</span>(color[node] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> color[node] == <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历该节点的所有相邻节点</span></span><br><span class="line">        color[node] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:graph[node])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当该节点的所有路径都可以到达终点，说明该节点是一个安全节点</span></span><br><span class="line">        color[node] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反向图拓扑排序">反向图+拓扑排序</h2>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/find-eventual-safe-states/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-isy6u/">【宫水三叶の相信科学系列】详解何为拓扑排序，以及求拓扑排序方法的正确性证明
- 找到最终的安全状态 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<p>在图论问题中，一个有向无环图必然存在至少一个拓扑序与之对应，反之亦然。</p>
<p>简单来说，就是将图中的所有节点展开成一维序列，对于序列中任意的节点(u,v)，如果在序列中u在v的前面，则说明图中存在从u到达v的通路，反之亦然</p>
<p>同时，我们需要知道图论中两个基本概念</p>
<ul>
<li>出度：有多少条边直接指向该节点</li>
<li>入度：由该节点指出的边有多少条</li>
</ul>
<p>因此，对于有向图的拓扑排序，我们可以使用如下思路输出拓扑序（BFS方式）</p>
<ol type="1">
<li>起始时，将所有入度为 0 的节点进行入队（入度为
0，说明没有边指向这些节点，将它们放到拓扑排序的首部，不会违反拓扑序定义）；</li>
<li><strong>从队列中进行节点出队操作，出队序列就是对应我们输出的拓扑序</strong>。
对于当前弹出的节点 x，遍历 x 的所有出度，即遍历所有由 x 直接指向的节点
y，对 y 做入度减一操作（因为 x
节点已经从队列中弹出，被添加到拓扑序中，等价于从 x
节点从有向图中被移除，相应的由 x 发出的边也应当被删除，带来的影响是与 x
相连的节点 y 的入度减一）；</li>
<li>对 y 进行入度减一之后，检查 y 的入度是否为 0，如果为 0 则将 y
入队（当 y 的入度为 0，说明有向图中在 y
前面的所有的节点均被添加到拓扑序中，此时 y
可以作为拓扑序的某个片段的首部被添加，而不是违反拓扑序的定义）；</li>
<li>循环流程 2、3 直到队列为空。</li>
</ol>
<p><strong>证明</strong>：</p>
<p>上述 BFS
方法能够求得「某个有向无环图的拓扑序」的前提是：我们必然能够找到（至少）一个「入度为
0 的点」，在起始时将其入队。</p>
<p>这可以使用反证法进行证明：假设有向无环图的拓扑序不存在入度为 0
的点。</p>
<p>那么从图中的任意节点 x 进行出发，沿着边进行反向检索，由于不存在入度为
0 的节点，因此每个点都能够找到上一个节点。</p>
<p>当我们找到一条长度为 n + 1 的反向路径时，由于我们图中只有 n
个节点，因此必然有至少一个节点在该路径中重复出现，即该反向路径中存在环，与我们「有向无环图」的起始条件冲突。</p>
<p>得证「有向无环图的拓扑序」必然存在（至少）一个「入度为 00
的点」。</p>
<p>即按照上述的 BFS
方法，我们能够按照流程迭代下去，直到将有向无环图的所有节点从队列中弹出。</p>
<p>反之，如果一个图不是「有向无环图」的话，我们是无法将所有节点入队的，因此能够通过入队节点数量是否为
n 来<strong>判断是否为有向无环图</strong>。</p>
<p>那么这一题是如何使用「拓扑排序」解决问题的呢：根据题意，若一个节点没有出边，则该节点是安全的；若一个节点出边相连的点都是安全的，则该节点也是安全的。</p>
<p>因此只需要对该图的反图求一个拓扑排序，不断求出度为0的节点即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">eventualSafeNodes</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; reverseGraph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            reverseGraph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> v:graph[i])&#123;</span><br><span class="line">                <span class="comment">// 原本从v到i有一个节点，即存在边 i-&gt;v，在反图中就是 v-&gt;i</span></span><br><span class="line">                reverseGraph.get(v).add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 可以得到该节点在反图的入度</span></span><br><span class="line">            inDegree[i] = graph[i].length;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// res.add(curr);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:reverseGraph.get(curr))&#123;</span><br><span class="line">                --inDegree[i];</span><br><span class="line">                <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于最终结果要求是升序排列的，所有不能在遍历队列过程中就直接添加节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>847. 访问所有节点的最短路径</title>
    <url>/posts/31a4/</url>
    <content><![CDATA[<h1 id="847-访问所有节点的最短路径">847. 访问所有节点的最短路径</h1>
<p>存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1
编号。</p>
<p>给你一个数组 graph 表示这个图。其中，graph[i]
是一个列表，由所有与节点 i 直接相连的节点组成。</p>
<p>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes">https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes</a></p>
</blockquote>
<span id="more"></span>

<h2 id="题目理解">题目理解</h2>
<p>这一题的关键在于：</p>
<p>设最短路径为s，那么所有节点的一种全排列一定是s的一个子序列，考虑到这一点，可以使用当前节点+当前节点的排列作为状态标记</p>
<p>那么这样一共包含n*2^n中状态，只需要遍历这些状态，找到其中到达终点距离最短的即可</p>
<p>关键在于如何表示这些状态，题目中n最大为12，可以使用位图来存储排列信息</p>
<h2 id="bfs状态压缩">BFS+状态压缩</h2>
<p>这一题难度为困难，主要难点在于如何存储当前遍历的状态，从而找到最短路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathLength</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果使用BFS，那么需要考虑的问题就是可以多次访问节点，重复使用边，如何存储状态</span></span><br><span class="line">        <span class="comment">// int[] = &#123; nodeId,mask &#125;</span></span><br><span class="line">        <span class="comment">// mask实际上也可以用来表示状态，n位，和dp解法中的mask类似，表示关键节点的全排列</span></span><br><span class="line">        <span class="comment">// node就表示在mask状态下最后一个访问的节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[length][<span class="number">1</span>&lt;&lt;length];</span><br><span class="line">        <span class="comment">// 由于graph的是12，实际上可以将mask和nodeId放在一起做hash</span></span><br><span class="line">        <span class="comment">// [mask,nodeId]</span></span><br><span class="line">        <span class="comment">// 一共只需要16位</span></span><br><span class="line">        <span class="comment">// 2^(x+4)和 x*2^x</span></span><br><span class="line">        <span class="comment">// 好像还是 x*2^x小一点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="comment">// 每个节点都有可能作为起点开始搜索</span></span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,<span class="number">1</span>&lt;&lt;i&#125;);</span><br><span class="line">            visited[i][<span class="number">1</span>&lt;&lt;i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">endState</span> <span class="operator">=</span> (<span class="number">1</span>&lt;&lt;length) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">// 当前队列的dist就是同一个值</span></span><br><span class="line">            <span class="keyword">while</span>(currSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span>[] state = queue.poll();</span><br><span class="line">                <span class="comment">// 到达终止状态</span></span><br><span class="line">                <span class="keyword">if</span>(state[<span class="number">1</span>] == endState)&#123;</span><br><span class="line">                    <span class="comment">// 由于是在两个循环内，一重break还不够，直接返回最好</span></span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 继续搜索</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i:graph[state[<span class="number">0</span>]])&#123;</span><br><span class="line">                  	<span class="comment">// 将 mask的第i位置1</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextState</span> <span class="operator">=</span> state[<span class="number">1</span>] | (<span class="number">1</span>&lt;&lt;i); </span><br><span class="line">                    <span class="keyword">if</span>(!visited[i][nextState])&#123;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,nextState&#125;);</span><br><span class="line">                        <span class="comment">// 必须要提前进行标记</span></span><br><span class="line">                        visited[i][nextState] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                --currSize;</span><br><span class="line">            &#125;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="floyd动态规划状态压缩">Floyd+动态规划+状态压缩</h2>
<p>这一题需要找到能够访问所有节点的最短路径长度，设最佳路径为序列s，那么所有节点的一种全排列一定路径序列的一个子序列（可以不连续），因此只需要枚举这些关键点就行，因此所有的状态数为
n*2^n，</p>
<p>使用dp[i,mask]来表示在mask下，最后一个访问的节点是i时经过的路径长度，其中mask记录了当前访问过的所有节点</p>
<p>状态转移方程 <span class="math display">\[
dp[i,mask] = min(dp[j,mask \otimes(1&lt;&lt;i)]+dis[j,i],dp[i,mask])
\]</span> 其中 <span class="math display">\[
mask\otimes(1&lt;&lt;i)
\]</span>
就表示将mask的第i为置0，即尚未访问到j的最短距离，然后在加上从j到i的最短距离（需要使用BFS或Floyd提前计算，存储到dis矩阵中），在所有可行点中找到最短的作为新值</p>
<p>而当mask是2的幂次时（仅包含一个1时，此时实际上就是开始状态，还没有开始走，因此dp[u,mask]
= 0</p>
<p>其中 u 代表 mask上1所在的位置（实际上就代表路径初始节点的选择）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathLength</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要求出任意两个节点之间的最短路径，然后安排路线？</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="comment">// 存储节点之间的距离</span></span><br><span class="line">        <span class="type">int</span>[][] dis = <span class="keyword">new</span> <span class="title class_">int</span>[length][length];</span><br><span class="line">        <span class="comment">// 距离初始化为INF，由于是一个连通且不带权的图，那么节点之间最长距离就是n+1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            Arrays.fill(dis[i],length+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k:graph[i])&#123;</span><br><span class="line">                dis[i][k] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从每个节点开始计算</span></span><br><span class="line">        <span class="comment">// 最外层循环是中间节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;length;++k)&#123;</span><br><span class="line">            <span class="comment">// 不断调整每个节点之间的距离</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;++j)&#123;</span><br><span class="line">                    dis[i][j] = Math.min(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;length;++i)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;length;++j)&#123;</span></span><br><span class="line">        <span class="comment">//         System.out.print(dis[i][j]+&quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     System.out.println();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// dis上可以得出每个节点之间的最短距离，之后需要计算访问所有节点的最短路径的长度</span></span><br><span class="line">        <span class="comment">// 由于是连通图，那么从哪个节点出发都是一样的</span></span><br><span class="line">        <span class="comment">// 使用 dp[i][mask]路径中关键节点i（当前路径下的最后一个节点，mask记录了当前访问过的全部节点，</span></span><br><span class="line">        <span class="comment">// 由于节点数最多只有12个，是完全足够存下的，每一位代表当前访问</span></span><br><span class="line">        <span class="comment">// 表示将mask上的第i位置0，^是java中位的异或运算</span></span><br><span class="line">        <span class="comment">// dp[i][mask] = Math.min(dp[j][mask ^ (1&lt;&lt;i)]+dis[i][j],dp[i][mask]);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">finalState</span> <span class="operator">=</span> (<span class="number">1</span>&lt;&lt;length) -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length][finalState+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            Arrays.fill(dp[i],Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处枚举了所有状态（实际上就是全排列）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">1</span>;mask&lt;=finalState;++mask)&#123;</span><br><span class="line">            <span class="comment">// 判断是否是一个数开始</span></span><br><span class="line">            <span class="keyword">if</span>((mask &amp; (mask-<span class="number">1</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 2^n</span></span><br><span class="line">                <span class="comment">// 这时候需要计算出mask上的1在哪一位</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> Integer.bitCount((mask&amp;(-mask))-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// System.out.println(&quot;1&lt;&lt;&quot;+value+&quot; == &quot;+mask);</span></span><br><span class="line">                <span class="comment">// 使用mask&amp;(-mask) -1可以快速求出这一位位于那一个1上</span></span><br><span class="line">                dp[value][mask] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              	<span class="comment">// 对于每一个mask，都需要对当前状态进行更新</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">                    <span class="comment">// 此时mask需要i和j都是1</span></span><br><span class="line">                    <span class="keyword">if</span>((mask &amp; (<span class="number">1</span>&lt;&lt;i)) != <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;++j)&#123;</span><br><span class="line">                            <span class="keyword">if</span>((mask &amp; (<span class="number">1</span>&lt;&lt;j)) !=<span class="number">0</span> &amp;&amp; i!=j)&#123;</span><br><span class="line">                                dp[i][mask] = Math.min(dp[i][mask],dp[j][mask ^ (<span class="number">1</span>&lt;&lt;i)]+dis[j][i]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            res = Math.min(res,dp[i][finalState]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <url>/posts/9344/</url>
    <content><![CDATA[<h1 id="剑指-offer-07-重建二叉树">剑指 Offer 07. 重建二叉树</h1>
<p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指
Offer 07. 重建二叉树 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="递归实现">递归实现</h2>
<p>只要知道先序遍历、中序遍历、后序遍历的特点</p>
<ul>
<li>先序遍历 ：[根,[左子树],[右子树]]</li>
<li>中序遍历：[[左子树],根,[右子树]]</li>
<li>后序遍历：[[左子树],[右子树],根]</li>
</ul>
<p>只要给出中序遍历和先序（后序）遍历结果，在树中数字唯一的情况下是可以将二叉树进行还原的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    Map&lt;Integer,Integer&gt; inorderMap;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="built_in">this</span>.size = preorder.length;</span><br><span class="line">        <span class="built_in">this</span>.inorderMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">            inorderMap.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3 9 20 15 7</span></span><br><span class="line">        <span class="comment">// 9 3 15 20 7</span></span><br><span class="line">        <span class="comment">// 在先序遍历中，第一个是根节点，其后一个为左节点，</span></span><br><span class="line">        <span class="comment">// 在中序遍历中，根节点左边数字是左子树，右边是右子树</span></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,<span class="number">0</span>,size-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [inorderLeft,inorderRight]区间，确保该子树的节点范围</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span> rootIndex,<span class="type">int</span> inorderLeft,<span class="type">int</span> inorderRight)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorderLeft &gt; inorderRight) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[rootIndex]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftChildIndex</span> <span class="operator">=</span> rootIndex + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inorderRoot</span> <span class="operator">=</span> inorderMap.get(root.val);</span><br><span class="line">        <span class="comment">// 这个节点不在范围内，说明实际不存在</span></span><br><span class="line">        <span class="comment">// if(inorderRoot &lt; inorderLeft || inorderRoot &gt; inorderRight) return null;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftTreeSize</span> <span class="operator">=</span> inorderRoot - inorderLeft;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightChildIndex</span> <span class="operator">=</span> leftChildIndex + leftTreeSize;</span><br><span class="line">        <span class="comment">// 此处如果左子树大小为1，则inorderLeft == inorderRoot-1,右子树同理，</span></span><br><span class="line">        <span class="comment">// 但是如果左子树为空，则此时inorderRoot和inorderLeft重合，</span></span><br><span class="line">        <span class="comment">// 那么inorderRoot-1一定小于inorderLeft，因此就会直接返回</span></span><br><span class="line">        root.left = helper(leftChildIndex,inorderLeft,inorderRoot-<span class="number">1</span>);</span><br><span class="line">        root.right = helper(rightChildIndex,inorderRoot+<span class="number">1</span>,inorderRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 16. 数值的整数次方</title>
    <url>/posts/13c2/</url>
    <content><![CDATA[<h1 id="剑指-offer-16-数值的整数次方">剑指 Offer 16. 数值的整数次方</h1>
<p>实现 <a
href="https://www.cplusplus.com/reference/valarray/pow/">pow(<em>x</em>,
<em>n</em>)</a> ，即计算 x 的 n
次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/</a></p>
</blockquote>
<span id="more"></span>

<h2 id="快速幂二分">快速幂（二分）</h2>
<p>由于指数幂次的计算特点 <span class="math display">\[
x^n = (x^2)^{\frac{n}{2}}
\]</span>
可以在每次计算过程中都计算当前值的平方，这样每次都可以使n减半，这样就可以在o(logn)时间复杂度内完成计算</p>
<h3 id="递归写法">递归写法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 每次都乘上两次自身</span></span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这个地方是个坑点，如果是直接使用 return myPow(1/x,-n) </span></span><br><span class="line">        <span class="comment">// 当n=-2147483648的时候，就会出现 n = -n ,从而出现死循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==-<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>/x;</span><br><span class="line">      	<span class="comment">// 此处位移也必须采用带符号的位移，保证携带有符号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> x*myPow(x*x,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> myPow(x*x,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代写法">迭代写法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) != <span class="number">0</span> )&#123;</span><br><span class="line">        res *= x;</span><br><span class="line">      &#125;</span><br><span class="line">      x = x * x;</span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 17. 打印从1到最大的n位数</title>
    <url>/posts/268/</url>
    <content><![CDATA[<h1 id="剑指-offer-17-打印从1到最大的n位数">剑指 Offer 17.
打印从1到最大的n位数</h1>
<p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n
位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p>*需要考虑大整数问题</p>
<span id="more"></span>

<h2 id="字符串全排列">字符串+全排列</h2>
<p>实际上，本题的主要考察点是大数越界情况下的打印。需要解决一下三个问题</p>
<ol type="1">
<li>如何表示大数（int？long？还是string）</li>
<li>如何生成数字
<ul>
<li>字符串大数加减法（模拟竖式计算）</li>
<li>全排列生成</li>
</ul></li>
</ol>
<p>对于字符串模拟的可以直接使用BigInteger实现，这里不做详细介绍，重点介绍一下全排列解法</p>
<p>考虑位数为2的情况</p>
<p>1,2,...99</p>
<p>实际上可以将前面的0也算入，即00,01,02,...99，最后只需要在递归结束的时候删除前导0即可</p>
<p>便可以理解为全排列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">printNumbers</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="comment">// 打印出k为的所有数字（从1开始)</span></span><br><span class="line">        <span class="built_in">this</span>.res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line">        helper(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(Deque&lt;Character&gt; deque)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(deque.size() == k)&#123;</span><br><span class="line">            <span class="comment">// 删除前导0</span></span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">leadingZero</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : deque)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!leadingZero)&#123;</span><br><span class="line">                        sb.append(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    leadingZero = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sb.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> i=<span class="string">&#x27;0&#x27;</span>;i&lt;=<span class="string">&#x27;9&#x27;</span>;++i)&#123;</span><br><span class="line">            deque.addLast(i);</span><br><span class="line">            helper(deque);</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 19. 正则表达式的匹配</title>
    <url>/posts/e7c8/</url>
    <content><![CDATA[<h1 id="剑指-offer-19-正则表达式的匹配">剑指 Offer 19.
正则表达式的匹配</h1>
<p>请实现一个函数用来匹配包含'.
'和'<em>'的正则表达式。模式中的字符'.'表示任意一个字符，而'</em>'表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a"均不匹配。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof">https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>*这一题动态规划需要考虑的地方很多，需要把所有情况都考虑完整，LeetCode上标定的难度是困难</p>
<p>匹配问题上大多数都是动态规划问题，例如最长公共子串</p>
<p>正则表达是的匹配本质上和最长公共子串类似，也需要判断两个串是否匹配，因此使用dp[i,j]代表A串的前i个字符是否可以和B串的前j个字符匹配</p>
<p>由于A串仅包含a-z，B串可以包含a-z、'.'、'*'三种情况，需要分别讨论</p>
<ul>
<li>当 B[j] 为 a-z时，那么只需要判断A[i] == B[j]
即可，不等说明不匹配，直接return
false，如果相同，那就只需要看前面的串能否匹配</li>
<li>当 B[j] 为 '.' 时，由于 '.' 为通配，效果实际上和 A[i] ==
B[j]一致，直接看前面的串能否匹配即可</li>
<li>当 B[j] 为 '*'
时，那么还需要查看B[j-1]，其代表B[j-1]可以出现多次（0次也行）
<ul>
<li>此时检查A[i] 如果 A[i] == B[j-1] || B[j-1] == '.'
那么当前串是否匹配取决于dp[i-1,j]注意此处j并没有移动，这时因为B[j-1]B[j]的组合可以匹配多个B[j-1]</li>
<li>如果不满足，那么说明B[j-1]B[j]组合没有作用，只需要看前面的能否匹配，即
dp[i,j-2]</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 空正则表达式可以匹配空串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 空串可以匹配到空串</span></span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  	<span class="comment">// 非空串匹配</span></span><br><span class="line">                    <span class="type">char</span> <span class="variable">pChar1</span> <span class="operator">=</span> p.charAt(j-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(pChar1!=<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">// 此时不是空正则串，需要拿值出来判断一下</span></span><br><span class="line">                        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == pChar1 || pChar1 == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                            dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 碰到 &#x27;*&#x27; 号</span></span><br><span class="line">                        <span class="keyword">if</span>(j&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="type">char</span> <span class="variable">pChar2</span> <span class="operator">=</span> p.charAt(j-<span class="number">2</span>);</span><br><span class="line">                          	<span class="comment">// 忽略 c* 的情况</span></span><br><span class="line">                            dp[i][j] |= dp[i][j-<span class="number">2</span>];</span><br><span class="line">                          	<span class="comment">// 匹配到 c* 的情况</span></span><br><span class="line">                            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == pChar2 || pChar2 == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                                dp[i][j] |= dp[i-<span class="number">1</span>][j];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归">递归</h2>
<p>这一题递归的思路实际上和动态规划的思路差不多，不断缩小问题规模，最后得出解</p>
<p>对于s和p，一共包含四种可能的情况</p>
<ul>
<li>s为空，p不为空（需要检查p是否可以匹配空）</li>
<li>s不为空，p不为空（最为复杂，需要考虑多种情况）</li>
<li>s为空，p为空（直接匹配）</li>
<li>s不为空，p为空（直接不匹配）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先检查s和p是否是空串</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 可能匹配的情况只可能是什么？</span></span><br><span class="line">            <span class="comment">// 就是类似于 a*b*c*这种，且必须是连续的，因此只需要检查*是否在奇数位置上即可</span></span><br><span class="line">            <span class="comment">// 且题目上也说了，不会出现两个连续**的情况</span></span><br><span class="line">            <span class="comment">// 奇数长度说明至少需要匹配一个字符，那也可以直接返回false</span></span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(i) != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 空正则匹配非空，肯定没说了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后两个来比较</span></span><br><span class="line">        <span class="comment">// s的最后一个字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">sChar</span> <span class="operator">=</span> s.charAt(m-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// p的最后一个字符</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">pChar</span> <span class="operator">=</span> p.charAt(n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(pChar != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 要么是相同，要么是不通</span></span><br><span class="line">            <span class="keyword">if</span>(sChar == pChar || pChar == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> isMatch(s.substring(<span class="number">0</span>,m-<span class="number">1</span>),p.substring(<span class="number">0</span>,n-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// pChar是*的情况</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">pChar1</span> <span class="operator">=</span> p.charAt(n-<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>(pChar1 == sChar || pChar1 == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> isMatch(s.substring(<span class="number">0</span>,m-<span class="number">1</span>),p) || isMatch(s.substring(<span class="number">0</span>,m),p.substring(<span class="number">0</span>,n-<span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substring(<span class="number">0</span>,m),p.substring(<span class="number">0</span>,n-<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单独一个*？</span></span><br><span class="line">        <span class="keyword">if</span>(sChar == pChar)&#123;</span><br><span class="line">            <span class="keyword">return</span> isMatch(s.substring(<span class="number">0</span>,m-<span class="number">1</span>),p.substring(<span class="number">0</span>,n-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 20. 表示数值的字符串</title>
    <url>/posts/97fe/</url>
    <content><![CDATA[<h1 id="剑指-offer-20-表示数值的字符串">剑指 Offer 20.
表示数值的字符串</h1>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</p>
<p><strong>数值</strong>（按顺序）可以分成以下几个部分：</p>
<ol type="1">
<li><p>若干空格</p></li>
<li><p>一个 小数 或者 整数</p></li>
<li><p>（可选）一个 'e' 或 'E' ，后面跟着一个 整数</p></li>
<li><p>若干空格</p></li>
</ol>
<p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p>
<ol type="1">
<li><p>（可选）一个符号字符（'+' 或 '-'）</p></li>
<li><p>下述格式之一：</p>
<ol type="1">
<li><p>至少一位数字，后面跟着一个点 '.'</p></li>
<li><p>至少一位数字，后面跟着一个点 '.'
，后面再跟着至少一位数字</p></li>
<li><p>一个点 '.' ，后面跟着至少一位数字</p></li>
</ol></li>
</ol>
<p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p>
<ol type="1">
<li>（可选）一个符号字符（'+' 或 '-'）</li>
<li>至少一位数字</li>
</ol>
<p>部分数值列举如下：</p>
<ul>
<li>["+100", "5e2", "-123", "3.1416", "-1E-16", "0123"]</li>
</ul>
<p>部分非数值列举如下：</p>
<ul>
<li>["12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"]</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="有限状态机">有限状态机</h2>
<p>参考别人的状态图</p>
<p><img data-src="剑指%20Offer%2020.%20表示数值的字符串/dfa.png"
style="zoom:50%;" /></p>
<p>实现细节看代码就可以了，switch实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">State</span>&#123;</span><br><span class="line">        s0,s1,s2,s3,s4,s5,s6,s7,s8</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">// 有限状态机，没什么好说的，只要能正确归纳出有限状态机就可以写出来</span></span><br><span class="line">        <span class="type">State</span> <span class="variable">s</span> <span class="operator">=</span> State.s0;</span><br><span class="line">        <span class="type">char</span>[] chArr = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="keyword">while</span>(next &lt; length)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">curr</span> <span class="operator">=</span> chArr[next];</span><br><span class="line">            ++next;</span><br><span class="line">            <span class="comment">// System.out.println(&quot;curr State:&quot;+s+&quot; &quot;+curr);</span></span><br><span class="line">            <span class="keyword">switch</span>(s)&#123;</span><br><span class="line">                <span class="keyword">case</span> s0:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                        s = State.s0;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr == <span class="string">&#x27;+&#x27;</span> || curr == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s1;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s2;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s4;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> s1:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s4;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s2;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> s2:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="string">&#x27;e&#x27;</span> || curr == <span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s5;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s2;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s3;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                        s = State.s8;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> s3:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="string">&#x27;e&#x27;</span> || curr == <span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s5;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s3;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                        s = State.s8;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> s4:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s3;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> s5:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="string">&#x27;+&#x27;</span> || curr == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s6;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s7;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> s6:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s7;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> s7:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                        s = State.s7;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr ==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                        s = State.s8;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> s8:&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                        s = State.s8;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;curr State:&quot;+s);</span></span><br><span class="line">        <span class="keyword">if</span>(s == State.s2 || s == State.s3 || s == State.s7 || s == State.s8)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 26. 树的子结构</title>
    <url>/posts/73ea/</url>
    <content><![CDATA[<h1 id="剑指-offer-26-树的子结构">剑指 Offer 26. 树的子结构</h1>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指
Offer 26. 树的子结构 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="递归">递归</h2>
<p>由于树是递归定义的结构，因此通常使用递归来求解（不断划分子问题，最终求解）</p>
<p>编写递归函数有两个要点</p>
<ul>
<li>子问题</li>
<li>终止条件</li>
</ul>
<p>此处要求A中出现和B相同的结构和节点值，注意，这里并不是要求B是A的一颗子树（区别在于有些节点上B为空，但是A对应该节点可以不为空），只需要B上出现的所有节点值在A上出现且结构相同即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="comment">// 空树不是任意一个树的子结构</span></span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">null</span> || B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 对A进行遍历，对于A的每一个节点，都有可能和B具有相同结构</span></span><br><span class="line">        <span class="keyword">return</span> isSameStructure(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSameStructure</span><span class="params">(TreeNode A,TreeNode B)</span>&#123;</span><br><span class="line">        <span class="comment">// 但是不知道从哪个起点开始</span></span><br><span class="line">        <span class="comment">// 如果B是A的子结构，说明A的某棵子树一定会和B重合，实际上只需要A上包含B上所有的结构即可，</span></span><br><span class="line">        <span class="comment">// 有可能出现A不为空，但是B为空的，这种情况实际上也可以满足相同条件</span></span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">null</span> &amp;&amp; B != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 如果两个值相同，</span></span><br><span class="line">        <span class="keyword">return</span> A.val == B.val &amp;&amp; isSameStructure(A.left,B.left) &amp;&amp; isSameStructure(A.right,B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 28. 对称的二叉树</title>
    <url>/posts/382/</url>
    <content><![CDATA[<h1 id="剑指-offer-28-对称的二叉树">剑指 Offer 28. 对称的二叉树</h1>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/">剑指
Offer 28. 对称的二叉树 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="模拟">模拟</h2>
<p>看到这题，首先想到的是求出这颗树的镜像二叉树，然后判断它和它的镜像是否一样即可（主要是因为前一题就是让你求镜像二叉树23333
<a
href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">剑指
Offer 27. 二叉树的镜像 - 力扣（LeetCode） (leetcode-cn.com)</a>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val; </span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 题目上说的很清楚了，如果一颗二叉树和它的镜像一样，那么它是对称的</span></span><br><span class="line">        <span class="comment">// 那么可以先找出root的镜像数，然后进行遍历，判断每个节点是否相同</span></span><br><span class="line">        <span class="keyword">return</span> isSame(root,mirrorTree(root));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(TreeNode A,TreeNode B)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="literal">null</span> &amp;&amp; B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((A==<span class="literal">null</span> &amp;&amp; B!= <span class="literal">null</span>) || (A!=<span class="literal">null</span> &amp;&amp; B==<span class="literal">null</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> A.val == B.val &amp;&amp; isSame(A.left,B.left) &amp;&amp; isSame(A.right,B.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root.val);</span><br><span class="line">        newRoot.left = mirrorTree(root.right);</span><br><span class="line">        newRoot.right = mirrorTree(root.left);</span><br><span class="line">        <span class="keyword">return</span> newRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归">递归</h2>
<p>以下面这的树为例，可以发现，从根节点开始，需要判断其两棵子树是否对称（左子树的右子树和右子树的左子树是否相同，左子树的左子树和右子树的右子树是够相同）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  1        &lt;- root</span><br><span class="line">                 / \</span><br><span class="line">root.left-&gt;     2   2      &lt;- root.right</span><br><span class="line">               / \ / \</span><br><span class="line">              3  4 4  3</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> check(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode A,TreeNode B)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((A==<span class="literal">null</span>&amp;&amp;B!=<span class="literal">null</span>) || (A!=<span class="literal">null</span> &amp;&amp; B==<span class="literal">null</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="literal">null</span> &amp;&amp; B==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> A.val == B.val &amp;&amp; check(A.left,B.right) &amp;&amp; check(A.right,B.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="层序遍历">层序遍历</h2>
<p>从上面的样例可以看出，如果对这棵树进行层序遍历，其每一层的结构都是对称，那么只需要使用迭代方式生成这棵树每一层的结点情况，然后使用双指针进行判断即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>

<p>可以看到上面这个案例，其层序遍历结果实际上也是对称的，但是并不满足条件，这是由于我们在按层遍历过程中忽略了NULL结点，如果在遍历过程中考虑到了空节点，这样的层序遍历结果可以唯一对应一棵树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">            <span class="keyword">while</span>(currSize &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                list.add(curr);</span><br><span class="line">                <span class="keyword">if</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">                  	<span class="comment">// 如果该节点的左孩子和右孩子是空节点，同样也将其加入队列中，这样可以保持层序遍历结果正确性</span></span><br><span class="line">                    queue.offer(curr.left);</span><br><span class="line">                    queue.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">                --currSize;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前层遍历完成，判断是否对称</span></span><br><span class="line">            <span class="keyword">if</span>(!check(list)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(List&lt;TreeNode&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> list.get(l);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> list.get(r);</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(</span><br><span class="line">              (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) || </span><br><span class="line">              (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) || </span><br><span class="line">              left.val != right.val</span><br><span class="line">            ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 29. 顺时针打印矩阵</title>
    <url>/posts/703f/</url>
    <content><![CDATA[<h1 id="剑指-offer-29-顺时针打印矩阵">剑指 Offer 29. 顺时针打印矩阵</h1>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<span id="more"></span>

<h2 id="模拟">模拟</h2>
<p>这个题没什么好说的，对于矩阵顺时针而言，一共就四个方向，水平向左，竖直向下，水平向右，
竖直向上，四个步骤不断重复，因此只需要模拟这四个过程，遍历的过程中将结果加入到res中就行</p>
<p>使用(y,x)表示当前访问矩阵的坐标，初始化为(0,0)，同时限制访问的边界
xLeft,xRight,yTop,yBottom</p>
<p>每当执行一个步骤之后，需要更新对应的边界</p>
<ul>
<li>水平向左：该行访问完成，yTop向下走一行</li>
<li>竖直向下：该列访问完成，xRight向左走一行</li>
<li>水平向右：该行访问完成，yBottom向上走一行</li>
<li>竖直向上：该列访问完成，xLeft向右走一行</li>
</ul>
<p>同时使用i记录当前坐标在一维数组中的下标，每走过一个便自增，每执行一步就需要判断是否完成遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            1 2 3</span></span><br><span class="line"><span class="comment">            4 5 6   -&gt; 1,2,3,6,9,8,7,4,5</span></span><br><span class="line"><span class="comment">            7 8 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            1  2  3  4 </span></span><br><span class="line"><span class="comment">            5  6  7  8   -&gt; 1,2,3,4,8,12,11,10,9,5,6</span></span><br><span class="line"><span class="comment">            9  10 11 12</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">// 遍历顺序</span></span><br><span class="line">        <span class="comment">// (0,0) (0,1) (0,2) (1,2) (2,2) (2,1) (2,0) (1,0) (1,1)</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,x=<span class="number">0</span>,y=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xLeft</span> <span class="operator">=</span> <span class="number">0</span>,xRight = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">yTop</span> <span class="operator">=</span> <span class="number">0</span>,yBottom = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 首先水平向左</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;step1&quot;);</span></span><br><span class="line">            <span class="keyword">for</span>(x=xLeft;x&lt;=xRight;++x)&#123;</span><br><span class="line">                <span class="comment">// printCoord(y,x);</span></span><br><span class="line">                res[i++] = matrix[y][x]; </span><br><span class="line">            &#125;</span><br><span class="line">            ++yTop;</span><br><span class="line">            --x;</span><br><span class="line">            <span class="keyword">if</span>(i == length) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 竖直向下</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;step2&quot;);</span></span><br><span class="line">            <span class="keyword">for</span>(y=yTop;y&lt;=yBottom;++y)&#123;</span><br><span class="line">                <span class="comment">// printCoord(y,x);</span></span><br><span class="line">                res[i++] = matrix[y][x];</span><br><span class="line">            &#125;</span><br><span class="line">            --xRight;</span><br><span class="line">            --y;</span><br><span class="line">            <span class="keyword">if</span>(i == length) <span class="keyword">break</span>;</span><br><span class="line">          	<span class="comment">// 水平向右</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;step3&quot;);</span></span><br><span class="line">            <span class="keyword">for</span>(x=xRight;x &gt;= xLeft;--x)&#123;</span><br><span class="line">                <span class="comment">// printCoord(y,x);</span></span><br><span class="line">                res[i++] = matrix[y][x];</span><br><span class="line">            &#125;</span><br><span class="line">            --yBottom;</span><br><span class="line">            ++x;</span><br><span class="line">            <span class="keyword">if</span>(i == length) <span class="keyword">break</span>;</span><br><span class="line">          	<span class="comment">// 竖直向上</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;step4&quot;);</span></span><br><span class="line">            <span class="keyword">for</span>(y=yBottom;y &gt;= yTop;--y)&#123;</span><br><span class="line">                <span class="comment">// printCoord(y,x);</span></span><br><span class="line">                res[i++] = matrix[y][x];</span><br><span class="line">            &#125;</span><br><span class="line">            ++xLeft;</span><br><span class="line">            ++y;</span><br><span class="line">            <span class="keyword">if</span>(i == length) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printCoord</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(&quot;</span>+x+<span class="string">&quot;,&quot;</span>+y+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 30. 包含min函数的栈</title>
    <url>/posts/d44e/</url>
    <content><![CDATA[<h1 id="剑指-offer-30-包含min函数的栈">剑指 Offer 30.
包含min函数的栈</h1>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min
函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<span id="more"></span>

<h2 id="单调栈">单调栈</h2>
<p>由于需要实现O(1)时间复杂度的最小元素查询，需要再维护一个单调栈，不断存储加入的序列中的最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; monoStack;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        monoStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要实现单调栈？</span></span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(monoStack.empty() || x &lt;= monoStack.peek())&#123;</span><br><span class="line">            monoStack.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// pop的时候需要更新minValue，因为可能把最小值给pop掉了</span></span><br><span class="line">        <span class="keyword">if</span>(stack.pop() == monoStack.peek())&#123;</span><br><span class="line">            monoStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> monoStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 31. 栈的压入、弹出序列</title>
    <url>/posts/5f77/</url>
    <content><![CDATA[<h1 id="剑指-offer-31-栈的压入弹出序列">剑指 Offer 31.
栈的压入、弹出序列</h1>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列
{1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1}
是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2}
就不可能是该压栈序列的弹出序列。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof">https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="模拟">模拟</h2>
<p>这一题还挺有意思的，需要判断对一个不包含重复数字的入栈序列，给出的出栈序列是否合法</p>
<p>可以使用栈根据弹出序列来模拟压栈、出栈的实际执行情况，如果可以正确执行，就说明是一个合法的序列，如果不能就说明不是</p>
<p>那么问题来了：如何使用栈进行模拟呢？</p>
<p>首先需要明白，出栈序列的每一个元素都是其出栈那个状态的栈顶元素，如果不满足这个条件，说明不是一个合法的出栈序列</p>
<p>下面拿一个具体的例子如何进行模拟</p>
<p>入栈序列：{1,2,3,4,5}</p>
<p>出栈序列：{4,5,3,2,1}</p>
<p>出栈序列的值包含两种情况，在栈顶或还没进栈</p>
<ul>
<li>下一个出栈值是栈顶元素：直接出栈，进行下一步操作</li>
<li>下一个出栈值是还没有进栈，那么就需要将该值放到栈顶，之后再将其出栈，进行下一步操作</li>
</ul>
<p>因此只需按上面两种情况进行模拟即可</p>
<p>初始状态</p>
<p>stack = []</p>
<p>入栈序列 = {1,2,3,4,5}</p>
<p>出栈序列 = {4,5,3,2,1}</p>
<p>step1：此时模拟栈为空，那么出栈元素只可能在入栈序列中，将其置于栈顶，然后出栈</p>
<p>stack = [1,2,3]</p>
<p>入栈序列 = {5}</p>
<p>出栈序列 = {5,3,2,1}</p>
<p>step2：此时模拟栈的栈顶元素为3，不等于下一个出栈元素，说明结果要么在入栈序列中，如果不在就说明是一个非法的出栈序列，这一步中出栈元素在待入栈序列中，因此将其出栈即可</p>
<p>stack = [1,2,3]</p>
<p>入栈序列 = {}</p>
<p>出栈序列 = {3,2,1}</p>
<p>step3：此时入栈序列已经为空，只需要比较栈顶元素是否等于出栈元素即可</p>
<p>stack = [1,2]</p>
<p>入栈序列 = {}</p>
<p>出栈序列 = {2,1}</p>
<p>step4：</p>
<p>stack = [1]</p>
<p>入栈序列 = {}</p>
<p>出栈序列 = {1}</p>
<p>step5：</p>
<p>stack = []</p>
<p>入栈序列 = {}</p>
<p>出栈序列 = {}</p>
<p>结论：{4,5,3,2,1}是入栈序列{1,2,3,4,5}的一个合法出栈序列</p>
<p>思路弄清楚了之后就可以开始编码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据进栈序列，判断是否是合法的出栈序列（出栈序列种数是著名的卡特兰数）</span></span><br><span class="line">        <span class="comment">// pushed中的所有数都是唯一的</span></span><br><span class="line">        <span class="comment">// popped实际上是pushed中的一个排列，可以按照popped对pushed情况进行模拟</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> pushed.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j&lt;length)&#123;</span><br><span class="line">            <span class="comment">// 如果当前没有路可以走了，说明这个排列不对</span></span><br><span class="line">            <span class="keyword">if</span>(i==length &amp;&amp; stack.peek() != popped[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          	<span class="comment">// 出栈值在待入栈序列时</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; length &amp;&amp; pushed[i] != popped[j])&#123;</span><br><span class="line">                stack.push(pushed[i]);</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时i自增，j也自增</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;length) ++i;</span><br><span class="line">            ++j;</span><br><span class="line">          	<span class="comment">// 出栈值在栈顶时</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek() == popped[j])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 32. 二叉搜索树的后序遍历序列</title>
    <url>/posts/495a/</url>
    <content><![CDATA[<h1 id="剑指-offer-32-二叉搜索树的后序遍历序列">剑指 Offer 32.
二叉搜索树的后序遍历序列</h1>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回
<code>true</code>，否则返回
<code>false</code>。假设输入的数组的任意两个数字都互不相同。</p>
<span id="more"></span>

<h2 id="排序递归还原二叉树">排序+递归（还原二叉树）</h2>
<p>由于题目明确说明是二叉搜索树，而二叉搜索树的中序遍历结果一定是有序的，且题目明说不包含重复数组，摆明了让你还原二叉树，因此可以根据后序遍历和对后序遍历序列排序后的中序遍历结果还原出这颗二叉树，同时在还原过程中对二叉树进行检查</p>
<p>满足，左孩子 &lt; 根 &lt; 右孩子</p>
<p>而二叉树的还原在 <strong>剑指 Offer 07. 重建二叉树</strong>
中有具体介绍，这里不过多赘述</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; indexMap;</span><br><span class="line">    <span class="type">int</span>[] inorder;</span><br><span class="line">    <span class="type">int</span>[] postorder;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 二叉搜索树的后序遍历结果</span></span><br><span class="line">        <span class="comment">// [[左子树],[右子树],根]</span></span><br><span class="line">        <span class="comment">// 最后一个值是根节点，然后倒数第二个是无法确定的</span></span><br><span class="line">        <span class="comment">// 对于一个二叉搜索树而言，其一定满足左孩子&lt;根&lt;右孩子</span></span><br><span class="line">        <span class="comment">// 二叉搜索树的中序遍历结果是有序的，那么可以对postorder进行排序，获得中序遍历结果</span></span><br><span class="line">        <span class="comment">// 然后就可以开始判断了</span></span><br><span class="line">        <span class="built_in">this</span>.indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.postorder = postorder;</span><br><span class="line">        <span class="built_in">this</span>.length = postorder.length;</span><br><span class="line">        <span class="built_in">this</span>.inorder = Arrays.copyOf(postorder,<span class="built_in">this</span>.length);</span><br><span class="line">        Arrays.sort(<span class="built_in">this</span>.inorder);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">this</span>.length;++i)&#123;</span><br><span class="line">            indexMap.put(<span class="built_in">this</span>.inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(<span class="built_in">this</span>.length-<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">this</span>.length-<span class="number">1</span>,<span class="literal">true</span>,postorder[<span class="built_in">this</span>.length-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 可以根据inorder和postorder还原二叉树，然后检查其左节点和右节点是否正确</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">boolean</span> isLeftChild,<span class="type">int</span> parentVal)</span>&#123;</span><br><span class="line">        <span class="comment">// 空节点直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 拿到根节点值对应的中序遍历下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[index];</span><br><span class="line">      	<span class="comment">// 检查是否满足二叉搜索树的条件</span></span><br><span class="line">        <span class="keyword">if</span>((isLeftChild &amp;&amp; rootVal &gt; parentVal) || (!isLeftChild &amp;&amp; rootVal &lt; parentVal)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightChildIndex</span> <span class="operator">=</span> index - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inorderIndex</span> <span class="operator">=</span> indexMap.get(rootVal);</span><br><span class="line">        <span class="comment">// 之后可以计算出左子树大小和右子树大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftChildIndex</span> <span class="operator">=</span> rightChildIndex - right + inorderIndex;</span><br><span class="line">        <span class="keyword">return</span> check(leftChildIndex,left,inorderIndex-<span class="number">1</span>,<span class="literal">true</span>,rootVal) &amp;&amp;</span><br><span class="line">               check(rightChildIndex,inorderIndex+<span class="number">1</span>,right,<span class="literal">false</span>,rootVal); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个解法并不是最优解，还有其他解法</p>
<h2 id="单调栈">单调栈</h2>
<h2 id="递归">递归</h2>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 41. 数据流中的中位数</title>
    <url>/posts/9236/</url>
    <content><![CDATA[<h1 id="剑指-offer-41-数据流中的中位数">剑指 Offer 41.
数据流中的中位数</h1>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof">https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="优先队列">优先队列</h2>
<p>首先想到的是使用二分查找，维护一个有序序列，这样每次调用findMedian就可以在o(1)时间复杂度内返回，但是对于插入而言，则需要o(n)的时间复杂度，首先使用二分查找找到元素待插入的位置，然后需要将每个元素向后移动，这样插入的时间复杂度就会很高，实际效果并不好。</p>
<p>实际上可以使用优先队列进行优化，由于优先队列队首元素一定是该队中的最大（最小）值，那么可以将数据流排序后分成两部分（长度均分），其中较大的那一部分存储在小根堆中，较小的一部分存储在大根堆中，这样插入的时间复杂度为o(logn)，查找中位数时间复杂度为o(1)</p>
<p>既然要保持两个队列之间大小差距不超过1，在插入元素时需要考虑一下</p>
<ul>
<li><p>当maxHeap的大小和minHeap的大小一致的时候</p>
<p>先将元素插入到minHeap中，然后将minHeap的队首元素插入到maxHeap（这样会使得maxHeap的大小比minHeap大1）</p></li>
<li><p>当maxHeap大小比minHeap的大小大1的时候</p>
<p>先将元素插入到maxHeap中，然后将maxHeap的队首元素插入到minHeap中（这样就使得maxHeap的大小和minHeap一样大的）</p></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        minHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">// 小顶堆，保存较大的一半</span></span><br><span class="line">        maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; (y - x)); <span class="comment">// 大顶堆，保存较小的一半</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxHeap.size() &gt; minHeap.size()) &#123;</span><br><span class="line">            <span class="comment">// 将A中最小的插入B内</span></span><br><span class="line">            maxHeap.add(num);</span><br><span class="line">            minHeap.add(maxHeap.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 此时A的大小一定会比B多1，中位数就会位于A内</span></span><br><span class="line">            <span class="comment">// 当两者大小相等的时候</span></span><br><span class="line">            <span class="comment">// 默认插入较小的那一批，再将较小的中的最大号插入较大的一批中</span></span><br><span class="line">            minHeap.add(num);</span><br><span class="line">            maxHeap.add(minHeap.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> maxHeap.size() != minHeap.size() ? maxHeap.peek() : (maxHeap.peek() + minHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 44. 数字序列中的某一位的数字</title>
    <url>/posts/2bc2/</url>
    <content><![CDATA[<h1 id="剑指-offer-44-数字序列中的某一位的数字">剑指 Offer 44.
数字序列中的某一位的数字</h1>
<p>数字以0，1，2，3，4，5，6，7，8，9，1，0，1，1，1，2，1，3，1，4，1，5…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p>
<p>请写一个函数，求任意第n位对应的数字。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="数学">数学</h2>
<p>首先看到这个题没看懂题意，看了好半天才知道，就是将非负整数依次添加到序列中，组成序列为{0,1,2,3,4,5,6,7,8,9,1,0,1,1...}，其中1，0实际上是由10拆开得到的，每一个数字占一位，求第n位对应的数字</p>
<p>数字的位数是不断增加的，其中0～9只占一位，下标范围是0～9，10～99占两位，下标范围是10～189，100～999占三位，下标范围190～2889，根据这个可以计算出第n位对应数字所属的实际数字是几位的，知道了实际数字的位数和下标，可以计算出该实际数字是多少，最后根据下标可以计算出对应实际数组的第几位，求出这一位即可</p>
<p>语言表达能力不是很好，下面举个例子来介绍计算方法</p>
<p>假设我们要求第1234位对应的数字</p>
<p>step1：求第1234位对应的数字其所属实际数字A范围</p>
<p>由190（三位数起始下标） &lt; 1234 &lt;
2889（三位数结束下标），说明数A是是一个三位数</p>
<p>step2：根据下标求出实际数字A在三位数中的偏移量</p>
<p>由三位数起始下标可以计算出进入三位数后已经经过了多少个数，1234-190+1
=
1045，而这1045个数字都是类似于1，0，0，1，0，1这样排列起来的，因此实际数字A偏移量为1045/3
= 348（此处是整除），然后1045%3 =
1，说明第1234位数字对应于实际数字A的首位，</p>
<blockquote>
<p>类似于[1,0,0],[1,0,1],[1]
如果取模值为0，说明是实际数字的最后一位，如果取模值不为0，前 k / mod
个数字都可以表示完，现在实际上对应的是第 k / mod + 1个数字</p>
</blockquote>
<p>step3：计算出实际数字A</p>
<p>因为1045 / 3 = 348 且 1045%3 = 1 不为
0，说明前348个数字都可以完整表示，现在正在表示第349个数字，那么从100开始的第349个数字是
349 + 100 - 1 = 448</p>
<p>step4：根据取模值计算对应的数字</p>
<p>由于1045 % 3 =
1，说明表示的是448的最高位，那么可以得到第1234位对应的数字是4</p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">9</span>,<span class="number">189</span>,<span class="number">2889</span>,<span class="number">38889</span>,<span class="number">488889</span>,<span class="number">5888889</span>,<span class="number">68888889</span>,<span class="number">788888889</span>,<span class="number">2147483647</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] startVal = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>,<span class="number">100000</span>,<span class="number">1000000</span>,<span class="number">10000000</span>,<span class="number">100000000</span>&#125;;</span><br><span class="line">        <span class="type">int</span> pos=-<span class="number">1</span>;</span><br><span class="line">      	<span class="comment">// 确定n代表数子所属位数范围，是在几位数字之中</span></span><br><span class="line">        <span class="keyword">while</span>(n&gt;dp[pos+<span class="number">1</span>])&#123;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算至当前位数的数字开始经过了多少个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> n-dp[pos];</span><br><span class="line">      	<span class="comment">// 位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> pos + <span class="number">2</span>;</span><br><span class="line">      	<span class="comment">// 当前数字代表的位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> cnt % mod;</span><br><span class="line">      	<span class="comment">// 表示的实际数字范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cnt / mod + startVal[pos] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(bit&gt;<span class="number">0</span>)&#123;</span><br><span class="line">          	<span class="comment">// val表示完了，现在表示的是val+1</span></span><br><span class="line">            ++val;</span><br><span class="line">            <span class="comment">// 当bit等于1的时候代表的是最高位，以此类推</span></span><br><span class="line">          	<span class="comment">// 1 2 3 4 0</span></span><br><span class="line">          	<span class="comment">// 9 9 9 9 9</span></span><br><span class="line">          	<span class="comment">// 当bit大于0时，由于是倒着计算位数，需要反转一下</span></span><br><span class="line">          	<span class="comment">// 变成</span></span><br><span class="line">          	<span class="comment">// 4 3 2 1 0</span></span><br><span class="line">          	<span class="comment">// 9 9 9 9 9</span></span><br><span class="line">            bit = mod - bit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(bit&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            val /= <span class="number">10</span>;</span><br><span class="line">            --bit;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 取val的最低位</span></span><br><span class="line">        <span class="keyword">return</span> val % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 45. 把数组排成最小的数</title>
    <url>/posts/e2ad/</url>
    <content><![CDATA[<h1 id="剑指-offer-45-把数组排成最小的数">剑指 Offer 45.
把数组排成最小的数</h1>
<p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指
Offer 45. 把数组排成最小的数 - 力扣（LeetCode）
(leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="贪心自定义排序">贪心+自定义排序</h2>
<p>首先看到题目想到暴力，就需要枚举所有数字的组合方式（即全排列），那么共有nums.length!种排列方式，本题nums.length
&lt; 100，100!规模太大，肯定是不行的，那么就肯定需要找一点其他方法</p>
<p>这个解法说实话没想数来，看题解知道的，对于nums中的数字，如果有
String(x)+String(y) &lt;
String(y)+String(x)，说明x的优先级比y高，x排在y前面，按照这种排序方式对于nums进行排序，可保证最后得到的一定是最小的数字</p>
<p>证明：</p>
<p>首先说明为什么 String(x)+String(y) &lt;
String(y)+String(x)，x的优先级比y高</p>
<p>举个例子吧，x=101和y=10</p>
<p>10110和10101，明显是String(y)+String(x)更小，所以y在数字组合中一定是排在x前面的</p>
<p>再来看传递性，如果有x+y&lt;y+x且y+z&lt;z+y，则有x+z&lt;z+x</p>
<p>设x=1，y=10，z=101</p>
<p>明显有110&gt;101，则10的优先级比1高</p>
<p>10101&gt;10110，则10的优先级比101高</p>
<p>1101&gt;1010，则101的优先级比1高</p>
<p>当一个数，其和其余所有数组合之后得到的数都更小，说明这个数优先级很高，按照这个排序方式，最终一定可以的到最小的数（因为每一步都是最小）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(strs,(a,b)-&gt;(a+b).compareTo(b+a));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(String i:strs)&#123;</span><br><span class="line">            sb.append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 46. 把数字翻译成字符串</title>
    <url>/posts/11c0/</url>
    <content><![CDATA[<h1 id="剑指-offer-46-把数字翻译成字符串">剑指 Offer 46.
把数字翻译成字符串</h1>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1
翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成
“z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>统计数字翻译方法，典型的动态规划，首先可以将数字转换成字符串形式，之后按字符串序列来进行求解</p>
<p>使用dp[i]表示从0～i这段序列所有的翻译方式，dp[0] =
1，状态更新方程</p>
<p>value = (nums[i-1]-'0') * 10 + nums[i]-'0'</p>
<p>dp [i] = dp[i-1] + dp[i-2] if 10 &lt; value &lt; 26</p>
<p>dp[i] = dp[i-1]</p>
<p>只有两种可能，第i-1个和第i个可以代表一个字母，这算一种翻译方式，此时当将i-1和i看成一个整体时，翻译方法总数为dp[i-2]，当将i单独看成一个字母时，翻译总方法数为dp[i-1]，因此可得上述递推公式</p>
<p>根据递推公式可以写出代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] nums = String.valueOf(num).toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">// dp[i][j]表示数字串在[0,i]段具有翻译方式</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="comment">// 判断 nums[i-1] nums[i] 是否可以组合成一个</span></span><br><span class="line">            <span class="comment">// 注意 06 只能分开算，不能合并算</span></span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> (nums[i-<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + nums[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(value &lt; <span class="number">26</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">2</span>)&#123;</span><br><span class="line">                    dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ++dp[i];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从递推公式上可以看到，实际上dp[i]仅取决于dp[i-1]和dp[i-2]，那么实际上只需要使用三个数p，q，r记录三个值，并在遍历过程中不断更新即可，同时我们从后向前读取，使用取模操作，可以直接读取数字值，不需要转换成字符串来处理，这样可以将空间复杂度降低为o(1)</p>
<p>优化代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 实际上dp[i]仅和dp[i-1],dp[i-2]有关，可以只保存三个数</span></span><br><span class="line">        <span class="comment">// 同时从后向前遍历，可以不用转换成字符串，直接进行计算</span></span><br><span class="line">     		<span class="comment">// 一次读取两位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> num % <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// p代表dp[i-2]</span></span><br><span class="line">        <span class="comment">// q代表dp[i-1]</span></span><br><span class="line">        <span class="comment">// r代表dp[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      	<span class="comment">// 当 i 和 i-1 可以合起来代表一个字母时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> value &gt; <span class="number">9</span> &amp;&amp; value &lt; <span class="number">26</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> q;</span><br><span class="line">        num = num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            value = num % <span class="number">100</span>;</span><br><span class="line">            r = q;</span><br><span class="line">            <span class="keyword">if</span>(value &gt; <span class="number">9</span> &amp;&amp; value &lt; <span class="number">26</span>)&#123;</span><br><span class="line">                r += p;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 向前移动一位</span></span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">            p = q;</span><br><span class="line">            q = r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
    <url>/posts/6d2f/</url>
    <content><![CDATA[<h1 id="剑指-offer-48-最长不含重复字符的子字符串">剑指 Offer 48.
最长不含重复字符的子字符串</h1>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指
Offer 48. 最长不含重复字符的子字符串 - 力扣（LeetCode）
(leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划--哈希表">动态规划 + 哈希表</h2>
<p>dp[j]指的是以字符s[j]结尾的字符串的长度。注意，这个字符串需要尽可能的长，且不能含有重复字符。</p>
<p>我们可以记为字符串sub[j], 该字符串以字符s[j]结尾，长度为dp[j]。</p>
<p>这样就比较好理解状态转移方程了。固定右边界 j ，同时定义从边界 j
往左侧距离最近的相同字符的索引为 i 。</p>
<p>以字符s[j-1]结尾的字符串记录为sub[j-1]，其长度为dp[j-1]，注意sub
[j-1]中字符不重复。 我们看索引 j 的情况：在 j 的左侧寻找一个重复的字符s
[i],那么索引 i
可能在字符串sub[j-1]的区间内，也可能在字符串sub[j-1]的左边界更左侧才有可能寻找到。这样就需要分两种情况考虑。</p>
<ul>
<li><p>如果字符 s[i] 在子字符串 sub[j−1] 区间之外，也就是更左侧,
那么dp[j-1] &lt; j-i，这种情况下，由于sub
[j-1]中字符不重复，且当前最长，所以以s[ j
]为结尾的字符串只需要在子字符串 sub[j−1]后面接上这个字符s[ j
]就可以了，其长度dp [ j ] = dp[j-1]+1;</p></li>
<li><p>如果字符 s[ i ] 在子字符串 sub[ j− 1 ] 区间之中，必然dp[ j−1 ] ≥
j − i，这种情况下，由于我们需要寻找以s[ j ]结尾且最长的字符串，那么sub[
j ]的左边界只能是 i 了，其长度 dp[ j ] = j − i 。</p></li>
</ul>
<p>下面举个例子，设字符串为“abcdbaa”</p>
<p>初始化</p>
<p>dp = [0,0,0,0,0,0,0]</p>
<p>lastIndex = {}</p>
<p>step1:</p>
<p>index = 0，对应字符为 'a' ，lastIndex.get('b') =
null，直接更新并记录索引</p>
<p>lastIndex = {'a':0}</p>
<p>dp = [1,0,0,0,0,0,0]</p>
<p>step2</p>
<p>index = 1，对应字符为 'b' ，lastIndex.get('b') = null
，直接更新并记录索引</p>
<p>又由于此时 dp[0] = 1，且对于字符 'b'
而言，这是其第一次出现在字符串中，也就是说在以str[index-1] 即 'a'
为结尾的最长不包含重复字符的字符串（"a"）中并不包含 'b'，此时可以将 'b'
加入字符串中</p>
<p>lastIndex = {'a':0,'b':1}</p>
<p>dp = [1,2,0,0,0,0,0]</p>
<p>step3</p>
<p>index = 2，对应字符为 'c' ，lastIndex.get('c') = null
，直接更新并记录索引</p>
<p>又由于此时 dp[1] = 2，且对于字符 'c'
而言，这是其第一次出现在字符串中，也就是说在以str[index-1] 即 'b'
为结尾的最长不包含重复字符的字符串（"ab"）中并不包含 'c'，此时可以将 'c'
加入字符串中</p>
<p>lastIndex = {'a':0,'b':1,'c':2}</p>
<p>dp = [1,2,3,0,0,0,0]</p>
<p>step4</p>
<p>index = 3，对应字符为 'd' ，lastIndex.get('d') = null
，直接更新并记录索引</p>
<p>又由于此时 dp[2] = 3，且对于字符 'd'
而言，这是其第一次出现在字符串中，也就是说在以str[index-1] 即 'c'
为结尾的最长不包含重复字符的字符串（"abc"）中并不包含 'd'，此时可以将
'd' 加入字符串中</p>
<p>lastIndex = {'a':0,'b':1,'c':2,'d':4}</p>
<p>dp = [1,2,3,4,0,0,0]</p>
<p>step5</p>
<p>index = 4，对应字符为 'b'，lastIndex.get('b') = 1，而 dp[index-1] =
4（即对应字符串
"abcd"），此处可以发现b是曾经出现在dp[index-1]对应的最长不包含重复字符的字符串中的，那么此时以当前字符
'b' 结尾的最长不包含重复字符的字符串就只能是
"cbd"，即从其前一次出现的位置的下一个字符开始算起，再这期间，由于
dp[index-1]
对应的字符串不包含重复字符，那么其子字符串也一定不包含，最后按照第二条状态转移公式更新并记录索引</p>
<p>lastIndex = {'a':0,'b':4,'c':2,'d':3}</p>
<p>dp = [1,2,3,4,3,0,0]</p>
<p>step6</p>
<p>index = 5，对应字符为 'a'，lastIndex.get('a') = 0，dp[index-1] =
3，对应字符串为 "cbd"，此时 'a'
明显不在这个字符串中，可以将其加入，按照第一条状态转移公式进行更新</p>
<p>lastIndex = {'a':5,'b':4,'c':2,'d':3}</p>
<p>dp = [1,2,3,4,3,4,0]</p>
<p>step6</p>
<p>index = 6，对应字符为 'a'，lastIndex.get('a') = 5，dp[index-1] =
4，对应的字符串为
"cbda"，此时a位于该字符串中，使用第二条状态转移公式进行更新，此时以当前的
'a'结尾的符合条件的字符串就只有 "a"了</p>
<p>lastIndex = {'a':6,'b':4,'c':2,'d':3}</p>
<p>dp = [1,2,3,4,3,4,1]</p>
<p>此时遍历完成，返回dp中的最大值 4 （对应的是 "abcd" 或 "cdba"）</p>
<p>从状态转移方程中可以看到，dp[i] 实际上仅和
dp[i-1]有关，因此可以将空间复杂度优化为 o(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      	<span class="comment">// 记录字符上一次出现的位置</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// dp表示以s[i]结尾的不包含重复字符串的最长长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, dp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="comment">// 记录的是字符s[j]的前一个出现位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> map.getOrDefault(s.charAt(j), -<span class="number">1</span>); <span class="comment">// 获取索引 i</span></span><br><span class="line">            map.put(s.charAt(j), j); <span class="comment">// 更新哈希表</span></span><br><span class="line">          	<span class="comment">// dp &lt; j - i 实际判断的就是 str[j] 是否出现在 以 str[j-1] 结尾的满足条件的字符串中，如果不在就可以继续增加</span></span><br><span class="line">          	<span class="comment">// 如果再其中就只能从其出现位置之后重新开始计算</span></span><br><span class="line">            dp = dp &lt; j - i ? dp + <span class="number">1</span> : j - i; <span class="comment">// dp[j - 1] -&gt; dp[j]</span></span><br><span class="line">          	<span class="comment">// 最后记录一下最大值即可</span></span><br><span class="line">            res = Math.max(res, dp); <span class="comment">// max(dp[j - 1], dp[j])</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <url>/posts/a16a/</url>
    <content><![CDATA[<h1 id="剑指-offer-51-数组中的逆序对">剑指 Offer 51. 数组中的逆序对</h1>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指
Offer 51. 数组中的逆序对 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>最简单的，直接遍历数组中的每一个数对，判断前一个是否大于后一个，并计数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;l;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^2)，本题nums最长50000，要求算法时间复杂度至少是o(nlogn)级别的才行</p>
<h2 id="归并排序">归并排序</h2>
<p>看了眼题解，提示可以用归并排序来解这个题，那么首先了解一下归并排序，归并排序的思想是，将数组划分成两部分，分别将左右两部分排序后在进行合并</p>
<p>nums = [7,6,5,4,3,2,1,0]</p>
<p><strong>step1</strong></p>
<p>l=0, r=1</p>
<p>sort{7,6}</p>
<p>7 &gt; 6, cnt = 1</p>
<p>nums = [6,7,5,4,3,2,1,0]</p>
<p><strong>step2</strong></p>
<p>l=2, r=3</p>
<p>sort{5,4}</p>
<p>5 &gt; 4, cnt = 2</p>
<p>nums = [6,7,4,5,3,2,1,0]</p>
<p><strong>step3</strong></p>
<p>l=4, r=5</p>
<p>sort{3,2}</p>
<p>3&gt;2, cnt = 3</p>
<p>nums = [6,7,4,5,2,3,1,0]</p>
<p><strong>step4</strong></p>
<p>l=6, r=7</p>
<p>sort{1,0}</p>
<p>1&gt;0, cnt = 4</p>
<p>nums = [6,7,4,5,2,3,0,1]</p>
<p><strong>step5</strong></p>
<p>l=0,r=3</p>
<p>{6,7} merge {4,5}</p>
<p>6&gt;4, cnt=6</p>
<p>6&gt;5, cnt=8</p>
<p>nums= [4,5,6,7,2,3,0,1]</p>
<p><strong>step6</strong></p>
<p>l=4,r=7</p>
<p>{2,3} merge {0,1}</p>
<p>2&gt;0, cnt=10</p>
<p>2&gt;1, cnt=12</p>
<p>nums=[4,5,6,7,0,1,2,3]</p>
<p><strong>step7</strong></p>
<p>l=0,r=7</p>
<p>{4,5,6,7} merge {0,1,2,3}</p>
<p>4&gt;0,cnt=16</p>
<p>4&gt;1,cnt=20</p>
<p>4&gt;2,cnt=24</p>
<p>4&gt;3,cnt=28</p>
<p>nums=[0,1,2,3,4,5,6,7]</p>
<p>nums 已经有序，返回逆序对数28</p>
<p>代码实现也很简单，只需要在归并排序的基础上添加一行代码即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] temp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        temp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        mergeSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">// 归并排序模版代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(l+&quot; &quot;+r);</span></span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        mergeSort(nums,l,mid);</span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="comment">// 开始归并</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> l,l2 = mid+<span class="number">1</span>,i=l;</span><br><span class="line">        <span class="keyword">while</span>(l1&lt;=mid &amp;&amp; l2 &lt;= r)&#123;</span><br><span class="line">            <span class="comment">// 在这里计算的时候，如果有出现temp[l1]&gt;temp[l2]，说明左边的是要大于右边的</span></span><br><span class="line">            <span class="keyword">if</span>(nums[l1] &gt; nums[l2])&#123;</span><br><span class="line">                temp[i++] = nums[l2++];</span><br><span class="line">              	<span class="comment">// 只需要添加这一行</span></span><br><span class="line">                <span class="comment">// 所有在temp[l1]后面的都会比temp[l2]大，因此需要进行累加</span></span><br><span class="line">                cnt += (mid+<span class="number">1</span>-l1);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[i++] = nums[l1++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1&lt;=mid)&#123;</span><br><span class="line">            temp[i++] = nums[l1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2&lt;=r)&#123;</span><br><span class="line">            temp[i++] = nums[l2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=l;i&lt;=r;++i)&#123;</span><br><span class="line">            nums[i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序离散化树状数组">排序+离散化树状数组</h2>
<p>还有一种计算逆序对的思路，将nums中每一个数字映射到桶中，bucket[i]表示数字i出现的次数，例如
nums = [5,5,2,3,6]</p>
<p>那么 bucket = [0,0,1,1,0,2,1]</p>
<p>那么在建立映射的过程中，实际上就可以计算逆序对数了，具体做法就是从后向前遍历数组nums，对于当前数而言，其在bucket中的前缀和就可以表示在前面有多少个数小于他，因为在bucket中已经计过数的说明是在当前数后面出现的，而其在bucket中位置在当前数之前，这样就构成了逆序对，因此计算bucket的前缀和就可以得到当前数的逆序对，最终可以计算出所有的逆序对</p>
<p>具体计算过程</p>
<p>nums = [5,5,2,3,6]</p>
<p>bucket = [0,0,0,0,0,0,0]</p>
<p><strong>step1</strong></p>
<p>i = 4, nums[i] = 6</p>
<p>prefix[4] = 0</p>
<p>bucket = [0,0,0,0,0,0,1]</p>
<p><strong>step2</strong></p>
<p>i = 3, nums[i] = 3</p>
<p>prefix[3] = 0</p>
<p>bucket = [0,0,0,1,0,0,1]</p>
<p><strong>step3</strong></p>
<p>i = 2, nums[i] = 2</p>
<p>prefix[2] = 0</p>
<p>bucket = [0,0,1,1,0,0,1]</p>
<p><strong>step4</strong></p>
<p>i = 1, nums[i] = 5</p>
<p>prefix[5] = 2, cnt = 2</p>
<p>bucket = [0,0,1,1,0,1,1]</p>
<p><strong>step5</strong></p>
<p>i = 0, nums[i] = 5</p>
<p>prefix[5] = 2,cnt = 4</p>
<p>bucket = [0,0,1,1,0,2,1]</p>
<p>遍历结束，逆序对数为4</p>
<p>这个方法时间复杂度为o(n)，但是空间要求很高（桶需要足够大），因此并不实用，需要进行优化</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 56 - I. 数组中数字出现的次数</title>
    <url>/posts/8027/</url>
    <content><![CDATA[<h1 id="剑指-offer-56---i-数组中数字出现的次数">剑指 Offer 56 - I.
数组中数字出现的次数</h1>
<p>一个整型数组 <code>nums</code>
里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">剑指
Offer 56 - I. 数组中数字出现的次数 - 力扣（LeetCode）
(leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="位运算">位运算</h2>
<p>这一题非常巧妙的考察了的异或运算的性质</p>
<p>a^b = b^a</p>
<p>a^a = 0</p>
<p>0^a = a</p>
<p>由于nums中除了两个数字外，其他数字都出现了两次，设这两个数字对应下标分别为i和j，则有
<span class="math display">\[
xor = nums[0] \oplus nums[1] \oplus nums[2] \oplus \cdots \oplus
nums[n-1] = nums[i] \oplus nums[j]
\]</span>
又由于nums[i]和nums[j]一定是两个不同的值，那么对于nums[i]和nums[j]，其对应的二进制上至少有一位是不同的，之后我们根据这一位来将nums划分成两部分，再进行一次异或运算，就可以得到其中一个值，再和xor值进行一个异或运算就可以得到另外一个值</p>
<p>使用 <span class="math display">\[
xor \and (-xor)
\]</span>
就可以得到xor的最低位对应的数，这是由于计算机负数使用补码表示，取反+1，</p>
<p>下面拿0b00111101举例</p>
<p>该数对应的反码为</p>
<p>0b11000010</p>
<p>对应的补码为</p>
<p>0b11000011</p>
<p>之后再将这两个值进行一个与运算</p>
<p>0b00000001，这个值就代表了0b00111101的最末尾的1</p>
<p>再举一个，0b00000010</p>
<p>反码：0b11111101</p>
<p>补码：0b11111110</p>
<p>lowerbit：0b00000010，可以看到刚好对应的是0b00000010的最低位的1</p>
<p>知道这个之后，就可以写代码了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 除了两个数字之外，其它的数字都出现了两次</span></span><br><span class="line">        <span class="comment">// 考虑最坏情况</span></span><br><span class="line">        <span class="comment">// 共有 nums.length / 2 + 1 个不重复的数字，</span></span><br><span class="line">        <span class="comment">// 然后前 nums.length / 2 + 1都是不重复的，后面才是重复的</span></span><br><span class="line">        <span class="comment">// [1,2,3,4,5,1,2,3]</span></span><br><span class="line">        <span class="comment">// a^a = 0</span></span><br><span class="line">        <span class="comment">// 0^a = a</span></span><br><span class="line">        <span class="comment">// 1^2^3^4^5^1^2^3 = 4^5 = a^b</span></span><br><span class="line">        <span class="comment">// 根据lowerbit可以将nums划分成两部分，然后对这两部分分别进行异或，最终就可以找到不同的数字</span></span><br><span class="line">        <span class="comment">// lowerbit = res &amp; (-res)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">xor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            xor ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lowerbit</span> <span class="operator">=</span> xor &amp; (-xor);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>((lowerbit &amp; num) != <span class="number">0</span>)&#123;</span><br><span class="line">                a ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,xor^a&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 56 - II. 数组中数字出现的次数 II</title>
    <url>/posts/b470/</url>
    <content><![CDATA[<h1 id="剑指-offer-56---ii-数组中数字出现的次数-ii">剑指 Offer 56 - II.
数组中数字出现的次数 II</h1>
<p>在一个数组 <code>nums</code>
中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">剑指
Offer 56 - II. 数组中数字出现的次数 II - 力扣（LeetCode）
(leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>实际上这题都没有限制空间复杂度什么的，那么最简单的就是使用map统计每个数字出现的次数，然后返回出现次数为1的就可以了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(i) == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算1">位运算（1）</h2>
<p>这个思路实际上可以应用于其他数字出现于m次，仅有一个数字出现了1次。只需要统计每个位上1出现的次数，然后将这个出现次数模上m，当余数为1时就说明仅出现一个的那个数字在此位上为1，之后就可以根据这个还原出仅出现一次的数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 统计0～31为上数字出现的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.fill(counts,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;++i)&#123;</span><br><span class="line">                counts[i] += (num &amp; <span class="number">1</span>);</span><br><span class="line">              	<span class="comment">// 此处必须是无符号右移，防止符号上的1也被统计上</span></span><br><span class="line">                num &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 根据1出现的次数还原出仅出现1次的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(counts[i] % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                res |= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算2">位运算（2）</h2>
<p>位1计数器（每个状态代表1出现的次数）</p>
<p>有限状态机，从位运算（1）解法中可以看到，由于每位上1出现的次数对3取余后要么是0，要么是1，那么对于每一个输入的位，我们可以绘制出状态转移表，然后根据输入转移到下一个状态。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">输入\状态</th>
<th style="text-align: center;">0（代表1出现次数取余后为0）</th>
<th style="text-align: center;">1（代表1出现次数取余后为1）</th>
<th style="text-align: center;">2（代表1出现次数取余后为2）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<p>又由于三个状态需要使用两个二进制位来表示，那么可以得到 00，01，10
三个状态，之后再根据输入情况设置状态转移情况即可</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">输入\状态</th>
<th style="text-align: center;">00</th>
<th style="text-align: center;">01</th>
<th style="text-align: center;">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">00</td>
<td style="text-align: center;">01</td>
<td style="text-align: center;">10</td>
</tr>
<tr class="even">
<td style="text-align: center;">1</td>
<td style="text-align: center;">01</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">00</td>
</tr>
</tbody>
</table>
<p>再单独看每个位随输入的变化情况，记高位为a，低位为b</p>
<ul>
<li>当输入为0时
<ul>
<li>当a=0时
<ul>
<li>b保持不变</li>
</ul></li>
<li>当a=1时
<ul>
<li>b = 0</li>
</ul></li>
</ul></li>
<li>当输入为1时
<ul>
<li>当a=0时
<ul>
<li>b = ~b</li>
</ul></li>
<li>当a=1时
<ul>
<li>0</li>
</ul></li>
</ul></li>
</ul>
<p>根据这个状态变化情况，可以得出低位b的状态更新公式</p>
<p>b = b ^ n &amp; ~a;</p>
<p>再根据状态更新后的b来考察a的状态更新公式</p>
<p>a = a ^ n &amp; ~b;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ones</span> <span class="operator">=</span> <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            ones = ones ^ num &amp; ~twos;</span><br><span class="line">            twos = twos ^ num &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 57. 和为s的两个数字</title>
    <url>/posts/1fbe/</url>
    <content><![CDATA[<h1 id="剑指-offer-57-和为s的两个数字">剑指 Offer 57.
和为s的两个数字</h1>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<span id="more"></span>

<h2 id="集合">集合</h2>
<p>这个方法也适用于无序的数组，用一个集合存储数组中的数组，然后对于nums[i]判断target-nums[i]是否在集合中即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(target-num))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num,target-num&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n)</p>
<p>空间复杂度：o(n)</p>
<h2 id="二分查找">二分查找</h2>
<p>由于数组是一个递增排序的，直观反应出使用二分查找，对于nums中的每一个数组，判断target-nums[i]是否在数组中即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> target-nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> binarySearch(nums,target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(j &lt; l &amp;&amp; j &gt; -<span class="number">1</span> &amp;&amp; nums[j] == t)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[i],nums[j]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="comment">// System.out.println(l+&quot; &quot;+r);</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;index of target:&quot;+target+&quot; &quot;+l);</span></span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(nlogn)</p>
<p>空间复杂度：o(1)</p>
<h2 id="双指针">双指针</h2>
<p>由于数组是有序的，因此可以使用双指针</p>
<p>初始时l=0,r=nums.length-1，t = nums[l] + nums[r]</p>
<p>此时t和target之间有三种关系</p>
<ul>
<li>t &gt; target，此时nums[i]+nums[r]值太大，需要缩小一点，--r</li>
<li>t &lt; target，此时nums[i]+nums[r]值太小，需要放大一点，++l</li>
<li>t = target，直接返回 [nums[i],nums[r] ]即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[l] + nums[r];</span><br><span class="line">            <span class="keyword">if</span>(t &gt; target)&#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; target)&#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[l],nums[r]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n)</p>
<p>空间复杂度：o(1)</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 59 - II. 队列的最大值</title>
    <url>/posts/16a5/</url>
    <content><![CDATA[<h1 id="剑指-offer-59---ii-队列的最大值">剑指 Offer 59 - II.
队列的最大值</h1>
<p>请定义一个队列并实现函数 max_value
得到队列里的最大值，要求函数max_value、push_back 和 pop_front
的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="单调队列">单调队列</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    Deque&lt;Integer&gt; d;</span><br><span class="line">    <span class="comment">// 假如输入序列 [1,4,3,5,2]</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        输入1时，maxvalue 1</span></span><br><span class="line"><span class="comment">        输入4时，maxvalue 4 , </span></span><br><span class="line"><span class="comment">        输入3时，maxvalue 3 ，此时d为 [4,3,]，q为 [1,4,3,5]</span></span><br><span class="line"><span class="comment">        输入5是，maxvalue 5 ，此时d为 []</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        d = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d.isEmpty() ? -<span class="number">1</span> : d.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这是队列，不是栈，所以最后进来的一定最后出去，因此比它小的一定会优先其出去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 维护一个单调队列</span></span><br><span class="line">        <span class="comment">// 保持队首一定是当前的最大值</span></span><br><span class="line">        <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; d.peekLast() &lt; value) &#123;</span><br><span class="line">            d.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        d.offerLast(value);</span><br><span class="line">        q.offer(value);</span><br><span class="line">        <span class="comment">// System.out.println(d);</span></span><br><span class="line">        <span class="comment">// System.out.println(q);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        <span class="keyword">if</span> (ans == d.peekFirst()) &#123;</span><br><span class="line">            d.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 62. 圆圈中最后剩下的数字</title>
    <url>/posts/8994/</url>
    <content><![CDATA[<h1 id="剑指-offer-62-圆圈中最后剩下的数字">剑指 Offer 62.
圆圈中最后剩下的数字</h1>
<p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">剑指
Offer 62. 圆圈中最后剩下的数字 - 力扣（LeetCode）
(leetcode-cn.com)</a></p>
<p>这一题实际上就是约瑟夫环（Joseph circle）</p>
</blockquote>
<span id="more"></span>

<h2 id="模拟1">模拟（1）</h2>
<p>最开始想到的是使用双端队列，直接进行模拟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="comment">// 如何直接进行模拟的话，所需的时间复杂度为o(m*n)太高了，不合适</span></span><br><span class="line">        <span class="comment">// 可以进行倒退，假设最后一个剩下的数为k，是否可以计算出其前一个被删除的是哪一个？</span></span><br><span class="line">        <span class="comment">// 第一次删除对应的索引 -&gt; (0+m-1) % n = k1</span></span><br><span class="line">        <span class="comment">// 第二次删除对应的索引 -&gt; ((k1+1)+(m-1)) % n-1 = k2</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">minOps</span> <span class="operator">=</span> (m-<span class="number">1</span>+n)%n;</span><br><span class="line">          <span class="keyword">while</span>(minOps&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            deque.offerLast(deque.pollFirst());</span><br><span class="line">            --minOps;</span><br><span class="line">          &#125;</span><br><span class="line">          deque.pollFirst();</span><br><span class="line">          --n;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="keyword">return</span> deque.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为o(n^2)必定会超时的</p>
<h2 id="模拟2">模拟（2）</h2>
<p>同样可以使用ArrayList进行模拟</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="comment">// 如何直接进行模拟的话，所需的时间复杂度为o(m*n)太高了，不合适</span></span><br><span class="line">        <span class="comment">// 可以进行倒退，假设最后一个剩下的数为k，是否可以计算出其前一个被删除的是哪一个？</span></span><br><span class="line">        <span class="comment">// 第一次删除对应的索引 -&gt; (0+m-1) % n = k1</span></span><br><span class="line">        <span class="comment">// 第二次删除对应的索引 -&gt; ((k1+1)+(m-1)) % n-1 = k2</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            c = (c + m - <span class="number">1</span>) % n;</span><br><span class="line">            list.remove(c);</span><br><span class="line">            --n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于删除操作需要o(n)时间复杂度，最终时间复杂度为o(n^2)，空间复杂度为o(n)，勉强是可行的</p>
<h2 id="数学">数学</h2>
<p>实际上我们从双端队列的模拟运行结果可以看出，可以倒推出最后以被删除的数的下标，以n=5,m=3为例</p>
<p>初始状态 list = [0,1,2,3,4]，3所在位置为3</p>
<p>step1:</p>
<p>list = [3,4,0,1], drop 2，3所在位置为0</p>
<p>step2:</p>
<p>list = [1,3,4], drop 0，3所在位置为1</p>
<p>step3:</p>
<p>list = [1,3], drop 4， 3所在位置为1</p>
<p>step4:</p>
<p>list = [3], drop 1，3所在位置为0</p>
<p>然后我们从最后剩下的 3
倒着看，我们可以<strong>反向推出这个数字在之前每个轮次的位置</strong>。</p>
<p>最后剩下的 3 的下标是 0。</p>
<p>第四轮反推，补上 m 个位置，然后模上当时的数组大小 2，位置是(0 + 3) %
2 = 1。</p>
<p>第三轮反推，补上 m 个位置，然后模上当时的数组大小 3，位置是(1 + 3) %
3 = 1。</p>
<p>第二轮反推，补上 m 个位置，然后模上当时的数组大小 4，位置是(1 + 3) %
4 = 0。</p>
<p>第一轮反推，补上 m 个位置，然后模上当时的数组大小 5，位置是(0 + 3) %
5 = 3。</p>
<p>所以最终剩下的数字的下标就是3。因为数组是从0开始的，所以最终的答案就是3。</p>
<p>总结一下反推的过程，就是 (当前index + m) % 上一轮剩余数字的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最后一轮剩下2个人，所以从2开始反推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 63. 股票的最大利润</title>
    <url>/posts/e776/</url>
    <content><![CDATA[<h1 id="剑指-offer-63-股票的最大利润">剑指 Offer 63. 股票的最大利润</h1>
<p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">剑指
Offer 63. 股票的最大利润 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>使用dp[i]代表第i天可以获得的最大利润，dp[0] =
0，那么可以得到状态转移方程 <span class="math display">\[
dp[i] = max(dp[i-1],prices[i]-min(prices[0:i-1]))
\]</span>
如果直接使用这个状态转移方程去编写代码，每次获得min(prices[0:i-1])的时间复杂度为o(i)，整体时间复杂度为o(n^2)，一定会超时，需要进行优化，实际上可以在循环的时候不断更新当前的最小值，那么状态转移方程可以优化成下列形式
<span class="math display">\[
dp[i] = max(dp[i-1],prices[i]-min\_price)
\]</span>
又由于dp[i]仅和dp[i-1]有关，可以将其优化成一个数，然后不断更新其值 <span
class="math display">\[
dp = max(dp,prices[i]-min\_price)
\]</span> 最终代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p:prices)&#123;</span><br><span class="line">            price = Math.min(price,p);</span><br><span class="line">            profit = Math.max(p-price,profit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 64. 求1+2+...+n</title>
    <url>/posts/9336/</url>
    <content><![CDATA[<h1 id="剑指-offer-64-求12n">剑指 Offer 64. 求1+2+...+n</h1>
<p>求 <code>1+2+...+n</code>
，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">剑指 Offer
64. 求1+2+…+n - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="递归短路运算">递归+短路运算</h2>
<p>首先1一直加到n，最简单的就是采用循环，但是本题不准使用循环，那么使用递归也可以模拟循环，但是递归一定需要一个终止条件，而本题不允许使用条件判断语句，即if、A?B:C都是不可以用的，那么就只能使用逻辑表达式求值的短路运算了</p>
<p>对于一个逻辑表达式而言，如果运行时已经知道了该表达式的值时，就不会继续求值了，因此可以使用这个方法来结束递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      	<span class="comment">// 当n为0时，flag的值已经可以确定了，就不会继续执行递归程序，此时就可以终止递归计算，然后返回值</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> n!=<span class="number">0</span> &amp;&amp; (n+=sumNums(n-<span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算循环展开">位运算+循环展开</h2>
<p>小学就学过，1+2+...+n =
(1+n)*n/2，对于除二运算只需要向左位移一位即可，那么难点在于如何通过位运算实现两个数的乘法，实际上也是很简单的，</p>
<p>考虑15*7，将其转换成二进制形式</p>
<p>0b0000_1111 * 0b0000_0111</p>
<p>实际上可以将7拆分为(4+2+1)那么就变成 15*4+15*2+15*1 ，也即 15
&lt;&lt; 2 + 15 &lt;&lt; 1 + 15 &lt;&lt; 0</p>
<p>因此对于任何一个正整数，只需要将其展开31次，转换成二的幂次相加的形式即可</p>
<p>那么现在的实现目标就是，如何知道数字对应位上是否为1，实际上也很简单</p>
<p>b&amp;(1&lt;&lt;i) ==
0，说明数字b的第i位是0，然后同样使用上面的方法执行判断即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> multiply(n+<span class="number">1</span>,n)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span> bool;</span><br><span class="line">      	<span class="comment">// 本来是逐位进行判断的，将其循环展开，由于2^13&lt;10000&lt;2^14，因此只需要判断到13号位即可</span></span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">0</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">2</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">3</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">4</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">4</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">5</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">5</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">6</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">6</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">7</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">7</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">8</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">8</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">9</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">9</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">10</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">10</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">11</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">11</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">12</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        bool = ((b&amp;(<span class="number">1</span>&lt;&lt;<span class="number">13</span>)) != <span class="number">0</span>) &amp;&amp; (res += (a &lt;&lt; <span class="number">13</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 65. 不用加减乘除做加法</title>
    <url>/posts/862c/</url>
    <content><![CDATA[<h1 id="剑指-offer-65-不用加减乘除做加法">剑指 Offer 65.
不用加减乘除做加法</h1>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/”
四则运算符号。\</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/">剑指
Offer 65. 不用加减乘除做加法 - 力扣（LeetCode）
(leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="位运算">位运算</h2>
<p>由于不能使用四则运算符号计算加法，那么就需要使用位运算来模拟加法操作</p>
<p>首先考虑单比特的计算，设有一位信号a和b</p>
<p>那么对于a和b而言其相加共有四种情况</p>
<table>
<thead>
<tr class="header">
<th>a</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>b</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr class="even">
<td>r</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr class="odd">
<td>v</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>其中r代表不进位的结果，v代表进位的结果</p>
<p>那么对于一个正常的数，例如 30 + 17，下面我们来模拟一下计算过程</p>
<p>17 -&gt; 0b0001_0001</p>
<p>30 -&gt; 0b0001_1110</p>
<p>step1:</p>
<p>r = a ^ b = 0b0000_1111</p>
<p>v = ( a &amp; b ) &lt;&lt; 1 = 0b0010_0000</p>
<p>a = r</p>
<p>b = b</p>
<p>step2:</p>
<p>r = a ^ b = 0b0010_1111</p>
<p>v = ( a &amp; b ) &lt;&lt; 1 = 0b0000_0000</p>
<p>此时没有进位，说明计算完成，30+17的结果就是47 -&gt; 0b0010_1111</p>
<p>了解了过程，实际上代码实现起来就很简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> r,v;</span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 不进位相加的结果</span></span><br><span class="line">            r = a ^ b;</span><br><span class="line">            <span class="comment">// 进位结果</span></span><br><span class="line">          	<span class="comment">// 当前位进位结果需要配合下一位的一起计算，因此需要左移一位</span></span><br><span class="line">            v = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = r;</span><br><span class="line">            b = v;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而由于负数在计算机中使用补码表示，加减法可以统一处理，该方法不需要修改直接适用于负数的计算</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</title>
    <url>/posts/9bbf/</url>
    <content><![CDATA[<h1 id="剑指-offer-68---i-二叉搜索树的最近公共祖先">剑指 Offer 68 - I.
二叉搜索树的最近公共祖先</h1>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点
p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x
的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="递归利用二叉搜索树的性质">递归（利用二叉搜索树的性质）</h2>
<p>由于二叉搜索树的有序性质（一定存在 左孩子 &lt; 根 &lt;
右节点），因此只需要在遍历时进行判断即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      	<span class="comment">// 当当前节点的值比p和q都大，说明p和q一定都在root的左子树中，下一个需要判断root.left</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">      	<span class="comment">// root.right同理</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历">遍历</h2>
<p>可以分别找出从根节点到p和q的路径，然后找出二者最后一个重合的节点就是最近公共祖先，这个思路也同样适用于二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; path1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(),path2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        getPath(root,p,path1);</span><br><span class="line">        getPath(root,q,path2);</span><br><span class="line">        <span class="comment">// printPath(path1);</span></span><br><span class="line">        <span class="comment">// printPath(path2);</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">lastCommonNode</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(!path1.isEmpty() &amp;&amp; !path2.isEmpty() &amp;&amp; path1.peekFirst() == path2.peekFirst())&#123;</span><br><span class="line">            lastCommonNode = path1.peekFirst();</span><br><span class="line">            path1.pollFirst();</span><br><span class="line">            path2.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lastCommonNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printPath</span><span class="params">(Deque&lt;TreeNode&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(TreeNode t:path)&#123;</span><br><span class="line">            System.out.print(t.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">getPath</span><span class="params">(TreeNode root,TreeNode p,Deque&lt;TreeNode&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == p || getPath(root.left,p,path) || getPath(root.right,p,path)) &#123;</span><br><span class="line">            path.addFirst(root);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 005. 单词长度的最大乘积</title>
    <url>/posts/1829/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-005-单词长度的最大乘积">剑指 Offer II 005.
单词长度的最大乘积</h1>
<p>给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j]
不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回
0。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/aseY1I">https://leetcode-cn.com/problems/aseY1I</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力位运算">暴力+位运算</h2>
<p>首先看到这个题，没什么好想法，直接暴力吧，首先肯定需要遍历每一个单词对，判断这两个单词对之间是否存在相同字符，如果采用暴力方式判断的话，时间复杂度很高，o(n^2*m^2)，m
=
max(words[i].length)，但是这个题还有一个条件没有用到，字符串中仅包含<strong>英语小写字母</strong>，只有26个字母，那么就可以想到使用位图来表示一个字符串所使用的字母，然后对比两个字符串是否包含相同字符，就只需要将两个位图进行与运算，如果结果为0，则表示这两个字符串不包含相同字符，这样判断两个字符串是否具有相同字符就可以在o(1)的时间复杂度内完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先考虑暴力吧？</span></span><br><span class="line">        <span class="comment">// 直接遍历所有的words[i],words[j]，判断其是否包含相同字符？然后进行比较？</span></span><br><span class="line">        <span class="comment">// 这样感觉时间复杂度太高了</span></span><br><span class="line">        <span class="comment">// 由于仅包含小写字符</span></span><br><span class="line">        <span class="comment">// 26个，int可以装下，然后判断是否包含相同字符，只需要bitmap[i] &amp; bitmap[j] != 0，说明包含相同的字符</span></span><br><span class="line">        <span class="comment">// 直接位运算啊，怎么都需要遍历的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span>[] bitmap = <span class="keyword">new</span> <span class="title class_">int</span>[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> ch:words[i].toCharArray())&#123;</span><br><span class="line">                bitmap[i] |= (<span class="number">1</span>&lt;&lt;(ch-<span class="string">&#x27;a&#x27;</span>)); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((bitmap[i] &amp; bitmap[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    res = Math.max(words[i].length()*words[j].length(),res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1109. 航班预订统计</title>
    <url>/posts/f3e9/</url>
    <content><![CDATA[<h1 id="1109-航班预订统计">1109. 航班预订统计</h1>
<p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p>
<p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] =
[firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和
lasti ）的 每个航班 上预订了 seatsi 个座位。</p>
<p>请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i
上预订的座位总数。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/corporate-flight-bookings">https://leetcode-cn.com/problems/corporate-flight-bookings</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>暴力思路很简单，没什么好说的，开一个数组，然后遍历bookings，然后依次累加即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// 暴力，感觉会超时</span></span><br><span class="line">        <span class="comment">// 外层循环为 2*10^4</span></span><br><span class="line">        <span class="comment">// 内层循环最多为 2*10^4</span></span><br><span class="line">        <span class="comment">// 从 1～n</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] b:bookings)&#123;</span><br><span class="line">            <span class="comment">// [f,l]区间内预订了s个座位，感觉没有必要逐个相加的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> b[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> b[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> b[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=f;i&lt;=l;++i)&#123;</span><br><span class="line">                res[i-<span class="number">1</span>] += s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个题作为中等难度的题目，肯定不能使用暴力作为解法，还存在更有的解法</p>
<h2 id="差分数组前缀和">差分数组+前缀和</h2>
<p>差分数组+前缀和的解题思路在区间问题上很常用，题目 1893.
检查是否区域内所有整数都被覆盖 中也有用到这个思路</p>
<p>在暴力解法中，我们对于区间 [f,l]
内的所有数都进行了一遍操作，这一操作的时间复杂度为o(m)，然而使用差分数组可以将这一操作时间复杂度降至
o(1) ，只需要修改两个位置的值即可</p>
<ul>
<li>diff[l] += s</li>
<li>diff[r+1] -= s</li>
</ul>
<p>下面来演示一下为什么这样做是正确的</p>
<p>输入</p>
<p>bookings = [[1,2,10],[2,3,20],[2,5,25]]</p>
<p>n = 5</p>
<p>初始化 差分数组 diff = [0,0,0,0,0,0] 差分数组大小为
n+1，因为标记时最大需要到n</p>
<p>step1:</p>
<p>碰到区间 [1,2] ，更新diff如下</p>
<p>diff[0] += 10</p>
<p>diff[1+1] -= 10;</p>
<p>diff = [10,0,-10,0,0,0]</p>
<p>step2:</p>
<p>碰到区间 [2,3]，更新diff</p>
<p>diff[1] += 20</p>
<p>diff[3] -= 20</p>
<p>diff = [10,20,-10,-20]</p>
<p>step3:</p>
<p>碰到区间 [2,5]</p>
<p>diff[1] += 25</p>
<p>diff[5] -= 25</p>
<p>diff = [10,45,-10,-20,0,-25]</p>
<p>step4</p>
<p>计算diff的前缀和</p>
<p>prefixSum = [10,55,45,25,25,0]</p>
<p>原理</p>
<blockquote>
<p>注意到一个预订记录实际上代表了一个区间的增量。我们的任务是将这些增量叠加得到答案。因此，我们可以使用差分解决本题。</p>
<p>差分数组对应的概念是前缀和数组，对于数组 [1,2,2,4] ，其差分数组为
[1,1,0,2]，差分数组的第 i 个数即为原数组的第 i-1个元素和第 i
个元素的差值，也就是说我们对差分数组求前缀和即可得到原数组。</p>
<p>**差分数组的性质是，当我们希望对原数组的某一个区间 [l,r] 施加一个增量
inc 时，差分数组 d 对应的改变是：d[l] 增加 inc，d[r+1] 减少
inc。**这样对于区间的修改就变为了对于两个位置的修改。<strong>并且这种修改是可以叠加的，即当我们多次对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。</strong></p>
<p>在本题中，我们可以遍历给定的预定记录数组，每次 O(1)
地完成对差分数组的修改即可。当我们完成了差分数组的修改，只需要最后求出差分数组的前缀和即可得到目标数组。</p>
<p>注意本题中日期从 11
开始，因此我们需要相应的调整数组下标对应关系，对于预定记录
booking=[l,r,inc]，我们需要让 d[l−1] 增加 inc，d[r] 减少 inc。特别地，当
r 为 n 时，我们无需修改
d[r]，因为这个位置溢出了下标范围。如果求前缀和时考虑该位置，那么该位置对应的前缀和值必定为
0。读者们可以自行思考原因，以加深对差分数组的理解。</p>
<p>作者：LeetCode-Solution 链接：<a
href="https://leetcode-cn.com/problems/corporate-flight-bookings/solution/hang-ban-yu-ding-tong-ji-by-leetcode-sol-5pv8/">https://leetcode-cn.com/problems/corporate-flight-bookings/solution/hang-ban-yu-ding-tong-ji-by-leetcode-sol-5pv8/</a>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>*关键点：对差分数组求前缀和就可以还原出原数组，diff[i] = arr[i] -
arr[i-1]</p>
<p>例如对于</p>
<p>arr = [1,2,3,4,5,6]</p>
<p>diff = [1,1,1,1,1,1]</p>
<p>prefix = [1,2,3,4,5,6]</p>
<p>如果将数组 在 [1,4] 区间内的数全部增加10</p>
<p>arr = [1,12,13,14,15,6]</p>
<p>diff = [1,11,1,1,1,-9]</p>
<p>此时diff相对于原来的值</p>
<p>可以发现仅在 diff[1] 加了 10，diff[5] 减了10</p>
<p>再求前缀和又可以还原出数组</p>
<p>prefix = [1,12,13,14,15,6]</p>
<p>了解了差分数组这一独特的性质，再来看题目，就很明显可以看到这是一道差分数组+前缀和的经典题目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">      	<span class="comment">// 进行区间更新</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] b : bookings)&#123;</span><br><span class="line">            diff[b[<span class="number">0</span>]-<span class="number">1</span>]+=b[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(b[<span class="number">1</span>] &lt; n)&#123;</span><br><span class="line">                diff[b[<span class="number">1</span>]]-=b[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 计算前缀和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            diff[i] += diff[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>162. 寻找峰值</title>
    <url>/posts/a8cb/</url>
    <content><![CDATA[<h1 id="162-寻找峰值">162. 寻找峰值</h1>
<p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组
nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回
任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] = nums[n] = -∞ 。</p>
<p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 1000</li>
<li>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</li>
<li>对于所有有效的 i 都有 nums[i] != nums[i + 1]</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/find-peak-element">https://leetcode-cn.com/problems/find-peak-element</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>从题设中可以看到，数组长度并不大，且nums[i] !=
nums[i+1]，那么数组中一定存在最大值（峰值），最终只需要找到数组中的最大值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[idx]) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找">二分查找</h2>
<p>由于数组的两边都为负无穷，那么即使数组中元素是单调的，其也一定存在峰值（数组的两端），若数组不是单调的，那么数组中一定存在峰值，综上，数组中一定存在峰值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">          	<span class="comment">// 这是因为nums[mid] 一定大于 -∞ </span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 当nums[mid] &gt; nums[mid+1] 时，说明[0,mid]区间内一定存在峰值</span></span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1894. 找到需要补充粉笔的学生编号</title>
    <url>/posts/579b/</url>
    <content><![CDATA[<h1 id="1894-找到需要补充粉笔的学生编号">1894.
找到需要补充粉笔的学生编号</h1>
<p>一个班级里有 n 个学生，编号为 0 到 n - 1
。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1
的学生，以此类推，直到编号为 n - 1
的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。</p>
<p>给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k
。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗
chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要
补充 粉笔。</p>
<p>请你返回需要 补充 粉笔的学生 编号 。</p>
<p><strong>提示：</strong></p>
<ul>
<li>chalk.length == n</li>
<li>1 &lt;= n &lt;= 10<sup>5</sup></li>
<li>1 &lt;= chalk[i] &lt;= 10<sup>5</sup></li>
<li>1 &lt;= k &lt;= 10<sup>9</sup></li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk">https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>这个题实际上很简单，不论循环多少次，最终剩下的一定是 k % sum
，然后在这最后一次中找到那个学生所需粉笔数不够的就行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">chalkReplacer</span><span class="params">(<span class="type">int</span>[] chalk, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 实际上sum是有可能溢出的，需要注意</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c:chalk)&#123;</span><br><span class="line">            sum += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> k % sum;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 线性查找</span></span><br><span class="line">        <span class="comment">// o(n)</span></span><br><span class="line">        <span class="comment">// 实际上还可以转化为前缀和+二分查找优化成o(nlogn)</span></span><br><span class="line">        <span class="keyword">while</span>(t&gt;=chalk[i])&#123;</span><br><span class="line">            t -= chalk[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前缀和二分查找">前缀和+二分查找</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">chalkReplacer</span><span class="params">(<span class="type">int</span>[] chalk, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> chalk.length;</span><br><span class="line">        <span class="type">long</span>[] prefixSum = <span class="keyword">new</span> <span class="title class_">long</span>[l+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 由于所需粉笔数大于0，前缀和一定是一个递增的，可以使用二分查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            prefixSum[i+<span class="number">1</span>] = prefixSum[i] + chalk[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> k % prefixSum[l];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> upperBound(prefixSum,k % prefixSum[l]);</span><br><span class="line">        <span class="comment">// 找到第一个大于k的值即可</span></span><br><span class="line">        <span class="keyword">return</span>  prefixSum[idx] &lt;= t ? idx : idx - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">upperBound</span><span class="params">(<span class="type">long</span>[] arr,<span class="type">long</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &lt;= target)&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>223. 矩形面积</title>
    <url>/posts/9a83/</url>
    <content><![CDATA[<h1 id="223-矩形面积">223. 矩形面积</h1>
<p>给你 <strong>二维</strong> 平面上两个 <strong>由直线构成的</strong>
矩形，请你计算并返回两个矩形覆盖的总面积。</p>
<p>每个矩形由其 <strong>左下</strong> 顶点和 <strong>右上</strong>
顶点坐标表示：</p>
<ul>
<li>第一个矩形由其左下顶点 (ax1, ay1) 和右上顶点 (ax2, ay2) 定义。</li>
<li>第二个矩形由其左下顶点 (bx1, by1) 和右上顶点 (bx2, by2) 定义。</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/rectangle-area">https://leetcode-cn.com/problems/rectangle-area</a></p>
</blockquote>
<span id="more"></span>

<h2 id="数学">数学</h2>
<p>这个题就是一个简单的数学题，只需要判断两个矩形之间是否有相交即可</p>
<p>两个矩形重叠部分坐标计算</p>
<p>x1 = Math.max(ax1,bx1)</p>
<p>y1 = Math.max(ay1,by1)</p>
<p>x2 = Math.min(ax2,bx2)</p>
<p>y2 = Math.min(ay2,by2)</p>
<p>如果其中有任意一个坐标为负，说明两个矩形不相交，直接返回两个矩形的面积和即可</p>
<p>，否则就减去重叠部分的面积即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computeArea</span><span class="params">(<span class="type">int</span> ax1, <span class="type">int</span> ay1, <span class="type">int</span> ax2, <span class="type">int</span> ay2, <span class="type">int</span> bx1, <span class="type">int</span> by1, <span class="type">int</span> bx2, <span class="type">int</span> by2)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要计算两个矩形之间是否相交</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> s(ax1,ay1,ax2,ay2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">s2</span> <span class="operator">=</span> s(bx1,by1,bx2,by2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">s3</span> <span class="operator">=</span> s(Math.max(ax1,bx1),Math.max(ay1,by1),Math.min(ax2,bx2),Math.min(ay2,by2));</span><br><span class="line">        <span class="keyword">return</span> s1 + s2 - s3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">s</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x2 &lt; x1 || y2 &lt; y1) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (x2-x1) * (y2-y1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>292. Nim游戏</title>
    <url>/posts/c71b/</url>
    <content><![CDATA[<h1 id="292-nim游戏">292. Nim游戏</h1>
<p>你和你的朋友，两个人一起玩 Nim 游戏：</p>
<ul>
<li>桌子上有一堆石头。</li>
<li>你们轮流进行自己的回合，你作为先手。</li>
<li>每一回合，轮到的人拿掉 1 - 3 块石头。</li>
<li>拿掉最后一块石头的人就是获胜者。</li>
</ul>
<p>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为
n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/nim-game">https://leetcode-cn.com/problems/nim-game</a></p>
</blockquote>
<span id="more"></span>

<h2 id="博弈论">博弈论</h2>
<p>这是一道 Nim 游戏的简化版。</p>
<p>在不知晓博弈论结论前，可以先通过找规律得到猜想，然后再从「何种情况下，先手会处于必胜态」的角度来进行分析。</p>
<p>根据题意，我们尝试从小范围数据的情况进行讨论：</p>
<p>如果落到先手的局面为「石子数量为 1 - 3」的话，那么先手必胜；
如果落到先手的局面为「石子数量为
4」的话，那么先手决策完（无论何种决策），交到后手的局面为「石子数量为 1
-
3」，即此时后手必胜，对应先手必败（到这里我们有一个推论：如果交给先手的局面为
4 的话，那么先手必败）； 如果落到先手的局面为「石子数量为 5 -
7」的话，那么先手可以通过控制选择石子的数量，来使得后手处于「石子数量为
4」的局面（此时后手必败），因此先手必胜；
如果落到先手的局面为「石子数量为 8」的话，由于每次只能选 1 - 3
个石子，因此交由后手的局面为 5 - 7，根据流程 3
我们知道此时先手必败；</p>
<p>到这里，我们猜想 当起始局面石子数量为 4
的倍数，则先手必败，否则先手必胜（即 n % 4 != 0 时，先手必胜）。</p>
<p>然后我们通过「归纳法」证明一下该猜想的正确性。</p>
<p>在上面的「找规律」分析中，我们分情况讨论了最后一个决胜回合（我们称「剩余石子数量少于等于
4 的局面」为最后回合）的情况：如果交由先手的石子数量为
4，那么先手必败，否则先手必胜。</p>
<p>而对于「最后回合」前的任意回合（石子数量大于 4），我们需要证明
先手可以通过调整所选石子数量，来维持「n % 4 != 0」直到最后回合。</p>
<p>如果起始对先手而言满足「n % 4 !=
0」，此时先手可以通过选择石子数量为「n % 4」来确保交到后手的局面为 4
的倍数。</p>
<p>那么根据推论，此时的原始后手作为下一回合的先手角色，且面临石子数量为
4 的倍数的局面，为必败态。</p>
<p>进一步的解释就是，由于原始后手面临石子数量为 4 的倍数的局面，且只能选
1 - 3 个石子，因此无论如何选择，重新回到原始先手的仍然满足「n % 4 !=
0」（非 4 的倍数）。</p>
<p>因此 原始先手只需要确保每次都选择「x % 4」个石子（x
为当前石子数量），就可以确保交由自己的局面一直满足「x % 4 !=
0」，交由对方的局面一直满足「x % 4 == 0」，直到最后回合的到来。</p>
<p>至此，我们证明了 如果起始石子数量 n 满足「n % 4 !=
0」条件，那么先手必胜。</p>
<blockquote>
<p>作者：AC_OIer 链接：<a
href="https://leetcode-cn.com/problems/nim-game/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-wmz2t/">https://leetcode-cn.com/problems/nim-game/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-wmz2t/</a>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>代码就没什么好说的了，只需要判断初始时石子数目即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canWinNim</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 感觉是个数学题</span></span><br><span class="line">        <span class="comment">// A先手</span></span><br><span class="line">        <span class="comment">// 最开始时的时候应该都是拿三，谁也不知道</span></span><br><span class="line">        <span class="comment">// (n-3) % 3 ?然后有余数的话就是你赢，否则就是输</span></span><br><span class="line">        <span class="comment">// 尝试归纳法</span></span><br><span class="line">        <span class="comment">// n在1～3的时候必胜，因为你可以一次全部拿完</span></span><br><span class="line">      	<span class="comment">// n在4的时候必输</span></span><br><span class="line">        <span class="comment">// n在5～7的时候必胜？</span></span><br><span class="line">        <span class="comment">// 当n为4的时候，如果你拿了1，那么B拿3，B赢</span></span><br><span class="line">        <span class="comment">// 当出现4的倍数时候，你是一定输的，因为对手可以一直凑成4，最后让你输</span></span><br><span class="line">        <span class="keyword">return</span> n%<span class="number">4</span> != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>371. 两整数之和</title>
    <url>/posts/c75/</url>
    <content><![CDATA[<h1 id="371-两整数之和">371. 两整数之和</h1>
<p>给你两个整数 <code>a</code> 和 <code>b</code>
，<strong>不使用</strong> 运算符 <code>+</code> 和 <code>-</code>
，计算并返回两整数之和。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>-1000 &lt;= a, b &lt;= 1000</code></li>
</ul>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/sum-of-two-integers/">371.
两整数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="位运算">位运算</h2>
<p>这一题考查使用位运算实现加法，那么我们就从二进制数的加法来看如何计算加法的</p>
<p>以两个二进制数 0b0111 和 0b1110 为例</p>
<p>首先看最低位，</p>
<p>sum = a0+b0+carry = 1，</p>
<p>当前位值为 sum % 2 = 1，进位 sum / 2 = 0</p>
<p>再看前一位</p>
<p>sum = a1+b1+carry = 2</p>
<p>当前位值为 sum %2 = 0，进位 sum / 2 = 1</p>
<p>再前看一位</p>
<p>sum = a2+b2+carry= 3</p>
<p>当前位值位 sum % 2 = 1，进位 sum / 2 = 1</p>
<p>再看前一位</p>
<p>sum = a3+b3+carry = 2</p>
<p>当前位值位 sum % 2 = 0，进位 sum / 2 = 1</p>
<p>此时carry不为0，那么结果上还需要进一位</p>
<p>最终结果位 0b10101</p>
<p>从这个结果中可以看出，由于int只包含32位，我们只需要分别计算32个位上的结果即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>,i,a1,b1,c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;++i)&#123;</span><br><span class="line">          	<span class="comment">// 每次读取第i位的值</span></span><br><span class="line">            a1 = (a&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">            b1 = (b&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">          	<span class="comment">// a1+b1有三种情况，0，1，2，之后再分别讨论进位的情况</span></span><br><span class="line">            <span class="comment">// 这个代码写的属实有点丑陋</span></span><br><span class="line">            <span class="keyword">if</span>(a1 == <span class="number">1</span> &amp;&amp; b1 == <span class="number">1</span>)&#123;</span><br><span class="line">              	<span class="comment">// 如果进位为1，说明sum = 3，当前位为1，且进位也为1</span></span><br><span class="line">              	<span class="comment">// 如果进位为0，说明sum = 2，当前位为0，进位为1</span></span><br><span class="line">                <span class="comment">// if(c == 1)&#123;</span></span><br><span class="line">                <span class="comment">//     res |= (1&lt;&lt;i);</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                res |= (c&lt;&lt;i);</span><br><span class="line">                c = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a1 == <span class="number">0</span> &amp;&amp; b1 == <span class="number">0</span>)&#123;</span><br><span class="line">              	<span class="comment">// 如果进位为1，说明sum=1，当前位为1，进位为0</span></span><br><span class="line">              	<span class="comment">// 如果进位为0，说明sum=0，当前位位0，进位也为0</span></span><br><span class="line">                <span class="comment">// if(c == 1)&#123;</span></span><br><span class="line">                <span class="comment">//     res |= (1&lt;&lt;i);</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                res |= (c&lt;&lt;i);</span><br><span class="line">                c = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              	<span class="comment">// 如果进位为1，说明sum=2，当前位为0，进位为1</span></span><br><span class="line">              	<span class="comment">// 如果进位为0，说明sum=1，当前位为1，进位为0</span></span><br><span class="line">                <span class="comment">// if(c == 1)&#123;</span></span><br><span class="line">                <span class="comment">//     c = 1;</span></span><br><span class="line">                <span class="comment">// &#125;else&#123;</span></span><br><span class="line">                <span class="comment">//     res |= (1&lt;&lt;i);</span></span><br><span class="line">                <span class="comment">//     c = 0;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                res |= ((<span class="number">1</span>^c)&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上对a+b进行分解，可以分为两步，第一步是a^b（即不进位的加法），第二步是a&amp;b（下一位的进位情况）再将这两数的结果累加就可以得到两个数加法的结果，这个可以写成迭代的方式</p>
<h3 id="迭代写法">迭代写法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">      c = (a&amp;b)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">      a = a ^ b;</span><br><span class="line">      b = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归写法">递归写法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum(a^b,(a&amp;b)&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>437. 路径总和III</title>
    <url>/posts/4e47/</url>
    <content><![CDATA[<h1 id="437-路径总和iii">437. 路径总和III</h1>
<p>给定一个二叉树的根节点 root ，和一个整数 targetSum
，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>
<p>路径
不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/path-sum-iii">https://leetcode-cn.com/problems/path-sum-iii</a></p>
</blockquote>
<span id="more"></span>

<h2 id="dfs">dfs</h2>
<h3 id="路径记录">路径记录</h3>
<p>这个题一开始还没搞明白，只想到了从根节点进行搜索的方法，后面想到可以存储访问到当前节点之前的所有路径，之后再遍历路径并求出路径和判断是否等于目标值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> targetSum;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> _targetSum)</span> &#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        targetSum = _targetSum;</span><br><span class="line">        <span class="comment">// 一种暴力思路，以每个节点为根节点，搜索从该节点出发路径值为targetSum的?</span></span><br><span class="line">        <span class="comment">// 感觉必定会超时</span></span><br><span class="line">        dfs(root,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 向上寻找，是否有sum等于targetSum</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> path.size();</span><br><span class="line">        <span class="comment">// 从后向前进行叠加</span></span><br><span class="line">        <span class="keyword">if</span>(sum == targetSum) ++res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=length-<span class="number">1</span>;i&gt;-<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="comment">// 必须是连续的</span></span><br><span class="line">            sum += path.get(i);</span><br><span class="line">            <span class="keyword">if</span>(sum == targetSum) ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加了root.val，当前元素的下标就是length，因为长度变成length+1</span></span><br><span class="line">        path.add(root.val);</span><br><span class="line">        dfs(root.left,path);</span><br><span class="line">        dfs(root.right,path);</span><br><span class="line">        path.remove(length);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前缀和">前缀和</h3>
<p>由于树的特性，从根节点到任意一个子节点的路径都是唯一的，那么可以使用一个哈希表存储前缀和，然后可以在o(1)时间复杂度内找到所有满足条件的路径数目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> res,targetSum;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> _targetSum)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        targetSum = _targetSum;</span><br><span class="line">        map.put(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀和</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> currSum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        currSum += root.val;</span><br><span class="line">        <span class="comment">// currSum一定是已经加上了root.val的</span></span><br><span class="line">        <span class="comment">// 如果存在 currSum - targetSum的值，说明存在中间节点，是的从该节点出发到当前节点的路径和为targetSum</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(currSum - targetSum)) res += map.get(currSum-targetSum);</span><br><span class="line">        map.put(currSum,map.getOrDefault(currSum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        dfs(root.left,currSum);</span><br><span class="line">        dfs(root.right,currSum);</span><br><span class="line">        map.put(currSum,map.get(currSum)-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>470. 用Rand7()实现Rand10()</title>
    <url>/posts/4be5/</url>
    <content><![CDATA[<h1 id="470-用rand7实现rand10">470. 用Rand7()实现Rand10()</h1>
<p>已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法
rand10 生成 1 到 10 范围内的均匀随机整数。</p>
<p>不要使用系统的 Math.random() 方法。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/implement-rand10-using-rand7">https://leetcode-cn.com/problems/implement-rand10-using-rand7</a></p>
</blockquote>
<span id="more"></span>

<h2 id="数学">数学</h2>
<p>首先看到这个题目确实没什么思路【概率论都忘完了】，其实考察的就是概率论</p>
<blockquote>
<p>已知 rand_N() 可以等概率的生成[1, N]范围的随机数 那么： (rand_X() -
1) × Y + rand_Y() ==&gt; 可以等概率的生成[1, X * Y]范围的随机数 即实现了
rand_XY()</p>
<p>作者：kkbill 链接：<a
href="https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/">https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/</a>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>设数A是[1,X*Y]内的任意一个数，如果将其看成是A/Y的结果记为 a
和余数情况记为 b，那么A/Y*Y + A%Y = A</p>
<p>那么对于Rand7() -&gt; Rand10()</p>
<p>使用这个思路，可以做两次随机采样，且使用公式 Rand7() + (Rand7-1) * 7
来生成 [1,49]
的均匀分布，之后使用拒绝采样思想，当生成1～40的数时接受结果，生成41～49时拒绝（就是当这次抽样失败，进行下一次），这样可以从[1～49]转化成[1~40]的均匀分布，由于其每个数字出现的概率都是一样的，那么再对10取余+1就可得到[1~10]的均匀分布，思路是这样，但是我们每次进行采样都有9/49的概率进行下一次抽样，如果能够降低这个概率，就可以减少重新采样的次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The rand7() API is already defined in the parent class SolBase.</span></span><br><span class="line"><span class="comment"> * public int rand7();</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a random integer in the range 1 to 7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// idx一定是1～49内的一个数,因为col代表的余数，(row-1)代表的是除数</span></span><br><span class="line">            v = rand7() + (rand7() - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">            <span class="comment">// 生成 v 的概率是 1/49，然后取前40个，那么就是</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (v &gt; <span class="number">40</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + (v - <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0～39 % 10</p>
<p>0，1，2，3，4，5，6，7，8，9，</p>
<p>0，1，2，3，4，5，6，7，8，9，</p>
<p>0，1，2，3，4，5，6，7，8，9</p>
<p>0，1，2，3，4，5，6，7，8，9</p>
<p>1～40 % 10</p>
<p>1，2，3，4，5，6，7，8，9，0</p>
<p>1，2，3，4，5，6，7，8，9，0</p>
<p>1，2，3，4，5，6，7，8，9，0</p>
<p>1，2，3，4，5，6，7，8，9，0</p>
<p>实际上没有区别，因此 (v-1) % 10感觉意义不大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The rand7() API is already defined in the parent class SolBase.</span></span><br><span class="line"><span class="comment"> * public int rand7();</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a random integer in the range 1 to 7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">SolBase</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// idx一定是1～49内的一个数,因为col代表的余数，(row-1)代表的是除数</span></span><br><span class="line">            v = rand7() + (rand7() - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span>(v &lt; <span class="number">41</span>) <span class="keyword">return</span> v % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 此时 v 是 [1~9]的均匀分布</span></span><br><span class="line">            v -= <span class="number">40</span>;</span><br><span class="line">            v = rand7() + ( v - <span class="number">1</span> ) * <span class="number">7</span>;</span><br><span class="line">            <span class="comment">// 此时 v 是 [1~63]的均匀分布</span></span><br><span class="line">            <span class="keyword">if</span>(v &lt; <span class="number">61</span>) <span class="keyword">return</span> v % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            v -= <span class="number">60</span>;</span><br><span class="line">            <span class="comment">// 此时 v 是 [1~3] 的均匀分布</span></span><br><span class="line">            v = rand7() + ( v - <span class="number">1</span>) * <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span>(v &lt; <span class="number">21</span>) <span class="keyword">return</span> v % <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 最后只有一个1，拒绝采样</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*注：这个题其实很有实际意义，对于一个给定范围的均匀分布，我们要能够构造出任意区间的均匀分布，同时需要理解拒绝采样思想，限定样本的分布</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>502. IPO</title>
    <url>/posts/deb8/</url>
    <content><![CDATA[<h1 id="502-ipo">502. IPO</h1>
<p>假设 力扣（LeetCode）即将开始 IPO
。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO
之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k
个不同的项目。帮助 力扣 设计完成最多 k
个不同项目后得到最大总资本的方式。</p>
<p>给你 n 个项目。对于每个项目 i ，它都有一个纯利润 profits[i]
，和启动该项目需要的最小资本 capital[i] 。</p>
<p>最初，你的资本为 w
。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。</p>
<p>总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本
，并输出最终可获得的最多资本。</p>
<p>答案保证在 32 位有符号整数范围内。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/ipo">https://leetcode-cn.com/problems/ipo</a></p>
</blockquote>
<span id="more"></span>

<h2 id="贪心优先队列">贪心+优先队列</h2>
<p>这个题的思路很简单，对于当前拥有的本金w，每次在所有启动资金小于w（即可以完成的项目中）选择利润最大的，这样每次都是完成当前利润最大的项目，最终达到资本最大化，在这个思路下，可以很简单的写出o(n^2)算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, <span class="type">int</span>[] profits, <span class="type">int</span>[] capital)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> capital.length;</span><br><span class="line">      	<span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[l];</span><br><span class="line">      	<span class="keyword">while</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">          	<span class="type">int</span> <span class="variable">currProject</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          	<span class="type">int</span> <span class="variable">currProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i] &amp;&amp; w &gt;= capital[i] &amp;&amp; currProfit &gt; profits[i])&#123;</span><br><span class="line">										currProject = i;</span><br><span class="line">                  	currProfit = profits[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          	visited[currProject] = <span class="literal">true</span>;</span><br><span class="line">          	w += currProfit;</span><br><span class="line">          	--k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题数据量较大，直接暴力不可取，需要进一步优化，很明显最外层的k次循环节省不了，只能从查找当前最优项目出发，如何快速找到所有小于w的项目中利润率最大的，可以先对capital排序，然后使用优先队列找到最佳的即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximizedCapital</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> w, <span class="type">int</span>[] profits, <span class="type">int</span>[] capital)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> profits.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            arr[i][<span class="number">0</span>] = capital[i];</span><br><span class="line">            arr[i][<span class="number">1</span>] = profits[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (curr &lt; n &amp;&amp; arr[curr][<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">                pq.add(arr[curr][<span class="number">1</span>]);</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!pq.isEmpty()) &#123;</span><br><span class="line">                w += pq.poll();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>583. 两个字符串的删除操作</title>
    <url>/posts/a0e8/</url>
    <content><![CDATA[<h1 id="583-两个字符串的删除操作">583. 两个字符串的删除操作</h1>
<p>给定两个单词 <em>word1</em> 和 <em>word2</em>，找到使得
<em>word1</em> 和 <em>word2</em>
相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">583.
两个字符串的删除操作 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>这个题实际上是在求两个字符串的最长公共子序列，只需要求出最长公共子序列的长度，就可以直接得出最少的删除次数</p>
<p>dp[i,j]表示word1[0:i-1]的子序列中和word2[0:j-1]的子序列中相同长度最长的，状态转移方程</p>
<p>当 word1[i] == word2[j] 时，就只需要计算dp[i-1,j-1]中最长子序列长度
<span class="math display">\[
dp[i,j] = Math.max(dp[i-1,j-1]+1,dp[i,j])
\]</span> 当word1[i] != word2[j] 时，此时最长公共子序列一定在 dp[i,j-1]
和 dp[i-1,j]之中 <span class="math display">\[
dp[i,j] = Math.max(dp[i-1,j],dp[i,j-1])
\]</span></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="comment">// 求出两个字符串的最长公共子序列即可</span></span><br><span class="line">        <span class="comment">// dp[i][j]代表word1[0:i-1]中任意长度的子序列和word2[0:j-1]中任意长度的子序列的最长公共子序列长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span>[] w1 = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] w2 = word2.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l1;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=l2;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(w1[i-<span class="number">1</span>] == w2[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i][j]); </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 最终word1和word2都需要删除值dp[l1][l2]的长度，那么需要删除的字符数减去即可</span></span><br><span class="line">        <span class="keyword">return</span> l1+l2-(dp[l1][l2]&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>600. 不含连续1的非负整数</title>
    <url>/posts/2eb0/</url>
    <content><![CDATA[<h1 id="600-不含连续1的非负整数">600. 不含连续1的非负整数</h1>
<p>给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含
<strong>连续的1</strong> 的个数。</p>
<p><strong>说明:</strong> 1 &lt;= n &lt;= 109</p>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>逐个判断 [0,n]
内的数，是否满足条件，然后进行统计，时间复杂度o(n)，本题数据量极大，必定超时，需要考虑其他解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findIntegers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 1 &lt;= n &lt;= 10^9，数据量太大了</span></span><br><span class="line">        <span class="comment">// 先写一个暴力解法吧</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">31</span>;++j)&#123;</span><br><span class="line">                <span class="comment">// 连续两位都是1</span></span><br><span class="line">                <span class="keyword">if</span>(</span><br><span class="line">                    (((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>) &amp;&amp; </span><br><span class="line">                    (((i &gt;&gt; (j+<span class="number">1</span>)) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                )&#123;</span><br><span class="line">                    --res;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数位dp">数位DP</h2>
<p>dp[i,j]代表长度为 i 的二进制数，其最高位为 j ( 0 或 1 )
的合法数个数</p>
<p>初始条件</p>
<ul>
<li>dp[1,0] = 1 (此时仅有0一个)</li>
<li>dp[1,1] = 2 (此时有0、1两个合法数)</li>
</ul>
<p>那么考虑状态转移方程，已知 dp[i,0] 的方案数，记为A，dp[i,1]
的方案数，记为B</p>
<ul>
<li><p>对于最高位为0的情况，需要统计所有满足 (0...)
形式的合法数值，当前位的低一位只能填 1（填 0
会出现重复计数，即需要忽略前导零的数值），此时有：</p>
<p>dp[i + 1,0] = dp[i,1]</p></li>
<li><p>对于最高位为1的情况，则需要统计所有满足(0...)形式和(1...)形式的合法数值（因为(0...)一定是小于(1...)的，在相同的长度情况下），因此是一定需要进行计数的</p>
<p>dp[i + 1,1] = dp[i,0] + dp[i,1]</p></li>
</ul>
<p>当有了预先计算好的dp数组之后，可以计算所有小于n的合法数个数</p>
<p>下面以30为例</p>
<p>初始化</p>
<p>n = 0b0001_1110</p>
<p>dp = [</p>
<p>​
[0,0],[1,2],[2,3],[3,5],[5,8],[8,13],[13,21],[21,34],[34,55],[55,89]</p>
<p>]</p>
<p>可以很明显的看到，该二进制数的长度为4</p>
<p>step1:</p>
<p>从第4位开始计算，由于 (n &gt;&gt; 4) &amp; 1 ==
1，说明该数的第4位为1，很明显可以看到，如果第4位置0，那么 dp[5,0]
是一定满足条件的，则有 res += dp[5,0] = 8 (此时增加的是
0,1,10,100,101,1000,1001,1010)</p>
<p>step2:</p>
<p>从第3位开始计算，由于 (n &gt;&gt; 3) &amp; 1 ==
1，说明该数的第3位为1，此时不管前一位是什么，将这一位置0，此时dp[4,0]也是一定满足条件的，有
res += dp[4,0] = 13 (此时增加的是
10000,10001,10010,10100,10101)，相当于是固定了第4位为1，第3位为0的情况下计算满足条件的个数，此时由于第4位是1，第3位也是1，当固定了第4位和第3位是1的情况下，之后的所有数都一定不满足条件，因此可以结束循环</p>
<p>返回所有小于 30 的不含连续1的非负整数个数为13，分别是
0,1,10,100,101,1000,1001,1010,10000,10001,10010,10100,10101</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="comment">// f[i][j] 为考虑二进制长度为 i，而且最高位为 j（0 or 1）时的合法数个数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">0</span>] = f[i][<span class="number">1</span>];</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">1</span>] = f[i][<span class="number">0</span>] + f[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getLen</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      	<span class="comment">// 从最高位开始判断，找到第一个为1的位置即为该二进制数的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((n &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findIntegers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> getLen(n);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, prev = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 当前位是 0 还是 1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> ((n &gt;&gt; i) &amp; <span class="number">1</span>); </span><br><span class="line">            <span class="comment">// 如果当前位是 1，那么填 0 的话，后面随便填都符合，将方案数累加</span></span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">1</span>) ans += f[i + <span class="number">1</span>][<span class="number">0</span>]; </span><br><span class="line">            <span class="comment">// 出现连续位为 1，分支结束，方案数被计算完</span></span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="number">1</span> &amp;&amp; cur == <span class="number">1</span>) <span class="keyword">break</span>; </span><br><span class="line">            prev = cur;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划">动态规划</h2>
<p>从前一个解法的示例中可以看出，所有小于等于30的不含连续1的非负整数的个数为13，其分别是</p>
<p>0,1,10,100,101,1000,1001,1010,10000,10001,10010,10100,10101</p>
<p>我们可以看到</p>
<p>长度为1的不含连续1的非负整数的个数为2，</p>
<p>长度为2的不含连续1的非负整数的个数为3，</p>
<p>长度为3的不含连续1的非负整数的个数为5，</p>
<p>长度为4的不含连续1的非负整数的个数为8，</p>
<p>长度为5的不含连续1的非负整数的个数为13，</p>
<p>很明显这是一个斐波那契数列，那么满足</p>
<p>dp[n] = dp[n-1] + dp[n-2]</p>
<p>那么，知道这个条件之后，再计算所有小于等于n的不含连续1的非负整数的个数为多少</p>
<p>以3000为例，其二进制为 0b1011_1011_1000</p>
<p>dp = [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597]</p>
<p>在计算过程中实际上和数位dp的过程已知，当遍历的该位是1时，那么将该位置0的（即长度为i-1）的所有都可以计算，</p>
<p>即需要加上dp[i-1]，之后再计算下一位的时候则将该位置1（因为置0的已经计算过了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findIntegers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">31</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; <span class="number">31</span>; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">29</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; val) != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(dp[i+<span class="number">1</span>]);</span><br><span class="line">                res += dp[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (pre == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>91. 解码方法</title>
    <url>/posts/a9a4/</url>
    <content><![CDATA[<h1 id="91-解码方法">91. 解码方法</h1>
<p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;A&#x27; -&gt; 1</span><br><span class="line">&#x27;B&#x27; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; 26</span><br></pre></td></tr></table></figure>

<p>要 解码
已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106"
可以映射为：</p>
<p>"AAJF" ，将消息分组为 (1 1 10 6) "KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为 (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6"
和 "06" 在映射中并不等价。</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 s ，请计算并返回
<strong>解码</strong> 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/decode-ways">https://leetcode-cn.com/problems/decode-ways</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>这个题是一个很经典的动态规划题，字符编码主要有两种情况，长度为1和长度为2，长度为1的是
'1'~'9'，长度为2的则是 '10' ～
'26'，除此之外的都是不合法的，因此只需要考虑字符串中单个字符和两个字符能否组成字母即可</p>
<p>使用dp[i]表示字符串在 [0,i)
的子串共包含多少种解码方式，状态转移方程</p>
<p>需要观察 s[i-1]和s[i]的情况，</p>
<ul>
<li>如果 s[i-1]和s[i]可以组成一个单词，那么其对应的解码方式为
dp[i-2]，</li>
<li>如果将这个两个分开来看的话，其对应的解码方式为 dp[i-1]</li>
</ul>
<p>了解了基本情况之后，需要考虑特殊情况</p>
<ul>
<li>如果当前字符为 '0'，由于 '0'
不存在对应的字符，需要配合前一个字符一起组成字符（'10'或'20')，对应的解码方式为
dp[i-2]，否则就是无法解码（直接返回0）</li>
<li>如果前一个字符为 '0'，那么如果当前字符也为
'0'，此时无法解码，直接返回
0，此时只能由单个字符组成字母，对应解码方式为 dp[i-1]</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;++i)&#123;</span><br><span class="line">            curr = s.charAt(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(prev == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prev == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">              	<span class="comment">// 10，且只有这一种解码方式</span></span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="string">&#x27;0&#x27;</span>) dp[i] = dp[i-<span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 11~19</span></span><br><span class="line">              	<span class="keyword">else</span> dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prev == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">              	<span class="comment">// 20，且只有这一种解码方式</span></span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="string">&#x27;0&#x27;</span>) dp[i] = dp[i-<span class="number">2</span>];</span><br><span class="line">              	<span class="comment">// 21~26</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;6&#x27;</span>) dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              	<span class="comment">// 30等，不存在对应的解码方式，直接返回0</span></span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">              	<span class="comment">// 只能单独解码</span></span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上从状态转移方程中可以看到，dp[i]的结果仅与
dp[i-1]和dp[i-2]有关，可以不用数组进行存储，只存储两个值，然后不断更新即可</p>
<h1 id="639-解码方法-ii">639. 解码方法 II</h1>
<p>一条包含字母 A-Z 的消息通过以下的方式进行了编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;A&#x27; -&gt; 1</span><br><span class="line">&#x27;B&#x27; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; 26</span><br></pre></td></tr></table></figure>

<p>要 <strong>解码</strong>
一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106"
可以映射为：</p>
<ul>
<li>"AAJF" 对应分组 (1 1 10 6)</li>
<li>"KJF" 对应分组 (11 10 6)</li>
</ul>
<p>注意，像 (1 11 06) 这样的分组是无效的，因为 "06" 不可以映射为 'F'
，因为 "6" 与 "06" 不同。</p>
<p><strong>除了</strong> 上面描述的数字字母映射方案，编码消息中可能包含
'*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括
'0'）。例如，编码字符串 "1*" 可以表示
"11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19"
中的任意一条消息。对 "1*"
进行解码，相当于解码该字符串可以表示的任何编码消息。</p>
<p>给你一个字符串 s ，由数字和 '*' 字符组成，返回 <strong>解码</strong>
该字符串的方法 数目 。</p>
<p>由于答案数目可能非常大，返回对 10<sup>9</sup> + 7 取余 的结果。</p>
<blockquote>
<p>来源：力扣（LeetCode） 链接：<a
href="https://leetcode-cn.com/problems/decode-ways-ii">https://leetcode-cn.com/problems/decode-ways-ii</a>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="动态规划-1">动态规划</h2>
<p>这一题是上一题的变种，就是在解码中添加了一个可代表
'1'～'9'的'*'，从而使得解码方式更多，但是解题思路是一样的，由于构成字母的字符只有可能是
'1'~'26'中一个，那么可行的长度要么为1要么为2，因此我们只需要考虑情况前一个字符和当前字符能否组成字母，且有多少种组合方式即可</p>
<p>同样使用 dp[i]表示字符串[0,i)中所有的可行解码方式</p>
<ul>
<li><p>如果将s[i-1]和s[i]组合成一个字母的话，对应的编码方式为 dp[i-2] *
(counts(s[i-1]+s[i]))</p>
<p>counts(s[i-1]+s[i])表示s[i-1]和s[i]组成一个字母对应的所有可行解码方式</p></li>
<li><p>如果将s[i-1]和s[i]分成两个字母的话，对应的编码方式为 dp[i-1] *
(counts(s[i]))</p>
<p>counts(s[i])表示s[i]单独看成一个字母对应的所有可行解码方式</p></li>
</ul>
<p>接下来分析所有可行的解码方式</p>
<p>考查s[i-1]（记为prev）和s[i]（记为curr），所有的取值为
'*'、'0'~'9'</p>
<ul>
<li><p>如果prev为 '*'</p>
<ul>
<li><p>如果curr为'*'</p>
<p>分开看对应的解码方式为dp[i-1]*9</p>
<p>如果组合起来一起看的话，那么只有 prev为
'1'，curr可以为'1'~'9'（此时包含9种），当prev为'2'时，curr可以为'1'~'6'（此时包含6种）合起来可行的解码方式为
dp[i-2] * 15</p>
<p>因此 dp[i] = dp[i-1] * 9 + dp[i-2] * 15</p></li>
<li><p>如果curr为'0'</p>
<p>此时只能组合起来看，且 prev只能取 '2','1'，因此就2种取法</p>
<p>dp[i] = dp[i-2] * 2</p></li>
<li><p>如果curr为 '1'~'6'，当组合一起看的话，可以有
'11','21'两种，也可以单独看</p>
<p>dp[i] = dp[i-1] + dp[i-2] * 2</p></li>
<li><p>如果curr为'7'~'9'，当组合一起看的话，只有 '17'一种</p>
<p>dp[i] = dp[i-1] + dp[i-2]</p></li>
</ul></li>
<li><p>如果prev为 '0'</p>
<ul>
<li><p>如果curr为'*'</p>
<p>此时只能分开看，因此dp[i] = dp[i-1] * 9</p></li>
<li><p>如果curr为 '1'~'9'，此时也只能分开看，dp[i] = dp[i-1]</p></li>
<li><p>如果curr为'0'，此时碰到了两个连续的0，无法进行解码，直接返回0</p></li>
</ul></li>
<li><p>如果prev为'1'</p>
<ul>
<li><p>如果curr为'*'，分开看包含dp[i-1]*9种解码方式，组合一起看包含dp[i-2]*9，因此</p>
<p>dp[i] = dp[i-1] * 9 + dp[i-2] * 9</p></li>
<li><p>如果curr为'1'~'9'，分开看就是 dp[i-1]中，组合一起看就是
dp[i-2]种</p>
<p>dp[i] = dp[i-1] + dp[i-2]</p></li>
<li><p>如果curr为'0'，此时只能组合一起看</p>
<p>dp[i] = dp[i-2]</p></li>
</ul></li>
<li><p>如果prev为'2'</p>
<ul>
<li><p>如果curr为'*'，分开看包含dp[i-1]*9种，组合一起看包含dp[i-2]*6</p>
<p>dp[i] = dp[i-1]*6+dp[i-2]*9</p></li>
<li><p>如果curr为'1'~'6'，分开看dp[i-1]种，组合一起看dp[i-2]</p>
<p>dp[i] = dp[i-2] + dp[i-2]</p></li>
<li><p>如果curr为 '7' ~ '9'，此时只能分开看</p>
<p>dp[i] = dp[i-1]</p></li>
<li><p>如果curr为'0'，此时只能组合一起看</p>
<p>dp[i] = dp[i-2]</p></li>
</ul></li>
<li><p>如果prev为其他值'3'~'9'</p>
<ul>
<li><p>如果curr为 '*'，只能分开看</p>
<p>dp[i] = dp[i-1]*9</p></li>
<li><p>如果curr为'0'，此时无法进行解码，直接返回0</p></li>
<li><p>如果为其他值，也只能分开看</p>
<p>dp[i] = dp[i-1]</p></li>
</ul></li>
</ul>
<p>写出了状态转移方程之后，就可以很轻松的写出代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">      	<span class="comment">// 此处存储结果的时候必须要使用long，由于乘法计算是有可能超出int的表示范围，此时再对ie9+7取模也是没有用的</span></span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[l+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;++i)&#123;</span><br><span class="line">            <span class="comment">// 相乘的时候是有可能溢出的</span></span><br><span class="line">            curr = s.charAt(i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(prev == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// **</span></span><br><span class="line">                    dp[i] = ((dp[i-<span class="number">1</span>]*<span class="number">9</span>)%MOD+(dp[i-<span class="number">2</span>]*<span class="number">15</span>)%MOD)%MOD;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// *0</span></span><br><span class="line">                    dp[i] = (dp[i-<span class="number">2</span>] * <span class="number">2</span>) % MOD;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;6&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">// *1 ～ *6</span></span><br><span class="line">                    dp[i] = (dp[i-<span class="number">1</span>]+(dp[i-<span class="number">2</span>]*<span class="number">2</span>)%MOD)%MOD;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// *7 ～ *9</span></span><br><span class="line">                    dp[i] = (dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prev == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = (dp[i-<span class="number">1</span>] * <span class="number">9</span>) % MOD;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prev == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = ((dp[i-<span class="number">1</span>]*<span class="number">9</span>)%MOD+(dp[i-<span class="number">2</span>]*<span class="number">9</span>)%MOD)%MOD;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = dp[i-<span class="number">2</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i] = (dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prev == <span class="string">&#x27;2&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = ((dp[i-<span class="number">1</span>]*<span class="number">9</span>)%MOD+(dp[i-<span class="number">2</span>]*<span class="number">6</span>)%MOD)%MOD;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = dp[i-<span class="number">2</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr &gt;= <span class="string">&#x27;1&#x27;</span> &amp;&amp; curr &lt;= <span class="string">&#x27;6&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = (dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>]) % MOD;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    dp[i] = (dp[i-<span class="number">1</span>] * <span class="number">9</span>) % MOD;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(curr == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)dp[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，从状态转移方程中可以看到，dp[i]仅和dp[i-1]和dp[i-2]相关，因此可以只使用两个数，然后不断更新，将空间压缩至o(1)</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>650. 只有两个键的键盘</title>
    <url>/posts/5050/</url>
    <content><![CDATA[<h1 id="650-只有两个键的键盘">650. 只有两个键的键盘</h1>
<p>最初记事本上只有一个字符 'A'
。你每次可以对这个记事本进行两种操作：</p>
<p>Copy
All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
Paste（粘贴）：粘贴 上一次 复制的字符。 给你一个数字 n
，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A'
。返回能够打印出 n 个 'A' 的最少操作次数。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/2-keys-keyboard">https://leetcode-cn.com/problems/2-keys-keyboard</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>一开始直接看的话很难想到状态转移方程，那么我们先看几个简单的例子，之后逐步推导出状态转移方程。</p>
<p>首先可以想到使用dp[i]表示复制出i个A所需要的最小操作次数为dp[i]，那么需要考察dp[i]和之前计算好的状态之间的转移关系</p>
<p>由于复制是选中所有的字符进行复制，那么假设当前包含k个字符，那么复制了之后可以粘贴j-1次得到j*k个字符，通过这个我们可以想到，如果需要计算所需要的最少操作次数，我们应该从n的全部因数出发，对n进行因数分解，状态转移方程
<span class="math display">\[
dp[i] = min(dp[j] + i / j)
\]</span> 此处j需要满足 i % j == 0，即j是i的因子</p>
<p>因此我们只需要不断计算当前n的所有因子，并得出其最小值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSteps</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 只能进行两种操作，复制和粘贴（经典CV工程师）</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果是素数好像就只能是那么多，但是如果不是素数就可以稍微计算一手</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="comment">// 最大可能就是i，也就是质数的情况，此时只能一个一个进行复制</span></span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="comment">// 否则需要进行因数分解，然后计算出最小值？</span></span><br><span class="line">            <span class="comment">// 实际上大部分的时间都划分在质因数分解上面，如何快速找到这个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 可以整除的时候，就先凑出dp[j]，之后就全部进行复制即可</span></span><br><span class="line">                    <span class="comment">// 15的8次怎么来的，凑出5，然后copy，paste，paste，这样就是8次ß</span></span><br><span class="line">                    dp[i] = Math.min(dp[i],dp[j]+i/j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>673. 最长递增子序列的个数</title>
    <url>/posts/1f1b/</url>
    <content><![CDATA[<h1 id="673-最长递增子序列的个数">673. 最长递增子序列的个数</h1>
<p>给定一个未排序的整数数组，找到最长递增子序列的个数。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">673.
最长递增子序列的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<h2 id="300-最长递增子序列">300. 最长递增子序列</h2>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7]
是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<blockquote>
<p>来源：力扣（LeetCode） 链接：<a
href="https://leetcode-cn.com/problems/longest-increasing-subsequence">https://leetcode-cn.com/problems/longest-increasing-subsequence</a>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>这一题需要计算出数组中最长递增子序列的长度，使用动态规划进行计算，dp[i]表示以nums[i]结尾的最长递增子序列长度
<span class="math display">\[
dp[i] = Math.max(dp[j]+1,dp[i])
\]</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="comment">// 此处初始化dp[i] = 1是必须的</span></span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么回到这一题，我们需要计算出最长递增子序列的个数，通过前一个算法我们可以计算出最长递增子序列的长度，为计算出所有的个数，我们还需要添加一个数组来计算最长递增子序列的长度，使用count[i]表示以nums[i]即为的最长递增子序列的个数</p>
<p>那么对于counts[i]的状态转移方程</p>
<p>counts[i] = counts[j] if nums[j] &lt; nums[i] &amp;&amp; dp[i] &lt;
dp[j] + 1</p>
<p>counts[i] += counts[j] if nums[j] &lt; nums[i] &amp;&amp; dp[i] ==
dp[j] + 1</p>
<p>下面以数组 [1,3,5,4,7 ] 来介绍计算过程</p>
<p>初始化</p>
<p>dp = [0,0,0,0,0]</p>
<p>counts = [0,0,0,0,0]</p>
<p>step1:</p>
<p>i = 0</p>
<p>dp[0] = 1 ,代表子序列 [1]</p>
<p>coutns[0] = 1</p>
<p>step2:</p>
<p>i = 1</p>
<p>nums[i] &gt; nums[i-1]</p>
<p>dp[1] = dp[0] + 1 = 2, 代表子序列 [1,3]</p>
<p>counts[1] = 1</p>
<p>step3:</p>
<p>i = 2</p>
<p>nums[i] &gt; nums[i-1]</p>
<p>dp[2] = dp[1] + 1 = 3, 代表子序列 [1,3,5]</p>
<p>counts[2] = 1</p>
<p>step4:</p>
<p>i = 3</p>
<p>nums[i] &lt; nums[i-1]</p>
<p>dp[3] = dp[1] + 1 = 3 ，代表子序列 [1,3,4]</p>
<p>counts[2] = 1</p>
<p>step5:</p>
<p>i = 4</p>
<p>nums[i] &gt; nums[i-1]</p>
<p>dp[4] = dp[2] + 1 = 4，代表子序列 [1,3,5,7]</p>
<p>counts[4] = 1</p>
<p>此时 dp[4] 同样满足 dp[4] = dp[3] + 1 ，对应子序列 [1,3,4,7]</p>
<p>counts[4] += counts[3]</p>
<p>counts[4] = 2</p>
<p>遍历结束，返回最终结果2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNumberOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// f[i]表示以nums[i]结尾的最长子序列长度</span></span><br><span class="line">        <span class="comment">// g[i]表示以nums[i]结尾的最长子序列个数</span></span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n], g = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            f[i] = g[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f[i] &lt; f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                        f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">                        g[i] = g[j];</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f[i] == f[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                        g[i] += g[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 记录最长子序列的长度</span></span><br><span class="line">            max = Math.max(max, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] == max) ans += g[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>678. 有效的括号字符串</title>
    <url>/posts/818d/</url>
    <content><![CDATA[<h1 id="678-有效的括号字符串">678. 有效的括号字符串</h1>
<p>给定一个只包含三种字符的字符串：（ ，） 和
*，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：</p>
<ul>
<li>任何左括号 ( 必须有相应的右括号 )。</li>
<li>任何右括号 ) 必须有相应的左括号 ( 。</li>
<li>左括号 ( 必须在对应的右括号之前 )。</li>
</ul>
<ul>
<li>可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。</li>
</ul>
<p>一个空字符串也被视为有效字符串。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/valid-parenthesis-string">https://leetcode-cn.com/problems/valid-parenthesis-string</a></p>
</blockquote>
<span id="more"></span>

<h2 id="栈">栈</h2>
<p>使用两个栈分别存储 '(' 和 '*'
的下标，分别记为left和star，然后每当碰到 ')' 时优先使用 '('
栈中的进行匹配，如果实在没有再使用 '*'
进行匹配，当遍历完成的时候，如果left和star不为空时，此时即为类似
'***(((' 或 '(((***' 这种情况，当碰到 '*(' 时就可以直接返回
false，因为无法匹配 '(' 也就是判断
star栈中栈顶元素下标是否比left栈顶元素下标大即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkValidString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; left = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; star = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                left.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                star.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!left.isEmpty())&#123;</span><br><span class="line">                    left.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!star.isEmpty())&#123;</span><br><span class="line">                    star.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 两个栈都为空，实在没有可以匹配的，直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后遍历结束时候</span></span><br><span class="line">        <span class="keyword">while</span>(!left.isEmpty() &amp;&amp; !star.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 形成的是 *( 这种，没有可行的，直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(star.peek() &lt; left.peek()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                star.pop();</span><br><span class="line">                left.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划">动态规划</h2>
<p>定义dp[i,j]表示字符串在 [i,j]
闭区间内的子串否是一个有效的括号字符串子串，按子串的长度划分初始状态</p>
<ul>
<li>当长度为1的时候，'*' 为一个有效的括号字符串</li>
<li>当长度为2的时候，'*)'，'()'，'(*'，'**'</li>
</ul>
<p>之后考虑状态转移方程</p>
<p>dp[i,j] = dp[i+1,j-1] &amp;&amp; (dp[i+1] == '(' || dp[i+1] == '*')
&amp;&amp; (dp[j-1] == '*' || dp[j-1] == ')' )</p>
<p>dp[i,j] = dp[i,k] &amp;&amp; dp[k+1,j]
（i到k为合法串，且k+1到j也为合法串时，两个拼接同样满足）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="贪心">贪心</h2>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 008. 和大于等于target的最短子数组</title>
    <url>/posts/bb96/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-008-和大于等于target的最短子数组">剑指 Offer II
008. 和大于等于target的最短子数组</h1>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl,
numsl+1, ..., numsr-1, numsr]
，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/2VG8Kg">https://leetcode-cn.com/problems/2VG8Kg</a></p>
</blockquote>
<span id="more"></span>

<h2 id="前缀和二分查找">前缀和+二分查找</h2>
<p>从题目中可以看到，数组中仅包含正整数，那么其前缀和一定是一个非递减的序列，就可以使用二分查找，两数之差大于等于target的索引差最小值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先计算前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] prefixSum = <span class="keyword">new</span> <span class="title class_">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            prefixSum[i+<span class="number">1</span>] = prefixSum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=length;prefixSum[i] &gt;= target;--i)&#123;</span><br><span class="line">            <span class="comment">// 二分查找</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> prefixSum[i] - target;</span><br><span class="line">            <span class="comment">// upperBound</span></span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(prefixSum[mid] &gt; t)&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            minLength = Math.min(minLength,i-l+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLength == Integer.MAX_VALUE ? <span class="number">0</span> : minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口">滑动窗口</h2>
<p>滑动窗口思想也很简单，使用两个指针，分别指向窗口的最左边和最右端，之后不断变更窗口大小，同时记录窗口值符合条件，下面拿个例子判断</p>
<p>初始化：</p>
<p>nums = [2,3,1,2,4,3]</p>
<p>target = 7</p>
<p>res = Integer.MAX_VALUE</p>
<p>l=0</p>
<p>r=0</p>
<p>sum = 0</p>
<p>step1：</p>
<p>窗口为 [2]，sum=2 &lt; 7，不符合条件，继续更新</p>
<p>sum = 2</p>
<p>l = 0</p>
<p>r = 1</p>
<p>step2：</p>
<p>窗口为 [2,3]，sum=5 &lt; 7，不符合条件，继续更新</p>
<p>sum = 5</p>
<p>l = 0</p>
<p>r = 2</p>
<p>step3：</p>
<p>窗口为 [2,3,1]，sum =6 &lt; 7，不符合条件，继续更新</p>
<p>sum = 6</p>
<p>l = 0</p>
<p>r = 3</p>
<p>step4：</p>
<p>窗口为 [2,3,1,2]，sum=8&gt;7，符合条件</p>
<p>记录最小窗口大小 res = min(Integer.MAX_VALUE,4)= 4</p>
<p>收缩窗口</p>
<p>l = 1，窗口变成 [3,1,2]，sum=6 &lt; 7，不符合条件，继续更新</p>
<p>r = 4</p>
<p>sum = 6</p>
<p>step5：</p>
<p>窗口为 [3,1,2,4]，sum=10 &gt; 7，符合条件</p>
<p>记录最小窗口大小 res = min(4,4) = 4</p>
<p>收缩窗口</p>
<p>l = 2，窗口为 [1,2,4]，sum=7&gt;=7，符合条件</p>
<p>记录最小窗口大小 res = min(3,4) = 3</p>
<p>收缩窗口</p>
<p>l = 3，窗口为 [2,4]，sum=6&lt;7，不符合条件，继续更新</p>
<p>r = 5</p>
<p>sum = 6</p>
<p>step6：</p>
<p>窗口为 [2,4,3]，sum=9&gt;7，符合条件</p>
<p>记录最小窗口大小 res = min(3,3) = 3</p>
<p>收缩窗口</p>
<p>l = 4，窗口为[4,3]，sum=7&gt;=7，符合条件</p>
<p>记录最小窗口大小 res = min(3,2) = 2</p>
<p>收缩窗口</p>
<p>l = 5，窗口为[3]，sum=3 &lt; 7，不符合条件，继续更新</p>
<p>r = 6 == length</p>
<p>遍历结束，返回最小窗口大小为2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">          	<span class="comment">// [left,right]区间内的和</span></span><br><span class="line">            total += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (total &gt;= target) &#123;</span><br><span class="line">              	<span class="comment">// 当满足条件是更新长度</span></span><br><span class="line">                ret = Math.min(ret, right - left + <span class="number">1</span>);</span><br><span class="line">              	<span class="comment">// 左指针右移</span></span><br><span class="line">              	<span class="comment">// 收缩窗口</span></span><br><span class="line">                total -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret &gt; nums.length ? <span class="number">0</span> : ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口模版">滑动窗口模版</h2>
<p>滑动窗口适用于求解数组中连续区间内的值问题（和、积等）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化左边界 left = <span class="number">0</span></span><br><span class="line">初始化返回值 ret = 最小值 or 最大值</span><br><span class="line"><span class="keyword">for</span> 右边界 in 可迭代对象:</span><br><span class="line">	更新窗口内部信息</span><br><span class="line">	<span class="keyword">while</span> 根据题意进行调整：</span><br><span class="line">		比较并更新ret(收缩场景时)</span><br><span class="line">		扩张或收缩窗口大小</span><br><span class="line">	比较并更新ret(扩张场景时)</span><br><span class="line">返回 ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 010. 和为k的子数组</title>
    <url>/posts/6aaa/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-010-和为k的子数组">剑指 Offer II 010.
和为k的子数组</h1>
<p>给定一个整数数组和一个整数 <code>k</code> **，**请找到该数组中和为
<code>k</code> 的连续子数组的个数。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/QTMn0o/">剑指 Offer II 010.
和为 k 的子数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="前缀和">前缀和</h2>
<p>看到连续子数组，下意识想到滑动窗口，可是这个题并不能使用滑动窗口来解，题目设定数组中的数为整数，并不是正整数，这并不符合滑动窗口扩大或收缩的条件，因此无法适用，那么除了这个之外，能快速计算连续区间内的和的就是前缀和了</p>
<p>可以先求出数组对应的前缀和，然后遍历不同长度的子数组，找到满足条件的即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] prefixSum = <span class="keyword">new</span> <span class="title class_">int</span>[length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            prefixSum[i+<span class="number">1</span>] = prefixSum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历前缀和，找出即可</span></span><br><span class="line">        <span class="comment">// o(n^2)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      	<span class="comment">// 遍历所有子数组情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prefixSum[i]-prefixSum[j] == k)&#123;</span><br><span class="line">                    ++cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的算法时间复杂度为
o(n^2)，实际上可以使用哈希表进一步优化，使其时间复杂度降为 o(n)</p>
<p>主要思路是在计算前缀和的过程中将之前计算的结果存储在哈希表中，然后每当计算从0～当前位置的前缀和之后，就从哈希表中判断是够满足</p>
<p>sum - target 的值，如果存在，则说明存在连续子数组</p>
<p>下面以数组 [0,1,2,3,0,-1,-2,-3] 为例，找出所有和为 3 的子数组</p>
<p>初始化</p>
<p>map = {0:1}</p>
<p>代表空数组的前缀和0</p>
<p>sum = 0</p>
<p>cnt = 0</p>
<p>step1:</p>
<p>sum += nums[0]，sum = 0</p>
<p>在map中查找 sum-target 即 前缀和为-3的，并不存在，更新map</p>
<p>map = {0:2}</p>
<p>step2:</p>
<p>sum += nums[1]，sum = 1</p>
<p>在map中查找 sum-target 即 前缀和为-2的，并不存在，更新map</p>
<p>map = {0:2,1:1}</p>
<p>step3:</p>
<p>sum += nums[2]，sum = 3</p>
<p>在map中查找
sum-target即前缀和为0的，此时存在2个前缀和为0，更新cnt</p>
<p>cnt = 2，代表的是 [0,1,2] 和 [1,2]</p>
<p>map = {0:2,1:1,3:1}</p>
<p>step4:</p>
<p>sum += nums[3]，sum = 6，找 sum-target
即前缀和为3的，此时存在1个前缀和为3的，更新cnt</p>
<p>cnt = 3，代表 [0,1,2] , [1,2] , [3]</p>
<p>map = {0:2,1:1,3:1,6:1}</p>
<p>step5:</p>
<p>sum += nums[4]，sum =
6，找sum-target即前缀和为3的，此时存在1一个前缀和为3的，更新cnt</p>
<p>cnt = 4，代表 [0,1,2] , [1,2] , [3] , [3,0]</p>
<p>map = {0:2,1:1,3:1,6:2}</p>
<p>step6:</p>
<p>sum += nums[5]，sum =
5，找sum-target即前缀和为2的，此时并不存在，更新map</p>
<p>map = {0:2,1:1,3:1,5:1,6:2}</p>
<p>step7:</p>
<p>sum += nums[6]，sum = 3，找sum-target即前缀和为0的，更新cnt</p>
<p>cnt = 6，代笔 [0,1,2] , [1,2] , [3] , [3,0] , [0,1,2,3,0,-1,-2] ,
[1,2,3,0,-1,-2]</p>
<p>map = {0:2,1:1,3:2,5:1,6:2}</p>
<p>step8:</p>
<p>sum += nums[7]，sum =
0，找sum-target即前缀和为-3的，不存在，更新map</p>
<p>map = {0:3,1:1,3:2,5:1,6:2}</p>
<p>遍历结束，返回cnt = 6</p>
<p>知道流程后，写出代码就很容易了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            res += map.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">            map.put(pre_sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要遍历一次，时间复杂度为 o(n)</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 011. 0和1个数相同的子数组</title>
    <url>/posts/859a/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-011-0和1个数相同的子数组">剑指 Offer II 011.
0和1个数相同的子数组</h1>
<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的
<code>0</code> 和 <code>1</code>
的最长连续子数组，并返回该子数组的长度。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/A1NYOS/">剑指 Offer II 011.
0 和 1 个数相同的子数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="前缀和">前缀和</h2>
<p>这个题实际上还有一点脑筋急转弯，如果按照正常思路，用zeros[i]表示从0～i上包含0的个数，ones[i]表示从0～i上包含1个数，这样可以遍历所有的子数组，判断0和1的个数是否相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] zeros = <span class="keyword">new</span> <span class="title class_">int</span>[l+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] ones = <span class="keyword">new</span> <span class="title class_">int</span>[l+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;++i)&#123;</span><br><span class="line">          	<span class="comment">// 统计0出现次数</span></span><br><span class="line">            zeros[i] = zeros[i-<span class="number">1</span>];</span><br><span class="line">          	<span class="comment">// 1出现次数</span></span><br><span class="line">            ones[i] = ones[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                ++zeros[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++ones[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后遍历区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            System.out.println(zeros[i+<span class="number">1</span>]+<span class="string">&quot; &quot;</span>+ones[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="comment">// 需要快速找出 两个数组区间内值相同的</span></span><br><span class="line">                <span class="keyword">if</span>(zeros[i+<span class="number">1</span>]-zeros[j] == ones[i+<span class="number">1</span>]-ones[j])&#123;</span><br><span class="line">                    res = Math.max(i+<span class="number">1</span>-j,res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// o(n^2)必定超时，没什么好说的就</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样的算法时间复杂度为 o(n^2)，本题数据量较大，必定超时</p>
<p>因此需要找一个条件进行替换，关键在于，如果将0全部替换成-1，那么就是找出所有和为0的子数组</p>
<p>例如 [1,1,1,0,0,0,1,0,1,1,1,0]，将0替换成-1</p>
<p>[1,1,1,-1,-1,-1,1,-1,1,1,1,-1]，这样题目就转换成找出和为0的子数组中长度最长的那一个</p>
<p>对应前缀和</p>
<p>[1,2,3,2,1,0,1,0,1,2,3,2]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// map记录的是第一次出现sum的位置，这样才能尽可能保持长度最长，因为越到后面长度越长</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录第一次出现0的位置</span></span><br><span class="line">        map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="comment">// 将0替换成-1，这样只需要找出前缀和为0的即可</span></span><br><span class="line">            sum += (nums[i]==<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sum))&#123;</span><br><span class="line">                res = Math.max(i-map.get(sum),res);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              	<span class="comment">// 记录第一次出现sum的位置</span></span><br><span class="line">                map.put(sum,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 017. 含所有字符的最短字符串</title>
    <url>/posts/49ad/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-017-含所有字符的最短字符串">剑指 Offer II 017.
含所有字符的最短字符串</h1>
<p>给定两个字符串 s 和 t 。返回 s 中包含 t
的所有字符的最短子字符串。如果 s
中不存在符合条件的子字符串，则返回空字符串 "" 。</p>
<p>如果 s 中存在多个符合条件的子字符串，返回任意一个。</p>
<p>注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t
中该字符数量。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/M1oyTv">https://leetcode-cn.com/problems/M1oyTv</a></p>
</blockquote>
<span id="more"></span>

<h2 id="滑动窗口">滑动窗口</h2>
<h3 id="暴力">暴力</h3>
<p>很明显，可以将初始窗口大小设置为t的长度，之后逐个进行判断，并不断增加窗口的大小，最终遍历s所有长度在
[t.length(),s.length()]内的子串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 思路1，直接暴力，从长度为t的窗口开始遍历？</span></span><br><span class="line">        Map&lt;Character,Integer&gt; tMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tLength</span> <span class="operator">=</span> t.length(),sLength = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tLength;++i)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t1</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            tMap.put(t1,tMap.getOrDefault(t1,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> tLength;l&lt;=sLength;++l)&#123;</span><br><span class="line">          	<span class="comment">// 从长度为tLength的子串一直到长度为sLength的子串</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> l;</span><br><span class="line">            <span class="comment">// 初始化窗口</span></span><br><span class="line">            Map&lt;Character,Integer&gt; sMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;right;++i)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">s1</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">                sMap.put(s1,sMap.getOrDefault(s1,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(check(tMap,sMap)) <span class="keyword">return</span> s.substring(left,right);</span><br><span class="line">            <span class="keyword">while</span>(right &lt; sLength)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">leftChar</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="type">char</span> <span class="variable">rightChar</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">                sMap.put(leftChar,sMap.get(leftChar)-<span class="number">1</span>);</span><br><span class="line">                sMap.put(rightChar,sMap.getOrDefault(rightChar,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                ++left;</span><br><span class="line">                ++right;</span><br><span class="line">                <span class="keyword">if</span>(check(tMap,sMap)) <span class="keyword">return</span> s.substring(left,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历完所有的都没找到，直接返回空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Map&lt;Character,Integer&gt; map1,Map&lt;Character,Integer&gt; map2)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Character ch:map1.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map2.getOrDefault(ch,<span class="number">0</span>) &lt; map1.get(ch)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，在计算过程中需要不断遍历s，初始化窗口，然后开始滑动，这一个过程太耗时间，实际上只需要初始化一次窗口即可</p>
<p>时间复杂度：o(n^2)</p>
<h3 id="优化">优化</h3>
<p>由于暴力解法中遍历了所有的子串，且每次都需要重新初始化窗口，实际上可以在一次遍历中不断调整窗口大小，同时记录满足条件的最小值即可</p>
<p>下面以 s = "ADOBECODEBANC" 和 t = "ABC" 来介绍计算过程</p>
<p>初始化：</p>
<p>tMap = {A:1,B:1,C:1}</p>
<p>left = 0, right = 0, cnt = 0</p>
<p><strong>step1:</strong></p>
<p>窗口为 [0,0] 代表s的子串 A</p>
<p>sMap = {A:1}，而A在t内，cnt=1, right=1</p>
<p><strong>step2：</strong></p>
<p>窗口为 [0,1] 代表s的子串 AD</p>
<p>sMap = {A:1,D:1}，D并不在t内，cnt保持不变，right=2</p>
<p><strong>step3：</strong></p>
<p>窗口为 [0,2] 代表s的子串 ADO</p>
<p>sMap = {A:1,D:1,O:1}，O并不在t内，cnt保持不变，right=3</p>
<p><strong>step4：</strong></p>
<p>窗口为 [0,3] 代表s的子串 ADOB</p>
<p>sMap = {A:1,B:1,D:1,O:1}，B在t内，cnt=2，right=4</p>
<p><strong>step5：</strong></p>
<p>窗口为 [0,4] 代表s的子串 ADOBE</p>
<p>sMap = {A:1,B:1,D:1,E:1,O:1}，E并不在t内，cnt保持不变，right=5</p>
<p><strong>step6：</strong></p>
<p>窗口为 [0,5] 代表s的子串 ADOBEC，C在t内，cnt=3，right=6</p>
<p>cnt == tMap.size()，说明ADOBEC已经包含了ABC的所有字符，更新res =
ADOBEC</p>
<p><strong>step7:</strong></p>
<p>窗口为 [0,6] 代表s的子串 ADOBECO</p>
<p>sMap =
{A:1,B:1,C;1,D:1,E:1,O:2}，O并不在t内，cnt保持不变，right=7</p>
<p><strong>step8:</strong></p>
<p>窗口为 [0,7] 代表s的子串 ADOBECOD</p>
<p>sMap =
{A:1,B:1,C:1,D:2,E:1,O:2}，D并不在t内，cnt保持不变，right=8</p>
<p><strong>step9:</strong></p>
<p>窗口为 [0,8] 代表s的子串 ADOBECODE</p>
<p>sMap =
{A:1,B:1,C:1,D:2,E:2,O:2}，E并不在t内，cnt保持不变，right=9</p>
<p><strong>step10:</strong></p>
<p>窗口为 [0,9] 代表s的子串 ADOBECODEB</p>
<p>sMap =
{A:1,B:2,C:1,D:2,E:2,O:2}，B在t内，但已经满足条件，cnt保持不变，right=10</p>
<p><strong>step11:</strong></p>
<p>窗口为 [0,10] 代表s的子串 ADOBECODEB</p>
<p>sMap =
{A:1,B:2,C:1,D:2,E:2,O:2}，B在t内，但已经满足条件，cnt保持不变，right=11</p>
<p><strong>step12:</strong></p>
<p>窗口为 [0,11] 代表s的子串 ADOBECODEBA</p>
<p>sMap = {A:2,B:2,C:1,D:2,E:2,O:2}，A在t内，</p>
<p>此时s.charAt(0) = 'A'，且t只需要一个
'A'，此时子字符串中已经包含了两个'A'，收缩窗口，更新sMap</p>
<p>sMap = {A:1,B:2,C:1,D:2,E:2,O:2}</p>
<p>left = 1，窗口为 [1,11] 代表s的子串 DOBECODEBA，</p>
<p>此时s.charAt(1) = 'D'，且t不需要 'D'，收缩窗口，更新sMap</p>
<p>sMap = {A:1,B:2,C:1,D:1,E:2,O:2}</p>
<p>left = 2，窗口为 [2,11] 代表s的子串 OBECODEBA</p>
<p>此时s.charAt(2) = 'O'，且t不需要 'O'，收缩窗口，更新sMap</p>
<p>sMap = {A:1,B:2,C:1,D:1,E:2,O:1}</p>
<p>left = 3，窗口为 [3,11] 代表s的子串 BECODEBA</p>
<p>此时s.charAt(3) = 'B'，且t只需要一个
'B'，此时子字符串中已经包含了两个'B'，收缩窗口，更新sMap</p>
<p>sMap = {A:1,B:1,C:1,D:1,E:2,O:1}</p>
<p>left = 4，窗口为 [4,11] 代表s的子串 ECODEBA</p>
<p>此时s.charAt(4) = 'E'，且t不需要 'E'，收缩窗口，更新sMap</p>
<p>sMap = {A:1,B:1,C:1,D:1,E:1,O:1}</p>
<p>left = 5，窗口为 [5,11] 代表s的子串 CODEBA</p>
<p>此时s.charAt(5) = 'C'
，且t需要一个'C'，s仅包含一个'C'，无法继续收缩窗口，继续扩展窗口，right=12</p>
<p><strong>step13:</strong></p>
<p>窗口为 [5,12] 代表s的子串 CODEBAN</p>
<p>sMap =
{A:1,B:1,C:1,D:1,E:1,N:1,O:1}，N不在t内，cnt保持不变，right=13</p>
<p><strong>step14</strong></p>
<p>窗口为 [5,13] 代表s的子串
CODEBANC，C在t内，但是s已经包含过一个C，可以收缩窗口，更新sMap</p>
<p>sMap = {A:1,B:1,C:1,D:1,E:1,N:1,O:1}</p>
<p>left=6，窗口为 [6,13] 代表s的子串 ODEBANC</p>
<p>此时s.charAt(6) = 'O'，t不包含'O'，收缩窗口，更新sMap</p>
<p>sMap = {A:1,B:1,C:1,D:1,E:1,N:1}</p>
<p>left=7，窗口为 [7,13] 代表s的子串 DEBANC</p>
<p>此时s.charAt(7) = 'D'，t不包含 'D'，收缩窗口，更新sMap</p>
<p>sMap = {A:1,B:1,C:1,E:1,N:1}</p>
<p>left=8，窗口为 [8,13] 代表s的子串 EBANC</p>
<p>此时s.charAt(8) = 'E'，t不包含 'E'，收缩窗口，更新sMap</p>
<p>sMap = {A:1,B:1,C:1,N:1}</p>
<p>left=9，窗口为 [9,13] 代表s的子串 BANC</p>
<p>此时s.charAt(9) =
'B'，t需要一个'B'，此时子串也仅包含一个B，无法进行收缩，更新res</p>
<p>res = BANC</p>
<p>此时遍历结束，返回最小窗口为BANC</p>
<p>从这个过程中，可以很清楚的看到，在遍历s的过程中，不断判断是否可以收缩窗口，从而在仅遍历一次s的情况下得到结果</p>
<p>时间复杂度o(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 思路1，直接暴力，从长度为t的窗口开始遍历？</span></span><br><span class="line">        <span class="comment">// 超时，卡在最后一个样例</span></span><br><span class="line">        Map&lt;Character,Integer&gt; tMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),sMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">tLength</span> <span class="operator">=</span> t.length(),sLength = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tLength;++i)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t1</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            tMap.put(t1,tMap.getOrDefault(t1,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 仅遍历一次s，在遍历过程中更新左右指针，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tUniqueChars</span> <span class="operator">=</span> tMap.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;right &lt; sLength;++right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">s1</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            sMap.put(s1,sMap.getOrDefault(s1,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 遍历过程中不断判断当前是否满足条件</span></span><br><span class="line">            <span class="keyword">if</span>(tMap.containsKey(s1) &amp;&amp; sMap.get(s1).equals(tMap.get(s1))) ++cnt;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">s2</span> <span class="operator">=</span> s.charAt(left);</span><br><span class="line">                <span class="comment">// 当最左端的字符没用时，收缩窗口</span></span><br><span class="line">                <span class="keyword">if</span>(sMap.get(s2) &gt; tMap.getOrDefault(s2,<span class="number">0</span>))&#123;</span><br><span class="line">                    sMap.put(s2,sMap.get(s2)-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(tMap.containsKey(s2) &amp;&amp; tMap.get(s2) &gt; sMap.get(s2)) --cnt;</span><br><span class="line">                    ++left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt == tUniqueChars &amp;&amp; (res.equals(<span class="string">&quot;&quot;</span>) || res.length() &gt; right + <span class="number">1</span> -left))&#123;</span><br><span class="line">                res = s.substring(left,right+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 020. 回文子字符串的个数</title>
    <url>/posts/1deb/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-020-回文子字符串的个数">剑指 Offer II 020.
回文子字符串的个数</h1>
<p>给定一个字符串 <code>s</code>
，请计算这个字符串中有多少个回文子字符串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/a7VOhD/">剑指 Offer II 020.
回文子字符串的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>没什么好说的，遍历字符串的所有子串，判断是否是回文串即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 暴力的话也不是不行，数据量又不大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=l;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(check(s.substring(i,j)))&#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(s);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(l) != s.charAt(r)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^3)</p>
<p>空间复杂度：o(1)</p>
<h2 id="动态规划">动态规划</h2>
<p>dp[i,j]代表字符串从i到j的子串是否是回文串，有以下初始化方案</p>
<p>dp[i,i] = true</p>
<p>dp[i,i+1] = true if s.charAt(i) == s.charAt(i+1)</p>
<p>dp[i,j] = dp[i+1,j-1] &amp;&amp; s.charAt(i) == s.charAt(j)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[l][l];</span><br><span class="line">        <span class="comment">// dp[i][i] = 1;</span></span><br><span class="line">        <span class="comment">// dp[i][i+1] = true if s.charAt(i) == s.charAt(i+1)</span></span><br><span class="line">        <span class="comment">// dp[i][j] = dp[i+1][j-1] &amp;&amp; s.charAt(i) == s.charAt(j)</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;l;++i)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i-<span class="number">1</span>][i] = <span class="literal">true</span>;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=l;++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+j&lt;l;++i)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i+j;</span><br><span class="line">                dp[i][k] = dp[i+<span class="number">1</span>][k-<span class="number">1</span>] &amp;&amp; arr[i] == arr[k];</span><br><span class="line">                <span class="keyword">if</span>(dp[i][k]) ++res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^2)</p>
<p>空间复杂度：o(n^2)</p>
<h2 id="滑动窗口">滑动窗口</h2>
<p>遍历字符串，对每个字符，都看作回文的中心，向两端延申进行判断直到非回文。</p>
<p>回文的中心可能是一个字符，也可能是两个字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] arr;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        arr = s.toCharArray();</span><br><span class="line">        length = arr.length;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            check(i,i);</span><br><span class="line">            check(i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;-<span class="number">1</span> &amp;&amp; r &lt; length &amp;&amp; arr[l] == arr[r])&#123;</span><br><span class="line">            ++res;</span><br><span class="line">            --l;</span><br><span class="line">            ++r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^2)</p>
<p>空间复杂度：o(1)</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 022. 链表中环的入口节点</title>
    <url>/posts/6dcb/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-022-链表中环的入口节点">剑指 Offer II 022.
链表中环的入口节点</h1>
<p>给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着
next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回
null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos
来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是
-1，则在该链表中没有环。注意，pos
仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/c32eOV">https://leetcode-cn.com/problems/c32eOV</a></p>
</blockquote>
<span id="more"></span>

<h2 id="哈希表">哈希表</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接使用哈希表记录一下哪个节点被访问过了，当再一次访问到这个节点的时候就是环的入口</span></span><br><span class="line">        Map&lt;ListNode,Boolean&gt; notVisited = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head!= <span class="literal">null</span> &amp;&amp; notVisited.getOrDefault(head,<span class="literal">true</span>))&#123;</span><br><span class="line">            notVisited.put(head,<span class="literal">false</span>);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快慢指针">快慢指针</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 慢的走的距离为 x+y</span></span><br><span class="line">            <span class="comment">// 快的走的距离为 x+y + n(y+z)</span></span><br><span class="line">            <span class="comment">// 且有 n(y+z) = x+y</span></span><br><span class="line">            <span class="comment">// x = n(y+z) - y</span></span><br><span class="line">            <span class="comment">// 也就是说，如果此时放一个指针在head处让他和slow同时前进，当这个指针和slow指针相遇的时候，就一定是环的入口x</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">point</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="keyword">while</span> (point != slow) &#123;</span><br><span class="line">                    point = point.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 031. 最近最少使用缓存</title>
    <url>/posts/449b/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-031-最近最少使用缓存">剑指 Offer II 031.
最近最少使用缓存</h1>
<p>运用所掌握的数据结构，设计和实现一个 LRU (Least Recently
Used，最近最少使用) 缓存机制 。</p>
<p>实现 LRUCache 类：</p>
<ul>
<li><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU
缓存</p></li>
<li><p>int get(int key) 如果关键字 key
存在于缓存中，则返回关键字的值，否则返回 -1 。</p></li>
<li><p>void put(int key, int value)
如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p></li>
</ul>
<p>提示：</p>
<ul>
<li>1 &lt;= capacity &lt;= 3000</li>
<li>0 &lt;= key &lt;= 10000</li>
<li>0 &lt;= value &lt;= 10<sup>5</sup></li>
<li>最多调用 2 * 10<sup>5</sup> 次 get 和 put</li>
</ul>
<p><strong>进阶</strong>：是否可以在 <code>O(1)</code>
时间复杂度内完成这两种操作？</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/OrIXps">https://leetcode-cn.com/problems/OrIXps</a></p>
</blockquote>
<span id="more"></span>

<h2 id="双向链表哈希表">双向链表+哈希表</h2>
<p>首先我们需要知道最近最少使用缓存（LRU
cache）的思路，根据缓存内数据的使用情况，当缓存被占满的时候，优先替换掉最不常用的数据（也就是最近一段时间内都没有被使用的数据），而要想在o(1)的时间复杂度内完成插入和获取操作，首先获取十分简单，只需要使用哈希表即可，但是对于插入操作，由于cache存在容量限制，当容量满的时候需要选择最近不常使用的数据进行替换，单纯使用哈希表就不能在o(1)时间内进行删除并插入，因此我们考虑使用双向链表实现</p>
<p>为了实现o(1)时间复杂度内的检索，使用哈希表，同时为了实现o(1)时间内删除最近不常使用的数据，需要使用双向链表，哈希表中存储了双向链表的每一个节点，同时将数据的使用顺序组织称队列形式，每当一个数据最近被访问了，就将其放在队列的头部，每当缓存满的时候就优先删除队列尾部的数据，这样可以实现LRU，双向链表实现起来指针操作较多，容易出现错误，因此可以优先创建好链表头和链表尾，减少判断，提高代码正确性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node next;</span><br><span class="line">        Node(<span class="type">int</span> k,<span class="type">int</span> v)&#123;</span><br><span class="line">            key = k;</span><br><span class="line">            val = v;</span><br><span class="line">        &#125;</span><br><span class="line">        Node(<span class="type">int</span> k,<span class="type">int</span> v,Node p,Node n)&#123;</span><br><span class="line">            key = k;</span><br><span class="line">            val = v;</span><br><span class="line">            prev = p;</span><br><span class="line">            next = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node head,tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Node&gt; cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> _capacity)</span> &#123;</span><br><span class="line">        capacity = _capacity;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 预先创立好head和tail，防止代码执行过程中判断prev和next是否为空，提前创建好head和tail节点就可以保证不为空，减少出错几率</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">        tail.prev = head;</span><br><span class="line">        head.next = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;get...&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cache.get(key).val;</span><br><span class="line">      	<span class="comment">// 将最近访问的节点插入到队列头</span></span><br><span class="line">        put(key,val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;put...&quot;);</span></span><br><span class="line">        <span class="comment">// printList();</span></span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key))&#123;</span><br><span class="line">            <span class="comment">// 需要将map进行删除</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">            node.prev.next = node.next;</span><br><span class="line">            node.next.prev = node.prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printList();</span></span><br><span class="line">        <span class="comment">// 将现在的节点插入到末尾</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key,value,prev,tail);</span><br><span class="line">        prev.next = curr;</span><br><span class="line">        tail.prev = curr;</span><br><span class="line">        <span class="comment">// printList();</span></span><br><span class="line">        cache.put(key,curr);</span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt; capacity)&#123;</span><br><span class="line">            <span class="comment">// 删除队列尾部的元素</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">            head.next = node.next;</span><br><span class="line">            head.next.prev = head;</span><br><span class="line">            cache.remove(node.key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printList();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&#x27;[&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Node</span> <span class="variable">curr</span> <span class="operator">=</span> head.next;curr != tail;curr = curr.next)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;(&#x27;</span>).append(curr.key).append(<span class="string">&#x27;,&#x27;</span>).append(curr.val).append(<span class="string">&#x27;)&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 035. 最小时间差</title>
    <url>/posts/72b1/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-035-最小时间差">剑指 Offer II 035. 最小时间差</h1>
<p>给定一个 24 小时制（小时:分钟
<strong>"HH:MM"</strong>）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= timePoints &lt;= 2 * 10^4</code></li>
<li><code>timePoints[i]</code> 格式为 <strong>"HH:MM"</strong></li>
</ul>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/569nqc/">https://leetcode-cn.com/problems/569nqc/</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>没什么好说的，直接两两比较，计算时间差即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> &#123;</span><br><span class="line">        <span class="comment">// 就直接暴力呗，两两进行计算即可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">1440</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> timePoints.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="comment">// System.out.println(i+&quot; &quot;+j);</span></span><br><span class="line">                min = Math.min(min,difference(timePoints.get(i),timePoints.get(j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">difference</span><span class="params">(String t1,String t2)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] hm1 = parseTimeString(t1);</span><br><span class="line">        <span class="type">int</span>[] hm2 = parseTimeString(t2);</span><br><span class="line">        <span class="comment">// 计算时间差，统一采用t1-t2，最后返回绝对值即可</span></span><br><span class="line">        <span class="comment">// 一天总共 24*60 = 1440 分钟</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> abs((hm1[<span class="number">0</span>]-hm2[<span class="number">0</span>])*<span class="number">60</span> + hm1[<span class="number">1</span>]-hm2[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// System.out.println(t1+&quot;-&quot;+t2+&quot;:&quot;+t);</span></span><br><span class="line">        <span class="comment">// 有可能两个时间是在同一天，也有可能是在不同的天，因此需和1440（一天的时间）计算比较而得</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(t,<span class="number">1440</span>-t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;<span class="number">0</span>) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">return</span> -v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parseTimeString(String t)&#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>] = (t.charAt(<span class="number">0</span>)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + (t.charAt(<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        res[<span class="number">1</span>] = (t.charAt(<span class="number">3</span>)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + (t.charAt(<span class="number">4</span>)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^2)</p>
<p>本题测试样例为 2*10^4
，数量级还是有点大，卡的死死的，纯暴力会超时</p>
<h2 id="暴力优化">暴力优化</h2>
<p>由于一天按分钟划分只有24*60 =
1440个时间间隔，因此当timePoints的长度大于1440时一定存在重复元素，直接返回0，这样可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> &#123;</span><br><span class="line">      	<span class="keyword">if</span>(timePoints.size() &gt; <span class="number">1440</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 就直接暴力呗，两两进行计算即可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">1440</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> timePoints.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">                <span class="comment">// System.out.println(i+&quot; &quot;+j);</span></span><br><span class="line">                min = Math.min(min,difference(timePoints.get(i),timePoints.get(j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">difference</span><span class="params">(String t1,String t2)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] hm1 = parseTimeString(t1);</span><br><span class="line">        <span class="type">int</span>[] hm2 = parseTimeString(t2);</span><br><span class="line">        <span class="comment">// 计算时间差，统一采用t1-t2，最后返回绝对值即可</span></span><br><span class="line">        <span class="comment">// 一天总共 24*60 = 1440 分钟</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> abs((hm1[<span class="number">0</span>]-hm2[<span class="number">0</span>])*<span class="number">60</span> + hm1[<span class="number">1</span>]-hm2[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// System.out.println(t1+&quot;-&quot;+t2+&quot;:&quot;+t);</span></span><br><span class="line">        <span class="comment">// 有可能两个时间是在同一天，也有可能是在不同的天，因此需和1440（一天的时间）计算比较而得</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(t,<span class="number">1440</span>-t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;<span class="number">0</span>) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">return</span> -v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parseTimeString(String t)&#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>] = (t.charAt(<span class="number">0</span>)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + (t.charAt(<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        res[<span class="number">1</span>] = (t.charAt(<span class="number">3</span>)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + (t.charAt(<span class="number">4</span>)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自定义排序">自定义排序</h2>
<p>直接暴力行不通，可以先对timePoints数组进行排序，按照小时和分钟进行排序，之后计算两个元素之间差值的最小值即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(timePoints.size() &gt; <span class="number">1440</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">1440</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> timePoints.size();</span><br><span class="line">        <span class="type">int</span>[][] t = <span class="keyword">new</span> <span class="title class_">int</span>[l][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            t[i] = parseTimeString(timePoints.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(t,(a,b)-&gt;a[<span class="number">0</span>]==b[<span class="number">0</span>]?a[<span class="number">1</span>]-b[<span class="number">1</span>]:a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// for(int[] ti:t)&#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(ti[0]+&quot;:&quot;+ti[1]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 自定义排序+遍历？</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;l;++i)&#123;</span><br><span class="line">            min = Math.min(min,difference(t[i-<span class="number">1</span>],t[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后再比较一下首尾即可</span></span><br><span class="line">        min = Math.min(min,difference(t[l-<span class="number">1</span>],t[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">difference</span><span class="params">(<span class="type">int</span>[] hm1,<span class="type">int</span>[] hm2)</span>&#123;</span><br><span class="line">        <span class="comment">// 计算时间差，统一采用t1-t2，最后返回绝对值即可</span></span><br><span class="line">        <span class="comment">// 一天总共 24*60 = 1440 分钟</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> abs((hm1[<span class="number">0</span>]-hm2[<span class="number">0</span>])*<span class="number">60</span> + hm1[<span class="number">1</span>]-hm2[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// System.out.println(t1+&quot;-&quot;+t2+&quot;:&quot;+t);</span></span><br><span class="line">        <span class="comment">// 有可能两个时间是在同一天，也有可能是在不同的天，因此需和1440（一天的时间）计算比较而得</span></span><br><span class="line">        <span class="keyword">return</span> Math.min(t,<span class="number">1440</span>-t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;<span class="number">0</span>) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">return</span> -v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parseTimeString(String t)&#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>] = (t.charAt(<span class="number">0</span>)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + (t.charAt(<span class="number">1</span>)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        res[<span class="number">1</span>] = (t.charAt(<span class="number">3</span>)-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + (t.charAt(<span class="number">4</span>)-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 037. 小行星碰撞</title>
    <url>/posts/d4b9/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-037-小行星碰撞">剑指 Offer II 037. 小行星碰撞</h1>
<p>给定一个整数数组 asteroids，表示在同一行的小行星。</p>
<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>
<p>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>
<p>提示：</p>
<ul>
<li>2 &lt;= asteroids.length &lt;= 10<sup>4</sup></li>
<li>-1000 &lt;= asteroids[i] &lt;= 1000</li>
<li>asteroids[i] != 0</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/XagZNi">https://leetcode-cn.com/problems/XagZNi</a></p>
</blockquote>
<span id="more"></span>

<h2 id="模拟栈">模拟+栈</h2>
<p>只需要使用用例模拟一下就可以很快知道如何实现了，</p>
<p>我们从左往右进行遍历，在遍历的过程使用栈存储向右移动的小行星，如果碰到一个向左的小行星，此时检查栈是否为空，如果不为空，说明一定会发生碰撞，此时再根据规则进行消除即可，最终结果一定是向左移动的小行星在向右移动的小行星的左侧，否则就会发生碰撞</p>
<p>实际上这个思想已经有点类似于单调栈了（栈中小行星都是同一方向的，碰到不同方向的就会发生碰撞）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] asteroidCollision(<span class="type">int</span>[] asteroids) &#123;</span><br><span class="line">        <span class="comment">// 模拟？</span></span><br><span class="line">        Stack&lt;Integer&gt; right = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(),left = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:asteroids)&#123;</span><br><span class="line">            <span class="comment">// 从左向右遍历</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                right.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 存活确认</span></span><br><span class="line">                <span class="keyword">if</span>(right.isEmpty()) left.push(i);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 同右侧的进行对撞</span></span><br><span class="line">                    <span class="keyword">while</span>(!right.isEmpty() &amp;&amp; Math.abs(i) &gt; Math.abs(right.peek()) )&#123;</span><br><span class="line">                        right.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(right.isEmpty()) left.push(i);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(Math.abs(i) == Math.abs(right.peek())) right.pop();</span><br><span class="line">                     </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[right.size()+left.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> res.length;</span><br><span class="line">      	<span class="comment">// 由于使用栈进行存储，需要倒着填值，且一定是right在右，即优先填充right</span></span><br><span class="line">        <span class="keyword">while</span>(!right.isEmpty()) res[--i] = right.pop();</span><br><span class="line">        <span class="keyword">while</span>(!left.isEmpty()) res[--i] = left.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 038. 每日温度</title>
    <url>/posts/3a8e/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-038-每日温度">剑指 Offer II 038. 每日温度</h1>
<p>请根据每日 气温 列表 temperatures
，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用
0 来代替。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/iIQa4I">https://leetcode-cn.com/problems/iIQa4I</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>没什么好说的，对于当前的数，遍历数组，找到下一个比他更大的值，如果不存在，就为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temperatures.length;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; temperatures.length &amp;&amp; temperatures[j] &lt;= temperatures[i]) ++j;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; temperatures.length) res[i] = j-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(n^2)</p>
<p>空间复杂度：o(1)</p>
<h2 id="单调栈">单调栈</h2>
<p>使用栈存储当前尚未找到下一个更大值的数据（实际上栈中存储数据为单调不增的），每遍历到下一个数据的时候，将其与栈顶元素进行比较，如果比栈顶元素大，就将栈顶元素出栈，不断执行这个过程，确保栈中存储的数据是一个单调递减的</p>
<p>下面以 [74,75,71,69,72,76] 为例介绍算法的执行过程</p>
<p>初始化：</p>
<p>monoStack = []</p>
<p>res = [0,0,0,0,0,0]</p>
<p>step1:</p>
<p>当前元素 74，栈为空，直接将74入栈</p>
<p>monoStack = [74]</p>
<p>step2:</p>
<p>当前元素75，栈顶元素74，75大于74，74出栈，同时更新res</p>
<p>此时栈为空，直接将75入栈</p>
<p>res[0] = 1</p>
<p>monoStack = [75]</p>
<p>step3: 当前元素71，栈顶元素75，71小于75，71入栈，等待结果</p>
<p>monoStack = [75,71]</p>
<p>step4:</p>
<p>当前元素69，栈顶元素71，69小于71，69入栈，等待结果</p>
<p>monoStack = [75,71,69]</p>
<p>step5:</p>
<p>当前元素72，栈顶元素69，72大于69，69出栈，并更新res</p>
<p>res[3] = 1</p>
<p>此时栈顶元素为71，72大于71，71出栈，更新res</p>
<p>res[2] = 2</p>
<p>此时栈顶元素75，75大于72，72入栈</p>
<p>monoStack = [75,72]</p>
<p>step6:</p>
<p>当前元素76，栈顶元素72，76大于72，72出栈，更新res</p>
<p>res[4] = 1</p>
<p>此时栈顶元素75，76大于75，75出栈，更新res</p>
<p>res[1] = 4</p>
<p>此时栈为空，76入栈</p>
<p>此时遍历结束，返回res = [1,4,2,1,1,0]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="comment">// 找到数组中下一个大于该数字的索引</span></span><br><span class="line">        <span class="comment">// 如果直接暴力的话，那就是 o(n^2)，直接超时</span></span><br><span class="line">        <span class="comment">// 维护一个单调递减的栈，因为当出现递增的时候可以直接确定值，只有递减的时候需要进一步判断</span></span><br><span class="line">        <span class="comment">// （75，2）（71，3）（69，4）（72，5）</span></span><br><span class="line">      	<span class="comment">// 栈中实际存储的是元素在数组中的索引</span></span><br><span class="line">        Stack&lt;Integer&gt; monoStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[l];</span><br><span class="line">        monoStack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;temperatures.length;++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!monoStack.isEmpty() &amp;&amp; temperatures[i]&gt;temperatures[monoStack.peek()])&#123;</span><br><span class="line">                <span class="comment">// 找到比他大的值，出栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> monoStack.pop();</span><br><span class="line">                res[curr] = i - curr;</span><br><span class="line">            &#125;</span><br><span class="line">            monoStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>187. 重复的DNA序列</title>
    <url>/posts/de11/</url>
    <content><![CDATA[<h1 id="187-重复的dna序列">187. 重复的DNA序列</h1>
<p>所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T'
的核苷酸组成，例如："ACGAATTCCG"。在研究 DNA 时，识别 DNA
中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串
s 中出现次数超过一次。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/repeated-dna-sequences">https://leetcode-cn.com/problems/repeated-dna-sequences</a></p>
</blockquote>
<span id="more"></span>

<h2 id="解题思路">解题思路</h2>
<p>思路很简单，遍历所有的子串，统计子串出现的次数，将所有出现次数大于1的子串即可</p>
<p>那么现在问题的核心在于，如何确定合适的哈希函数，使得我们能在o(1)时间复杂度内计算出对应字符子串的哈希值</p>
<p>由于本题字符子串的长度并不大，且仅包含四种字符，不难想到两种哈希方式</p>
<ul>
<li>直接使用字符串（使用的实际上是字符串的hashCode()函数）</li>
<li>位运算（四种碱基可以使用两位二进制来代替，而目标子串长度为10，只需要20位就可以表示该字符子串，也是可行的</li>
</ul>
<p>如果目标子串的长度变为100，那么位运算和直接使用字符串来计算哈希值的代价太高，需要使用其他方法</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/">【宫水三叶】一题双解
:「滑动窗口」&amp;「字符串哈希」 - 重复的DNA序列 - 力扣（LeetCode）
(leetcode-cn.com)</a></p>
</blockquote>
<p>其中利用质数幂的性质</p>
<p>子串长度为 10，因此上述解法的计算量为 10^6</p>
<p>若题目给定的子串长度大于 100
时，加上生成子串和哈希表本身常数操作，那么计算量将超过 10^7会 TLE。</p>
<p>因此一个能够做到严格 O(n) 的做法是使用「字符串哈希 + 前缀和」。</p>
<p>具体做法为，我们使用一个与字符串 s 等长的哈希数组 h[]，以及次方数组
p[]。</p>
<p>由字符串预处理得到这样的哈希数组和次方数组复杂度为
O(n)。当我们需要计算子串 s[i...j]的哈希值，只需要利用前缀和思想</p>
<p>h[j] - h[i - 1] * p[j - i + 1]</p>
<p>即可在 O(1) 时间内得出哈希值（与子串长度无关）。</p>
<p>作者：AC_OIer 链接：<a
href="https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/">https://leetcode-cn.com/problems/repeated-dna-sequences/solution/gong-shui-san-xie-yi-ti-shuang-jie-hua-d-30pg/</a>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="哈希表滑动窗口">哈希表+滑动窗口</h2>
<h3 id="字符串直接哈希">字符串直接哈希</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 长度为10^5，肯定不能用暴力</span></span><br><span class="line">        <span class="comment">// 总共子串的长度为 s.length() - 10</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(l &lt; <span class="number">11</span>) <span class="keyword">return</span> res;</span><br><span class="line">        window.append(s.substring(<span class="number">0</span>,<span class="number">10</span>));</span><br><span class="line">        map.put(window.toString(),<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="comment">// 删除首位</span></span><br><span class="line">            window.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">            window.append(s.charAt(i));</span><br><span class="line">            <span class="type">String</span> <span class="variable">curr</span> <span class="operator">=</span> window.toString();</span><br><span class="line">            map.put(curr,map.getOrDefault(curr,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry :map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                res.add(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="位运算哈希">位运算哈希</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 位运算+哈希表+滑动窗口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Character,Integer&gt; charMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        charMap.put(<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        charMap.put(<span class="string">&#x27;C&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        charMap.put(<span class="string">&#x27;G&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">        charMap.put(<span class="string">&#x27;T&#x27;</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MASK</span> <span class="operator">=</span> (<span class="number">1</span>&lt;&lt;<span class="number">20</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用两位bit表示一个碱基，这样长度为10的子串就可以使用一个int来表示</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; count = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">window</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">windowHash</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(l &lt; <span class="number">11</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            window.append(ch);</span><br><span class="line">            windowHash = MASK &amp; (windowHash&lt;&lt;<span class="number">2</span> | charMap.get(ch));</span><br><span class="line">        &#125;</span><br><span class="line">        count.put(windowHash,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            window.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">            window.append(ch);</span><br><span class="line">            windowHash = MASK &amp; (windowHash&lt;&lt;<span class="number">2</span> | charMap.get(ch));</span><br><span class="line">            count.put(windowHash,count.getOrDefault(windowHash,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(count.get(windowHash) == <span class="number">2</span>)&#123;</span><br><span class="line">                res.add(window.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前缀和哈希">前缀和哈希</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e5</span>+<span class="number">10</span>, P = <span class="number">131313</span>;</span><br><span class="line">    <span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[N], p = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            h[i] = h[i - <span class="number">1</span>] * P + s.charAt(i - <span class="number">1</span>);</span><br><span class="line">            p[i] = p[i - <span class="number">1</span>] * P; <span class="comment">// 对应 p^(i-1)</span></span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i + <span class="number">10</span> - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">10</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> h[j] - h[i - <span class="number">1</span>] * p[j - i + <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> map.getOrDefault(hash, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">1</span>) ans.add(s.substring(i - <span class="number">1</span>, i + <span class="number">10</span> - <span class="number">1</span>));</span><br><span class="line">            map.put(hash, cnt + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>211. 添加与搜索单词 - 数据结构设计</title>
    <url>/posts/362c/</url>
    <content><![CDATA[<h1 id="211-添加与搜索单词---数据结构设计">211. 添加与搜索单词 -
数据结构设计</h1>
<p>请你设计一个数据结构，支持 添加新单词 和
查找字符串是否与任何先前添加的字符串匹配 。</p>
<p>实现词典类 WordDictionary ：</p>
<ul>
<li><code>WordDictionary() </code>初始化词典对象</li>
<li><code>void addWord(word)</code>将 word
添加到数据结构中，之后可以对它进行匹配</li>
<li><code>bool search(word)</code> 如果数据结构中存在字符串与 word
匹配，则返回 true ；否则，返回 false 。word 中可能包含一些 '.' ，每个 .
都可以表示任何一个字母。</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure">https://leetcode-cn.com/problems/design-add-and-search-words-data-structure</a></p>
</blockquote>
<span id="more"></span>

<h2 id="trie前缀树">Trie（前缀树）</h2>
<p>这个题没什么好说，需要检查字符串是否和之前添加的字符串匹配，且需要搜索包含
'.'的，因此这题没什么好说的，一定是一个Tire的题了，关于前缀树的首先实际上我们早就做过，<code>212. 单词搜索 II</code>
和
<code>208. 实现Trie（前缀树）</code>中都有讲，这里就不说了，只需要讲一下如何实现搜索代码即可</p>
<p>对于一个包含 '.'
的字符串，那么我们需要遍历所有可能，在前缀数中进行匹配，意味着我们需要穷举前缀树的每一个分支，判断是否有可行的，这实际上是一个递归的过程，因此我们需要讲搜索写成递归形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">        <span class="type">boolean</span> isEnd;</span><br><span class="line">        TrieNode[] next;</span><br><span class="line">        TrieNode()&#123;</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WordDictionary</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入部分的代码实际上和前缀树的插入一样的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="type">char</span>[] wordArr = word.toCharArray();</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currIndex</span> <span class="operator">=</span> wordArr[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr.next[currIndex] == <span class="literal">null</span>)&#123;</span><br><span class="line">                curr.next[currIndex] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next[currIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        curr.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchInTrie(<span class="number">0</span>,word.toCharArray(),root);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 主要的区别在与前缀树部分，如果仅是普通的删除，那么只需要在前缀树上沿着路径不断进行搜索即可</span></span><br><span class="line">    <span class="comment">// 如果出现了 &#x27;.&#x27; ，那么就需要遍历所有可能的分支</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">searchInTrie</span><span class="params">(<span class="type">int</span> currIndex,<span class="type">char</span>[] wordArr,TrieNode currNode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(currNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(currNode.isEnd &amp;&amp; currIndex == wordArr.length) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(currIndex == wordArr.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(wordArr[currIndex] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">                <span class="comment">// 遍历分支</span></span><br><span class="line">                <span class="keyword">if</span>(searchInTrie(currIndex+<span class="number">1</span>,wordArr,currNode.next[i]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 沿前缀树一路向后走即可</span></span><br><span class="line">            res = searchInTrie(currIndex+<span class="number">1</span>,wordArr,currNode.next[wordArr[currIndex]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj.addWord(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>229. 求众数 II</title>
    <url>/posts/372b/</url>
    <content><![CDATA[<h1 id="229-求众数-ii">229. 求众数 II</h1>
<p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过
<code>⌊ n/3 ⌋</code> 次的元素。</p>
<span id="more"></span>

<h2 id="摩尔投票法">摩尔投票法</h2>
<p>在 <code>面试题 17.10. 主要元素</code>
中，我们求过主要元素（实际上就是出现次数超过<code>⌊ n/2 ⌋</code>次的元素，在这一题中我们使用的摩尔投票法同样可以套用到这里</p>
<blockquote>
<p>摩尔投票法：</p>
<p>其思路就是对拼消耗，假设我们要选出出现次数大于 n/k
的元素，那么我们最多只有 k-1 个候选元素（这也很好理解，如果出现次数超过
n/k 的有k次，那么所有元素出现次数会超过n</p>
<p>在这 k-1
个候选元素中，我们套用对拼消耗思想，记录当前候选者及其对应的选票，然后检查当前选票情况，如果当前选票和候选选票不同，此时出现对拼，二者选票都减一，如果当前数已经为0，更新新候选者</p>
</blockquote>
<p>了解了这个思路后，我们可以写出求出现次数大于 n/k 次的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> majorityElementK(nums,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">majorityElementK</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length / <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> k - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 求出现次数大于 n/k 的元素</span></span><br><span class="line">        <span class="type">int</span>[] candidate = <span class="keyword">new</span> <span class="title class_">int</span>[t];</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[t];</span><br><span class="line">        <span class="comment">// 对拼阶段</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums)&#123;</span><br><span class="line">            <span class="comment">// 检查所有选票</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">notCandidate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;++j)&#123;</span><br><span class="line">                <span class="comment">// 如果当前数是候选者之一，其计数加一</span></span><br><span class="line">                <span class="keyword">if</span>(candidate[j] == i)&#123;</span><br><span class="line">                    ++count[j];</span><br><span class="line">                    notCandidate = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(notCandidate)&#123;</span><br><span class="line">                <span class="comment">// 检查是否需要更新计数</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">updateCount</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(count[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                        candidate[j] = i;</span><br><span class="line">                        count[j] = <span class="number">1</span>;</span><br><span class="line">                        updateCount = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(updateCount)&#123;</span><br><span class="line">                    <span class="comment">// 当前所有侯选者计数都不为0，那么所有候选者计数都减一</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;++j)&#123;</span><br><span class="line">                        --count[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 验证阶段</span></span><br><span class="line">        Arrays.fill(count,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;t;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == candidate[j])&#123;</span><br><span class="line">                    <span class="comment">// 这个计数是互斥的，如果两个值相同的话，也就只会统计一次</span></span><br><span class="line">                    ++count[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] &gt; l) res.add(candidate[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="暴力面试必挂法">暴力（面试必挂法）</h2>
<p>暴力属实没什么好说的了，统计每一个数字出现的次数，然后筛选出所有超过
n/3
的元素即可，面试要是问到了这个题，然后给出这个解法，估计是直接没了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 最简单的方法，统计每个数字出现的次数即可</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> nums.length / <span class="number">3</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue() &gt; threshold)&#123;</span><br><span class="line">                res.add(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>260. 只出现一次的数字 III</title>
    <url>/posts/4e2f/</url>
    <content><![CDATA[<h1 id="260-只出现一次的数字-iii">260. 只出现一次的数字 III</h1>
<p>给定一个整数数组
nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。
找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p>
<p>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/single-number-iii">https://leetcode-cn.com/problems/single-number-iii</a></p>
</blockquote>
<span id="more"></span>

<h2 id="哈希表">哈希表</h2>
<p>这个题用哈希表面试就别想过了，考察的就是位运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(k) == <span class="number">1</span>)&#123;</span><br><span class="line">                res[curr] = k;</span><br><span class="line">                ++curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算">位运算</h2>
<p>看到这种数组中出现多次，一个数字仅出现一次的就容易想到位运算</p>
<blockquote>
<p>a ^ a = 0</p>
<p>a ^ 0 = a</p>
<p>位运算的性质</p>
</blockquote>
<p>使用上面两条性质，对nums做一次异或可以很快的得到 res[0]^res[1]
的值，记为xor</p>
<p>那么我们只需要找到一种方式，使得res[0]和res[1]区分开来即可</p>
<p>此时我们再观察异或的值</p>
<blockquote>
<p>1 ^ 0 = 1</p>
</blockquote>
<p>那么对于xor中值为1的，说明res[0]和res[1]是存在不同的，那么通过这个位，我们可以将数组分成两部分，A和B，且A中仅出现res[0]，剩下的数字都出现两次，取一次异或就可以知道res[0]，同理，对于B也是一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 这种题目感觉大概率是和位运算有关的</span></span><br><span class="line">        <span class="comment">// a^b^c^b^c^d = a^d</span></span><br><span class="line">        <span class="comment">// b^b = 0</span></span><br><span class="line">        <span class="comment">// a^0 = a</span></span><br><span class="line">        <span class="comment">// 最后只可以知道a^d的结果，只要知道其中一个的结果就可以解出两个数了</span></span><br><span class="line">        <span class="comment">// a^(a^d) = d</span></span><br><span class="line">        <span class="comment">// (a^d)^d = a</span></span><br><span class="line">        <span class="comment">// 那么关键就在于，如何找出这个只出现了一次的数呢？</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">xor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            xor ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到xor中为1的那一位，用来区分res[0]和res[1]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lowbit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(((xor &gt;&gt; lowbit) &amp; <span class="number">1</span>) ==<span class="number">0</span>)&#123;</span><br><span class="line">            ++lowbit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 之后可以使用这个和对num进行分组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((num&gt;&gt;lowbit)&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                res[<span class="number">0</span>] ^= num;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[<span class="number">1</span>] ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>282. 给表达式添加运算符</title>
    <url>/posts/ffea/</url>
    <content><![CDATA[<h1 id="282-给表达式添加运算符">282. 给表达式添加运算符</h1>
<p>给定一个仅包含数字 0-9 的字符串 num 和一个目标值整数 target ，在 num
的数字之间添加 二元 运算符（不是一元）+、- 或 *
，返回所有能够得到目标值的表达式。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/expression-add-operators">https://leetcode-cn.com/problems/expression-add-operators</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>这个题没什么好说的，只能暴力枚举出所有的表达式，然后逐个计算其值是否等于目标值</p>
<p>首先考虑放置符号的位置，设num的长度为n，那么n个数之间共有n-1个位置可以插入运算符，一共有四种可选的运算符，加、减、乘、空（不放置），因此所有可能的表达式的值为
4<sup>n-1</sup>种，那么我们只需要计算出所有表达式即可，这个过程可以使用dfs进行搜索</p>
<p>还有一种思路就是在枚举的过程中计算表达式的值（记忆化搜索思路，加快计算），同时构造表达式的时候需要使用StringBuilder，直接使用String构造字符串效率太低</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; res;</span><br><span class="line">    <span class="keyword">private</span> String num;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> target;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> l;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">addOperators</span><span class="params">(String _num, <span class="type">int</span> _target)</span> &#123;</span><br><span class="line">        <span class="comment">// 没什么好说的，这个题就是一个暴力搜索的题，但是需要进行优化</span></span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        num = _num;</span><br><span class="line">        l = num.length();</span><br><span class="line">        target = _target;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0L</span>,<span class="number">0L</span>,<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 同时记录了前一个值和当前表达式的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> currPos,<span class="type">long</span> currRes,<span class="type">long</span> prevValue,StringBuilder sb)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(currPos == l &amp;&amp; currRes == target)&#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用StringBuilder记录，防止频繁进行字符串操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">originLength</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="keyword">if</span>(currPos &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=currPos;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="comment">// 对于 05 这种是不行的</span></span><br><span class="line">            <span class="keyword">if</span>(i!=currPos &amp;&amp; num.charAt(currPos) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="type">char</span> <span class="variable">currChar</span> <span class="operator">=</span> num.charAt(i);</span><br><span class="line">            sb.append(currChar);</span><br><span class="line">            currValue = currValue * <span class="number">10</span> + (currChar-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(currPos==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 确定第一个数</span></span><br><span class="line">                dfs(i+<span class="number">1</span>,currValue,currValue,sb);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 确定之后的数，然后在currPos之间插入运算符</span></span><br><span class="line">                sb.setCharAt(originLength,<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">                dfs(i+<span class="number">1</span>,currRes+currValue,currValue,sb);</span><br><span class="line">                sb.setCharAt(originLength,<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">                dfs(i+<span class="number">1</span>,currRes-currValue,-currValue,sb);</span><br><span class="line">                <span class="type">long</span> <span class="variable">mul</span> <span class="operator">=</span> prevValue * currValue;</span><br><span class="line">                sb.setCharAt(originLength,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">                dfs(i+<span class="number">1</span>,currRes-prevValue+mul,mul,sb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.setLength(originLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>301. 删除无效的括号</title>
    <url>/posts/3379/</url>
    <content><![CDATA[<h1 id="301-删除无效的括号">301. 删除无效的括号</h1>
<p>给你一个由若干括号和字母组成的字符串 <code>s</code>
，删除最小数量的无效括号，使得输入的字符串有效。</p>
<p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/remove-invalid-parentheses/">301.
删除无效的括号 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h3 id="dfs剪枝">DFS+剪枝</h3>
<blockquote>
<p><em>剪枝的艺术</em></p>
</blockquote>
<p>看到这个题，要求输出所有可能的结果，那已经是铁铁的暴力搜索了</p>
<p>首先可以遍历一遍字符串计算出需要删除的无效括号的数目，然后得出最终结果的长度</p>
<p>只需要分别统计不匹配的左括号和右括号数目即可，算法很简单</p>
<p>对于字符串 "()())()"</p>
<p>leftCount = 0</p>
<p>rightCount = 0</p>
<p>step1:</p>
<p>leftCount = 1,rightCount = 0</p>
<p>step2:</p>
<p>leftCount = 0,rightCount = 0</p>
<p>step3:</p>
<p>leftCount = 1,rightCount = 0</p>
<p>step4:</p>
<p>leftCount = 0,rightCount = 0</p>
<p>step5:</p>
<p>leftCount = 0,rightCount = 1</p>
<p>step6:</p>
<p>leftCount = 1,rightCount = 1</p>
<p>step7:</p>
<p>leftCount = 0,rightCount = 1</p>
<p>最终不匹配的括号数为 leftCount + rightCount = 1</p>
<p>只需要删除一个右括号就可以使字符串变得有效</p>
<p>对于删除过程，我们可以使用dfs进行删除，对于每一个字符，其都可以选择加入当前构造的字符串或者不加入，</p>
<p>遍历结束时只需要判断当前字符串是否是符合条件即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxScore,length,finalLength;</span><br><span class="line">    <span class="keyword">private</span> String targetString;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">removeInvalidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 对于括号匹配题目，可以使用1代表左括号，-1代表右括号</span></span><br><span class="line">        <span class="comment">// 那么对于一个合法的括号对，可以很容易知道，其匹配过程中前缀和一定是正值</span></span><br><span class="line">        <span class="comment">// 且可能的最大值为 min(leftCount,rightCount)</span></span><br><span class="line">        <span class="comment">// 还可以提前计算出匹配串的长度</span></span><br><span class="line">        <span class="type">int</span> l1=<span class="number">0</span>,l2=<span class="number">0</span>,r1=<span class="number">0</span>,r2=<span class="number">0</span>;</span><br><span class="line">        targetString = s;</span><br><span class="line">        length = s.length();</span><br><span class="line">        set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                ++l1;</span><br><span class="line">                ++l2;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                ++r1;</span><br><span class="line">                <span class="keyword">if</span>(l2&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    --l2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ++r2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        finalLength = length - l2 - r2;</span><br><span class="line">        maxScore = Math.min(l1,r1);</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,l2,r2,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> currIndex,String s,<span class="type">int</span> leftCount,<span class="type">int</span> rightCount,<span class="type">int</span> prefixSum)</span>&#123;</span><br><span class="line">        <span class="comment">// 剪枝代码，很关键</span></span><br><span class="line">        <span class="keyword">if</span>(prefixSum &lt; <span class="number">0</span> || prefixSum &gt; maxScore || leftCount &lt; <span class="number">0</span> || rightCount &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(currIndex == length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prefixSum == <span class="number">0</span> &amp;&amp; s.length() == finalLength)&#123;</span><br><span class="line">                set.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">currChar</span> <span class="operator">=</span> targetString.charAt(currIndex);</span><br><span class="line">        <span class="keyword">if</span>(currChar == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            dfs(currIndex+<span class="number">1</span>,s+String.valueOf(currChar),leftCount,rightCount,prefixSum+<span class="number">1</span>);</span><br><span class="line">            dfs(currIndex+<span class="number">1</span>,s,leftCount-<span class="number">1</span>,rightCount,prefixSum);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(currChar == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            dfs(currIndex+<span class="number">1</span>,s+String.valueOf(currChar),leftCount,rightCount,prefixSum-<span class="number">1</span>);</span><br><span class="line">            dfs(currIndex+<span class="number">1</span>,s,leftCount,rightCount-<span class="number">1</span>,prefixSum);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(currIndex+<span class="number">1</span>,s+String.valueOf(currChar),leftCount,rightCount,prefixSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中包含两步剪枝</p>
<ol type="1">
<li>前缀和剪枝（尽可能保证字符串是有效的，不会出现有未匹配的右括号）</li>
<li>删除个数剪枝，当删除个数达到上限时直接返回，没有必要进一步搜索了</li>
</ol>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>352. 将数据流变为多个不相交区间</title>
    <url>/posts/b/</url>
    <content><![CDATA[<h1 id="352-将数据流变为多个不相交区间">352.
将数据流变为多个不相交区间</h1>
<p>给你一个由非负整数 a1, a2, ..., an
组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。</p>
<p>实现 SummaryRanges 类：</p>
<ul>
<li><code>SummaryRanges()</code> 使用一个空数据流初始化对象。</li>
<li><code>void addNum(int val)</code> 向数据流中加入整数 val 。</li>
<li><code>int[][] getIntervals()</code> 以不相交区间 [starti, endi]
的列表形式返回对数据流中整数的总结。</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals">https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals</a></p>
</blockquote>
<span id="more"></span>

<h2 id="二分查找模拟">二分查找+模拟</h2>
<p>首先题目要求是根据输入的整数，将这些整数划分到不同区间内，例如
[1,2,3,5,6,7] 就可以划分为两个区间 [1,3] 和 [5,7]</p>
<p>那么对于下一个待插入的整数，我们可以使用二分查找找到其所在的位置，然后判断其前一个和后一个的区间，然后插入即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SummaryRanges</span> &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">10</span>, -<span class="number">10</span>&#125;, tail = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10010</span>, <span class="number">10010</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummaryRanges</span><span class="params">()</span> &#123;</span><br><span class="line">        list.add(head);</span><br><span class="line">        list.add(tail);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n-<span class="number">1</span>;</span><br><span class="line">      	<span class="comment">// 注意此处一定 r = n-1，因为我们之后需要读取p对应的下标，如果r == n的话，就会取不到值</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (list.get(mid)[<span class="number">0</span>] &gt; val) r = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] cur = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;val, val&#125;;</span><br><span class="line">        <span class="type">int</span>[] prev = list.get(r);</span><br><span class="line">        <span class="type">int</span>[] next = list.get(r+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((prev[<span class="number">0</span>] &lt;= val &amp;&amp; val &lt;= prev[<span class="number">1</span>]) || (next[<span class="number">0</span>] &lt;= val &amp;&amp; val &lt;= next[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="comment">// pass</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev[<span class="number">1</span>] + <span class="number">1</span> == val &amp;&amp; val == next[<span class="number">0</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">            prev[<span class="number">1</span>] = next[<span class="number">1</span>];</span><br><span class="line">            list.remove(next);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev[<span class="number">1</span>] + <span class="number">1</span> == val) &#123;</span><br><span class="line">            prev[<span class="number">1</span>] = val;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[<span class="number">0</span>] - <span class="number">1</span> == val) &#123;</span><br><span class="line">            next[<span class="number">0</span>] = val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.add(r + <span class="number">1</span>, cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] getIntervals() &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n - <span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) ans[idx++] = list.get(i);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集">并查集</h2>
<p>由于数据范围并不大，我们可以使用一个长度为10001的数组，来存储当前数字的右边界，这样我们遍历的时候只需要不断找左右边界即可</p>
<p>下面举例实现，假设我们数据范围就是10</p>
<p>流数据为 [1,5,7,3,2,6]</p>
<p><strong>初始化</strong></p>
<p>arr = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]</p>
<p><strong>step1</strong>:</p>
<p>当前数据为1，且此时 arr[1] =
-1，表示其父节点并不存在，那么其右节点就是其本身</p>
<p>更新 arr[1] = 1</p>
<p>arr = [-1,1,-1,-1,-1,-1,-1,-1,-1,-1]</p>
<p><strong>step2</strong>:</p>
<p>当前数据为5，且此时 arr[5] =
-1，表示其父节点并不存在，那么其右节点就是其本身</p>
<p>更新 arr[5] = 5</p>
<p>arr = [-1,1,-1,-1,-1,5,-1,-1,-1,-1]</p>
<p><strong>step3</strong>:</p>
<p>当前数据为7，且此时 arr[7] =
-1，表示其父节点并不存在，那么其右节点就是其本身</p>
<p>更新 arr[7] = 7</p>
<p>arr = [-1,1,-1,-1,-1,5,-1,7,-1,-1]</p>
<p><strong>step4</strong>:</p>
<p>当前数据为3，且此时 arr[3] =
-1，表示其父节点并不存在，那么其右节点就是其本身</p>
<p>更新 arr[3] = 3</p>
<p>arr = [-1,1,-1,3,-1,5,-1,7,-1,-1]</p>
<p><strong>step5</strong>:</p>
<p>当前数据为2，且此时 arr[2] =
-1，表示其父节点并不存在，那么其右节点就是其本身</p>
<p>更新 arr[2] = 2</p>
<p>arr = [-1,1,-1,3,-1,5,-1,7,-1,-1]</p>
<p>但此时我们发现可以进行合并</p>
<p>arr = [-1,3,3,3,-1,5,-1,7,-1,-1]</p>
<p><strong>step6</strong>:</p>
<p>当前数据为6，且此时 arr[6] =
-1，表示其父节点并不存在，那么其右节点就是其本身</p>
<p>更新 arr[6] = 6</p>
<p>arr = [-1,3,3,3,-1,5,6,7,-1,-1]</p>
<p>但此时我们发现可以进行合并</p>
<p>arr = [-1,3,3,3,-1,7,7,7,-1,-1]</p>
<p>// 但是如果此时我们插入一个4的话，数字就变成
1，2，3，4，5，6，7最终数据范围为</p>
<p>这种变化并不是一次就可以完成的，而是在FIND的过程中进行路径压缩后实现的</p>
<p>arr = [-1,7,7,7,7,7,7,7,-1,-1]</p>
<h3 id="并查集普通版">并查集（普通版）</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SummaryRanges</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10010</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummaryRanges</span><span class="params">()</span> &#123;</span><br><span class="line">        Arrays.fill(arr,-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[val] == -<span class="number">1</span>)&#123;</span><br><span class="line">            arr[val] = val;</span><br><span class="line">          	<span class="comment">// 合并连续区间 实际上代表的区间就是 [val,arr[val]] [val+1,arr[val+1]]</span></span><br><span class="line">          	<span class="comment">// 当val+1存在时就可以进行合并</span></span><br><span class="line">            UNION(val,val+<span class="number">1</span>);</span><br><span class="line">          	<span class="comment">// 同理，合并区间</span></span><br><span class="line">            UNION(val-<span class="number">1</span>,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">FIND</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[val] == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> val;</span><br><span class="line">        <span class="keyword">while</span>(arr[root] != root)&#123;</span><br><span class="line">            root = arr[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 路径压缩</span></span><br><span class="line">        <span class="keyword">while</span>(arr[val] != val)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> arr[val];</span><br><span class="line">            arr[val] = root;</span><br><span class="line">            val = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">UNION</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">      	<span class="comment">// 这里调用的时候一定是 a &lt; b，实际上只需要判断 a是否小于-1即可</span></span><br><span class="line">        <span class="keyword">if</span>(a &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> FIND(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> FIND(b);</span><br><span class="line">        <span class="keyword">if</span>(rootA == -<span class="number">1</span> || rootB == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">      	<span class="comment">// 由于 a &lt; b，那么rootA一定是小于rootB的，只需要更新arr[a]即可</span></span><br><span class="line">        arr[a] = rootB;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] getIntervals() &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">                <span class="comment">// 快速找到右边界</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> FIND(i);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;start, end&#125;);</span><br><span class="line">                i = end + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[list.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SummaryRanges object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SummaryRanges obj = new SummaryRanges();</span></span><br><span class="line"><span class="comment"> * obj.addNum(val);</span></span><br><span class="line"><span class="comment"> * int[][] param_2 = obj.getIntervals();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="并查集集合">并查集+集合</h3>
<p>在普通版的并查集中，我们需要遍历可能的左边界来的出最后结果，实际上我们可以使用set来存储左边界，这样就可以快速得出所有区间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SummaryRanges</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10010</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummaryRanges</span><span class="params">()</span> &#123;</span><br><span class="line">        Arrays.fill(arr,-<span class="number">1</span>);</span><br><span class="line">        set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[val] == -<span class="number">1</span>)&#123;</span><br><span class="line">            arr[val] = val;</span><br><span class="line">            set.add(val);</span><br><span class="line">            UNION(val,val+<span class="number">1</span>);</span><br><span class="line">            UNION(val-<span class="number">1</span>,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">FIND</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[val] == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> val;</span><br><span class="line">        <span class="keyword">while</span>(arr[root] != root)&#123;</span><br><span class="line">            root = arr[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update, path compress</span></span><br><span class="line">        <span class="keyword">while</span>(arr[val] != val)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> arr[val];</span><br><span class="line">            arr[val] = root;</span><br><span class="line">            val = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">UNION</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="comment">// 此处一定是 a &lt; b，那么rootA 一定小于 rootB</span></span><br><span class="line">        <span class="keyword">if</span>(a&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootA</span> <span class="operator">=</span> FIND(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootB</span> <span class="operator">=</span> FIND(b);</span><br><span class="line">        <span class="keyword">if</span>(rootA == -<span class="number">1</span> || rootB == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        arr[a] = rootB;</span><br><span class="line">      	<span class="comment">// 当a和b可以进行合并的时候，那么a可能是左边界，但是b一定不是左边界</span></span><br><span class="line">        <span class="comment">// 此时b一定不是左边界</span></span><br><span class="line">        set.remove(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] getIntervals() &#123;</span><br><span class="line">        <span class="comment">// System.out.println(set);</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[set.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> start:set)&#123;</span><br><span class="line">            res[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start,FIND(start)&#125;;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SummaryRanges object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SummaryRanges obj = new SummaryRanges();</span></span><br><span class="line"><span class="comment"> * obj.addNum(val);</span></span><br><span class="line"><span class="comment"> * int[][] param_2 = obj.getIntervals();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>414. 第三大的数</title>
    <url>/posts/e56d/</url>
    <content><![CDATA[<h1 id="414-第三大的数">414. 第三大的数</h1>
<p>给你一个非空数组，返回此数组中
<strong>第三大的数</strong>（所有不同数字中排第三大的数）
。如果不存在，则返回数组中最大的数。</p>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= nums.length &lt;= 10<sup>4</sup></li>
<li>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</li>
</ul>
<span id="more"></span>

<h2 id="排序">排序</h2>
<p>如果使用排序就没有什么好说的，使用set去重并进行排序，找到第三个最大的即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">thirdMax</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 由于存在 Integer.MIN_VALUE，当出现减法的时候，比较器就会失效，需要操作一下</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a==b?<span class="number">0</span>:(a&gt;b?-<span class="number">1</span>:<span class="number">1</span>));</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(i))&#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">                set.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(queue.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> queue.poll();</span><br><span class="line">        queue.poll();</span><br><span class="line">        queue.poll();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于本题数据卡的比较死，在排序算法中需要注意比较器的设置，如果直接使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Comparatpr</span>&lt;Integer&gt;()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> o1,<span class="type">int</span> o2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o2 - o1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当遇到 o2 - o1 溢出的时候就会排序出错，因此需要直接判断 o2 和 o1
的大小，比较器设置如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> o1,<span class="type">int</span> o2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o1 == o2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(o1 &lt; o2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确保返回值不会溢出，且能正确表示序关系，这样就实现正确的排序，最后找出第三大的值即可</p>
<h2 id="遍历">遍历</h2>
<blockquote>
<p><strong>经典的找数组次大值的做法是使用两个变量 <code>a</code> 和
<code>b</code> 分别存储遍历过程中的最大值和次大值。</strong></p>
<p><a
href="https://leetcode-cn.com/problems/third-maximum-number/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-pmln/">【宫水三叶】一题双解
:「排序」&amp;「遍历」 - 第三大的数 - 力扣（LeetCode）
(leetcode-cn.com)</a></p>
</blockquote>
<p>类似于找次大值的做法，我们可以使用三个变量a，b，c来分别存储遍历过程中的最大值、次大值和第三大值，最后返回c即可</p>
<p>由于 a，b，c之间存在序关系 <code>a &gt; b &gt; c</code></p>
<p>对于当前遍历的值，其更新规则是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if x &gt; a:</span><br><span class="line">		// 直接更新最大值，其他值依次后推</span><br><span class="line">    c = b;</span><br><span class="line">    b = a;</span><br><span class="line">    a = x;</span><br><span class="line">elif x &lt; a &amp;&amp; x &gt; b:</span><br><span class="line">		// 此处判断条件中必须添加 x &lt; a，防止 x和a值相同</span><br><span class="line">		// 更新次大值</span><br><span class="line">		c = b;</span><br><span class="line">		b = x;</span><br><span class="line">elif x &lt; b &amp;&amp; x &gt; c:</span><br><span class="line">		// 添加 x &lt; b的原因也是一样，防止出现值相同的情况</span><br><span class="line">		// 更新第三大值</span><br><span class="line">		c = x;</span><br></pre></td></tr></table></figure>

<p>由于数据最小值为
Integer,MIN_VALUE，此时无法判断是不存在第三大值还是第三大值就是Integer.MIN_VALUE</p>
<p>我们使用long来存储a，b，c三个值，并用
Long.MIN_VALUE进行初始化，这样就可以判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">thirdMax</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> Long.MIN_VALUE,b = Long.MIN_VALUE,c = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:nums)&#123;</span><br><span class="line">            <span class="comment">// System.out.println(a+&quot; &quot;+b+&quot; &quot;+c);</span></span><br><span class="line">            <span class="keyword">if</span>(x &gt; a)&#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = a;</span><br><span class="line">                a = x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; a &amp;&amp; x &gt; b)&#123;</span><br><span class="line">                c = b;</span><br><span class="line">                b = x;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; b &amp;&amp; x &gt; c)&#123;</span><br><span class="line">                c = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c == Long.MIN_VALUE ? (<span class="type">int</span>)a : (<span class="type">int</span>)c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>453. 最小操作次数使数组元素相等</title>
    <url>/posts/7527/</url>
    <content><![CDATA[<h1 id="453-最小操作次数使数组元素相等">453.
最小操作次数使数组元素相等</h1>
<p>给你一个长度为 <code>n</code> 的整数数组，每次操作将会使
<code>n - 1</code> 个元素增加 <code>1</code>
。返回让数组所有元素相等的最小操作次数。</p>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/">453.
最小操作次数使数组元素相等 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="数学脑筋急转弯">数学（脑筋急转弯）</h2>
<p>逆向思维，由于题目要求让数组中所有元素值相同，那么就只需要考虑数组元素之间的相对大小，因此对数组中n-1个加一实际上等价于数组中选一个元素减一，那么从这个角度来想的话，要将数组元素变为相等只需要将所有元素都变成最小值即可。分析之后就可以很快的写出代码来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 每次操作会使n-1个元素+1</span></span><br><span class="line">        <span class="comment">// 思路就是每次只更新最小的n-1个数字，不断执行这个操作，一定可以得到最小的操作次数</span></span><br><span class="line">        <span class="comment">// 但是这种模拟一定会超时，时间复杂度为 o(n^2)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            minValue = Math.min(minValue,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">// 把所有元素都减成minValue</span></span><br><span class="line">            res += (num - minValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>496. 下一个更大元素 I</title>
    <url>/posts/ab50/</url>
    <content><![CDATA[<h1 id="496-下一个更大元素-i">496. 下一个更大元素 I</h1>
<p>给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2
的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2
中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1
。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/next-greater-element-i">https://leetcode-cn.com/problems/next-greater-element-i</a></p>
</blockquote>
<span id="more"></span>

<h2 id="模拟">模拟</h2>
<p>对于nums1中的每一个字符nums1[i]，首先找到nums1[i]在nums2中对应的索引num2Index，然后再在nums2中找到下一个比nums1[i]更大的元素即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 首先暴力是一定可以的，时间复杂度为 o(nums1.length*nums2.length)</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l2;++i)&#123;</span><br><span class="line">            <span class="comment">// 记录nums2中每个数字的索引位置</span></span><br><span class="line">            map.put(nums2[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[l1];</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums1)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nums2Index</span> <span class="operator">=</span> map.get(num);</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextGreater</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=nums2Index+<span class="number">1</span>;j&lt;l2;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums2[j] &gt; num)&#123;</span><br><span class="line">                    nextGreater = nums2[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[++curr] = nextGreater;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表单调栈">哈希表+单调栈</h2>
<p>由于需要找到nums1上元素在nums2中下一个更大的元素，我们可以先对nums2处理，求出其每一个元素的下一个更大元素并使用哈希表存储下来，这样我们只需要再遍历一次nums1就可以得出结果</p>
<p>那么现在关键就是，如何生成nums2中每一个元素的下一个更大值？实际上这就是一个很经典的单调栈题，只需要维护一个单调递减的栈即可在o(n)时间复杂度内实现这个功能</p>
<p>下面举一个例子实现</p>
<p><strong>初始化</strong></p>
<p>nums2 = [1,3,4,2]</p>
<p>monoStack = []</p>
<p>map = {}</p>
<p><strong>step1</strong></p>
<p>当前元素1，栈为空，入栈</p>
<p>monoStack = [1]</p>
<p><strong>step2</strong></p>
<p>当前元素3，栈顶元素为1，此时就可以知道下一个比1大的元素为3</p>
<p>map = {1:3}</p>
<p>monoStack = [3]</p>
<p><strong>step3</strong></p>
<p>当前元素4，栈顶元素为3，此时就可以知道下一个比3大的元素为4</p>
<p>map = {1:3,3:4}</p>
<p>monoStack = [4]</p>
<p><strong>step4</strong></p>
<p>当前元素2，栈顶元素为4，直接入栈</p>
<p>monoStack = [4,2]</p>
<p>此时数组遍历完成，此时如果栈中还有剩余元素的话，就说明没有比他更大的值，直接将其所有值设置为-1即可</p>
<p>最终我们可以构造出nums2中所有元素的下一个最大值</p>
<p>map = {1:3,3:4,4:-1,2:-1}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; nextGreaterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; monoStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="comment">// 最后一个元素没有比他更大的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums2)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!monoStack.isEmpty() &amp;&amp; num &gt; monoStack.peek())&#123;</span><br><span class="line">                nextGreaterMap.put(monoStack.pop(),num);</span><br><span class="line">            &#125;</span><br><span class="line">            monoStack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!monoStack.isEmpty())&#123;</span><br><span class="line">            nextGreaterMap.put(monoStack.pop(),-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(nextGreaterMap);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; l1;++i)&#123;</span><br><span class="line">            nums1[i] = nextGreaterMap.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>240. 搜索二维矩阵 II</title>
    <url>/posts/3bb7/</url>
    <content><![CDATA[<h1 id="240-搜索二维矩阵-ii">240. 搜索二维矩阵 II</h1>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target
。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii">https://leetcode-cn.com/problems/search-a-2d-matrix-ii</a></p>
</blockquote>
<p>这题还有一个条件更强的前置题 <code>74. 搜索二维矩阵</code></p>
<p>其每行中的整数从左到右按升序排列，且每行第一个整数大于前一行最后一个整数</p>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>没什么好说的，直接遍历矩阵中的每一个元素，检查是否相等即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 从右上角开始搜索？</span></span><br><span class="line">        <span class="comment">// 如果直接暴力</span></span><br><span class="line">        <span class="comment">// o(m*n)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(m*n)</p>
<p>空间复杂度：o(1)</p>
<h2 id="暴力二分查找">暴力+二分查找</h2>
<p>由于矩阵按行、按列都是升序排列，很容易想到二分查找，那么我们只需要按行或者含列进行即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] num:matrix)&#123;</span><br><span class="line">            <span class="keyword">if</span>(binarySearch(num,target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] num,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> num.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(num[mid] &gt; target)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num[l] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>*注：关于二分查找的边界情况，还需要仔细考虑（否则容易出现死循环）</p>
<h2 id="抽象bst">抽象BST</h2>
<blockquote>
<p><a
href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/gong-shui-san-xie-yi-ti-shuang-jie-er-fe-y1ns/">【宫水三叶】一题双解
:「二分」&amp;「抽象 BST」 - 搜索二维矩阵 II - 力扣（LeetCode）
(leetcode-cn.com)</a></p>
</blockquote>
<p>可以将矩阵抽象为以右上角为根的二叉搜索树，然后套用二叉树性质进行搜索即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; m &amp;&amp; c &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 每次都以当前节点为根节点，判断target位于其左子树还是右子树上</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[r][c] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[r][c] &gt;target) --c;</span><br><span class="line">            <span class="keyword">else</span> ++r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>869. 重新排列得到2的幂</title>
    <url>/posts/266d/</url>
    <content><![CDATA[<h1 id="869-重新排列得到2的幂">869. 重新排列得到2的幂</h1>
<p>给定正整数 N
，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p>
<p>如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回
false。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/reordered-power-of-2">https://leetcode-cn.com/problems/reordered-power-of-2</a></p>
</blockquote>
<span id="more"></span>

<h2 id="dfs剪枝">DFS+剪枝</h2>
<p>首先看到题目中提到将数字重新排序，很容易想到将数字转换成字符串，然后求其全排列，判断全排列中是否存在一种排列是二的幂次即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer,List&lt;String&gt;&gt; map;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="type">String</span> <span class="variable">valStr</span> <span class="operator">=</span> String.valueOf(val);</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> valStr.length();</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(length,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(valStr);</span><br><span class="line">            map.put(length,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储二的幂次对应的字符串</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; availPowerOf2;</span><br><span class="line">    <span class="comment">// 存储每个位置可能的值</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Set&lt;Character&gt;&gt; availNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> l;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[] charArr;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">reorderedPowerOf2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先将n转换成字符串再说吧</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        charArr = num.toCharArray();</span><br><span class="line">        l = num.length();</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[l];</span><br><span class="line">        availPowerOf2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        availPowerOf2.addAll(map.get(l));</span><br><span class="line">        availNum = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String s:availPowerOf2)&#123;</span><br><span class="line">                set.add(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            availNum.add(set);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">StringBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> currIndex,StringBuilder sb)</span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println(s);</span></span><br><span class="line">        <span class="keyword">if</span>(sb.length() == l)&#123;</span><br><span class="line">            <span class="keyword">return</span> availPowerOf2.contains(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> charArr[i];</span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; availNum.get(currIndex).contains(ch))&#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                sb.append(ch);</span><br><span class="line">                <span class="keyword">if</span>(dfs(currIndex+<span class="number">1</span>,sb))&#123;</span><br><span class="line">                    res = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sb.deleteCharAt(currIndex);</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="词频统计">词频统计</h2>
<p>实际上，如果一个一个数的排列可以变成二的幂次，那么将这两个数中每一位数字出现次数一定是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer,List&lt;<span class="type">int</span>[]&gt;&gt; map;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">30</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="type">String</span> <span class="variable">valStr</span> <span class="operator">=</span> String.valueOf(val);</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> valStr.length();</span><br><span class="line">            List&lt;<span class="type">int</span>[]&gt; list = map.getOrDefault(length,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(count(valStr));</span><br><span class="line">            map.put(length,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">reorderedPowerOf2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先将n转换成字符串再说吧</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">        <span class="type">int</span>[] countNum = count(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] powerOf2 : map.get(num.length()))&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(powerOf2,countNum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] count(String s)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:s.toCharArray())&#123;</span><br><span class="line">            ++res[ch-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] a1,<span class="type">int</span>[] a2)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a1[i] != a2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 001. 整数除法</title>
    <url>/posts/665/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-001-整数除法">剑指 Offer II 001. 整数除法</h1>
<p>给定两个整数 <code>a</code> 和 <code>b</code> ，求它们的除法的商
<code>a/b</code> ，要求不得使用乘号 <code>'*'</code>、除号
<code>'/'</code> 以及求余符号 <code>'%'</code> 。</p>
<p>注意：</p>
<ul>
<li>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345)
= 8 以及 truncate(-2.7335) = -2</li>
<li>假设我们的环境只能存储 32 位有符号整数，其数值范围是
[−2<sup>31</sup>, 2<sup>31</sup>−1]。本题中，如果除法结果溢出，则返回
2<sup>31</sup> − 1</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/xoh6Oh">https://leetcode-cn.com/problems/xoh6Oh</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力超时">暴力（超时）</h2>
<p>最简单的，从除法定义出发，a = a/b * b +
a%b，即a最多可以包含多少倍的b，那么最简单的就在循环中不断减去，直到最终结果小于b为止，对于负数情况，可以先取出符号位，然后取绝对值，同时存在一种特殊情况，当a为<code>-2^31</code>即Integer.MIN_VALUE时，b为1时，实际除出来的结果为<code>2^31</code>，而这个值已经超出Integer.MAX_VALUE（<code>2^31-1</code>)，按照题目要求，最终结果返回<code>2^31-1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">// 感觉还是需要使用位运算来模拟</span></span><br><span class="line">        <span class="comment">// 特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(a == Integer.MIN_VALUE &amp;&amp; b == -<span class="number">1</span>) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 不能使用乘法、除法、取余，那就用减法嘛</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 还需要考虑负数问题</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isPositive</span> <span class="operator">=</span> ( a&gt;<span class="number">0</span> &amp;&amp; b&gt;<span class="number">0</span> ) || ( a&lt;<span class="number">0</span> &amp;&amp; b&lt;<span class="number">0</span> );</span><br><span class="line">        a = abs(a);</span><br><span class="line">        b = abs(b);</span><br><span class="line">        <span class="comment">// 对于 a &gt;&gt; b的情况，需要减的太过了</span></span><br><span class="line">        <span class="comment">// 如果a=2^31，b=1，这样的话计算起来太慢了，需要找其他方法</span></span><br><span class="line">        <span class="comment">// 实际上可以有更好的解决方式</span></span><br><span class="line">        <span class="keyword">while</span>(a&gt;=b)&#123;</span><br><span class="line">            a-=b;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isPositive ? i : -i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">abs</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&lt;<span class="number">0</span>) <span class="keyword">return</span> -v;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算">位运算</h2>
<p>实际上，这个思路有点类似于 <code>剑指 Offer 64. 求1+2+...+n</code>
，剑指 Offer 64
一题实际上是需要使用位运算模拟乘法，而本题要求用位运算模拟除法，本质上思路是一致的。</p>
<p>下面举一个例子来介绍</p>
<p>求 15 / 2</p>
<p>初始化</p>
<p>a = 15</p>
<p>b = 2</p>
<p>v = 0</p>
<p>step1:</p>
<p>首先可以很快知道 2^3 = 8 &lt; 15 &lt; 2^4 = 16，包含4倍的2</p>
<p>此时更新值</p>
<p>a = 15 - 8 = 7</p>
<p>b = 2</p>
<p>v = 4 （2^3 &gt;&gt; 1 = 4）</p>
<p>step2:</p>
<p>又有2^2 = 4 &lt; 7 &lt; 2^3 = 8，此时包含2倍的2</p>
<p>a = 7 - 4 = 3</p>
<p>b = 2</p>
<p>v = 6 （4 + 2^2 &gt;&gt; 1 = 6)</p>
<p>step3:</p>
<p>此时 2 &lt; 3 &lt; 2^2 = 4</p>
<p>a = 3 - 2 = 1</p>
<p>b = 2</p>
<p>v = 7 (6 + 2&gt;&gt;1 = 7)</p>
<p>此时 a &lt; b ，计算完成，a/b 结果为 7</p>
<p>知道计算过程之后，写出代码就很简单了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isPositive</span> <span class="operator">=</span> (a&gt;<span class="number">0</span>&amp;&amp;b&gt;<span class="number">0</span>) || (a&lt;<span class="number">0</span>&amp;&amp;b&lt;<span class="number">0</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">a1</span> <span class="operator">=</span> Math.abs((<span class="type">long</span>)a);</span><br><span class="line">        <span class="type">long</span> <span class="variable">b1</span> <span class="operator">=</span> Math.abs((<span class="type">long</span>)b);</span><br><span class="line">        <span class="comment">// System.out.println(a1+&quot; &quot;+b1);</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a1&gt;=b1)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">b2</span> <span class="operator">=</span> b1;</span><br><span class="line">            <span class="type">long</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(a1 &gt; (b2 &lt;&lt; <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">// 每左移一次相当于乘二</span></span><br><span class="line">                b2 &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                shift &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v+=shift;</span><br><span class="line">            a1 -= b2;</span><br><span class="line">        &#125;</span><br><span class="line">        v = isPositive ? v : -v;</span><br><span class="line">        <span class="keyword">if</span>(v &gt; Integer.MAX_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 003. 前n个数字二进制中1的个数</title>
    <url>/posts/3600/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-003-前n个数字二进制中1的个数">剑指 Offer II 003.
前n个数字二进制中1的个数</h1>
<p>给定一个非负整数 <code>n</code> ，请计算 <code>0</code> 到
<code>n</code> 之间的每个数字的二进制表示中 1
的个数，并输出一个数组。</p>
<blockquote>
<p><a href="https://leetcode-cn.com/problems/w3tCBm/">剑指 Offer II 003.
前 n 个数字二进制中 1 的个数 - 力扣（LeetCode）
(leetcode-cn.com)</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<p>使用dp[i]表示数字i对应二进制中1的个数，可以很轻松的得出状态转移方程
<span class="math display">\[
dp[i] = dp[i&gt;&gt;1] + (i\&amp;1)
\]</span> 原理很容易理解，对于二进制 5，若已知 5&gt;&gt;1 即 0b10
对应的1的个数为1，那么只需要判断5的最后一位是否是1即可，使用
i&amp;1可以轻松判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">// dp[i] = dp[i&gt;&gt;1] + (i&amp;1);</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            dp[i] = dp[i&gt;&gt;<span class="number">1</span>] + (i&amp;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 17.10. 主要元素</title>
    <url>/posts/5ff6/</url>
    <content><![CDATA[<h1 id="面试题-1710-主要元素">面试题 17.10. 主要元素</h1>
<p>数组中占比超过一半的元素称之为主要元素。给你一个整数数组，找出其中的主要元素。若没有，返回-1。请设计时间复杂度为O(N)、空间复杂度为O(1)的解决方案。</p>
<blockquote>
<p>题目连接：<a
href="https://leetcode-cn.com/problems/find-majority-element-lcci/">https://leetcode-cn.com/problems/find-majority-element-lcci/</a></p>
</blockquote>
<p>题目乍一看很简单，直接HashMap统计每个数出现的次数，然后找出现次数最多的数判断是不是主要元素即可，但是这个题目要求设计的是空间复杂度为O(1)的解决方案，使用HashMap的空间复杂度为O(n)，并不符合题目要求</p>
<span id="more"></span>

<h2 id="boyer-moore投票算法">Boyer-Moore投票算法</h2>
<p>想了半天没想出好的解决方案，看了题解，用了Boyer-Moore投票算法</p>
<blockquote>
<p>Boyer-Moore投票算法</p>
<p>核心思想是每次在数组中删除两个不同的数，最后剩下的一定是出现次数最多的数</p>
</blockquote>
<h3 id="模拟算法执行过程">模拟算法执行过程</h3>
<p>输入数组 nums</p>
<p>暂存数组 temp</p>
<p>考虑测试用例 [1,2,5,9,5,9,5,5,5]</p>
<p>开始遍历数组：</p>
<p>Init:</p>
<p>​ temp: [ ]</p>
<p>​ nums: [ 1,2,5,9,5,9,5,5,5 ]</p>
<p>Iter1:</p>
<p>​ temp: [ 1 ]</p>
<p>​ nums: [ 2,5,9,5,9,5,5,5 ]</p>
<p>Iter2:</p>
<p>​ temp: [ ]</p>
<p>​ nums: [ 5,9,5,9,5,5,5 ]</p>
<p>Iter3:</p>
<p>​ temp: [ 5 ]</p>
<p>​ nums: [ 9,5,9,5,5,5 ]</p>
<p>Iter4:</p>
<p>​ temp: [ ]</p>
<p>​ nums: [ 5,9,5,5,5 ]</p>
<p>Iter5:</p>
<p>​ temp: [ 5 ]</p>
<p>​ nums: [ 9,5,5,5 ]</p>
<p>Iter6:</p>
<p>​ temp: [ ]</p>
<p>​ nums: [ 5,5,5 ]</p>
<p>Iter7:</p>
<p>​ temp: [ 5 ]</p>
<p>​ nums: [ 5,5 ]</p>
<p>Iter8:</p>
<p>​ temp: [ 5,5 ]</p>
<p>​ nums: [ 5 ]</p>
<p>iter9:</p>
<p>​ temp: [ 5,5,5 ]</p>
<p>​ nums: [ ]</p>
<h3 id="算法思想解释">算法思想解释</h3>
<p>知乎上看到一个解释，解释的十分透彻</p>
<p>核心就是<strong>对拼消耗</strong>。</p>
<p>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。</p>
<p>那就大混战呗，最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。</p>
<p>最后能剩下的必定是自己人。</p>
<blockquote>
<p>作者：知乎用户 链接：<a
href="https://www.zhihu.com/question/49973163/answer/617122734">https://www.zhihu.com/question/49973163/answer/617122734</a>
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="java实现">Java实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 最简单的思路，直接统计nums中每个数出现的次数，之后给出占比最大的就行，超过一半说明一定是出现次数最多的</span></span><br><span class="line">        <span class="comment">// 但是这样的空间复杂度为O(N)，题目要求空间复杂度为O(1)</span></span><br><span class="line">        <span class="comment">// Boyer-Moore 投票法，将不同的数之间彼此抵消，最后找到剩下的就是主要元素</span></span><br><span class="line">        <span class="comment">// 这也是O(n)时间复杂度，O(1)空间复杂度找众数的算法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">candidate</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == candidate)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 碰见不一样的抵消一次计数</span></span><br><span class="line">                --count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println(&quot;candidate:&quot;+candidate+&quot;,count:&quot;+count);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过上述方法，一定可以找出出现次数最多的元素，最后统计candidate出现的次数</span></span><br><span class="line">        <span class="comment">// 最后找出的candidate一定是众数，但不一定是主要元素，因此还需要进行检验</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num == candidate)&#123;</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据主要元素定义，如果candidate出现次数小于数组长度的一半，不是主要元素</span></span><br><span class="line">        <span class="keyword">return</span> count * <span class="number">2</span> &gt; nums.length ? candidate : -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 这一条在数组长度为偶数的时候可以生效，但是奇数的时候不行，因为奇数情况下没有可以抵消的</span></span><br><span class="line">        <span class="comment">// return count == 0? -1 : candidate;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>318. 最大单词长度乘积</title>
    <url>/posts/d235/</url>
    <content><![CDATA[<h1 id="318-最大单词长度乘积">318. 最大单词长度乘积</h1>
<p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j])
的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回
0。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths">https://leetcode-cn.com/problems/maximum-product-of-word-lengths</a></p>
</blockquote>
<span id="more"></span>

<h2 id="位运算">位运算</h2>
<p>看到判断两个只包含26个字母的字符串，下意识想到使用位运算存储每一个字符的使用情况，然后使用与运算，就可以在o(1)时间内判断两个单词是否存在公共字母，之后遍历一遍即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="type">int</span>[] bitmaps = <span class="keyword">new</span> <span class="title class_">int</span>[l];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            bitmaps[i] = getBitmap(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;l;++j)&#123;</span><br><span class="line">                <span class="comment">// 无论如何都需要进行两两比较吧</span></span><br><span class="line">                <span class="keyword">if</span>((bitmaps[i] &amp; bitmaps[j]) == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 不是重复单词</span></span><br><span class="line">                    res = Math.max(res,words[i].length()*words[j].length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getBitmap</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:word.toCharArray())&#123;</span><br><span class="line">            res |= (<span class="number">1</span>&lt;&lt;(ch-<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个稍微优化一点的地方在于：对于掩码相同的字符串，我们只需要保存其最大长度即可，这样可以稍微减少一点比较次数，使用Map存储掩码和对应长度即可</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>367. 有效的完全平方数</title>
    <url>/posts/49c1/</url>
    <content><![CDATA[<h1 id="367-有效的完全平方数">367. 有效的完全平方数</h1>
<p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回
true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如 sqrt 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/valid-perfect-square">https://leetcode-cn.com/problems/valid-perfect-square</a></p>
</blockquote>
<span id="more"></span>

<h2 id="二分查找">二分查找</h2>
<p>由于 <span class="math inline">\(y=x^2\)</span>
是在x&gt;0是单调递增，那么对于每一个x1 &gt; x2必有 x1^2 &gt;
x2^2，因此可以使用二分来搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="comment">// 二分查找</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// System.out.println(l+&quot; &quot;+r+&quot; &quot;+mid);</span></span><br><span class="line">            <span class="comment">// 此处mid直接乘上mid会溢出</span></span><br><span class="line">            <span class="comment">// 由于数值范围较大，直接mid相乘可能会溢出</span></span><br><span class="line">            <span class="keyword">if</span>(mid * mid &gt; num)&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l * l == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数学数列求和">数学（数列求和）</h2>
<p>考虑等差数列的求和公式 <span class="math display">\[
S = \frac{(a_1+a_n)\times n}{2} \\
a_n = a_1+(n-1)\times k \\
S = a_1\times n + \frac{k\times n \times (n-1)}{2}
\]</span> 对于首项为1，公差为2的等差数列，带入上述公式可以发现其数列和S
= n^2</p>
<p>因此只需要不断减去奇数，观察最后结果是不是0即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            num -= i;</span><br><span class="line">            i+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>375. 猜数字大小 II</title>
    <url>/posts/7ea4/</url>
    <content><![CDATA[<h1 id="375-猜数字大小-ii">375. 猜数字大小 II</h1>
<p>我们正在玩一个猜数游戏，游戏规则如下：</p>
<ol type="1">
<li>我从 1 到 n 之间选择一个数字。</li>
<li>你来猜我选了哪个数字。</li>
<li>如果你猜到正确的数字，就会 <strong>赢得游戏</strong> 。</li>
<li>如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小
，并且你需要继续猜数。</li>
<li>每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x
的现金。如果你花光了钱，就会 <strong>输掉游戏</strong> 。</li>
</ol>
<p>给你一个特定的数字 n ，返回能够 <strong>确保你获胜</strong>
的最小现金数，不管我选择那个数字 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii">https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划">动态规划</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先演示一遍游戏规则：</span><br><span class="line"></span><br><span class="line">设 n = 20</span><br><span class="line">目标数字为 8</span><br><span class="line"></span><br><span class="line">第一轮猜 4，不对，需要支出4，被告知目标结果比4大</span><br><span class="line">第二轮猜 9，不对，需要支出9，被告知目标结果比9小</span><br><span class="line">第三轮猜 7，不对，需要支出7，被告知目标结果比7大</span><br><span class="line">第四轮猜 8，正确</span><br><span class="line"></span><br><span class="line">总共支出为 4+9+7 = 20</span><br><span class="line"></span><br><span class="line">本题的目标就是找出所有猜测方案中可以确保获胜的最小现金数（也就是无论目标值是多少，我猜对这个结果所需要支出钱的上限）</span><br></pre></td></tr></table></figure>

<p>使用dp[i,j]表示目标数字在[i,j]区间时确保可以获胜的最小现金数，最终目标是求解dp[1,n]</p>
<p>然后考虑状态更新方程，设我们当前猜了[i,j]中的一个值k，考虑最差情况，k值并不是目标值，那么还需要继续猜，由于会告知我们目标值比k大还是比k小，这样可以缩小下一步搜索的范围，最终所需要支出的价格为
<span class="math display">\[
k + max(dp[i,k-1],dp[k+1,j])
\]</span> 最终dp[i,j]则为所有情况中的最小值，那么状态更新公式为 <span
class="math display">\[
dp[i,j] = \min\limits_{i \leq k \leq j}(k+\max(dp[i,k-1],dp[k+1,j]))
\]</span>
然后考虑最终结果，当区间内只包含一个结果时，没有其他可以选，一定猜对，则需要支出价格为0，即dp[i,i]
= 0</p>
<p>接下来我们只需要从最小的区间开始，不断扩大区间搜素的范围即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMoneyAmount</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 最小化最大问题</span></span><br><span class="line">        <span class="comment">// 对于一个给定的n，在1～n中无论选择了哪一个都可以赢</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;++l)&#123;</span><br><span class="line">            <span class="comment">// l代表区间长度，优先遍历长度少的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> n-l+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// System.out.println(end);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=end;++i)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+l-<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// System.out.println(i+&quot; &quot;+j);</span></span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;++k)&#123;</span><br><span class="line">                    <span class="comment">// 这个地方的min max是精髓，需要好好理解一下</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],k+Math.max(dp[i][k-<span class="number">1</span>],dp[k+<span class="number">1</span>][j]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.printf(&quot;dp[%d][%d]=%d\n&quot;,i,j,dp[i][j]);</span></span><br><span class="line">                <span class="comment">// 遍历所有区间</span></span><br><span class="line">                <span class="comment">// 例如长度为2的话</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>384. 打乱数组</title>
    <url>/posts/c006/</url>
    <content><![CDATA[<h1 id="384-打乱数组">384. 打乱数组</h1>
<p>给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。</p>
<p>实现 Solution class:</p>
<ul>
<li>Solution(int[] nums) 使用整数数组 nums 初始化对象</li>
<li>int[] reset() 重设数组到它的初始状态并返回</li>
<li>int[] shuffle() 返回数组随机打乱后的结果</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/shuffle-an-array">https://leetcode-cn.com/problems/shuffle-an-array</a></p>
</blockquote>
<span id="more"></span>

<h2 id="knuth洗牌算法">knuth洗牌算法</h2>
<p>写了一个<code>next_permutation</code>，好像会检查随机性，直接WA了，没办法，看看题解吧</p>
<blockquote>
<p>作者：AC_OIer 链接：<a
href="https://leetcode-cn.com/problems/shuffle-an-array/solution/gong-shui-san-xie-xi-pai-suan-fa-yun-yon-0qmy/">https://leetcode-cn.com/problems/shuffle-an-array/solution/gong-shui-san-xie-xi-pai-suan-fa-yun-yon-0qmy/</a>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<p>共有 n 个不同的数，根据每个位置能够选择什么数，共有 n! 种组合。</p>
<p>题目要求每次调用 shuffle
时等概率返回某个方案，或者说每个元素都够等概率出现在每个位置中。</p>
<p>我们可以使用 Knuth 洗牌算法，在 O(n) 复杂度内等概率返回某个方案。</p>
<p>具体的，我们从前往后尝试填充 [0, n - 1]
该填入什么数时，通过随机当前下标与（剩余的）哪个下标进行值交换来实现。</p>
<p>对于下标 x 而言，我们从 [x, n - 1] 中随机出一个位置与 x
进行值交换，当所有位置都进行这样的处理后，我们便得到了一个公平的洗牌方案。</p>
<p>对于下标为 0 位置，从 [0, n - 1]随机一个位置进行交换，共有 n
种选择；下标为 1 的位置，从 [1, n - 1]随机一个位置进行交换，共有 n - 1
种选择 ... 且每个位置的随机位置交换过程相互独立。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span>[] _nums)</span> &#123;</span><br><span class="line">        nums = _nums;</span><br><span class="line">        n = nums.length;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] shuffle() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            arr[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始shuffle</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">// 将i和[i,n)内的一个数进行交换</span></span><br><span class="line">            swap(i,i+random.nextInt(n-i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int[] param_1 = obj.reset();</span></span><br><span class="line"><span class="comment"> * int[] param_2 = obj.shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>397. 整数替换</title>
    <url>/posts/f3f9/</url>
    <content><![CDATA[<h1 id="397-整数替换">397. 整数替换</h1>
<p>给定一个正整数 n ，你可以做如下操作：</p>
<ol type="1">
<li>如果 n 是偶数，则用 n / 2替换 n 。</li>
<li>如果 n 是奇数，则可以用 n + 1或n - 1替换 n 。</li>
</ol>
<p>n 变为 1 所需的最小替换次数是多少？</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/integer-replacement">https://leetcode-cn.com/problems/integer-replacement</a></p>
</blockquote>
<span id="more"></span>

<h2 id="记忆化搜索">记忆化搜索</h2>
<p>这个题难度不大，状态转移方程都已经给出来了</p>
<p>使用dp[i]表示将数i替换为1所需要的最小替换次数</p>
<p>if i % 1 == 0 dp[i] = 1 + dp[i/1]</p>
<p>if i % 1 == 1 dp[i] = 1 + max(dp[i+1],dp[i-1])</p>
<p>但是我们可以看到这个状态转移方程中奇数情况涉及了dp[i+1]这个值实际上会比当前求解值更大，</p>
<p>但是此时i为奇数，实际上i+1和i-1一定是偶数，因此状态转移方程可以变成</p>
<p>if i % 1 == 1 dp[i] = 2 +
max(dp[(i+1)&gt;&gt;1],dp[(i-1)&gt;&gt;1])</p>
<p>这样遍历的方向就可以确定了，可以开数组进行计算了</p>
<p>但是本题数据范围很大，最大需要求解
2^31-1的变换次数，动态规划无法开出这么大的空间，考虑搜索吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        map.put(<span class="number">1L</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerReplacement</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索</span></span><br><span class="line">    <span class="comment">// dfs返回的结果就是当前值对应的最小操作次数？</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">long</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(v)) <span class="keyword">return</span> map.get(v);</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">if</span>((v &amp; <span class="number">1</span>) == <span class="number">0</span>) res = <span class="number">1</span> + dfs(v&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> res = <span class="number">1</span> + Math.min(dfs(v+<span class="number">1</span>),dfs(v-<span class="number">1</span>));</span><br><span class="line">        map.put(v,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个细节需要注意，当v ==
2^31-1时，计算过程中有可能越界，因此需要使用long进行运算，还有一种方式就是判断取值，然后做特殊处理</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>423. 从英文中重建数字</title>
    <url>/posts/bb5b/</url>
    <content><![CDATA[<h1 id="423-从英文中重建数字">423. 从英文中重建数字</h1>
<p>给你一个字符串 <code>s</code>
，其中包含字母顺序打乱的用英文单词表示的若干数字（<code>0-9</code>）。按
<strong>升序</strong> 返回原始的数字。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/">https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/</a></p>
</blockquote>
<span id="more"></span>

<h2 id="脑筋急转弯">脑筋急转弯</h2>
<p>这个题还挺有意思的，需要从打乱的字符串中还原出英文表示的数字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span>]</span><br><span class="line"><span class="comment">// 有些字母可以唯一确定一个数字的</span></span><br><span class="line"><span class="comment">// z唯一确定zero、w唯一确定two、u唯一确定four，x唯一确定six，g唯一确定eight，先把这些能确定的先减掉</span></span><br><span class="line"><span class="comment">// 剩下 one,three,five,seven,nine无法确认</span></span><br><span class="line"><span class="comment">// 由于包含s的数字只有six和seven，确定完six的个数之后再根据当前s的值可以确定seven的个数（seven）</span></span><br><span class="line"><span class="comment">// 包含t的有two、three、eight，但是two和eight都已经被确定了，那么根据当前剩下的t值可以计算出three的个数，注意此处3中包含了两个e，减去的时候需要减去两个e（three）</span></span><br><span class="line"><span class="comment">// 包含o的有zero、one、two、four，其他的已经在之前的代码中确定了，剩下的就一定是one的个数（one）</span></span><br><span class="line"><span class="comment">// 包含v的有five和seven，seven的个数已经确定，直接减去即可，剩下的是five的个数（five）</span></span><br><span class="line"><span class="comment">// 最终检查nine的个数即可（看哪一个单词都行，剩下的应该只有满足nine的了）</span></span><br><span class="line"><span class="comment">// 最好是看i或者e要不然容易出毛病呢，因为9中n出现了两次</span></span><br></pre></td></tr></table></figure>

<p>从不同数字的英文表示中可以看出来，有些字母仅在一个单词中出现，那么根据这个字母出现的次数可以唯一确定一个数字，再由给定的字符串一定是有效的，那么有些字母可以代表多个单词，将其他的确定之后，剩下的也就可以确定了</p>
<p>可以看到，首先可以确定[0,2,4,6,8]，因为其包含可以唯一标识的字母</p>
<p>之后再按顺序确定[7,3,1,5,9]即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] words;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        words = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">            <span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">originalDigits</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] numberCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 统计每个字母出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:s.toCharArray())&#123;</span><br><span class="line">            ++count[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分别开始计算，这一步实际上可以简化为优先在数组中找出对应数字的出现次数</span></span><br><span class="line">        numberCount[<span class="number">0</span>] = count[<span class="string">&#x27;z&#x27;</span>-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        subtract(count,words[<span class="number">0</span>],numberCount[<span class="number">0</span>]);</span><br><span class="line">        numberCount[<span class="number">2</span>] = count[<span class="string">&#x27;w&#x27;</span>-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        subtract(count,words[<span class="number">2</span>],numberCount[<span class="number">2</span>]);</span><br><span class="line">        numberCount[<span class="number">4</span>] = count[<span class="string">&#x27;u&#x27;</span>-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        subtract(count,words[<span class="number">4</span>],numberCount[<span class="number">4</span>]);</span><br><span class="line">        numberCount[<span class="number">6</span>] = count[<span class="string">&#x27;x&#x27;</span>-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        subtract(count,words[<span class="number">6</span>],numberCount[<span class="number">6</span>]);</span><br><span class="line">        numberCount[<span class="number">8</span>] = count[<span class="string">&#x27;g&#x27;</span>-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        subtract(count,words[<span class="number">8</span>],numberCount[<span class="number">8</span>]);</span><br><span class="line">        <span class="comment">// 之后可以得出其他的</span></span><br><span class="line">        numberCount[<span class="number">7</span>] = count[<span class="string">&#x27;s&#x27;</span>-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        subtract(count,words[<span class="number">7</span>],numberCount[<span class="number">7</span>]);</span><br><span class="line">        numberCount[<span class="number">3</span>] = count[<span class="string">&#x27;t&#x27;</span>-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        subtract(count,words[<span class="number">3</span>],numberCount[<span class="number">3</span>]);</span><br><span class="line">        numberCount[<span class="number">1</span>] = count[<span class="string">&#x27;o&#x27;</span>-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        subtract(count,words[<span class="number">1</span>],numberCount[<span class="number">1</span>]);</span><br><span class="line">        numberCount[<span class="number">5</span>] = count[<span class="string">&#x27;v&#x27;</span>-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        subtract(count,words[<span class="number">5</span>],numberCount[<span class="number">5</span>]);</span><br><span class="line">        numberCount[<span class="number">9</span>] = count[<span class="string">&#x27;i&#x27;</span>-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        subtract(count,words[<span class="number">9</span>],numberCount[<span class="number">9</span>]);</span><br><span class="line">        <span class="comment">// 最后根据计数结果生成升序字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;numberCount[i];++j)&#123;</span><br><span class="line">                sb.append(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span>[] count,String word,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:word.toCharArray())&#123;</span><br><span class="line">            count[ch-<span class="string">&#x27;a&#x27;</span>] -= c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>519. 随机翻转矩阵</title>
    <url>/posts/3ce2/</url>
    <content><![CDATA[<h1 id="519-随机翻转矩阵">519. 随机翻转矩阵</h1>
<p>给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0
。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j)
，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j)
被选取的概率应当均等。</p>
<p>尽量最少调用内置的随机函数，并且优化时间和空间复杂度。</p>
<p>实现 Solution 类：</p>
<ul>
<li>Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象</li>
<li>int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j]
，并将其对应格子中的值变为 1</li>
<li>void reset() 将矩阵中所有的值重置为 0</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/random-flip-matrix">https://leetcode-cn.com/problems/random-flip-matrix</a></p>
</blockquote>
<span id="more"></span>

<h2 id="哈希表shuffle">哈希表+shuffle</h2>
<p>这一题需要实现随机翻转矩阵，实际上如果将矩阵使用以为数组实现的话，其实现思路和
<code>384. 打乱数组是一样的了</code>，首先创建一个大小为m*n的一维数组，数组上每位初始化为对应的索引，表示正常顺序。</p>
<p>生成一维数组之后，由于需要确保所有满足 matrix[i,j] ==
0的下标(i,j)被选取的概率均等，最初矩阵全部为0，实际上就需要确定每一对(i,j)出现的概率都是
1/(m*n)，我们只需要生成一维数组对应的排列，再通过公式 (i,j) = (index / n
, index % n)得出二维的下标</p>
<p>然后开始flip，具体流程是：</p>
<p>使用curr表示随机排列中的第curr位，由于前面的已经是打乱过的，不需要纳入考虑，第curr位只需要考虑[curr,l-curr)中任意一个即可，使用random生成对应的随机数即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] matrix;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> l;</span><br><span class="line">    <span class="keyword">private</span> Random random; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> curr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span> _m, <span class="type">int</span> _n)</span> &#123;</span><br><span class="line">        m = _m;</span><br><span class="line">        n = _n;</span><br><span class="line">        l = m * n;</span><br><span class="line">        <span class="comment">// 使用一维数组模拟二维即可</span></span><br><span class="line">        matrix = <span class="keyword">new</span> <span class="title class_">int</span>[l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            matrix[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] flip() &#123;</span><br><span class="line">        <span class="comment">// 返回修改的下标，并使其对应的值变为1</span></span><br><span class="line">        <span class="comment">// 需要确保所有满足matrix[i][j]==0的(i,j)满足的概率均等</span></span><br><span class="line">        <span class="comment">// 之前的一个也是这样，确保概率为1/m*n</span></span><br><span class="line">        <span class="comment">// 如何实现呢？</span></span><br><span class="line">        <span class="comment">// 这个感觉和shuffle有点像，实际上也可以理解为将所有的下标进行一个shuffle</span></span><br><span class="line">        <span class="comment">// 第i次调用flip时记录当前待生成的值的位置，然后在(i,j)的区间内随机生成一个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> curr + random.nextInt(l-curr);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> matrix[x];</span><br><span class="line">        matrix[x] = matrix[curr];</span><br><span class="line">        ++curr;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;index / n, index % n&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 将矩阵重新变为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            matrix[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(m, n);</span></span><br><span class="line"><span class="comment"> * int[] param_1 = obj.flip();</span></span><br><span class="line"><span class="comment"> * obj.reset();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>由于本题数据量1 &lt;= m,n &lt;= 10000，考虑边界情况 m = n =
10000时无法生成这么大的数组，需要优化</p>
<p>我们使用一维数组的目的是生成随机排列，对于每一次的flip，我们用到的数据是
matrix[x]，实际上可以使用哈希表进行存储，减少空间占用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> l;</span><br><span class="line">    <span class="keyword">private</span> Random random; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> curr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span> _m, <span class="type">int</span> _n)</span> &#123;</span><br><span class="line">        m = _m;</span><br><span class="line">        n = _n;</span><br><span class="line">        l = m * n;</span><br><span class="line">        <span class="comment">// 使用一维数组模拟二维即可</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] flip() &#123;</span><br><span class="line">        <span class="comment">// 返回修改的下标，并使其对应的值变为1</span></span><br><span class="line">        <span class="comment">// 需要确保所有满足matrix[i][j]==0的(i,j)满足的概率均等</span></span><br><span class="line">        <span class="comment">// 之前的一个也是这样，确保概率为1/m*n</span></span><br><span class="line">        <span class="comment">// 如何实现呢？</span></span><br><span class="line">        <span class="comment">// 这个感觉和shuffle有点像，实际上也可以理解为将所有的下标进行一个shuffle</span></span><br><span class="line">        <span class="comment">// 第i次调用flip时记录当前待生成的值的位置，然后在(i,j)的区间内随机生成一个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> curr + random.nextInt(l-curr);</span><br><span class="line">        <span class="comment">// index = matrix[x]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.getOrDefault(x,x);</span><br><span class="line">        <span class="comment">// swap</span></span><br><span class="line">        <span class="comment">// matrix[x] = matrix[curr];</span></span><br><span class="line">        map.put(x,map.getOrDefault(curr,curr));</span><br><span class="line">        ++curr;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;index / n, index % n&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 将矩阵重新变为0</span></span><br><span class="line">        map.clear();</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>594. 最长和谐子序列</title>
    <url>/posts/5f3b/</url>
    <content><![CDATA[<h1 id="594-最长和谐子序列">594. 最长和谐子序列</h1>
<p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。</p>
<p>现在，给你一个整数数组 nums
，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/longest-harmonious-subsequence">https://leetcode-cn.com/problems/longest-harmonious-subsequence</a></p>
</blockquote>
<span id="more"></span>

<h2 id="思路">思路</h2>
<p>子序列是由数组中任意一些数构成的，其不考虑连续信息。且对于和谐数组，其最大值和最小值之差为1，因此实际上和谐数组中仅包含两个数，最大值和最小值</p>
<h2 id="排序双指针">排序+双指针</h2>
<p>首先对数组进行排序，然后我们的序列就一定是
[a,a,a,a,a,...,a+1,a+1,...,a+1]这种形式</p>
<p>可以使用双指针进行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLHS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] - nums[i] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(i+<span class="string">&quot; &quot;</span>+j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] - nums[i] == <span class="number">1</span>) ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            System.out.println(i+<span class="string">&quot; &quot;</span>+j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表">哈希表</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLHS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历所有的最大值、最小值数对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                ans = Math.max(ans, map.get(i) + map.get(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>598. 范围求和 II</title>
    <url>/posts/3287/</url>
    <content><![CDATA[<h1 id="598-范围求和-ii">598. 范围求和 II</h1>
<p>给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M
上的一系列更新操作。</p>
<p>操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b
的数组表示，含义是将所有符合 0 &lt;= i &lt; a 以及 0 &lt;= j &lt; b
的元素 M[i][j] 的值都增加 1。</p>
<p>在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/range-addition-ii">https://leetcode-cn.com/problems/range-addition-ii</a></p>
</blockquote>
<span id="more"></span>

<h2 id="脑筋急转弯">脑筋急转弯</h2>
<p>这个题如果直接模拟，时间复杂度太高，没有必要，我们需要找到其中的规律。</p>
<p>由于每一个操作都会将矩阵左上角小于
(a,b)那一块增加，因此实际上所有操作都是包含重叠部分的，我们只需要遍历一遍增加的范围，求出范围的交集就可以得出最终最大的结果，因为范围交集是一直在增加的，最终的结果一定是最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span>[][] ops)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟的话必超时啊</span></span><br><span class="line">        <span class="comment">// 有没有其他办法？ </span></span><br><span class="line">        <span class="comment">// 只要求出所有ops中相交的部分即可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">resR</span> <span class="operator">=</span> m,resC = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] op:ops)&#123;</span><br><span class="line">            resR = Math.min(op[<span class="number">0</span>],resR);</span><br><span class="line">            resC = Math.min(op[<span class="number">1</span>],resC);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resR * resC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>629. K个逆序对数组</title>
    <url>/posts/8d47/</url>
    <content><![CDATA[<h1 id="629-k个逆序对数组">629. K个逆序对数组</h1>
<p>给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k
个逆序对的不同的数组的个数。</p>
<p>逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i &lt; j且 a[i]
&gt; a[j]，则其为一个逆序对；否则不是。</p>
<p>由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/k-inverse-pairs-array">https://leetcode-cn.com/problems/k-inverse-pairs-array</a></p>
</blockquote>
<span id="more"></span>

<h1 id="动态规划">动态规划</h1>
<p>首先找一个样例来作为测试</p>
<p>当 n = 4时，计算k=4的逆序对数</p>
<p>首先已知 n = 3时，各逆序数情况</p>
<p>dp = [1,2,2,1]</p>
<p>对应的前缀和</p>
<p>sum = [1,3,5,6]</p>
<p>分别对应</p>
<p>0：1 2 3</p>
<p>1：1 3 2 2 1 3</p>
<p>2：2 3 1 3 1 2</p>
<p>3：3 2 1</p>
<p>对于 n = 5的情况，此时计算结果应该是</p>
<p>前一个的逆序对数取值范围为 3*2 / 1 -&gt;
[0,3]，取值范围为0，1，2，3</p>
<p>那么至少是3和2才行，也就是res = dp[2] + dp[1]</p>
<p>接下来计算n = 4的情况</p>
<p>target &gt;= length的情况，此时少计算了什么？</p>
<p>假设第一个位置的值为1，那么只需要考虑剩下三个的计算结果，即 2 3
4中逆序数为4的情况</p>
<p>而2 3 4不可能得出逆序数为4的情况，res = 0</p>
<p>假设第一个位置的值为2，那么首先无论后面三个如何排列，一定包含一个逆序对
(2,1)，因此只需要找到逆序对数为3的情况即可</p>
<p>dp[3] = 1，res = 1 ，对应的情况为 (2,4,3,1)</p>
<p>以此类推，当第一个位置的值为3时，无论如何排列都一定包含逆序对
(3,1)和(3,2)，只需要找到逆序对为2的即可</p>
<p>res = res + dp[2] = 3，对应的情况为 (3,2,4,1)
、(3,4,2,1)、(2,4,3,1)</p>
<p>最后，当第一个位置的值为4时，一定包含逆序对(4,1)，(4,2)和(4,3)，找出逆序对为1的情况</p>
<p>res = res + dp[1] = 5，对应的情况为 (4,1,3,2)、(4,2,1,3)、(3,2,4,1)
、(3,4,2,1)、(2,4,3,1)</p>
<p>实际上可以使用前缀和进行优化</p>
<p>res = dp[3] + dp[2] + dp[1]</p>
<p>可以使用前缀和优化</p>
<p>对应n = 3的情况，则是 dp[3] + dp[2] + dp[1] + dp[0] = 6</p>
<p>未使用前缀和优化前的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kInversePairs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 找出包含从1到n的数字，恰好包含k个逆序对的不同的数组的个数？</span></span><br><span class="line">        <span class="type">int</span>[] dp = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] sum = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">// 从数组长度为i开始计算</span></span><br><span class="line">            <span class="comment">// res[i]代表当前长度数组中逆序对恰好为i的数组个数</span></span><br><span class="line">            <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;++j)&#123;</span><br><span class="line">                res[j] = getTargetInversePairs(dp,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printArr(res);</span></span><br><span class="line">            dp = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getTargetInversePairs(dp,n,k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printArr</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:arr)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getTargetInversePairs</span><span class="params">(<span class="type">int</span>[] dp,<span class="type">int</span> length,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="comment">// 已知长度为length-1的数字中逆序对情况，dp[i]表示逆序对为i对应的种类数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 这里需要使用前缀和数组进行优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;++i)&#123;</span><br><span class="line">            <span class="comment">// System.out.println(target+&quot; &quot;+i);</span></span><br><span class="line">            <span class="keyword">if</span>(target - i &gt;= dp.length) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target -i &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            res = (res+dp[target-i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(length+&quot; &quot;+target+&quot; &quot;+res);</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在计算的时候需要累加，这个是一个o(n)的时间复杂度，实际上还可以优化</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>677. 键值映射</title>
    <url>/posts/c664/</url>
    <content><![CDATA[<h1 id="677-键值映射">677. 键值映射</h1>
<p>实现一个 MapSum 类，支持两个方法，insert 和 sum：</p>
<ul>
<li>MapSum() 初始化 MapSum 对象</li>
<li>void insert(String key, int val) 插入 key-val 键值对，字符串表示键
key ，整数表示值 val 。如果键 key
已经存在，那么原来的键值对将被替代成新的键值对。</li>
<li>int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key
的值的总和。</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/map-sum-pairs">https://leetcode-cn.com/problems/map-sum-pairs</a></p>
</blockquote>
<span id="more"></span>

<h2 id="前缀树">前缀树</h2>
<p>看到题目中提到返回所有以前缀prefix开头的键key的值的总和，很容易想到本题需要实现前缀树</p>
<p>但与一般的前缀树不同，本题需要计算以前缀开头的键key的值的总和，可以添加一项sum，在插入过程中直接更新每个节点对应的preifxsum，如果已经存在则需要提前减掉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapSum</span> &#123;</span><br><span class="line">    <span class="comment">// 实现前缀树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">        <span class="comment">// sum存储当前节点对应的前缀和</span></span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        TrieNode[] next;</span><br><span class="line">        <span class="type">boolean</span> end;</span><br><span class="line">        <span class="comment">// val存储对应的值</span></span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TrieNode()&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            end = <span class="literal">false</span>;</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MapSum</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(String key)</span>&#123;</span><br><span class="line">        <span class="comment">// 从Map中检索对应的值是否出现过</span></span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:key.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">// 如果当前值没有出现过，直接返回0</span></span><br><span class="line">            <span class="keyword">if</span>(curr.next[index] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            curr = curr.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 必须是结尾才行</span></span><br><span class="line">        <span class="keyword">return</span> curr.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 还需要判断是否已经存在了，已经存在了需要更新sum的值</span></span><br><span class="line">        <span class="comment">// 插入的时候将结果不断累加上去即可</span></span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> get(key);</span><br><span class="line">        val -= prev;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:key.toCharArray())&#123;</span><br><span class="line">            <span class="comment">// 逐个插入</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr.next[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                curr.next[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            curr.sum += val;</span><br><span class="line">            curr = curr.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        curr.sum += val;</span><br><span class="line">        curr.end = <span class="literal">true</span>;</span><br><span class="line">        curr.val = val + prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">curr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:prefix.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> index= ch -<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr.next[index] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            curr = curr.next[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr.sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MapSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MapSum obj = new MapSum();</span></span><br><span class="line"><span class="comment"> * obj.insert(key,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.sum(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>859. 亲密字符串</title>
    <url>/posts/7dee/</url>
    <content><![CDATA[<h1 id="859-亲密字符串">859. 亲密字符串</h1>
<p>给你两个字符串 s 和 goal ，只要我们可以通过交换 s 中的两个字母得到与
goal 相等的结果，就返回 true ；否则返回 false 。</p>
<p>交换字母的定义是：取两个下标 i 和 j （下标从 0 开始）且满足 i != j
，接着交换 s[i] 和 s[j] 处的字符。</p>
<p>例如，在 "abcd" 中交换下标 0 和下标 2 的元素可以生成 "cbad" 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/buddy-strings">https://leetcode-cn.com/problems/buddy-strings</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力超时">暴力（超时）</h2>
<p>这个思路很简单，直接遍历所有可行的交换方案，检查是否相等即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">buddyStrings</span><span class="params">(String s, String goal)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接暴力的话，考虑将(i,j)进行交换，然后判断s和goal是否相同？</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() != goal.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">char</span>[] a = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] b = goal.toCharArray();</span><br><span class="line">        <span class="comment">// 尝试交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;l;++j)&#123;</span><br><span class="line">                swap(a,i,j);</span><br><span class="line">                <span class="keyword">if</span>(check(a,b)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                swap(a,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span>[] a,<span class="type">char</span>[] b)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] arr,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> arr[a];</span><br><span class="line">        arr[a] = arr[b];</span><br><span class="line">        arr[b] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于测试用例</p>
<p>s = "baaaaaaaaaaaaaaaaaaaaaac"</p>
<p>g = "caaaaaaaaaaaaaaaaaaaaaab"</p>
<p>中间部分存在很多不必要的判断，实际上没必要进行检查的</p>
<h2 id="暴力优化">暴力（优化）</h2>
<p>由于s和g字符串之间存在很多的相同部分，因此我们实际上只需要保存不同的地方即可</p>
<p>使用两个List来保存s[i] != g[i]的部分，然后判断即可</p>
<p>但是题目要求的是字符串s必须经过一次交换操作之后和g相同，那么如果s和g已经相同，且s中不包含重复字符，那么交换之后一定是不同的，也就是说还需要判断是否存在相同字符串</p>
<p>里面存在很多细节，需要多加注意</p>
<p>相同只有两种情况</p>
<ol type="1">
<li>s和g之间包含的字符是相同的，且只有两个位置上的值不一样</li>
<li>s和g相同且s存在重复字符（这样可以通过交换重复字符使得s和g一样）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">buddyStrings</span><span class="params">(String s, String goal)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接暴力的话，考虑将(i,j)进行交换，然后判断s和goal是否相同？</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() != goal.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">char</span>[] a = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] b = goal.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] c1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] c2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">diffCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 尝试交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i])&#123;</span><br><span class="line">                ++diffCount;</span><br><span class="line">                <span class="keyword">if</span>(diffCount &gt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++c1[a[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            ++c2[b[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查两个字符串是否是一样的</span></span><br><span class="line">        <span class="comment">// 当两个字符串本身就是相同的时候，需要判断s是否包含相同字符</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasSame</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c1[i] != c2[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(c1[i] &gt; <span class="number">1</span>) hasSame = <span class="literal">true</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="comment">// 判断字符串不同位数是不是1</span></span><br><span class="line">        <span class="keyword">return</span> (diffCount == <span class="number">2</span>) || (diffCount == <span class="number">0</span> &amp;&amp; hasSame);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 039. 直方图最大矩形面积</title>
    <url>/posts/5eb0/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-039-直方图最大矩形面积">剑指 Offer II 039.
直方图最大矩形面积</h1>
<p>给定非负整数数组 heights
，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为
1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= heights.length &lt;=10<sup>5</sup></li>
<li>0 &lt;= heights[i] &lt;= 10<sup>4</sup></li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/0ynMMM">https://leetcode-cn.com/problems/0ynMMM</a></p>
</blockquote>
<span id="more"></span>

<h2 id="单调栈">单调栈</h2>
<p>如果采用暴力的话，我们需要以所有高度为高，计算矩形以这个高度可以达到的最大面积，然后求出最大面积，这种算法的时间复杂度为o(n^2)，需要确认有多少连续的满足当前高度</p>
<p>这个题实际上和前两题思路类似，都是使用栈维护一个单调数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="comment">// 单调栈？如何进行维护，如何计算最大值？</span></span><br><span class="line">        <span class="comment">// 需要维护一个单调递增的栈，内部存储的是高度对应的索引</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;heights.length;++i)&#123;</span><br><span class="line">            <span class="comment">// 以栈顶元素对应的高度作为矩形的计算高度，</span></span><br><span class="line">            <span class="comment">// 那么其对应的矩形的宽度就是左边第一个小于该高度的索引到右边第一个大于该高度的索引</span></span><br><span class="line">            <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span> &amp;&amp; heights[i] &lt;= heights[stack.peek()] )&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> heights[stack.pop()];</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                res = Math.max(res,height*width);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组遍历完成，此时栈有可能不为空，那么此时右边界就变成了heights.length</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> heights[stack.pop()];</span><br><span class="line">            <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> heights.length - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            res = Math.max(res,height*width);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过了几个月再来看又有点没办法理解了，还是写一个例子帮助理解</p>
<p>初始化:</p>
<p>heights = [2,1,5,6,2,3]</p>
<p>stack = [-1]</p>
<p>res = 0</p>
<p>step1:</p>
<p>索引为0，当前高度为2，栈顶元素为-1，直接进栈</p>
<p>stack = [-1,0]</p>
<p>step2:</p>
<p>索引为1，当前高度为1，栈顶元素为0，对应高度为1，此时高度小于栈顶对应高度，</p>
<p>出栈，计算面积，高度为栈顶元素高度2，宽度为1，更新res = 1</p>
<p>然后再进栈</p>
<p>stack = [-1,1]</p>
<p>step3:</p>
<p>索引为2，当前高度为5，栈顶元素为1，对应高度为1，此时高度大于栈顶对应高度，直接进栈</p>
<p>stack = [-1,1,2]</p>
<p>step4:</p>
<p>索引为3，当前高度为6，栈顶元素为2，对应高度为5，此时高度大于栈顶对应高度，直接进栈</p>
<p>stack = [-1,1,2,3]</p>
<p>step5:</p>
<p>索引为4，当前高度为2，栈顶元素为3，对应高度为6，此时高度小于栈顶对应高度，</p>
<p>出栈，计算面积，高度为栈顶元素高度6，宽度1，更新res = 6</p>
<p>stack = [-1,1,2]</p>
<p>出栈，计算面积，高度为栈顶元素高度5，宽度2，更新res = 10</p>
<p>stack = [-1,1]</p>
<p>此时高度大于栈顶对应高度，直接进栈</p>
<p>stack = [-1,1,4]</p>
<p>step6:</p>
<p>索引为5，当前高度为3，栈顶元素为4，对应高度为2，此时高度大于栈顶对应高度，直接进栈</p>
<p>stack = [-1,1,4,5]</p>
<p>此时遍历结束，但是栈不为空，此时右边界为height.length</p>
<p>出栈，计算面积，高度为栈顶元素高度3，宽度1，res = 10</p>
<p>出栈，计算面积，高度为栈顶元素高度2，宽度2，res = 10</p>
<p>出栈，计算面积，高度为栈顶元素高度1，宽度5，res = 10</p>
<p>此时栈顶为-1，结束</p>
<p>最终直方图中最大面积为10</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer II 040. 矩阵中最大的矩形</title>
    <url>/posts/1019/</url>
    <content><![CDATA[<h1 id="剑指-offer-ii-040-矩阵中最大的矩形">剑指 Offer II 040.
矩阵中最大的矩形</h1>
<p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵
<code>matrix</code> ，找出只包含 <code>1</code>
的最大矩形，并返回其面积。</p>
<p>**注意：**此题 <code>matrix</code> 输入格式为一维 <code>01</code>
字符串数组。</p>
<span id="more"></span>

<h2 id="脑筋急转弯单调栈">脑筋急转弯+单调栈</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">从上至下逐层遍历，可以看成一个直方图</span><br><span class="line">step1 </span><br><span class="line">height = [1,0,1,0,0]</span><br><span class="line"></span><br><span class="line">step2</span><br><span class="line">height = [2,0,2,1,1]</span><br><span class="line"></span><br><span class="line">step3</span><br><span class="line">height = [3,1,3,2,2]</span><br><span class="line"></span><br><span class="line">step4</span><br><span class="line">height = [4,0,0,3,0]</span><br></pre></td></tr></table></figure>

<p>然后使用 <code>剑指 Offer II 039. 直方图最大矩形面积</code>
进行计算即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(String[] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length();</span><br><span class="line">        <span class="type">int</span>[] height = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String row:matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> row.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">                    height[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ++height[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,largestRectangleArea(height));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换成直方图求最大面积</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="comment">// 单调栈？如何进行维护，如何计算最大值？</span></span><br><span class="line">        <span class="comment">// 需要维护一个单调递增的栈，内部存储的是高度对应的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;heights.length;++i)&#123;</span><br><span class="line">            <span class="comment">// 以栈顶元素对应的高度作为矩形的计算高度，</span></span><br><span class="line">            <span class="comment">// 那么其对应的矩形的宽度就是左边第一个小于该高度的索引到右边第一个大于该高度的索引</span></span><br><span class="line">            <span class="keyword">while</span>(stack.peek() != -<span class="number">1</span> &amp;&amp; heights[i] &lt;= heights[stack.peek()] )&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> heights[stack.pop()];</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> i - stack.peek() - <span class="number">1</span>;</span><br><span class="line">                res = Math.max(res,height*width);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组遍历完成，此时栈有可能不为空，那么此时右边界就变成了heights.length</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek() != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> heights[stack.pop()];</span><br><span class="line">            <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> heights.length - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            res = Math.max(res,height*width);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1044. 最长重复子串</title>
    <url>/posts/880b/</url>
    <content><![CDATA[<h1 id="1044-最长重复子串">1044. 最长重复子串</h1>
<p>给你一个字符串 s ，考虑其所有 重复子串 ：即，s 的连续子串，在 s
中出现 2 次或更多次。这些出现之间可能存在重叠。</p>
<p>返回 任意一个 可能具有最长长度的重复子串。如果 s
不含重复子串，那么答案为 "" 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/longest-duplicate-substring">https://leetcode-cn.com/problems/longest-duplicate-substring</a></p>
</blockquote>
<span id="more"></span>

<h2 id="题意">题意</h2>
<p>本题又是一个字符串匹配题，两个难点：</p>
<ol type="1">
<li>如何找到具有最长长度的重复子串</li>
<li>如果快速判断一个子串是否在字符串中出现多次（两次以上）</li>
</ol>
<h2
id="字符串哈希rabin-karp字符串编码">字符串哈希（Rabin-Karp字符串编码）</h2>
<p>将所有字母编码成0-25之间的数字（实际上使用ASCII码也是一样的效果），对于
"abcde" 则可以编码成 "01234"</p>
<p>如果将字符串看成一个26进制数，他对应的编码的十进制表示就是字符串的哈希值</p>
<p>下面求解一下 abcde 的字符串哈希值 <span class="math display">\[
abcde = 0\times26^4 + 1\times26^3 + 2\times26^2 + 3\times26^1 +
4\times26^0 = 19010
\]</span> 如果在计算过程中顺便存储了前缀和sum <span
class="math display">\[
\begin{align*}
a &amp; = 0 \times 26 ^ 0 = 0  \\
ab &amp; = 0 \times 26 ^ 1 + 1 \times 26 ^ 0 = 1 \\
abc &amp; = 0 \times 26 ^ 2 + 1 \times 26 ^ 1 + 2 \times 26 ^ 2 = 28 \\
abcd &amp; = 0 \times 26 ^ 3 + 1 \times 26 ^ 2 + 2 \times 26 ^ 1 + 3
\times 26 ^ 0 = 731 \\
abcde &amp; = 0 \times 26 ^ 4 + 1 \times 26 ^ 3 + 2 \times 26 ^ 2 + 3
\times 26 ^ 1 + 4 \times 26 ^ 0 = 19010 \\
\end{align*}
\]</span> 那么要计算bcd的字符串哈希，只需要使用 abcd 的哈希值减去 a * 26
^ 3 即可，bcd的字符串哈希就是731</p>
<p>对于其任意一个子串的字符串哈希都可以这样计算</p>
<h2 id="暴力超时">暴力（超时）</h2>
<p>需要找到任意一个最长长度的重复子串，首先想到的就是遍历，从长度最长的向下遍历，当第一个满足的时候返回</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span>[] h, p;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestDupSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> P = <span class="number">1000002</span>, n = s.<span class="built_in">length</span>();</span><br><span class="line">        h = <span class="keyword">new</span> <span class="type">long</span>[n + <span class="number">10</span>]; p = <span class="keyword">new</span> <span class="type">long</span>[n + <span class="number">10</span>];</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            p[i + <span class="number">1</span>] = p[i] * P;</span><br><span class="line">            h[i + <span class="number">1</span>] = h[i] * P + s.<span class="built_in">charAt</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;<span class="number">-1</span>;--i)&#123;</span><br><span class="line">            String t = <span class="built_in">check</span>(s,i);</span><br><span class="line">            <span class="keyword">if</span>(t.<span class="built_in">length</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans = t;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">check</span><span class="params">(String s, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        Set&lt;Long&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> cur = h[j] - h[i - <span class="number">1</span>] * p[j - i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (set.<span class="built_in">contains</span>(cur)) <span class="keyword">return</span> s.<span class="built_in">substring</span>(i - <span class="number">1</span>, j);</span><br><span class="line">            set.<span class="built_in">add</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找字符串哈希">二分查找+字符串哈希</h2>
<p>为什么可以使用二分查找算法？</p>
<p>由于子串的长度是单调不减的，且假如s中长度为m的子串s1在s中出现了多次，那么对于s1的任意一个子串在s中出现了多次，而对于一个长度比m更大的子串则需要进一步判断，这符合二分查找的二段性，因此可以使用二分查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span>[] h, p;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestDupSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">P</span> <span class="operator">=</span> <span class="number">1313131</span>, n = s.length();</span><br><span class="line">        h = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">10</span>]; p = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">10</span>];</span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            p[i + <span class="number">1</span>] = p[i] * P;</span><br><span class="line">            h[i + <span class="number">1</span>] = h[i] * P + s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> check(s, mid);</span><br><span class="line">            <span class="keyword">if</span> (t.length() != <span class="number">0</span>) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            ans = t.length() &gt; ans.length() ? t : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">check</span><span class="params">(String s, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Set&lt;Long&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + len - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算当前子串的字符串哈希值</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> h[j] - h[i - <span class="number">1</span>] * p[j - i + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 如果当前子串在set中已经出现过了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(cur)) <span class="keyword">return</span> s.substring(i - <span class="number">1</span>, j);</span><br><span class="line">            set.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1995. 统计特殊四元组</title>
    <url>/posts/f51a/</url>
    <content><![CDATA[<h1 id="1995-统计特殊四元组">1995. 统计特殊四元组</h1>
<p>给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同
四元组 (a, b, c, d) 的 数目 ：</p>
<p>nums[a] + nums[b] + nums[c] == nums[d] ，且 a &lt; b &lt; c &lt;
d</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/count-special-quadruplets">https://leetcode-cn.com/problems/count-special-quadruplets</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>题目数据量不大，暴力枚举也还行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countQuadruplets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果暴力的话，就是四重循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">0</span>;a&lt;l;++a)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b=a+<span class="number">1</span>;b&lt;l;++b)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> c=b+<span class="number">1</span>;c&lt;l;++c)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> d=c+<span class="number">1</span>;d&lt;l;++d)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(nums[a] + nums[b] + nums[c] == nums[d]) ++res;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表-on3">哈希表-o(n^3)</h2>
<p>枚举的时间复杂度为o(n^4)，实在是太高了，是否存在简单一点的办法呢？</p>
<p>注意到等式</p>
<p><code>nums[a] + nums[b] + nums[c] == nums[d]</code></p>
<p>如果我们倒着枚举nums[c]，由于d的位置一定大于c，那么实际上我们可以使用哈希表存储d对应值出现的次数，这样可以减少一个维度的判断，将时间复杂度度降低到o(n^3)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countQuadruplets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果暴力的话，就是四重循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 由于nums[a] + nums[b] + nums[c] 的值最大可以到300</span></span><br><span class="line">        <span class="comment">// 未避免溢出，这里取到301</span></span><br><span class="line">        <span class="type">int</span>[] countD = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">301</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> l-<span class="number">2</span>;c &gt; <span class="number">0</span>;--c)&#123;</span><br><span class="line">            ++countD[nums[c+<span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;b&lt;c;++b)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;a&lt;b;++a)&#123;</span><br><span class="line">                    <span class="comment">// 由于nums[d]的值一直存储着的，直接读取即可</span></span><br><span class="line">                    res += countD[nums[a] + nums[b] + nums[c]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希表-on2">哈希表-o(n^2)</h2>
<p>实际上我们还可以降低一个时间复杂度，将等式进行变换</p>
<p><code>nums[a] + nums[b] == nums[d] - nums[c]</code></p>
<p>只需要我们使用哈希表存储 <code>nums[d]-nums[c]</code>的值就可以</p>
<p>在遍历a之前首先根据b的索引遍历所有nums[d]-nums[c]的情况，然后累加即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countQuadruplets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果暴力的话，就是四重循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 由于nums[a] + nums[b] + nums[c] 的值最大可以到300</span></span><br><span class="line">        <span class="comment">// 未避免溢出，这里取到301</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">401</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> l-<span class="number">3</span>;b&gt;<span class="number">0</span>;--b)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> b + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 在枚举a之前先将当前b的位置枚举出所有d-c的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> l-<span class="number">1</span>;d&gt;c;--d)&#123;</span><br><span class="line">                <span class="comment">// 只需要遍历到所有的nums[d]-nums[c]对即可，这个实际上只和b有关了，就可以进行降维</span></span><br><span class="line">                <span class="comment">// nums[d] - nums[c] 可能是一个负值，进行偏移，</span></span><br><span class="line">                ++count[nums[d]-nums[c] + <span class="number">200</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;a &lt; b;++a)&#123;</span><br><span class="line">                res += count[nums[a] + nums[b] + <span class="number">200</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>372. 超级次方</title>
    <url>/posts/2335/</url>
    <content><![CDATA[<h1 id="372-超级次方">372. 超级次方</h1>
<p>你的任务是计算 <code>ab</code> 对 <code>1337</code>
取模，<code>a</code> 是一个正整数，<code>b</code>
是一个非常大的正整数且会以数组形式给出。</p>
<span id="more"></span>

<h2 id="数学">数学</h2>
<p>对于取模运算，其满足以下两个性质 <span class="math display">\[
(a+b)\%c = (a\%c+b\%c)\%c \\
(a*b)\%c = (a\%c*b\%c)\%c
\]</span>
那么对于幂运算，其实际上就是多次乘法运算，那么我们可以进行叠加，使用以下公式
<span class="math display">\[
\begin{align*}
a^b \bmod c &amp;= a^{ ({\left \lfloor \frac{b}{10} \right \rfloor} * 10
+ b \bmod 10) } \bmod c \\
&amp;=  (a^{\left \lfloor \frac{b}{10} \right \rfloor * 10} * a^{b \bmod
10)}) \bmod c \\
&amp;= ((a^{\left \lfloor \frac{b}{10} \right \rfloor})^{10} \bmod c *
a^{b\bmod10} \bmod c )\bmod c
\end{align*}
\]</span> 由于b实际上是一个数组，那么b mod 10就可以很简单的获得，即
b[b.length-1]，而对于 <span class="math inline">\((a^{\left \lfloor
\frac{b}{10} \right \rfloor})^{10} \bmod c\)</span>
实际上就只需要b最后一位前移，这就实现一个递归，终止条件就是当读取到最后一位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1337</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superPow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(a,b,b.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次计算第pos对应的mod值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>[] b,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (qpow(dfs(a,b,pos-<span class="number">1</span>),<span class="number">10</span>) * qpow(a,b[pos])) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        a %= MOD;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>) res = res * a % MOD;</span><br><span class="line">            a = a * a % MOD;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>419. 甲板上的战舰</title>
    <url>/posts/6f7/</url>
    <content><![CDATA[<h1 id="419-甲板上的战舰">419. 甲板上的战舰</h1>
<p>给你一个大小为 m x n 的矩阵 board
表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.'
，返回在甲板 board 上放置的 战舰 的数量。</p>
<p>战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1
行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k
可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔
（即没有相邻的战舰）。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/battleships-in-a-board">https://leetcode-cn.com/problems/battleships-in-a-board</a></p>
</blockquote>
<span id="more"></span>

<h2 id="题意">题意</h2>
<p>这个题看了半天，才搞明白意思，一艘战舰是直的，它的长度为k，它既可以水平摆也可以竖直摆，现在给你一个甲板，要你统计出甲板上的战舰数目。</p>
<p>这个题关键在于战舰与战舰之间一定是不相连的，而战舰之间一定是水平或竖直的（也就是战舰的部分与部分之间一定是相连的）</p>
<p>对于一个给定的部分，我们可以搜索出其相连的部分，并将其标记一下即可</p>
<h2 id="搜索dfs-or-bfs">搜索（DFS or BFS）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[][] board;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countBattleships</span><span class="params">(<span class="type">char</span>[][] _board)</span> &#123;</span><br><span class="line">        <span class="comment">// 看了半天题意都没看懂</span></span><br><span class="line">        <span class="comment">// &#x27;x&#x27;代表战舰，&#x27;.&#x27;代表空位</span></span><br><span class="line">        <span class="comment">// 战舰的形状是 (1,k) 或 (k,1)，其中k为任意大小</span></span><br><span class="line">        <span class="comment">// 需要统计战舰的个数</span></span><br><span class="line">        <span class="comment">// 第一种办法，直接dfs找连通分量</span></span><br><span class="line">        m = _board.length;</span><br><span class="line">        n = _board[<span class="number">0</span>].length;</span><br><span class="line">        board = _board;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="comment">// 直接修改board，将遍历过的节点转换成&#x27;.&#x27;，这样可以节省空间</span></span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                    dfs(i,j);</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d : dir)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x + d[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">ny</span> <span class="operator">=</span> y + d[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 如果两个X是相连的，那么他们一定属于同一个战舰，这样就可以统计出所有的战舰</span></span><br><span class="line">            <span class="keyword">if</span>(nx&gt;=<span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; board[nx][ny] == <span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">                dfs(nx,ny);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="脑筋急转弯">脑筋急转弯</h2>
<p>由于战舰和战舰之间不是相连的，那么我们只需要找出一个点，这个点可以唯一代表一个战舰即可，这个点就是战舰头，由于战舰头的上(0,-1)和左(-1,0)一定是不相连的，只需要统计有多少个这个即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countBattleships</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; board[i - <span class="number">1</span>][j] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; board[i][j - <span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;X&#x27;</span>) res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>472. 连接词</title>
    <url>/posts/ba3/</url>
    <content><![CDATA[<h1 id="472-连接词">472. 连接词</h1>
<p>给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words
中的所有 连接词 。</p>
<p>连接词
定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/concatenated-words">https://leetcode-cn.com/problems/concatenated-words</a></p>
</blockquote>
<span id="more"></span>

<h2 id="排序前缀树dfs">排序+前缀树+dfs</h2>
<p>这个题看到之后首先想到的是字符串哈希，然后对于每个字符串进行判断（动态规划），但是写起来注意的细节挺多的，暂时不考虑。</p>
<p>前缀树的思想比较简单，由于words中存在一些字符串可以由其他的字符串组合而成，那么一个字符串一定是只能被比其长度更短的字符串表示。基于这个思想，我们首先对words按照长度进行排序，然后建立前缀树。每插入一个words[i]之前，首先判断这个单词是否可以被其他单词表示，如何可以就输出到结果中。</p>
<p>对于前缀树数据结构，这里不做过多解释，前面很多题都做过了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">        Trie[] children;</span><br><span class="line">        <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">            children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findAllConcatenatedWordsInADict</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Arrays.sort(words, (a, b) -&gt; a.length() - b.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="comment">// 先搜索，后插入</span></span><br><span class="line">            <span class="keyword">if</span> (word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dfs(word, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">// 在插入当前单词之前先判断其是否可以由比他长度更短的单词表示，如果不行再将其插入到字典树中</span></span><br><span class="line">                ans.add(word);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                insert(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(String word, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.length() == start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.isEnd) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(word, i + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> trie;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>475. 供暖器</title>
    <url>/posts/f3ef/</url>
    <content><![CDATA[<h1 id="475-供暖器">475. 供暖器</h1>
<p>冬季已经来临。
你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p>
<p>在加热器的加热半径范围内的每个房屋都可以获得供暖。</p>
<p>现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters
的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。</p>
<p>说明：所有供暖器都遵循你的半径标准，加热的半径也一样。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/heaters">https://leetcode-cn.com/problems/heaters</a></p>
</blockquote>
<span id="more"></span>

<h2 id="排序二分查找">排序+二分查找</h2>
<p>这个题思路不难想到，找到距离每个房屋最近的两个diameter（左侧和右侧），然后找出距离最近的那一个，由此可以统计出所有加热器距离其所需要覆盖房屋的最小半径，所有加热半径中最大的就是可以覆盖所有的最小加热半径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRadius</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> house : houses) &#123;</span><br><span class="line">            <span class="comment">// 对于每个house找到距离其最近的两个heater（左端和右端）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> binarySearch(heaters, house);</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftDistance</span> <span class="operator">=</span> i &lt; <span class="number">0</span> ? Integer.MAX_VALUE : house - heaters[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightDistance</span> <span class="operator">=</span> j &gt;= heaters.length ? Integer.MAX_VALUE : heaters[j] - house;</span><br><span class="line">            <span class="comment">// 计算每一个house距离最近的heater的距离</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">curDistance</span> <span class="operator">=</span> Math.min(leftDistance, rightDistance);</span><br><span class="line">            ans = Math.max(ans, curDistance);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到最接近target的那个值（lower_bound)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (right - left + <span class="number">1</span>) / <span class="number">2</span> + left;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>507. 完美数</title>
    <url>/posts/53f4/</url>
    <content><![CDATA[<h1 id="507-完美数">507. 完美数</h1>
<p>对于一个 正整数，如果它和除了它自身以外的所有 正因子
之和相等，我们称它为 「完美数」。</p>
<p>给定一个 整数 n， 如果是完美数，返回 true，否则返回 false</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/perfect-number">https://leetcode-cn.com/problems/perfect-number</a></p>
</blockquote>
<span id="more"></span>

<h2 id="数学">数学</h2>
<p>对于任意一个数，其正因子都是成对存在的，这个很容易想到 <span
class="math display">\[
b = n \mod a
\]</span> 则有 <span class="math display">\[
a\times b = n
\]</span> 也就是a和b都是正因子</p>
<p>因此我们只需要求出n的所有正因子，并累加其和判断最终结果是否和n相同即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPerfectNumber</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// o(sqrt(n))</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= num / i; i++) &#123;</span><br><span class="line">            <span class="comment">// i和num/i都是正因子</span></span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) ans += i + num / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是实际上完美数就那么即可，可以直接打表求出来</p>
<p>6,28,496,8128,33550336</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>686. 重复叠加字符串匹配</title>
    <url>/posts/14e3/</url>
    <content><![CDATA[<h1 id="686-重复叠加字符串匹配">686. 重复叠加字符串匹配</h1>
<p>给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b
成为叠加后的字符串 a 的子串，如果不存在则返回 -1。</p>
<p>注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是
"abc"，重复叠加 2 次是 "abcabc"。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/repeated-string-match">https://leetcode-cn.com/problems/repeated-string-match</a></p>
</blockquote>
<span id="more"></span>

<h2 id="字符串匹配脑筋急转弯">字符串匹配+脑筋急转弯</h2>
<p>首先可以知道该题一定要用到字符串匹配，需要判断a的重复叠加字符串是否包含b</p>
<p>又由于重复叠加字串的性质，如果b在重复叠加了s次a内，那么s*a.length()一定要大于b，而且由于重复叠加的特性，能和b匹配的实际字串数就是a的长度，也就是说我们最多比较a.length()次就可以知道是否包含（因为之后的匹配都是循环的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">repeatedStringMatch</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先判断b中是否包含a中不存在的字符</span></span><br><span class="line">        <span class="type">int</span>[] countA = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] countB = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:a.toCharArray())&#123;</span><br><span class="line">            ++countA[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:b.toCharArray())&#123;</span><br><span class="line">            ++countB[ch-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            <span class="comment">// 该字符仅在B中出现过，那么永远无法匹配</span></span><br><span class="line">            <span class="keyword">if</span>(countB[i] != <span class="number">0</span> &amp;&amp; countA[i] == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行下一步的匹配</span></span><br><span class="line">        <span class="comment">// 由于重叠字符串的性质，最长叠加字符串的长度是很容易确定的</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 关键在于当叠加后a的长度超过b的长度，b的起始位置在a上的位置只有a.length()个，如果以这些字符串作为起始构成的重叠字符串都无法匹配，那么之后的也无法匹配</span></span><br><span class="line">        <span class="keyword">while</span>(sb.length() &lt; b.length())&#123;</span><br><span class="line">            sb.append(a);</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再多加一次</span></span><br><span class="line">        sb.append(a);</span><br><span class="line">        <span class="comment">// KMP，子串匹配</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> sb.indexOf(b);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果刚好重复了res次就可以匹配，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> index + b.length() &gt; res * a.length()  ? res + <span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>825. 适龄的朋友</title>
    <url>/posts/7b79/</url>
    <content><![CDATA[<h1 id="825-适龄的朋友">825. 适龄的朋友</h1>
<p>在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i]
是第 i 个用户的年龄。</p>
<p>如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x !=
y）发送好友请求：</p>
<p>age[y] &lt;= 0.5 * age[x] + 7 age[y] &gt; age[x] age[y] &gt; 100
&amp;&amp; age[x] &lt; 100 否则，x 将会向 y 发送一条好友请求。</p>
<p>注意，如果 x 向 y 发送一条好友请求，y 不必也向 x
发送一条好友请求。另外，用户不会向自己发送好友请求。</p>
<p>返回在该社交媒体网站上产生的好友请求总数。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/friends-of-appropriate-ages">https://leetcode-cn.com/problems/friends-of-appropriate-ages</a></p>
</blockquote>
<span id="more"></span>

<h2 id="排序双指针">排序+双指针</h2>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>846. 一手顺子</title>
    <url>/posts/6c98/</url>
    <content><![CDATA[<h1 id="846-一手顺子">846. 一手顺子</h1>
<p>Alice
手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是
groupSize ，并且由 groupSize 张连续的牌组成。</p>
<p>给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数
groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false
。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/hand-of-straights">https://leetcode-cn.com/problems/hand-of-straights</a></p>
</blockquote>
<span id="more"></span>

<h2 id="优先队列哈希表">优先队列+哈希表</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNStraightHand</span><span class="params">(<span class="type">int</span>[] hand, <span class="type">int</span> groupSize)</span> &#123;</span><br><span class="line">        <span class="comment">// 思路：</span></span><br><span class="line">        <span class="comment">// 由于需要将手牌划分成多个group，每个group大小都是groupSize</span></span><br><span class="line">        <span class="comment">// 因此hand.length % groupSize == 0</span></span><br><span class="line">        <span class="comment">// 否则不能划分</span></span><br><span class="line">        <span class="comment">// 当可以划分时，从手牌的最小值开始划分</span></span><br><span class="line">        <span class="keyword">if</span>(hand.length % groupSize != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a-b);</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : hand)&#123;</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(map.get(curr) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 判断以curr值开始的顺子是否是连续的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;groupSize;++j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> map.getOrDefault(curr+j,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                map.put(curr+j,cnt-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>851. 喧闹和富有</title>
    <url>/posts/6519/</url>
    <content><![CDATA[<h1 id="851-喧闹和富有">851. 喧闹和富有</h1>
<p>有一组 n 个人作为实验对象，从 0 到 n - 1
编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为
x 的人简称为 "person x "。</p>
<p>给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比
person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i
的安静值。richer 中所给出的数据 逻辑自恰（也就是说，在 person x 比
person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况
）。</p>
<p>现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y
的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y
是最安静的人（也就是安静值 quiet[y] 最小的人）。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/loud-and-rich">https://leetcode-cn.com/problems/loud-and-rich</a></p>
</blockquote>
<span id="more"></span>

<h2 id="题意">题意</h2>
<p>该题本质上是一个图论题，quiet数组代表了图中包含的所有节点，richer数组描述了图中所有点边，因此需要先建立图（临接表或临接矩阵），之后进行搜索，找出一个节点可能到达其他节点中具有最小quiet值的节点</p>
<h2 id="拓扑排序">拓扑排序</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] loudAndRich(<span class="type">int</span>[][] richer, <span class="type">int</span>[] quiet) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> quiet.length;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] in = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 建图，a-&gt;[b,c,d,...]</span></span><br><span class="line">        <span class="comment">// 采用临接表方式建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] r : richer) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> r[<span class="number">0</span>], b = r[<span class="number">1</span>];</span><br><span class="line">            List&lt;Integer&gt; list = map.getOrDefault(a, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            list.add(b);</span><br><span class="line">            map.put(a, list);</span><br><span class="line">            <span class="comment">// 记录每个节点的入度</span></span><br><span class="line">            in[b]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 队列</span></span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 将所有入度为0的节点放进去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = i;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == <span class="number">0</span>) d.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!d.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> d.pollFirst();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u : map.getOrDefault(t, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (quiet[ans[t]] &lt; quiet[ans[u]]) ans[u] = ans[t];</span><br><span class="line">                <span class="keyword">if</span> (--in[u] == <span class="number">0</span>) d.addLast(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>911. 在线选举</title>
    <url>/posts/43d9/</url>
    <content><![CDATA[<h1 id="911-在线选举">911. 在线选举</h1>
<p>给你两个整数数组 <code>persons</code> 和 <code>times</code>
。在选举中，第<code> i</code> 张票是在时刻为<code> times[i]</code>
时投给候选人<code> persons[i]</code> 的。</p>
<p>对于发生在时刻 <code>t</code> 的每个查询，需要找出在<code> t</code>
时刻在选举中领先的候选人的编号。</p>
<p>在 <code>t</code>
时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。</p>
<p>实现 <code>TopVotedCandidate</code> 类：</p>
<ul>
<li><code>TopVotedCandidate(int[] persons, int[] times)</code> 使用
<code>persons</code> 和<code> times</code> 数组初始化对象。</li>
<li><code>int q(int t)</code> 根据前面描述的规则，返回在时刻
<code>t</code> 在选举中领先的候选人的编号。</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/online-election">https://leetcode-cn.com/problems/online-election</a></p>
</blockquote>
<span id="more"></span>

<h2 id="二分查找">二分查找</h2>
<p>根据题意，第i张票是在times[i]时刻投给persons[i]，那么当时刻t位于区间
[ times[i] , times[i-1]
)内时，其结果都是确定的，因为此时并没有新的选票产生，也就不会发生变化，那么我们只需要遍历times[i]，记录下times[i]时刻的获胜候选人即可，使用一个哈希表存储每个候选人的选票，然后不断更新当前的胜者即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TopVotedCandidate</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] times,winner;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> l;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TopVotedCandidate</span><span class="params">(<span class="type">int</span>[] persons, <span class="type">int</span>[] _times)</span> &#123;</span><br><span class="line">        times = _times;</span><br><span class="line">        l = times.length;</span><br><span class="line">        winner = <span class="keyword">new</span> <span class="title class_">int</span>[l];</span><br><span class="line">        <span class="comment">// 使用map还不如数组模拟的哈希表快</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; voteCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">winnerIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        voteCount.put(-<span class="number">1</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">candidateIndex</span> <span class="operator">=</span> persons[i];</span><br><span class="line">            voteCount.put(candidateIndex,voteCount.getOrDefault(candidateIndex,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(voteCount.get(candidateIndex) &gt;= voteCount.get(winnerIndex))&#123;</span><br><span class="line">                <span class="comment">// 更新当前时刻的票数领先者</span></span><br><span class="line">                winnerIndex = candidateIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// winner[i]记录的是times[i]时刻的优胜者</span></span><br><span class="line">            <span class="comment">// 由于在times[i]到times[i+1]的区间内不存在新的选票，那么对[times[i],times[i+1])区间内的时刻，其优胜都是winner[i]</span></span><br><span class="line">            winner[i] = winnerIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i : winner)&#123;</span></span><br><span class="line">        <span class="comment">//     System.out.print(i+ &quot; &quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// System.out.println();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">q</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="comment">// 进行二分查找即可，需要找到upperbound-1即可</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// System.out.println(left+&quot; &quot;+right+&quot; &quot;+mid);</span></span><br><span class="line">            <span class="keyword">if</span>(times[mid] &gt; t)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(left + &quot; &quot;+times[left] + &quot; &quot; + t);</span></span><br><span class="line">        <span class="keyword">return</span> winner[left-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TopVotedCandidate object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TopVotedCandidate obj = new TopVotedCandidate(persons, times);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.q(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1185. 一周中的第几天</title>
    <url>/posts/ba26/</url>
    <content><![CDATA[<h1 id="1185-一周中的第几天">1185. 一周中的第几天</h1>
<p>给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。</p>
<p>输入为三个整数：day、month 和 year，分别表示日、月、年。</p>
<p>您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday",
"Wednesday", "Thursday", "Friday", "Saturday"}。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/day-of-the-week">https://leetcode-cn.com/problems/day-of-the-week</a></p>
</blockquote>
<span id="more"></span>

<h2 id="模拟注意细节">模拟（注意细节）</h2>
<p>这题思路很简单，我们只需要找出一个已知星期几的时间（例如1970.1.1是星期四）然后计算当前日期距离1970.1.2过了多少天即可，注意这里计算的是1970.1.2，而不是1970.1.1，因为我们需要计算从1970.1.1后过了多久，那么1970.1.1那一天是不能统计在内的，当然为了强迫症的话也可以从1969.12.31开始计算偏移，这样后面计算出来的结果不需要减1）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] daysOfMonth = &#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] weekdays = &#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>, <span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">startYear</span> <span class="operator">=</span> <span class="number">1970</span>;</span><br><span class="line">    <span class="comment">// 1970.1.1是星期四</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">startWeekDay</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dayOfTheWeek</span><span class="params">(<span class="type">int</span> day, <span class="type">int</span> month, <span class="type">int</span> year)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 首先计算经过了多少年</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> startYear;y&lt;year;++y)&#123;</span><br><span class="line">            days += isLeap(y) ? <span class="number">366</span>:<span class="number">365</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后计算month距离1.1过了多少天</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;m&lt;month;++m)&#123;</span><br><span class="line">            days += daysOfMonth[m];</span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">2</span> &amp;&amp; isLeap(year))&#123;</span><br><span class="line">                ++days;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后计算day</span></span><br><span class="line">        <span class="comment">// 计算1970.1.2 到 year.month.day过了多少天</span></span><br><span class="line">        days += day-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 通过取模运算就可以求出year.month.day是星期几了</span></span><br><span class="line">        <span class="keyword">return</span> weekdays[(startWeekDay + days)% <span class="number">7</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLeap</span><span class="params">(<span class="type">int</span> year)</span>&#123;</span><br><span class="line">        <span class="comment">// 4的倍数且不是100的倍数 或 400的倍数，两种情况</span></span><br><span class="line">        <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1220. 统计元音字母序列的数目</title>
    <url>/posts/6a2e/</url>
    <content><![CDATA[<h1 id="1220-统计元音字母序列的数目">1220. 统计元音字母序列的数目</h1>
<p>给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n
的字符串：</p>
<ul>
<li>字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o',
'u'）</li>
<li>每个元音 'a' 后面都只能跟着 'e'</li>
<li>每个元音 'e' 后面只能跟着 'a' 或者是 'i'</li>
<li>每个元音 'i' 后面 不能 再跟着另一个 'i'</li>
<li>每个元音 'o' 后面只能跟着 'i' 或者是 'u'</li>
<li>每个元音 'u' 后面只能跟着 'a'</li>
</ul>
<p>由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/count-vowels-permutation">https://leetcode-cn.com/problems/count-vowels-permutation</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划普通版">动态规划（普通版）</h2>
<p>看到这种统计次数的题目，基本就是一个动态规划</p>
<p>很容易想到状态定义为<code>dp[l][k]</code>，表示长度为l且以k结尾的字母序列数目，其中k为(a,e,i,o,u)中的一个</p>
<p>题目中也很明确的给出了状态转移的关系（由于动态规划是从下至上进行求解，我们需要对题目的条件进行翻译），实际上就是找出一个字母可以跟在哪些字母后面</p>
<ul>
<li>a可以跟在 e，i，u后面</li>
<li>e可以跟在a，i后面</li>
<li>i可以跟在e，o后面</li>
<li>o可以跟在i后面</li>
<li>u可以跟在i，o后面</li>
</ul>
<p>可以写出状态转移方程 <span class="math display">\[
\begin{cases}
dp[l+1][a] = dp[l][e] + dp[l][i] + dp[l][u] \\
dp[l+1][e] = dp[l][a] + dp[l][i] \\
dp[l+1][i] = dp[l][e] + dp[l][o] \\
dp[l+1][o] = dp[l][i] \\
dp[l+1][u] = dp[l][i] + dp[l][o]
\end{cases}
\]</span>
可以看到长度为l+1的状态只依赖于长度为l的状态，因此可以将空间压缩至o(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)(<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countVowelPermutation</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// dp[l][k] 表示以k结尾的长度为l的字母序列个数，其中k为a、e、i、o、u中的一个</span></span><br><span class="line">        <span class="comment">// dp[1][k] = 1</span></span><br><span class="line">        <span class="comment">// 考虑a可以跟在哪些字符串的后面</span></span><br><span class="line">        <span class="comment">// e，i，u</span></span><br><span class="line">        <span class="comment">// 则有dp[l+1][a] = dp[l][e] + dp[l][i] + dp[l][u]</span></span><br><span class="line">        <span class="comment">// e 可以在 a、i后面</span></span><br><span class="line">        <span class="comment">// dp[l+1][e] = dp[l][a] + dp[l][i]</span></span><br><span class="line">        <span class="comment">// i 可以在 e、o后面</span></span><br><span class="line">        <span class="comment">// dp[l+1][i] = dp[l][e] + dp[l][o]</span></span><br><span class="line">        <span class="comment">// o 可以在 i后面</span></span><br><span class="line">        <span class="comment">// dp[l+1][o] = dp[l][i]</span></span><br><span class="line">        <span class="comment">// u 可以在 i、o后面</span></span><br><span class="line">        <span class="comment">// dp[l+1][u] = dp[l][i] + dp[l][o]</span></span><br><span class="line">        <span class="comment">// 可以看到，第l+1的仅依赖于第l次的</span></span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// a,e,i,o,u</span></span><br><span class="line">        <span class="comment">// 0,1,2,3,4</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            temp[<span class="number">0</span>] = ((dp[<span class="number">1</span>] + dp[<span class="number">2</span>]) % MOD + dp[<span class="number">4</span>]) % MOD;</span><br><span class="line">            temp[<span class="number">1</span>] = (dp[<span class="number">0</span>] + dp[<span class="number">2</span>]) % MOD;</span><br><span class="line">            temp[<span class="number">2</span>] = (dp[<span class="number">1</span>] + dp[<span class="number">3</span>]) % MOD;</span><br><span class="line">            temp[<span class="number">3</span>] = dp[<span class="number">2</span>] % MOD;</span><br><span class="line">            temp[<span class="number">4</span>] = (dp[<span class="number">2</span>] + dp[<span class="number">3</span>]) % MOD;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">5</span>;++k)&#123;</span><br><span class="line">                dp[k] = temp[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">            res = (res + dp[i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划矩阵快速幂">动态规划（矩阵快速幂）</h2>
<h1
id="从状态转移方程中可以看到长度为l1的状态仅依赖于长度为l的状态如果我们将所有长度为l的状态看成一个向量的话则有--beginalign-left-beginmatrix-dpl1a--dpl1e--dpl1i--dpl1o--dpl1u--endmatrix-right-t---left-beginmatrix-0--1--1--0--1--1--0--1--0--0--0--1--0--1--0--0--0--1--0--0--0--0--1--1--0-endmatrix-right-times-left-beginmatrix-dpla--dple--dpli--dplo--dplu--endmatrix-right-t--n1----nn--times--n1-endalign--通过这个我们可以求解dpn--left-beginmatrix-dpna--dpne--dpni--dpno--dpnu--endmatrix-right-t">从状态转移方程中可以看到，长度为l+1的状态仅依赖于长度为l的状态，如果我们将所有长度为l的状态看成一个向量的话，则有
<span class="math display">\[
\begin{align}
\left[
\begin{matrix}
dp[l+1][a] \\
dp[l+1][e] \\
dp[l+1][i] \\
dp[l+1][o] \\
dp[l+1][u] \\
\end{matrix}
\right] ^T
&amp; =
\left[
\begin{matrix}
0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 0
\end{matrix}
\right]
\times
\left[
\begin{matrix}
dp[l][a] \\
dp[l][e] \\
dp[l][i] \\
dp[l][o] \\
dp[l][u] \\
\end{matrix}
\right] ^T \\
(n,1)  &amp; = (n,n)  \times  (n,1)
\end{align}
\]</span> 通过这个我们可以求解dp[n] $$ \left[ \begin{matrix} dp[n][a] \
dp[n][e] \ dp[n][i] \ dp[n][o] \ dp[n][u] \ \end{matrix} \right]^ T</h1>
<p>\left[ \begin{matrix} 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \ 1 &amp; 0
&amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 0
&amp; 1 &amp; 0 &amp; 0 \ 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \end{matrix}
\right] ^ {n-1} &amp; \times &amp; \left[ \begin{matrix} dp[1][a] \
dp[1][e] \ dp[1][i] \ dp[1][o] \ dp[1][u] \ \end{matrix} \right]^ T $$
只要我们通过矩阵快速幂算法求出变换矩阵的n次方即可（有一说一矩阵快速幂写起来真麻烦，超级码力奥了属于是）</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1576. 替换所有的问号</title>
    <url>/posts/93bb/</url>
    <content><![CDATA[<h1 id="1576-替换所有的问号">1576. 替换所有的问号</h1>
<p>给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?'
转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。</p>
<p>注意：你 不能 修改非 '?' 字符。</p>
<p>题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。</p>
<p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters">https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters</a></p>
</blockquote>
<span id="more"></span>

<h2 id="模拟">模拟</h2>
<p>对于一个需要的替换的问号，我们只需要考虑其前一个字符和后一个字符，然后选择与这两个都不同的即可</p>
<p>下面介绍思路：</p>
<p>前一个字符为prev，后一个字符为next</p>
<p>使用一个数组存储a-z，之后我们分别将prev和next交换至数组末尾，然后在数组中选择第0号元素即可（实际上前24个都是与prev、next不同的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] candidate = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] candidatePos = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">1313L</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;++i)&#123;</span><br><span class="line">            <span class="comment">// 记录每一个字母所在的位置</span></span><br><span class="line">            <span class="comment">// 当筛选出两个不需要的单词之后我们就随机生成一个[0,23] or [0,24]的数，之后找出</span></span><br><span class="line">            candidate[i] = (<span class="type">char</span>)(i+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            candidatePos[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">modifyString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要将问号替换为不包含连续重复的字符</span></span><br><span class="line">        <span class="comment">// 对于每一个&#x27;?&#x27;的位置i，只需要找到s.charAt(i-1)和s.charAt(i+1)两个值</span></span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">char</span> next,prev,curr;</span><br><span class="line">        <span class="type">int</span> last;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            curr = arr[i];</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                last = <span class="number">25</span>;</span><br><span class="line">                <span class="comment">// 需要排除两个字母</span></span><br><span class="line">                prev = (i == <span class="number">0</span>) ? <span class="string">&#x27;?&#x27;</span> : arr[i-<span class="number">1</span>];</span><br><span class="line">                next = (i + <span class="number">1</span> == l) ? <span class="string">&#x27;?&#x27;</span> : arr[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(prev != <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                    swap(prev,last);</span><br><span class="line">                    --last;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(next != <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">                    swap(next,last);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 实际上只用到了candidate上面的三个值</span></span><br><span class="line">                <span class="comment">// 此时arr[i]一定和next与last不一样</span></span><br><span class="line">                <span class="comment">// 此处也可以使用random，但是也不是很需要了</span></span><br><span class="line">                <span class="comment">// 这样的结果也是随机的</span></span><br><span class="line">                arr[i] = candidate[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> originCh,<span class="type">int</span> targetPos)</span>&#123;</span><br><span class="line">        <span class="comment">// 将字符ch交换至pos位置上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">originPos</span> <span class="operator">=</span> candidatePos[originCh-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="type">char</span> <span class="variable">targetCh</span> <span class="operator">=</span> candidate[targetPos];</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        candidate[targetPos] = originCh;</span><br><span class="line">        candidate[originPos] = targetCh;</span><br><span class="line">        <span class="comment">// 修改candidatePos</span></span><br><span class="line">        candidatePos[originCh-<span class="string">&#x27;a&#x27;</span>] = targetPos;</span><br><span class="line">        candidatePos[targetCh-<span class="string">&#x27;a&#x27;</span>] = originPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1584. 连接所有点的最小费用</title>
    <url>/posts/5bac/</url>
    <content><![CDATA[<h1 id="1584-连接所有点的最小费用">1584. 连接所有点的最小费用</h1>
<p>给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi,
yi] 。</p>
<p>连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi -
xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。</p>
<p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有
一条简单路径时，才认为所有点都已连接。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points">https://leetcode-cn.com/problems/min-cost-to-connect-all-points</a></p>
</blockquote>
<span id="more"></span>

<h2 id="最小生成树">最小生成树</h2>
<h3 id="kruskal优先队列并查集">Kruskal+优先队列+并查集</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] rank = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">        <span class="type">int</span> target;</span><br><span class="line">        <span class="type">int</span> source;</span><br><span class="line">        <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">        Edge(<span class="type">int</span> t,<span class="type">int</span> s,<span class="type">int</span> w)&#123;</span><br><span class="line">            target = t;</span><br><span class="line">            source = s;</span><br><span class="line">            weight = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Edge&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a.weight-b.weight);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">Edge</span>(i,j,dist(points[i],points[j])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">v0</span> <span class="operator">=</span> edge.source;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> edge.target;</span><br><span class="line">            <span class="keyword">if</span>(FIND(v0) != FIND(v1))&#123;</span><br><span class="line">                res += edge.weight;</span><br><span class="line">                UNION(v0,v1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">UNION</span><span class="params">(<span class="type">int</span> index1,<span class="type">int</span> index2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> FIND(index1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> FIND(index2);</span><br><span class="line">        <span class="keyword">if</span>(r1 == r2)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rank[r1] &gt; rank[r2])&#123;</span><br><span class="line">            arr[r2] = r1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[r1] = r2;</span><br><span class="line">            <span class="keyword">if</span>(rank[r1] == rank[r2])&#123;</span><br><span class="line">                ++rank[r2];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">FIND</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">while</span>(arr[root] != root)&#123;</span><br><span class="line">            root = arr[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(arr[index] != root)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> arr[index];</span><br><span class="line">            arr[index] = root;</span><br><span class="line">            index = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dist</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> [] b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(a[<span class="number">0</span>]-b[<span class="number">0</span>]) + Math.abs(a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="prim优先队列">Prim+优先队列</h3>
<p>prim算法的基本思想是从一个根节点开始，找到其连接的边，每次将最小边权加入到树中，直到所有节点连通</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">// prim算法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">        <span class="comment">// int[] is [weight,target]</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">            visited[j] = <span class="literal">false</span>;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;dist(points[<span class="number">0</span>],points[j]),j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] edge = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!visited[next])&#123;</span><br><span class="line">                res += weight;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                    <span class="comment">// 计算每个节点距离当前生成树的最小距离</span></span><br><span class="line">                    <span class="keyword">if</span>(!visited[i] &amp;&amp; i != next)&#123;</span><br><span class="line">                        <span class="comment">// 存在重复计算</span></span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;dist(points[next],points[i]),i&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[next] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dist</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span>[] b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(a[<span class="number">0</span>]-b[<span class="number">0</span>]) + Math.abs(a[<span class="number">1</span>]-b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>215. 数组中的第K个最大元素</title>
    <url>/posts/6b1a/</url>
    <content><![CDATA[<h1 id="215-数组中的第k个最大元素">215. 数组中的第K个最大元素</h1>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第
<code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code>
个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>没什么好说的，直接暴力搜索吧 o(n^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">            <span class="comment">// 每次不断找寻数组中的最大值，然后将最大值放在数组的最前面</span></span><br><span class="line">            <span class="comment">// 然后缩小数组的范围（这样就可以不搜索最大值了）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findLargest(nums,i);</span><br><span class="line">            <span class="comment">// 将最大值放在数组的前面</span></span><br><span class="line">            swap(nums,index,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLargest</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> begin)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> begin;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[begin];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; max)&#123;</span><br><span class="line">                index = i;</span><br><span class="line">                max = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序">排序</h2>
<p>找第k大的元素，直接排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="-快速排序应用分治">!!! 快速排序应用+分治</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nth_element(nums,k,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">nth_element</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> n, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 假如n的范围是0~nums.length-1</span></span><br><span class="line">        <span class="comment">// 那么需要调整一下</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end) <span class="keyword">return</span> nums[begin];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot_index</span> <span class="operator">=</span> partition(nums, begin, end);</span><br><span class="line"><span class="comment">//        if(pivot_pos == n) return nums[pivot_pos];</span></span><br><span class="line">        <span class="comment">// 划分成了两个区间 begin,k和end,k+1</span></span><br><span class="line">        <span class="comment">// 计算pivot_pos在[begin,end]内子数组的一个偏移量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">local_index</span> <span class="operator">=</span> pivot_index - begin + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= local_index) &#123;</span><br><span class="line">            <span class="keyword">return</span> nth_element(nums, n, begin, pivot_index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当要找的元素比pivot_pos更大时</span></span><br><span class="line">        <span class="comment">// [begin,pivot_pos] [pivot_pos+1,end]</span></span><br><span class="line">        <span class="keyword">return</span> nth_element(nums, n - local_index, pivot_index + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里采用随机数进行优化，相比固定值可以大幅提升效果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> begin + random.nextInt(end - begin + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// int pivotIndex = (begin + end) &gt;&gt; 1;</span></span><br><span class="line">        <span class="comment">// int pivotIndex = begin;</span></span><br><span class="line">        swap(arr, pivotIndex, end);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> begin;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 因为把pivot放在了最后，所以low指针先走</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &gt; arr[end]) left++;</span><br><span class="line">            <span class="comment">// 这里必须是互斥的，否则出现相等时会出现问题</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &lt;= arr[end]) right--;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) swap(arr, left, right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(arr, left, end);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">        nums[a] = nums[b];</span><br><span class="line">        nums[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优先队列">优先队列</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b)-&gt;b-a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">            --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>219. 存在重复元素 II</title>
    <url>/posts/eb26/</url>
    <content><![CDATA[<h1 id="219-存在重复元素-ii">219. 存在重复元素 II</h1>
<p>给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个
不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) &lt;= k
。如果存在，返回 true ；否则，返回 false 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/contains-duplicate-ii">https://leetcode-cn.com/problems/contains-duplicate-ii</a></p>
</blockquote>
<span id="more"></span>

<h2 id="哈希表">哈希表</h2>
<p>对于当前遍历的元素<code>nums[i]</code>，我们可以使用一个哈希表来记录<code>nums[i]</code>最后一次出现的索引<code>j</code>，如果<code>j-i &lt; k</code>就可以直接返回true，如果所有都不存在则返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 直接暴力搜索</span></span><br><span class="line">        <span class="comment">// 对于每个元素，从i-k一直到i+k</span></span><br><span class="line">        <span class="comment">// 哈希表吧，记录每一个出现位置，辅助二分查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 记录该数的最后一次出现位置</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lastPos</span> <span class="operator">=</span> map.getOrDefault(nums[i],-<span class="number">1</span>);</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">            <span class="keyword">if</span>(lastPos != -<span class="number">1</span> &amp;&amp; i-lastPos&lt;=k)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口">滑动窗口</h2>
<p>还有一种做法，维护一个长度为k+1的滑动窗口（确保窗口两端的元素下标差j-i等于k），在每次插入新元素之前判断是否已经出现过，如果有就可以直接返回true，没有就加入继续判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsNearbyDuplicate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 移除窗口的最左端元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; k) set.remove(nums[i - k - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(nums[i])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>373. 查找和最小的K对数字</title>
    <url>/posts/78d8/</url>
    <content><![CDATA[<h1 id="373-查找和最小的k对数字">373. 查找和最小的K对数字</h1>
<p>给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。</p>
<p>定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2
。</p>
<p>请找到和最小的 k 个数对 (u1,v1), (u2,v2) ... (uk,vk) 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums">https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums</a></p>
</blockquote>
<span id="more"></span>

<h2 id="找规律优先队列">找规律+优先队列</h2>
<p>本题要求我们找出两个有序数组中和最小的前k对数，最容易想到的就是先生成所有的可能对（m*n），之后进行排序或者使用TopK就可以找出和最小的前k对数，这种方法时间复杂度为o(mn
log(mn))，先不说是否会超时，我们是开不出这么大的数组的，那么是否还有其他解决方案呢？</p>
<p>实际上是有的，为了更好的阐述这个题目的思想，我们拿一个例子来说明</p>
<p>nums1 = [1,2,3,4]</p>
<p>nums2 = [5,6,7]</p>
<p>对于这两个数组我们可以枚举出所有的pair</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(0,0) (0,1) (0,2)</span><br><span class="line">(1,0) (1,1) (1,2)</span><br><span class="line">(2,0) (2,1) (2,2)</span><br><span class="line">(3,0) (3,1) (3,2)</span><br><span class="line"></span><br><span class="line">再将其和写出来</span><br><span class="line"></span><br><span class="line">6	7	8</span><br><span class="line">7	8	9</span><br><span class="line">8	9	10</span><br><span class="line">9	10	11</span><br></pre></td></tr></table></figure>

<p>从这个矩阵中我们可以看到，该矩阵每一行、每一列都是有序的，因此我们要找的TopK就有很明显的特征了</p>
<p>如果将这个矩阵的右边节点和下边节点看成子节点，可以连接成以下图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">|\</span><br><span class="line">7-7</span><br><span class="line">|\|\</span><br><span class="line">8-8-8</span><br><span class="line">|\|\|</span><br><span class="line">9-9-9</span><br><span class="line"> \|\|</span><br><span class="line"> 10-10 </span><br><span class="line">   \|</span><br><span class="line">    11</span><br></pre></td></tr></table></figure>

<p>那么TopK就一定是按这个顺序排列的，使用优先队列，从根节点开始，每次添加两个节点(i+1,j)和(i,j+1)，但是这样会出现重复，且堆很容易满，为了确保不重复添加，我们可先将所有的右节点添加进去，</p>
<p>对于上图，我们优先队列中包含
{6,7,8}，这样当我们需要添加新节点的时候只需要添加一边即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">kSmallestPairs</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k, (o1, o2)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> nums1[o1[<span class="number">0</span>]] + nums2[o1[<span class="number">1</span>]] - nums1[o2[<span class="number">0</span>]] - nums2[o2[<span class="number">1</span>]];</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">axis</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            axis = <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="comment">// 这一步很关键，去重</span></span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            axis = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] currPair = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> currPair[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> currPair[<span class="number">1</span>];</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(nums1[i]);</span><br><span class="line">            list.add(nums2[j]);</span><br><span class="line">            ans.add(list);</span><br><span class="line">            <span class="keyword">if</span>(axis)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span> &lt; m)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i+<span class="number">1</span>,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(j+<span class="number">1</span> &lt; n)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j+<span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>382. 链表随机节点</title>
    <url>/posts/a0a6/</url>
    <content><![CDATA[<h1 id="382-链表随机节点">382. 链表随机节点</h1>
<p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点
被选中的概率一样 。</p>
<p>实现 Solution 类：</p>
<ul>
<li>Solution(ListNode head) 使用整数数组初始化对象。</li>
<li>int getRandom()
从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。</li>
</ul>
<p>提示：</p>
<ul>
<li>链表中的节点数在范围 [1, 10<sup>4</sup>] 内</li>
<li>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></li>
<li>至多调用 getRandom 方法 10<sup>4</sup> 次</li>
</ul>
<p>进阶：</p>
<ul>
<li>如果链表非常大且长度未知，该怎么处理？</li>
<li>你能否在不使用额外空间的情况下解决此问题？</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/linked-list-random-node">https://leetcode-cn.com/problems/linked-list-random-node</a></p>
</blockquote>
<span id="more"></span>

<h2 id="简单随机">简单随机</h2>
<p>数据量不大，可以开一个数组把所有的链表项都存起来，当需要随机访问的时候就生成一个[0,end]的随机数，返回即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;ListNode*&gt; list;</span><br><span class="line">    std::uniform_int_distribution&lt;<span class="type">int</span>&gt; u;</span><br><span class="line">    std::default_random_engine e;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode* head) &#123;</span><br><span class="line">        <span class="comment">// 链表并不支持随机访问</span></span><br><span class="line">        <span class="comment">// 一个很简单的思路就是</span></span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            list.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        u = std::<span class="built_in">uniform_int_distribution</span>&lt;<span class="type">int</span>&gt;(<span class="number">0</span>,list.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list[<span class="built_in">u</span>(e)]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(head);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="蓄水池采样进阶">蓄水池采样（进阶）</h2>
<p>当我们遍历第i个数的时候，先从[0,i)中随机生成一个数（均匀分布），当这个数等于0时将i作为最终随机选择的结果，不为0则保留原来的结果，那么最终遍历完结果为i的概率：
第i次[0,i)抽样结果为0 且 后面的 n-i 次抽样结果都不为0 <span
class="math display">\[
P(i) = \frac{1}{i} \cdot \frac{i}{i+1} \cdot \frac{i+1}{i+2} \cdots
\frac{n-1}{n} = \frac{1}{n}
\]</span> 真是非常巧妙的一种方法</p>
<p>知道原理之后实现起来就非常容易了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">    std::default_random_engine random_engine;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode* _head) &#123;</span><br><span class="line">        head = _head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* curr = head;curr != <span class="literal">nullptr</span>; curr = curr-&gt;next)&#123;</span><br><span class="line">            <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">uniform</span><span class="params">(<span class="number">0</span>,index++)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">uniform</span>(random_engine) == <span class="number">0</span>)&#123;</span><br><span class="line">                res = curr-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(head);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>390. 消除游戏</title>
    <url>/posts/efc8/</url>
    <content><![CDATA[<h1 id="390-消除游戏">390. 消除游戏</h1>
<p>列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对
arr 应用下述算法：</p>
<p>从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
给你整数 n ，返回 arr 最后剩下的数字。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/elimination-game">https://leetcode-cn.com/problems/elimination-game</a></p>
</blockquote>
<span id="more"></span>

<h2 id="找规律递归">找规律+递归</h2>
<p>这个题还挺有意思的，一开始没什么想法，拿一个数出来找找规律吧</p>
<p>假设 n = 40</p>
<p>首先进行直接模拟的看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接模拟计算</span><br><span class="line">n = 10</span><br><span class="line">1,2,3,4,5,6,7,8,9,10</span><br><span class="line">从左向右删除 </span><br><span class="line">2,4,6,8,10 -&gt; 2*[1,2,3,4,5]</span><br><span class="line">从右向左删除</span><br><span class="line">4,8 -&gt; 2*2*[1,2]</span><br><span class="line">从左向右删除</span><br><span class="line">8 -&gt; 2*2*2</span><br></pre></td></tr></table></figure>

<p>step1.
从[1,40]内从左向右删除第一个数字，然后每隔一个删除一个，直到到达列表末尾，实际上就是删除[1,40]内的所有奇数，那么剩下的结果为[1,40]内的所有偶数，也就是
<span class="math display">\[
2,4,6,8,10,...,40
\]</span> 那么实际上他可以化简为 <span class="math display">\[
2\times[1,20]
\]</span> step2.
从[1,20]内从右向左删除第一个数字，然后每隔一个删除一个，直到到达列表末尾，实际上就是删除[1,20]内的所有偶数，那么剩下的结果为[1,20]内的所有奇数，也就是
<span class="math display">\[
2 \times [1,3,5,7,9,...,19]
\]</span> 那么实际上可以化简为 <span class="math display">\[
2\times(2\times[1,10]-1)
\]</span> step3.
从[1,10]内从左向右删除，接下来我们重复删除操作，从左到右进行删除，实际上删除了[1,10]内所有偶数，也就是
<span class="math display">\[
2\times(2\times[1,3,5,7,9]-1)
\]</span> 转换成连续区间形式为（任意一个奇数都可以表示为2*k-1） <span
class="math display">\[
2\times(2\times(2\times[1,5])-1)
\]</span> step4.
从[1,5]内从右向左删除，实际上就是删除了[1,5]内的所有奇数，也就是 <span
class="math display">\[
2\times(2\times(2\times[2，4])-1)
\]</span> 转换一下可以得到 <span class="math display">\[
2\times(2\times(2\times(2\times[1，2]))-1)
\]</span> step5.
从[1,2]内从左向右删除，这就很简单了，删除1，那么可以得到最后剩下的值
<span class="math display">\[
2\times(2\times(2\times(2\times2))-1) = 30
\]</span> 因此最终剩下的值是30</p>
<p>从分析的过程可以很清晰的看到，这是一个递归结构，每一步删除都可以转换为一个规模更小的子问题，因此可以写出递归求解方程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 1 &lt; n &lt; 10^9</span></span><br><span class="line">        <span class="comment">// 数学</span></span><br><span class="line">        <span class="comment">// 实际上可以转换为一个递归问题</span></span><br><span class="line">        <span class="keyword">return</span> dfs(n,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">boolean</span> leftToRight)</span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(leftToRight)&#123;</span><br><span class="line">            <span class="comment">// 删除所有奇数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * dfs(n/<span class="number">2</span>,!leftToRight);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>)!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 从右向左且长度为偶数，那么等价于删除数组上所有的偶数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> * dfs(n/<span class="number">2</span>,!leftToRight) - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 删除了所有的奇数</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> * dfs(n/<span class="number">2</span>,!leftToRight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>89. 格雷编码</title>
    <url>/posts/c1bb/</url>
    <content><![CDATA[<h1 id="89-格雷编码">89. 格雷编码</h1>
<p>n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：</p>
<ul>
<li>每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）</li>
<li>第一个整数是 0</li>
<li>一个整数在序列中出现 不超过一次</li>
<li>每对 相邻 整数的二进制表示 恰好一位不同 ，且</li>
<li>第一个 和 最后一个 整数的二进制表示 恰好一位不同</li>
</ul>
<p>给你一个整数 n ，返回任一有效的 n 位格雷码序列 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/gray-code">https://leetcode-cn.com/problems/gray-code</a></p>
</blockquote>
<span id="more"></span>

<h2 id="暴力">暴力</h2>
<p>最简单的方式就是从0开始，每次反转当前数的1位，然后判断这个数是否已经加入序列中，如果没有就继续进行这一操作，直到序列长度为2^n</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">1</span>&lt;&lt;<span class="number">17</span>];</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Arrays.fill(visited,<span class="literal">false</span>);</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            res.add(curr);</span><br><span class="line">            visited[curr] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 开始变换</span></span><br><span class="line">            <span class="type">int</span> next;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                <span class="comment">// 由于异或运算的性质，将一个数的某位取反可以写成异或的形式</span></span><br><span class="line">                <span class="comment">// a ^ 0 = a</span></span><br><span class="line">                <span class="comment">// a ^ 1 = ~a</span></span><br><span class="line">                <span class="comment">// 下面这个式子就是将curr的第j位取反</span></span><br><span class="line">                next = curr ^ (<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                ++j;</span><br><span class="line">            &#125;<span class="keyword">while</span>(visited[next]);</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：o(2^n)</p>
<p>空间复杂度：o(2^n)</p>
<p>可以看到这种暴力方法的空间复杂度为o(2^n)，效率太低，实际上是有空间复杂度为o(1)的解法</p>
<h2 id="对称构造">对称构造</h2>
<p>直接用语言描述有点难度，直接给一个构造的例子吧</p>
<p>2位的格雷码序列（G_2）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00,01,11,10</span><br></pre></td></tr></table></figure>

<p>如果此时我们将2位格雷码序列进行翻转，得到的序列记为（G_2_prime）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10,11,01,00</span><br></pre></td></tr></table></figure>

<p>可以看到其同样满足格雷码定义</p>
<p>此时我们再将G_2_prime最高位变为1（也就是第3位置为1）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">110,111,101,100</span><br></pre></td></tr></table></figure>

<p>然后将G_2_prime和G_2拼接起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">000,001,011,010,110,111,101,100</span><br></pre></td></tr></table></figure>

<p>这样就构造出了3位的格雷码，因此这是一个递归的过程，我们只需要求出n-1位的格雷码，通过下面的构造方法就可以构造出n位的格雷码</p>
<ol type="1">
<li>翻转2位格雷码</li>
<li>将每个数的第n-1位置为1</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        construct(res,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">construct</span><span class="params">(List&lt;Integer&gt; list,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            list.add(<span class="number">0</span>);</span><br><span class="line">            list.add(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        construct(list,n-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 此时n-1位的格雷码已经构建完成，开始构建第n层的格雷码</span></span><br><span class="line">        <span class="comment">// 否则利用list构建长度为n的格雷码</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; (n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=N-<span class="number">1</span>;i&gt;-<span class="number">1</span>;--i)&#123;</span><br><span class="line">            <span class="comment">// 末位且第n位置1</span></span><br><span class="line">            list.add(list.get(i)|N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就不需要额外的visited输出判断修改是否已经存在了</p>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>913. 猫和老鼠</title>
    <url>/posts/2d0f/</url>
    <content><![CDATA[<h1 id="913-猫和老鼠">913. 猫和老鼠</h1>
<p>两位玩家分别扮演猫和老鼠，在一张 无向
图上进行游戏，两人轮流行动。</p>
<p>图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b
组成。</p>
<p>老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0
处有一个洞。</p>
<p>在每个玩家的行动中，他们 必须
沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1
，那么它必须移动到 graph[1] 中的任一节点。</p>
<p>此外，猫无法移动到洞中（节点 0）。</p>
<p>然后，游戏在出现以下三种情形之一时结束：</p>
<p>如果猫和老鼠出现在同一个节点，猫获胜。 如果老鼠到达洞中，老鼠获胜。
如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。
给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：</p>
<p>如果老鼠获胜，则返回 1； 如果猫获胜，则返回 2； 如果平局，则返回 0
。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/cat-and-mouse">https://leetcode-cn.com/problems/cat-and-mouse</a></p>
</blockquote>
<span id="more"></span>

<h2 id="动态规划博弈论">动态规划+博弈论</h2>
<p>这题是个困难题，关键在于如何定义最佳状态进行搜索</p>
<p>同时还需要联想到动态规划</p>
<p>对于当前棋盘的状态，我们可以分为三种</p>
<ol type="1">
<li>必胜状态</li>
<li>必输状态</li>
<li>必和状态</li>
</ol>
<p>而玩家的最佳状态就是：</p>
<p>优先选择能使自己进入最佳必胜状态的路径，实在不行选择必和状态也行（至少不能让对面赢），最后实在没办法了就投降（怎么选都是一个输）</p>
<p>然后还有两个细节</p>
<ol type="1">
<li>猫不可以进入老鼠洞，即当猫走的时候不可以进入0节点</li>
<li>当猫和老鼠处于同一个位置的时候一定是平局</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] graph;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">55</span>;</span><br><span class="line">    <span class="comment">// dp[i][j][turns]</span></span><br><span class="line">    <span class="comment">// 为什么turns的总数为2*N*N</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N][N][<span class="number">2</span>*N];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">catMouseGame</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="comment">// 博弈论，老鼠位于节点1，猫位于节点2</span></span><br><span class="line">        <span class="comment">// 本题关键在于如何对问题进行建模</span></span><br><span class="line">        <span class="comment">// 如何定义最佳状态？</span></span><br><span class="line">        <span class="comment">// 这个涉及到博弈问题的三种状态：</span></span><br><span class="line">        <span class="comment">// 必胜状态</span></span><br><span class="line">        <span class="comment">// 必输状态</span></span><br><span class="line">        <span class="comment">// 必和状态</span></span><br><span class="line">        <span class="comment">// 选择最佳策略就是：优先选择进入必胜状态，实在不行的时候进入必和状态，当无法进入的时候就只能进入必输状态了</span></span><br><span class="line">        <span class="comment">// 因此我们需要从起始位置开始</span></span><br><span class="line">        <span class="comment">// 对于当前状态，需要遍历所有相邻的边</span></span><br><span class="line">        <span class="comment">// 初始化dp</span></span><br><span class="line">        <span class="built_in">this</span>.graph = graph;</span><br><span class="line">        <span class="built_in">this</span>.n = graph.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                Arrays.fill(dp[i][j],-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> turn,<span class="type">int</span> catPos,<span class="type">int</span> mousePos)</span>&#123;</span><br><span class="line">        <span class="comment">// catPos == mousePos, cat win</span></span><br><span class="line">        <span class="comment">// mousePos == 0, mouse Win</span></span><br><span class="line">        <span class="comment">// turn &gt; 2*n*n, game draw</span></span><br><span class="line">        <span class="comment">// 首先判断当前状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currState</span> <span class="operator">=</span> dp[catPos][mousePos][turn];</span><br><span class="line">        <span class="keyword">if</span>(mousePos == <span class="number">0</span>)&#123;</span><br><span class="line">            currState = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mousePos == catPos)&#123;</span><br><span class="line">            currState = <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(turn &gt;= <span class="number">2</span>*n)&#123;</span><br><span class="line">            <span class="comment">// 此处控制递归深度，原本最大状态数为 2*n*n</span></span><br><span class="line">            <span class="comment">// 但可以证明这个深度可以降低至 2*n</span></span><br><span class="line">            <span class="comment">// 即猫、老鼠经过的状态数总和（超过这个值后就一定会出现重合）</span></span><br><span class="line">            currState = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(currState ==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 对于当前状态开始计算</span></span><br><span class="line">            <span class="comment">// 判断是哪一个开始走</span></span><br><span class="line">            <span class="comment">// mouse先走，那么mouse对应的turn一定是偶数，则cat对应的turn一定是奇数</span></span><br><span class="line">            <span class="keyword">if</span>((turn&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">win</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">draw</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//cat move</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> nextPos : graph[catPos])&#123;</span><br><span class="line">                    <span class="comment">// 这里有个细节，猫不可以进入0，因为0是老鼠洞来的</span></span><br><span class="line">                    <span class="keyword">if</span>(nextPos == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextState</span> <span class="operator">=</span> dfs(turn+<span class="number">1</span>,nextPos,mousePos);</span><br><span class="line">                    <span class="keyword">if</span>(nextState == <span class="number">2</span>)&#123;</span><br><span class="line">                        win = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nextState == <span class="number">0</span>)&#123;</span><br><span class="line">                        draw = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(win) currState = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(draw) currState = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> currState = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">win</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">draw</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// mouse move</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> nextPos : graph[mousePos])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">nextState</span> <span class="operator">=</span> dfs(turn+<span class="number">1</span>,catPos,nextPos);</span><br><span class="line">                    <span class="keyword">if</span>(nextState == <span class="number">1</span>)&#123;</span><br><span class="line">                        win = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nextState == <span class="number">0</span>)&#123;</span><br><span class="line">                        draw = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(win) currState = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(draw) currState = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> currState = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[catPos][mousePos][turn] = currState;</span><br><span class="line">        <span class="keyword">return</span> currState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>743. 网络延迟时间</title>
    <url>/posts/ca48/</url>
    <content><![CDATA[<h1 id="743-网络延迟时间">743. 网络延迟时间</h1>
<p>有 n 个网络节点，标记为 1 到 n。</p>
<p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui,
vi, wi)，其中 ui 是源节点，vi 是目标节点， wi
是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，从某个节点 K
发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回
-1 。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/network-delay-time">https://leetcode-cn.com/problems/network-delay-time</a></p>
</blockquote>
<span id="more"></span>

<h2 id="单源最短路径dijkastra">单源最短路径（Dijkastra）</h2>
<p>这个题是一个很经典的单源最短路径题，主要考察Dijkstra算法（本质贪心）</p>
<p>简要介绍Dijkstra算法：</p>
<blockquote>
<p>当图中各边的权（本题中指的是节点之间的网络时延）不相等时，用固定的顺序对定点进行处理。把顶点依次记为v0到vn-1，并记s=v0.当处理顶点v1时，取连接顶点v0和顶点v1的边。当处理顶点v2时，考虑从顶点v0到顶点v2的最短距离，并把它与从顶点v0到顶点v1再到顶点v2的最短距离进行比较，取较小者为顶点v0到顶点v2之间的最短路径长度。当处理顶点vi时，利用已经处理过的从顶点v0到顶点vi-1的最短路径长度。但是这样可能会产生问题：也许从v0到vi的真正最短路径会经过顶点vj，而j&gt;i使用这个算法会遗漏这种路径。不过，如果以从顶点S出发所到达的顶点的距离（递增）为顺序对各个节点进行处理，就能避免这个问题了。现在假设已经处理了从顶点S出发所到达的距离最小的前i-1个顶点，称这些顶点的集合为集合S。现在准备按照这个顺序处理第i个顶点，称之为顶点X，则从顶点S到顶点X的最短路径中的倒数第二个顶点一定在集合S中。因此有
<span class="math display">\[
d(S,X) = min(d(S,U)+w(U,X))
\]</span>
也就是说，从顶点S到顶点X的最短路径长度为：从集合S中任取顶点U，都有一条从顶点S到顶点U的路径，在从顶点U到顶点X的边，计算从所有顶点U产生的路径中的最小值。</p>
<p>这个方法通常称为Dijkstra算法。它的技巧在于为V中所有的顶点X维护一个路径长度估计值D(X)。D中的元素初始化为INF，并且按照从顶点S出发所到达顶点的距离（递增顺序）处理各个顶点。每当处理一个顶点V时，它的任意一个相邻顶点X的D(X)值都可能随之改变。</p>
</blockquote>
<p>文字上的描述有点抽象，下面拿一个例子来展示Dijkstra算法过程</p>
<p><img data-src="Image/dijkstra.png" /></p>
<p>如上图所示，求节点1到其他的节点的最短路径</p>
<p>首先初始化距离数组d = [0,INF,INF,INF,INF,INF,INF]</p>
<p>其次初始化访问标记数组visited =
[false,false,false,false,false,false]</p>
<p>step1：找到从节点1可直接到达的节点，并记录其距离数组d</p>
<p>可以发现，从1节点可以直达的节点有[2,3,4]</p>
<p>更新距离数组d</p>
<p>[0,2,3,6,INF,INF]</p>
<p>visited[0] = true</p>
<p>step2：选择距离1节点最近的节点2开始计算，同时更新距离值</p>
<p>从节点2可以直达的节点有[1,5,6]，由于节点1已经访问过了，就不需要重新访问了</p>
<p>更新距离数组d</p>
<p>[0,2,3,6,6,8]</p>
<p>visited[1] = true</p>
<p>step3：选择未访问过且距离节点1最小的节点作为下一个访问节点（节点3），更新距离值</p>
<p>更新距离数组d</p>
<p>可以观察到，通过节点3到达节点4的距离会比直接到达节点4要短（2+3&lt;6)</p>
<p>[0,2,3,5,6,8]</p>
<p>visited[2] = true</p>
<p>step4：选择节点4进行更新</p>
<p>距离数组</p>
<p>[0,2,3,5,6,8]</p>
<p>visited[3] = true</p>
<p>step5：选择节点5进行更新</p>
<p>距离数组</p>
<p>[0,2,3,5,6,8]</p>
<p>visited[4] = true</p>
<p>step6：选择节点6进行更新</p>
<p>距离数组</p>
<p>[0,2,3,5,6,8]</p>
<p>visited[5] = true</p>
<p>至此所有节点都已经遍历完成，从节点1到达所有节点的最短路径也求解完成</p>
<p>代码实现（遍历）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            Arrays.fill(matrix[i],INF);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] t:times)&#123;</span><br><span class="line">            matrix[t[<span class="number">0</span>]-<span class="number">1</span>][t[<span class="number">1</span>]-<span class="number">1</span>] = t[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="comment">// 单源最短路径</span></span><br><span class="line">        <span class="type">int</span>[] d = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(d,INF);</span><br><span class="line">        d[k-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">// 找到未访问节点中距离最短的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[j] &amp;&amp; (minIndex == -<span class="number">1</span> || d[minIndex] &gt; d[j]))&#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[minIndex] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                d[j] = Math.min(d[j],d[minIndex] + matrix[minIndex][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历找最大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxD</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:d)&#123;</span><br><span class="line">            maxD = Math.max(i,maxD);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxD == INF ? -<span class="number">1</span> : maxD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从求解过程中可以看到，每一步都需要遍历距离数组D找到距离当前节点最近的节点进行更新，实际上可以使用优先队列进行优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> Integer.MAX_VALUE / <span class="number">2</span>;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt;[] g = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            g[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 临接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] t : times) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> t[<span class="number">0</span>] - <span class="number">1</span>, y = t[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            g[x].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;y, t[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dist, INF);</span><br><span class="line">        dist[k - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;((a, b) -&gt; a[<span class="number">0</span>] != b[<span class="number">0</span>] ? a[<span class="number">0</span>] - b[<span class="number">0</span>] : a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, k - <span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] p = pq.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> p[<span class="number">0</span>], x = p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dist[x] &lt; time) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// g[x]代表从x直接相邻的节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] e : g[x]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> e[<span class="number">0</span>], d = dist[x] + e[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (d &lt; dist[y]) &#123;</span><br><span class="line">                    dist[y] = d;</span><br><span class="line">                    pq.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;d, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:dist)&#123;</span><br><span class="line">            res = Math.max(res,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INF ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 37. 序列化二叉树</title>
    <url>/posts/bef/</url>
    <content><![CDATA[<h1 id="剑指-offer-37-序列化二叉树">剑指 Offer 37. 序列化二叉树</h1>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<p>你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列
/
反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode
序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof">https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof</a></p>
</blockquote>
<span id="more"></span>

<h2 id="层序遍历实现">层序遍历实现</h2>
<p>层序遍历将二叉树转换成字符串没什么难度，之前也写过很多了，这里不赘述，直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;TreeNode&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Codec</span><span class="params">()</span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 层序遍历进行序列化</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">curr</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(curr==<span class="literal">null</span>)&#123;</span><br><span class="line">                    sb.append(<span class="string">&quot;null&quot;</span>).append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sb.append(curr.val).append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">                    queue.offer(curr.left);</span><br><span class="line">                    queue.offer(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际难点在于如何对字符串进行反序列化</p>
<p>下面以一个例子来介绍反序列化过程</p>
<p><img data-src="Image/serialize-binary-tree.png" style="zoom:50%;" /></p>
<p>首先这棵树序列话结果如下</p>
<p>[1,2,null,3,4,null,null,7,null,8,9,null,null,11,10,null,null,null.null]</p>
<p>计算流程如下</p>
<p>对于一个不为null的节点，其一定包含两个孩子节点（不管是有值还是null）</p>
<p>因此可以统计孩子节点的个数，并使用队列存储前一层的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">  <span class="comment">// 如何将层序遍历结果还原成一棵树</span></span><br><span class="line">  <span class="comment">// 根据第一个值的情况，可以计算出当前层次包含的节点数</span></span><br><span class="line">  <span class="comment">// java的substring是区间是左闭右开的</span></span><br><span class="line">  <span class="comment">// 首先划分字符串</span></span><br><span class="line">  String[] nodes = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">rootVal</span> <span class="operator">=</span> nodes[<span class="number">0</span>];</span><br><span class="line">  <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nodes.length;</span><br><span class="line">  <span class="keyword">if</span>(rootVal.equals(<span class="string">&quot;null&quot;</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(rootVal));</span><br><span class="line">  queue.offer(root);</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">childCount</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">nextChildCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">TreeNode</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;length)&#123;</span><br><span class="line">    <span class="keyword">while</span>(childCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">nodeVal</span> <span class="operator">=</span> nodes[i];</span><br><span class="line">      <span class="keyword">if</span>(nodeVal.equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">        node = <span class="literal">null</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(nodeVal));</span><br><span class="line">        nextChildCount += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将其将入下一轮</span></span><br><span class="line">        queue.offer(node);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 由于不为空的节点一定包含两个孩子节点，偶数代表左孩子，奇数代表右孩子</span></span><br><span class="line">      <span class="keyword">if</span>((childCount &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 偶数说明是左孩子</span></span><br><span class="line">        parent = queue.poll();</span><br><span class="line">        parent.left = node;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        parent.right = node;</span><br><span class="line">      &#125;</span><br><span class="line">      --childCount;</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    childCount = nextChildCount;</span><br><span class="line">    nextChildCount = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>212. 单词搜索</title>
    <url>/posts/b08e/</url>
    <content><![CDATA[<h1 id="212-单词搜索">212. 单词搜索</h1>
<p>给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表
words，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过 相邻的单元格
内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<p>提示：</p>
<ul>
<li>m == board.length</li>
<li>n == board[i].length</li>
<li>1 &lt;= m, n &lt;= 12</li>
<li>board[i][j] 是一个小写英文字母</li>
<li>1 &lt;= words.length &lt;= 3 * 10<sup>4</sup></li>
<li>1 &lt;= words[i].length &lt;= 10</li>
<li>words[i] 由小写英文字母组成</li>
<li>words 中的所有字符串互不相同</li>
</ul>
<blockquote>
<p>链接：<a
href="https://leetcode-cn.com/problems/word-search-ii">https://leetcode-cn.com/problems/word-search-ii</a></p>
</blockquote>
<span id="more"></span>

<h2 id="dfs">dfs</h2>
<p>最简单的方式，直接判断每一个字符串是否在board中存在路径即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[][] board;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] _board, String[] words)</span> &#123;</span><br><span class="line">        <span class="comment">// 感觉直接暴力会超时</span></span><br><span class="line">        <span class="comment">// 如果words中存在一些重复的部分，是否可以减少搜索的时间？</span></span><br><span class="line">        <span class="comment">// 是否可以将路径记录一下（String代表路径）然后只需要判断word是否出现在路径中即可</span></span><br><span class="line">        board = _board;</span><br><span class="line">        m = _board.length;</span><br><span class="line">        n = _board[<span class="number">0</span>].length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="comment">// 同一个单元格内的字母再一个单词中不允许被重复使用</span></span><br><span class="line">        <span class="comment">// dfs?寻找路径</span></span><br><span class="line">        <span class="comment">// 如果直接暴力？</span></span><br><span class="line">        <span class="comment">// 遍历words，然后逐个判断每个单词是否可以在单词中出现</span></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">notIn</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m &amp;&amp; notIn;++i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n &amp;&amp; notIn;++j)&#123;</span><br><span class="line">                    <span class="comment">// 只需要找到一条路径即可</span></span><br><span class="line">                    <span class="keyword">if</span>(board[i][j] == word.charAt(<span class="number">0</span>) &amp;&amp; dfs(word,<span class="number">0</span>,i,j))&#123;</span><br><span class="line">                        res.add(word);</span><br><span class="line">                        notIn = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断棋盘当前位置是否出现在 word[idx]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(String word,<span class="type">int</span> idx,<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.charAt(idx) != board[x][y]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx == word.length()-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> x + dir[<span class="number">0</span>][i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> y + dir[<span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">if</span>(nextX &gt; -<span class="number">1</span> &amp;&amp; nextX &lt; m &amp;&amp; nextY &gt; -<span class="number">1</span> &amp;&amp; nextY &lt; n &amp;&amp; !visited[nextX][nextY])&#123;</span><br><span class="line">                res |= dfs(word,idx+<span class="number">1</span>,nextX,nextY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x][y] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种写法，直接记录路径，然后判断路径所对应的字符串是否出现在字典中即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[][] board;</span><br><span class="line">    <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] _board, String[] words)</span> &#123;</span><br><span class="line">        board = _board;</span><br><span class="line">        m = board.length; n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (String w : words) set.add(w);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">                sb.append(board[i][j]);</span><br><span class="line">                dfs(i, j, sb);</span><br><span class="line">                vis[i][j] = <span class="literal">false</span>;</span><br><span class="line">                sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, StringBuilder sb)</span> &#123;</span><br><span class="line">      	<span class="comment">// 由于字典中的字符串长度不会超过10，这里进行剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (sb.length() &gt; <span class="number">10</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(sb.toString())) &#123;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">            set.remove(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : dirs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dx</span> <span class="operator">=</span> i + d[<span class="number">0</span>], dy = j + d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (dx &lt; <span class="number">0</span> || dx &gt;= m || dy &lt; <span class="number">0</span> || dy &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (vis[dx][dy]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[dx][dy] = <span class="literal">true</span>;</span><br><span class="line">            sb.append(board[dx][dy]);</span><br><span class="line">            dfs(dx, dy, sb);</span><br><span class="line">            vis[dx][dy] = <span class="literal">false</span>;</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="trie">trie</h2>
<blockquote>
<p>关于 trie 这个数据结构，LeetCode上也有对应的数据结构设计题：</p>
<p><a
href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208.
实现 Trie (前缀树) - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>Trie（发音类似 "try"）或者说 前缀树
是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>主要包含的操作有：</p>
<ul>
<li><p>Trie()</p>
<p>初始化前缀树对象</p></li>
<li><p>void insert(String word)</p>
<p>向前缀树中插入字符串word</p></li>
<li><p>boolean search(String word)</p>
<p>检索word是否出现在前缀树中</p></li>
<li><p>boolean startsWith(String prefix)</p>
<p>检索已经插入的字符串中是否有前缀为prefix的（可以实现自动补全）</p></li>
</ul>
<p>其核心是使用「边」来代表有无字符，使用「点」来记录是否为「单词结尾」以及「其后续字符串的字符是什么」。</p>
</blockquote>
<p><img data-src="Image/trie.webp" /></p>
<h3 id="二维数组实现">二维数组实现</h3>
<p>对于trie中的每一个节点，存储其对应于字符集的每一个输入情况的下一个节点索引信息（通过数组实现树），然后查询的时候只需要沿着链不断向后查找，直到结束</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="type">int</span>[]&gt; trie;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; endSet;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 使用二维数组形式实现trie</span></span><br><span class="line">        trie = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        endSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:word.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ptr &gt;= trie.size())&#123;</span><br><span class="line">                trie.add(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span>[] currSet = trie.get(ptr);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(currSet[p] == <span class="number">0</span>)&#123;</span><br><span class="line">                trie.add(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>]);</span><br><span class="line">                currSet[p] = ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = currSet[p];</span><br><span class="line">        &#125;</span><br><span class="line">        endSet.add(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:word.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ptr &gt;= trie.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span>[] currSet = trie.get(ptr);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(currSet[p] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = currSet[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> endSet.contains(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> prefix.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ptr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:prefix.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ptr &gt;= trie.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span>[] currSet = trie.get(ptr);</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(currSet[p] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = currSet[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="trienode树节点实现">TrieNode（树节点）实现</h3>
<p>这种方式和实现n叉树类似，每一个节点会存储对应每一个输入的下一个节点指针，且在写法上相比数组实现方式更为简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">        TrieNode[] next;</span><br><span class="line">        <span class="type">boolean</span> isEnd;</span><br><span class="line">        TrieNode()&#123;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">ptr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:word.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(ptr.next[p] == <span class="literal">null</span>)&#123;</span><br><span class="line">                ptr.next[p] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr.next[p];</span><br><span class="line">        &#125;</span><br><span class="line">        ptr.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">ptr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:word.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> ch-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(ptr.next[p] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ptr = ptr.next[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptr.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">ptr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:prefix.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(ptr.next[p] == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            ptr = ptr.next[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="本题解法">本题解法</h2>
<p>使用前缀树来辅助剪枝，这样可以提高搜索销量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">        TrieNode[] next;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="comment">// 如果其是结束节点，存储对应的字符串</span></span><br><span class="line">        TrieNode()&#123;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">ptr</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:s.toCharArray())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(ptr.next[p] == <span class="literal">null</span>)&#123;</span><br><span class="line">                ptr.next[p] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ptr = ptr.next[p];</span><br><span class="line">        &#125;</span><br><span class="line">        ptr.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">char</span>[][] board;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] dirs = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] _board, String[] words)</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        board = _board;</span><br><span class="line">        m = _board.length;</span><br><span class="line">        n = _board[<span class="number">0</span>].length;</span><br><span class="line">        set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(root.next[p] != <span class="literal">null</span>)&#123;</span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    dfs(i,j,root.next[p]);</span><br><span class="line">                    visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:set)&#123;</span><br><span class="line">            res.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,TrieNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.s != <span class="literal">null</span>) &#123;</span><br><span class="line">          	<span class="comment">// 使用set去重，有可能两条路都能走出同一个单词来</span></span><br><span class="line">            set.add(root.s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] dir:dirs)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextX</span> <span class="operator">=</span> x + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextY</span> <span class="operator">=</span> y + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nextX &lt; <span class="number">0</span> || nextX &gt;= m || nextY &lt; <span class="number">0</span> || nextY &gt;= n || visited[nextX][nextY]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> board[nextX][nextY] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">// 使用前缀树进行剪枝，提高效率</span></span><br><span class="line">            <span class="keyword">if</span>(root.next[p] != <span class="literal">null</span>)&#123;</span><br><span class="line">                visited[nextX][nextY] = <span class="literal">true</span>;</span><br><span class="line">                dfs(nextX,nextY,root.next[p]);</span><br><span class="line">                visited[nextX][nextY] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode刷题记录</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>个人博客搭建记录</title>
    <url>/posts/96e0/</url>
    <content><![CDATA[<p>之前都是在知乎上写博客，这样看的人也多，方便讨论，但是知乎的 markdown
编辑器不是很好用，本地写完后还需要一张一张上传图片，太麻烦了，就自己搭一个博客，又不想进行域名备案啥的，服务器也要出钱
:( 。最后搜到 Github 有提供免费的静态页面部署功能，这样写完 markdown
笔记可以直接上传到
Github，还可以通过网页访问，nice！(白嫖的感觉真好)</p>
<h1 id="github-pages">Github Pages</h1>
<h2 id="创建主页仓库">创建主页仓库</h2>
<p>通过 <a href="https://pages.github.com/">Github Pages</a>，我们可以将
markdown
撰写的笔记转换成静态网页，并进行部署。其创建流程也十分简单，只需要创建一个名为
<code>&lt;username&gt;.github.io</code> 的仓库，如下图所示</p>
<p><img data-src="/posts/96e0/image-20230102151015131.png"
style="zoom:50%;" /></p>
<p>此处我们选择的是 Private
仓库，只有我们能进行修改，但是主页是公开访问的，这样可以保证笔记源文件安全
:) 。</p>
<span id="more"></span>

<p>创建完成后仓库中什么都没有</p>
<p><img data-src="/posts/96e0/image-20230102151942075.png"
style="zoom:33%;" /></p>
<p>此时我们在浏览器中输入 <a
href="https://purewhitevk.github.io"><span>https://purewhitevk.github.io</span></a>
（URL不区分大小写，直接用小写即可），显示404，页面不存在。</p>
<p><img data-src="/posts/96e0/image-20230102152125799.png"
style="zoom: 50%;" /></p>
<p>别心急，很快就可以看到博客页面了。</p>
<h2 id="静态博客框架">静态博客框架</h2>
<p>在网上搜了一下，有很多博客框架，例如 wordpress 等，但是 wordpress
需要数据库，还需要单独配服务器进行部署，太麻烦了，满足我们需求的有三个</p>
<ul>
<li><p>Jekyll（Github 原生支持）</p>
<p>使用 Ruby 实现</p></li>
<li><p>Hexo</p>
<p>使用 Node.js 实现</p></li>
<li><p>Hugo</p>
<p>使用 Go 实现</p></li>
</ul>
<p>三者在功能上大同小异，都可以直接将 <code>.md</code>
文件转换成<code>html</code> 文件，且支持部署在 Github Pages
上。个人比较推荐 <a
href="https://hexo.io/">Hexo</a>，其环境搭建起来比较方便，且插件较多，操作起来比较简单。</p>
<p><img data-src="/posts/96e0/image-20230102153212301.png"
style="zoom:50%;" /></p>
<h1 id="hexo环境配置">hexo环境配置</h1>
<h2 id="安装">安装</h2>
<ol type="1">
<li><p>全局安装 hexo-cli，这样我们可以直接调用 hexo 的命令行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>将我们的主页仓库 clone 到本地，此处我们将其放到文件夹
<code>Note</code> 下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/PureWhiteVK/PureWhiteVK.github.io.git Note</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载 <a
href="https://github.com/hexojs/hexo-starter">hexo-starter</a>
并解压到本地仓库中</p>
<p>点击右侧 <code>Code</code> 按钮，直接下载 ZIP
压缩包即可（其实我们也可以直接 fork 这个仓库，但是这样我们的仓库就不能是
private 了）</p>
<p><img data-src="/posts/96e0/image-20230102154426653.png"
style="zoom:50%;" /></p></li>
<li><p>使用 <code>npm install</code> 安装依赖</p></li>
<li><p>输入 <code>hexo server</code> 进行运行本地服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Note&gt; hexo server</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  hexois running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>在浏览器中打开
<code>localhost:4000</code>，就可以预览生成后的静态页面效果了</p>
<p><img data-src="/posts/96e0/image-20230102161237387.png"
style="zoom:50%;" /></p></li>
</ol>
<h2 id="主题">主题</h2>
<p>hexo 上有很多精美的主题，这里我们选择 <a
href="https://github.com/theme-next/hexo-theme-next">next</a>
作为博客主题，其比较稳定，功能也很全。</p>
<p>直接使用 npm 进行安装即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>安装之后，我们需要将主题配置文件
<code>node_modules/hexo-theme-next/_config.yml</code>
拷贝至根目录下，并重命名为 <code>_config.next.yml</code></p>
<p>最终修改根目录下的 <code>_config.yml</code>
即可，将其更换为我们需要的主题</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>最后清理之前生成的文件，并重建部署一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo server</span><br></pre></td></tr></table></figure>

<p>主题效果如下</p>
<p><img data-src="/posts/96e0/image-20230102163251257.png"
style="zoom:50%;" /></p>
<h2 id="插件">插件</h2>
<p>hexo 提供了很多插件来简化我们的操作，并提供一些其他的功能。由于 hexo
是基于 node.js 实现的，我们可以通过 npm 来安装和卸载 hexo 插件。</p>
<p>安装插件命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save &lt;plugin-name&gt;</span><br></pre></td></tr></table></figure>

<p>删除插件命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall --save &lt;plugin-name&gt;</span><br></pre></td></tr></table></figure>

<p>我们使用了以下几个插件（具体配置可以直接参考 hexo-next-theme
的插件使用文档：<a
href="https://theme-next.js.org/docs/third-party-services/">Third-party
Plugins | NexT</a> 即可）</p>
<ul>
<li>hexo-generator-searchdb：实现搜索功能，支持html文件检索</li>
<li>hexo-abbrlink：自动生成文章的永久链接</li>
<li>hexo-word-counter：统计文章字数</li>
</ul>
<h2 id="配置">配置</h2>
<p>hexo的配置文件位于根目录下的
<code>_config.yml</code>，下面列举了我们需要修改的一些关键配置项</p>
<h3 id="网站基本设置">网站基本设置</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">&quot;PureWhite&#x27;s Blog&quot;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">PureWhiteVK</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="url设置">URL设置</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://purewhitevk.github.io</span></span><br><span class="line"><span class="comment"># 这样我们笔记永久链接为 https://purewhitevk.github.io/posts/43fc/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span> </span><br><span class="line"><span class="comment"># 我们使用了 hexo-abbrlink 插件，其通过对名称以及时间戳使用 crc16 算法，生成四位的一个唯一编码</span></span><br><span class="line"><span class="comment"># 四位十六进制可以表示 65536 篇文章，这对于我们博客而言已经绰绰有余了</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc16</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="comment"># 末尾的index后缀</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 末尾的.html后缀</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="写作相关配置">写作相关配置</h3>
<p>这里我们主要调整生成 hexo 生成的 markdown 文件名称</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year/:month/:day/:title.md</span></span><br></pre></td></tr></table></figure>

<p>hexo 添加 post 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Note&gt; hexo new post <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: D:\Code\Note\<span class="built_in">source</span>\_posts\2023\01\02\Hello-World.md</span><br></pre></td></tr></table></figure>

<p>markdown 文件内容如下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2023-01-02 17:03:17</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>其会默认包含一些内容，其中用三横线包裹起来的是 Front
Matter，其用来标识 markdown
文档的一些属性，例如标题、创建日期、标签（tags）、类别（categories）、永久链接等，hexo
通过读取 Front Matter 来控制生成的 html 文件。</p>
<h3 id="next-主题配置">next 主题配置</h3>
<p>前面提到，我们从 <code>node_modules</code> 中将 next
的配置拷贝至了根目录，并重命名为
<code>_config.next.yml</code>，主题相关的配置直接在这个文件中进行修改即可，next
中提供了非常多的配置项，就不一一介绍了，详细可以直接参考Next主题文档：<a
href="https://theme-next.js.org/">NexT - Theme for Hexo</a></p>
<h2 id="图片">图片</h2>
<p>由于 markdown 和 html 在使用上的区别（markdown 本地，html
网络），我们在 markdown 中插入图片</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">image-description</span>](<span class="link">/local/path/to/image</span>)</span><br></pre></td></tr></table></figure>

<p>会被直接转换成 html 的 <code>img</code> 标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/local/path/to/image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image-description&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是一个是本地路径，一个是网络 URI，直接这么转换肯定会问题。</p>
<p>参考 hexo 的[资源管理文档](<a
href="https://hexo.io/docs/asset-folders">Asset Folders | Hexo</a>)，在
hexo 中，最简单的图片管理方式就是将图片文件放置在
<code>source/images</code> 文件夹下，这样在网页中我们可以直接通过
<code>/images/&lt;image-name&gt;</code> 进行访问。</p>
<blockquote>
<p>Assets are non-post files in the <code>source</code> folder, such as
images, CSS or JavaScript files. For instance, If you are only going to
have a few images in the hexoproject, then <strong>the easiest way is to
keep them in a <code>source/images</code> directory.</strong> Then, you
can access them using something like</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">/images/image.jpg</span>)</span><br></pre></td></tr></table></figure>

</blockquote>
<p>markdown 写法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">/images/image.jpg</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意images前面的 <code>/</code>
，必须包含这个斜杠，否则图片路径就变成了相对当前URL的路径，会导致图片访问出错。加上<code>/</code>
就表示是相对域名的URL，即
<code>https://purewhitevk.github.io/images/image.jpg</code>；而不加<code>/</code>时就是相对当前网址的URL，假设我们当前网址为
<code>https://purewhitevk.github.io/posts/abcd</code>
，那么对应的图片URL为
<code>https://purewhitevk.github.io/posts/abcd/images/image.jpg</code>，这样就会导致找不到图片。（通过相对路径读取图片文件也是一种可行的方式）</p>
</blockquote>
<p>对应生成的 html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/image.jpg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是这样我们在本地使用 typora 编写 markdown 时就会有问题，好在 typora
也给出了解决方案：<a
href="https://support.typora.io/Images/#relative-path-to-certain-folder">Images
in Typora - Typora Support</a>。只需要在 markdown 的 Front Matter
中添加两个属性，将 markdown
中所有的图片路径都修改成相对某个路径的绝对路径即可（也就是<code>/relative/to/some-image.png</code>的形式）。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置相对的路径，设置根目录为 source</span></span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../../../../</span></span><br><span class="line"><span class="comment"># 插入图片时自动拷贝图片到 source/images/ 下</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> <span class="string">../../../../images</span></span><br></pre></td></tr></table></figure>

<p>我们的文章都位于
<code>source/_posts/&lt;year&gt;/&lt;month&gt;/&lt;day&gt;</code>
路径下，图片存储路径为<code>source/images</code>下，通过设置<code>typora-root-url</code>，当我们在markdown中插入一张路径为
<code>/images/image.jpg</code> 时，其会自动将
<code>typora-root-url</code>和该路径进行拼接，最终结果就是
<code>../../../../images/image.jpg</code>，正确读取到图片。另外一个便捷的功能就是插入图片时自动拷贝到指定文件夹，这样我们可以丝滑的添加图片了，不需要手动上传并设置链接。</p>
<p>我们可以将这两个配置项添加到 markdown 模板中（hexo 中称为
scaffold，脚手架），就不用每次都手动添加，修改
<code>scaffolds/post.md</code> 如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">category:</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../../../../</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> <span class="string">../../../../images</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 此处 more 标签用于 next 主题显示摘要</span></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">more</span> <span class="string">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们通过 <code>hexo new post &lt;title&gt;</code>
时就会默认配置好 typora。</p>
<p>附：typora的图像存储相关设置</p>
<p><img data-src="/posts/96e0/image-20230105230235058.png"
style="zoom:50%;" /></p>
<p>由于我们使用 Front Matter 进行配置，在图像处就不需要任何配置了。</p>
<h2 id="公式">公式</h2>
<p>另外一个比较令人头疼的就是公式渲染问题，latex 公式在语法上和 markdown
存在一些冲突，如果使用默认的 <code>hexo-renderer-marked </code>
渲染引擎进行生成会导致最终渲染出来的 latex 公式是错误的，我们需要将
markdown 渲染引擎替换为 <code>hexo-renderer-pandoc</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先删除原来的渲染器</span></span><br><span class="line">npm uninstall --save hexo-renderer-marked</span><br><span class="line"><span class="comment"># 安装新的渲染器</span></span><br><span class="line">npm install --save hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>

<p>然后在 next 主题的配置文件 <code>_config.next.yml</code> 中开启
mathjax 的支持</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># &lt;--- 将此处 false 修改为 true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>写一个简单的公式测试一下效果</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\int</span> <span class="built_in">_</span>0 <span class="built_in">^</span><span class="keyword">\pi</span> <span class="keyword">\sin</span> x <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125; x = 2</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>对应渲染结果 <span class="math display">\[
\int _0 ^\pi \sin x \,\mathrm{d} x = 2
\]</span> 如果可以正确看到公式就说明公式配置成功。</p>
<h2 id="部署">部署</h2>
<p>在 hexo 官网中给出了 Github Pages 的部署方式：<a
href="https://hexo.io/docs/github-pages">GitHub Pages |
Hexo</a>，由于我们会将源代码也上传至 Github 仓库，我们使用 Github
Workflow 的方式来自动执行部署过程。</p>
<p>其部署过程很简单</p>
<ol type="1">
<li>提交代码 （push）</li>
<li>执行 workflow 中指定的操作，安装
node.js，执行相关命令生成静态页面</li>
<li>通过 Github Pages 展示静态页面</li>
</ol>
<p>由于我们将hexo的markdown渲染器修改为<code>hexo-renderer-pandoc</code>，其需要提前安装好
pandoc
并添加到环境变量，我们需要在官方提供的workflow中修改一下，在容器中安装好
pandoc，网上一搜发现也有大佬已经分享了 pandoc 的配置命令：<a
href="https://github.com/nikeee/setup-pandoc">nikeee/setup-pandoc</a>，直接拿过来用即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">nikeee/setup-pandoc@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">pandoc-version:</span> <span class="string">&#x27;2.7.3&#x27;</span> <span class="comment"># The pandoc version to download (if necessary) and use.</span></span><br></pre></td></tr></table></figure>

<p>最后根据本地使用的 node.js 和 pandoc
版本，将其修改成对应的版本即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Note&gt; node --version</span><br><span class="line">v18.12.1</span><br><span class="line">(base) PS D:\Code\Note&gt; pandoc --version</span><br><span class="line">pandoc.exe 2.19.2</span><br><span class="line">Compiled with pandoc-types 1.22.2.1, texmath 0.12.5.2, skylighting 0.13,</span><br><span class="line">citeproc 0.8.0.1, ipynb 0.2, hslua 2.2.1</span><br><span class="line">Scripting engine: Lua 5.4</span><br><span class="line">User data directory: C:\Users\xiao\AppData\Roaming\pandoc</span><br><span class="line">Copyright (C) 2006-2022 John MacFarlane. Web:  https://pandoc.org</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions. There is no</span><br><span class="line">warranty, not even <span class="keyword">for</span> merchantability or fitness <span class="keyword">for</span> a particular purpose.</span><br></pre></td></tr></table></figure>

<p>完整的 workflow 配置代码如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span>  <span class="comment"># default branch</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="string">recursive</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Pandoc</span> <span class="number">2.19</span><span class="number">.2</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">nikeee/setup-pandoc@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">pandoc-version:</span> <span class="string">&quot;2.19.2&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">18.12</span><span class="number">.1</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18.12.1&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure>

<p>由于我们仓库实际上还没有初始化，需要使用 git
初始化一下仓库再进行提交，初始化命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/PureWhiteVK/PureWhiteVK.github.io.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p>提交之后代码后，我们可以在 Actions 面板中看到正在执行的 Workflows</p>
<p><img data-src="/posts/96e0/image-20230102185759306.png"
style="zoom:50%;" /></p>
<p>第一次 pages build and deployment 一定会执行失败，因为我们还没设置
Github Page 部署时使用的分支，hexo 的 workflow
在执行后会单独创建一个分支（gh-pages）来存放静态网页，我们在设置中切换一下即可。</p>
<p><img data-src="/posts/96e0/image-20230102190220044.png"
style="zoom:50%;" /></p>
<p>调整完成后，可以看到提示我们网站已经上线了（Your site is live at <a
href="https://purewhitevk.github.io"><span>https://purewhitevk.github.io</span></a>），进入
<a
href="https://purewhitevk.github.io"><span>https://purewhitevk.github.io</span></a>
就可以访问到部署好的博客页面了。（github.io访问速度可能较慢，最好挂梯子）</p>
<p><img data-src="/posts/96e0/image-20230102190311710.png"
style="zoom: 25%;" /></p>
]]></content>
      <categories>
        <category>Hexo使用记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex公式学习笔记</title>
    <url>/posts/caff/</url>
    <content><![CDATA[<p>之前我们已经配置好了 hexo 对 LaTex 公式的支持（在 markdown 的 Front
Matter 中添加 <code>mathjax: true</code> 开启 LaTex
公式渲染支持），支持两种形式的公式输入</p>
<ul>
<li><p>内联公式（inline），通过 <code>$...$</code>
进行包裹（必须在同一行）</p>
<p>例：markdown 代码 <code>$\phi = 30$</code> 对应内联公式渲染结果 <span
class="math inline">\(\phi = 30\)</span></p>
<p>在 <code>$</code>
和公式之间不能存在空格，也就是说，对于<code>$ \phi = 30 $</code>
并不能得到正确的渲染结果</p></li>
<li><p>块公式（block），通过 <code>$$...$$</code>
进行包裹（两个<code>$$</code>必须在不同行）</p>
<p>例：markdown 代码</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\int</span> <span class="built_in">_</span>0 <span class="built_in">^</span><span class="keyword">\pi</span> <span class="keyword">\sin</span>(x) = 2</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>对应块渲染结果 <span class="math display">\[
\int _0 ^ \pi \sin x = 2
\]</span></p></li>
</ul>
<p>现在我们可以在 markdown
文档中添加并渲染公式了，那么下一步就是如何正确书写公式，以及一些常用公式符号。</p>
<span id="more"></span>

<h1 id="常用符号">常用符号</h1>
<p>可以使用在线的<a
href="https://www.latexlive.com/">LaTex公式编辑器</a>来手动选取，下面列举了一些常用的符号</p>
<h2 id="关系和运算符号">关系和运算符号</h2>
<p><span class="math display">\[
\begin{align}
&amp; &lt; &amp; &amp; \mathtt{&lt;} &amp;
&amp; \leq &amp; &amp; \mathtt{\backslash leq} &amp;
&amp; \ll &amp; &amp; \mathtt{\backslash ll} &amp;
\\
&amp; &gt; &amp; &amp; \mathtt{&gt;} &amp;
&amp; \geq &amp; &amp; \mathtt{\backslash geq} &amp;
&amp; \gg &amp; &amp; \mathtt{\backslash gg} &amp;
\\
\\
&amp; \in &amp; &amp; \mathtt{\backslash in} &amp;
&amp; \subset &amp; &amp; \mathtt{\backslash subset} &amp;
&amp; \subseteq &amp; &amp; \mathtt{\backslash subseteq} &amp;
\\
&amp; \ni &amp; &amp; \mathtt{\backslash ni} &amp;
&amp; \supset &amp; &amp; \mathtt{\backslash supset} &amp;
&amp; \supseteq &amp; &amp; \mathtt{\backslash supseteq} &amp;
\\
&amp; \notin &amp; &amp; \mathtt{\backslash notin} &amp;
\\
\\
&amp; = &amp; &amp; \mathtt{=} &amp;
&amp; \neq &amp; &amp; \mathtt{\backslash neq} &amp;
&amp; \equiv &amp; &amp; \mathtt{\backslash equiv} &amp;
\\
&amp; \approx &amp; &amp; \mathtt{\backslash approx} &amp;
&amp; \propto &amp; &amp; \mathtt{\backslash propto} &amp;
\\
\\
&amp; \parallel &amp; &amp; \mathtt{\backslash parallel} &amp;
&amp; \nparallel &amp; &amp; \mathtt{\backslash nparallel} &amp;
&amp; \sim &amp; &amp; \mathtt{\backslash sim} &amp;
\\
&amp; \perp &amp; &amp; \mathtt{\backslash perp} &amp;
\\
\\
&amp; + &amp; &amp; \text{+} &amp;
&amp; - &amp; &amp; \text{-} &amp;
&amp; \star &amp; &amp; \mathtt{\backslash star} &amp;
\\
&amp; \times &amp; &amp; \mathtt{\backslash times} &amp;
&amp; \div &amp; &amp; \mathtt{\backslash div} &amp;
&amp; \cdot &amp; &amp; \mathtt{\backslash cdot} &amp;
\\
&amp; \cup &amp; &amp; \mathtt{\backslash cup} &amp;
&amp; \cap &amp; &amp; \mathtt{\backslash cap} &amp;
&amp; \ast &amp; &amp; \mathtt{\backslash ast} &amp;
\\
&amp; \vee &amp; &amp; \mathtt{\backslash vee} &amp;
&amp; \wedge &amp; &amp; \mathtt{\backslash wedge} &amp;
&amp; \oplus &amp; &amp; \mathtt{\backslash oplus} &amp;
\\
&amp; \otimes &amp; &amp; \mathtt{\backslash otimes} &amp;
&amp; \ominus &amp; &amp; \mathtt{\backslash ominus} &amp;
&amp; \odot &amp; &amp; \mathtt{\backslash odot} &amp;
\end{align}
\]</span></p>
<h2 id="箭头符号">箭头符号</h2>
<p><span class="math display">\[
\begin{align}
&amp; \leftarrow &amp; &amp; \mathtt{\backslash leftarrow} &amp;
&amp; \rightarrow &amp; &amp; \mathtt{\backslash rightarrow} &amp;
\\
&amp; \uparrow &amp; &amp; \mathtt{\backslash uparrow} &amp;
&amp; \downarrow &amp; &amp; \mathtt{\backslash downarrow} &amp;
\\
&amp; \updownarrow &amp; &amp; \mathtt{\backslash updownarrow} &amp;
&amp; \leftrightarrow &amp; &amp; \mathtt{\backslash leftrightarrow}
&amp;
\\
\\
&amp; \nwarrow &amp; &amp; \mathtt{\backslash nwarrow} &amp;
&amp; \nearrow &amp; &amp; \mathtt{\backslash nearrow} &amp;
\\
&amp; \swarrow &amp; &amp; \mathtt{\backslash swarrow} &amp;
&amp; \searrow &amp; &amp; \mathtt{\backslash searrow} &amp;
\\
\\
&amp; \mapsto &amp; &amp; \mathtt{\backslash mapsto} &amp;
&amp; \rightleftharpoons &amp; &amp; \mathtt{\backslash
rightleftharpoons} &amp;
\\
&amp; \leftharpoonup &amp; &amp; \mathtt{\backslash leftharpoonup} &amp;
&amp; \rightharpoonup &amp; &amp; \mathtt{\backslash rightharpoonup}
&amp;
\\
&amp; \leftharpoondown &amp; &amp; \mathtt{\backslash leftharpoondown}
&amp;
&amp; \rightharpoondown &amp; &amp; \mathtt{\backslash rightharpoondown}
&amp;
\\
\\
&amp; \longleftarrow &amp; &amp; \mathtt{\backslash longleftarrow} &amp;
&amp; \longrightarrow &amp; &amp; \mathtt{\backslash longrightarrow}
&amp;
\\
&amp; \longleftrightarrow &amp; &amp; \mathtt{\backslash
longleftrightarrow} &amp;
&amp; \longmapsto &amp; &amp; \mathtt{\backslash longmapsto} &amp;
\\
\\
&amp; \Leftarrow &amp; &amp; \mathtt{\backslash Leftarrow} &amp;
&amp; \Rightarrow &amp; &amp; \mathtt{\backslash Rightarrow} &amp;
\\
&amp; \Uparrow &amp; &amp; \mathtt{\backslash Uparrow} &amp;
&amp; \Downarrow &amp; &amp; \mathtt{\backslash Downarrow} &amp;
\\
&amp; \Updownarrow &amp; &amp; \mathtt{\backslash Updownarrow} &amp;
&amp; \Leftrightarrow &amp; &amp; \mathtt{\backslash Leftrightarrow}
&amp;
\\
&amp; \Longleftarrow &amp; &amp; \mathtt{\backslash Longleftarrow} &amp;
&amp; \Longrightarrow &amp; &amp; \mathtt{\backslash Longrightarrow}
&amp;
\\
&amp; \Longleftrightarrow &amp; &amp; \mathtt{\backslash
Longleftrightarrow} &amp;
\end{align}
\]</span></p>
<p>注：当我们需要表示当且仅当关系是常用 <code>\Longleftrightarrow</code>
，为了简写，也可以使用 <code>\iff</code> （if and only if, 当且仅当)
来简化</p>
<h2 id="希腊字母">希腊字母</h2>
<p><span class="math display">\[
\begin{align}
&amp;\alpha &amp; &amp; \mathtt{\backslash alpha}&amp;  
&amp;\beta &amp; &amp; \mathtt{\backslash beta}&amp;
&amp;\gamma &amp; &amp; \mathtt{\backslash gamma}&amp;
\\
&amp;\delta &amp; &amp; \mathtt{\backslash delta}&amp;
&amp;\epsilon &amp; &amp; \mathtt{\backslash epsilon}&amp;
&amp;\zeta &amp; &amp; \mathtt{\backslash zeta}&amp;
\\
&amp;\eta &amp; &amp; \mathtt{\backslash eta}&amp;
&amp;\theta &amp; &amp; \mathtt{\backslash theta}&amp;
&amp;\iota &amp; &amp; \mathtt{\backslash iota}&amp;
\\
&amp;\kappa &amp; &amp; \mathtt{\backslash kappa}&amp;
&amp;\lambda &amp; &amp; \mathtt{\backslash lambda}&amp;
&amp;\mu &amp; &amp; \mathtt{\backslash mu}&amp;
\\
&amp;\nu &amp; &amp; \mathtt{\backslash nu}&amp;
&amp;\xi &amp; &amp; \mathtt{\backslash xi}&amp;
&amp;\omicron &amp; &amp; \mathtt{\backslash omicron}&amp;
\\
&amp;\pi &amp; &amp; \mathtt{\backslash pi}&amp;
&amp;\rho &amp; &amp; \mathtt{\backslash rho}&amp;
&amp;\sigma &amp; &amp; \mathtt{\backslash sigma}&amp;
\\
&amp;\tau &amp; &amp; \mathtt{\backslash tau}&amp;
&amp;\upsilon &amp; &amp; \mathtt{\backslash upsilon}&amp;
&amp;\phi &amp; &amp; \mathtt{\backslash phi}&amp;
\\
&amp;\chi &amp; &amp; \mathtt{\backslash chi}&amp;
&amp;\psi &amp; &amp; \mathtt{\backslash psi}&amp;
&amp;\omega &amp; &amp; \mathtt{\backslash omega}&amp;
\\
\\
&amp; \varepsilon &amp; &amp; \mathtt{\backslash varepsilon} &amp;
&amp; \vartheta &amp; &amp; \mathtt{\backslash vartheta} &amp;
&amp; \varpi &amp; &amp; \mathtt{\backslash varpi} &amp;
\\
&amp; \varrho &amp; &amp; \mathtt{\backslash varrho} &amp;
&amp; \varsigma &amp; &amp; \mathtt{\backslash varsigma} &amp;
&amp; \varphi &amp; &amp; \mathtt{\backslash varphi} &amp;
\\
&amp; \varkappa &amp; &amp; \mathtt{\backslash varkappa} &amp;
\\
\\
&amp;\Gamma &amp; &amp; \mathtt{\backslash Gamma}&amp;  
&amp; \Lambda &amp; &amp; \mathtt{\backslash Lambda} &amp;
&amp;\Sigma &amp; &amp; \mathtt{\backslash Sigma}&amp;  
\\
&amp; \Psi &amp; &amp; \mathtt{\backslash Psi} &amp;
&amp;\Delta &amp; &amp; \mathtt{\backslash Delta}&amp;  
&amp; \Xi &amp; &amp; \mathtt{\backslash Xi} &amp;
\\
&amp;\Upsilon &amp; &amp; \mathtt{\backslash Upsilon}&amp;  
&amp; \Omega &amp; &amp; \mathtt{\backslash Omega} &amp;
&amp;\Theta &amp; &amp; \mathtt{\backslash Theta}&amp;  
\\
&amp; \Pi &amp; &amp; \mathtt{\backslash Pi} &amp;
&amp;\Phi &amp; &amp; \mathtt{\backslash Phi}&amp;  
\end{align}
\]</span></p>
<h2 id="三角函数">三角函数</h2>
<p><span class="math display">\[
\begin{align}
&amp;\sin&amp; &amp;\mathtt{\backslash sin}&amp;
&amp;\cos&amp; &amp;\mathtt{\backslash cos}&amp;
\\
&amp;\tan&amp; &amp;\mathtt{\backslash tan}&amp;
&amp;\cot&amp; &amp;\mathtt{\backslash cot}&amp;
\\
&amp;\sec&amp; &amp;\mathtt{\backslash sec}&amp;
&amp;\csc&amp; &amp;\mathtt{\backslash csc}&amp;
\\
\\
&amp;\arcsin&amp; &amp;\mathtt{\backslash arcsin}&amp;
&amp;\arccos&amp; &amp;\mathtt{\backslash arccos}&amp;
\\
&amp;\arctan&amp; &amp;\mathtt{\backslash arctan}&amp;
\\
\\
&amp;\sinh&amp; &amp;\mathtt{\backslash sinh}&amp;
&amp;\cosh&amp; &amp;\mathtt{\backslash cosh}&amp;
\\
&amp;\tanh&amp; &amp;\mathtt{\backslash tanh}&amp;
&amp;\coth&amp; &amp;\mathtt{\backslash coth}&amp;
\\
\end{align}
\]</span></p>
<h2 id="其他符号">其他符号</h2>
<p><span class="math display">\[
\begin{align}
&amp; \infty &amp; &amp; \mathtt{\backslash infty} &amp;
&amp; \Re &amp; &amp; \mathtt{\backslash Re} &amp;
\\
&amp; \forall &amp; &amp; \mathtt{\backslash forall} &amp;
&amp; \exists &amp; &amp; \mathtt{\backslash exists} &amp;
\\
&amp; \nexists &amp; &amp; \mathtt{\backslash nexists} &amp;
&amp; \emptyset &amp; &amp; \mathtt{\backslash emptyset} &amp;
\\
&amp; \varnothing &amp; &amp; \mathtt{\backslash varnothing} &amp;
&amp; \top &amp; &amp; \mathtt{\backslash top} &amp;
\\
&amp; \partial &amp; &amp; \mathtt{\backslash partial} &amp;
&amp; \nabla &amp; &amp; \mathtt{\backslash nabla} &amp;
\end{align}
\]</span></p>
<h2 id="标识符号">标识符号</h2>
<p>有时我们可能需要在字母上添加上标（例如平均数 <span
class="math inline">\(\bar{x}\)</span>，估计值 <span
class="math inline">\(\hat{x}\)</span> 等），下标（下划线 <span
class="math inline">\(\underline{x}\)</span> ）等</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Result</th>
<th>Code</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a'</code> or <code>a^&#123;\prime&#125;</code></td>
<td><span class="math inline">\(a&#39;\)</span></td>
<td><code>a''</code></td>
<td><span class="math inline">\(a&#39;&#39;\)</span></td>
</tr>
<tr class="even">
<td><code>\hat&#123;a&#125;</code></td>
<td><span class="math inline">\(\hat{a}\)</span></td>
<td><code>\bar&#123;a&#125;</code></td>
<td><span class="math inline">\(\bar{a}\)</span></td>
</tr>
<tr class="odd">
<td><code>\acute&#123;a&#125;</code></td>
<td><span class="math inline">\(\acute{a}\)</span></td>
<td><code>\check&#123;a&#125;</code></td>
<td><span class="math inline">\(\check{a}\)</span></td>
</tr>
<tr class="even">
<td><code>\grave&#123;a&#125;</code></td>
<td><span class="math inline">\(\grave{a}\)</span></td>
<td><code>\dot&#123;a&#125;</code></td>
<td><span class="math inline">\(\dot{a}\)</span></td>
</tr>
<tr class="odd">
<td><code>\mathring&#123;a&#125;</code></td>
<td><span class="math inline">\(\mathring{a}\)</span></td>
<td><code>\breve&#123;a&#125;</code></td>
<td><span class="math inline">\(\breve{a}\)</span></td>
</tr>
<tr class="even">
<td><code>\tilde&#123;a&#125;</code></td>
<td><span class="math inline">\(\tilde{a}\)</span></td>
<td><code>\vec&#123;a&#125;</code></td>
<td><span class="math inline">\(\vec{a}\)</span></td>
</tr>
<tr class="odd">
<td><code>\underline&#123;a&#125;</code></td>
<td><span class="math inline">\(\underline{a}\)</span></td>
<td><code>\overline&#123;a&#125;</code></td>
<td><span class="math inline">\(\overline{a}\)</span></td>
</tr>
<tr class="even">
<td><code>\overrightarrow&#123;AB&#125;</code></td>
<td><span class="math inline">\(\overrightarrow{AB}\)</span></td>
<td><code>\overleftarrow&#123;AB&#125;</code></td>
<td><span class="math inline">\(\overleftarrow{AB}\)</span></td>
</tr>
<tr class="odd">
<td><code>\widehat&#123;AB&#125;</code></td>
<td><span class="math inline">\(\widehat{AB}\)</span></td>
<td><code>\widetilde&#123;AB&#125;</code></td>
<td><span class="math inline">\(\widetilde{AB}\)</span></td>
</tr>
</tbody>
</table>
<h2 id="括号">括号</h2>
<p>常见的括号 <code>()</code>、中括号 <code>[]</code>、以及大括号
<code>&#123;&#125;</code> 都可以直接在键盘中输入，由于大括号在 LaTex
中的特殊含义（用来包裹一段公式），我们使用时需要添加 <code>\</code>
进行转义，即 <code>\&#123;</code> 和 <code>\&#125;</code></p>
<p>对于竖线 <code>|</code> ，我们可以直接从键盘中输入，也可以使用
<code>\mid</code> 来表示，双竖线（范数的表示）可以使用 <code>\|</code>
来表示（不能使用两个竖线，因为双竖线应该表示为一个字符），示例如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\|</span>x<span class="keyword">\|</span><span class="built_in">_</span>2</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\|x\|_2
\]</span></p>
<p>其他分隔符表示如下 <span class="math display">\[
\begin{align}
&amp; / &amp; &amp; \mathtt{/} &amp;
&amp; \backslash &amp; &amp; \mathtt{\backslash backslash} &amp;
\\
&amp; \langle &amp; &amp; \mathtt{\backslash langle} &amp;
&amp; \rangle &amp; &amp; \mathtt{\backslash rangle} &amp;
\\
&amp; \lceil &amp; &amp; \mathtt{\backslash lceil} &amp;
&amp; \rceil &amp; &amp; \mathtt{\backslash rceil} &amp;
\\
&amp; \lfloor &amp; &amp; \mathtt{\backslash lfloor} &amp;
&amp; \rfloor &amp; &amp; \mathtt{\backslash rfloor} &amp;
\end{align}
\]</span></p>
<p>当我们使用这些括号包裹一个大的公式时，如下所示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2&#125;&#123;y<span class="built_in">^</span>3&#125;)</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
(\frac{x^2}{y^3})
\]</span></p>
<p>我们可以发现这个括号（parentheses）不能完全的包裹住公式，此时我们需要使用
<code>\left(...\right)</code> 来自动调整括号的大小</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>(<span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2&#125;&#123;y<span class="built_in">^</span>3&#125;<span class="keyword">\right</span>)</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left(\frac{x^2}{y^3}\right)
\]</span></p>
<p>除此之外，在中间表示时还可以使用 <code>\middle</code>
来进行控制（条件概率时）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">P<span class="keyword">\left</span>(A=2<span class="keyword">\middle</span>|<span class="keyword">\frac</span>&#123;A<span class="built_in">^</span>2&#125;&#123;B&#125;&gt;4<span class="keyword">\right</span>)</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
P\left(A=2\middle| \frac{A^2}{B}&gt;4\right)
\]</span></p>
<p>而对于花括号（curly
braces）和方括号（brackets）时，需要使用转义符进行转义
<code>\&#123;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span><span class="keyword">\&#123;</span><span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2&#125;&#123;y<span class="built_in">^</span>3&#125;<span class="keyword">\right</span><span class="keyword">\&#125;</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left\{\frac{x^2}{y^3}\right\}
\]</span></p>
<p>我们还可以使用 <code>.</code> 来忽略左侧或右侧符号</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>. <span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>3&#125;&#123;3&#125; <span class="keyword">\right</span>| <span class="built_in">_</span>0 <span class="built_in">^</span>1</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left.\frac{x^3}{3}\right|_0^1
\]</span></p>
<p>最终，如果我们还是不满意，可以手动调整符号的大小</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">( <span class="keyword">\big</span>( <span class="keyword">\Big</span>( <span class="keyword">\bigg</span>( <span class="keyword">\Bigg</span>(</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
( \big( \Big( \bigg( \Bigg(
\]</span></p>
<h2 id="空格">空格</h2>
<p>如果我们直接在公式中输入空格，如果直接在字母中间插入空格，会被直接忽略掉，如果我们明确需要插入空格，需要通过指令形式显式给出，在
LaTex 中空格相关的指令总结如下</p>
<table>
<thead>
<tr class="header">
<th>指令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>（space）</td>
<td>默认空格</td>
<td><span class="math inline">\(abc \rightarrow \leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>\,</code></td>
<td>短空格(3/18 em)</td>
<td><span class="math inline">\(abc \rightarrow\,\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>\!</code></td>
<td>短负空格(-3/18 em)</td>
<td><span class="math inline">\(abc \rightarrow \! \leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>!:</code></td>
<td>中空格(4/18 em)</td>
<td><span class="math inline">\(abc \rightarrow\:\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>!;</code></td>
<td>大空格(5/18 em)</td>
<td><span class="math inline">\(abc \rightarrow\;\leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>\enspace</code></td>
<td>0.5字宽空格 (0.5 em)</td>
<td><span class="math inline">\(abc \rightarrow\enspace\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>\quad</code></td>
<td>1字宽空格(1 em)</td>
<td><span class="math inline">\(abc \rightarrow\quad\leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>\qquad</code></td>
<td>2字宽空格(2 em)</td>
<td><span class="math inline">\(abc \rightarrow\qquad\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>\hspace&#123;3em&#125;</code></td>
<td>自定义宽度空格</td>
<td><span class="math inline">\(abc \rightarrow\hspace{3em}\leftarrow
abc\)</span></td>
</tr>
</tbody>
</table>
<p>注：em 是一种长度单位，和 px 意义，但是其是相对字宽来度量的，1 em
就表示一个字宽</p>
<p>空格在积分公式的书写上十分有用，如果我们直接写的话，如下所示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\int</span> y <span class="keyword">\mathrm</span>&#123;d&#125; x</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\int y \mathrm{d} x
\]</span></p>
<p>我们可以看到被积函数 <span class="math inline">\(y\)</span> 和微元
<span class="math inline">\(\mathrm{d}x\)</span>
之间距离太短，看起来不是很自然，此时我们就可以在二者之间插入一个小的空白，如下所示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\int</span> y <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125; x</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\int y \,\mathrm{d} x
\]</span></p>
<p>这样看起来就十分自然了。</p>
<p>另外一个示例就是分段函数的表示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">f(n) = </span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">n / 2 <span class="built_in">&amp;</span> <span class="keyword">\quad</span> <span class="keyword">\text</span>&#123;if &#125; n <span class="keyword">\text</span>&#123; is even&#125; <span class="keyword">\\</span></span><br><span class="line">-(n+1)/2 <span class="built_in">&amp;</span> <span class="keyword">\quad</span> <span class="keyword">\text</span>&#123;if &#125; n <span class="keyword">\text</span>&#123; is odd&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
f(n) =
\begin{cases}
n / 2 &amp; \quad \text{if } n \text{ is even} \\
-(n+1)/2 &amp; \quad \text{if } n \text{ is odd}
\end{cases}
\]</span></p>
<h1 id="字体">字体</h1>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Command</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Upright Roman Font</td>
<td><code>\mathrm&#123;&#125;</code></td>
<td><span class="math inline">\(\mathrm{x}\)</span></td>
</tr>
<tr class="even">
<td>Normal Italic Font</td>
<td><code>\mathnormal&#123;&#125;</code></td>
<td><span class="math inline">\(\mathnormal{x}\)</span></td>
</tr>
<tr class="odd">
<td>Calligraphic Font</td>
<td><code>\mathcal&#123;&#125;</code></td>
<td><span class="math inline">\(\mathcal{X}\)</span></td>
</tr>
<tr class="even">
<td>Upright Roman Boldface</td>
<td><code>\mathbf&#123;&#125;</code></td>
<td><span class="math inline">\(\mathbf{x}\)</span></td>
</tr>
<tr class="odd">
<td>Upright Sans Serif</td>
<td><code>\mathsf&#123;&#125;</code></td>
<td><span class="math inline">\(\mathsf{x}\)</span></td>
</tr>
<tr class="even">
<td>Italic Font</td>
<td><code>\mathit&#123;&#125;</code></td>
<td><span class="math inline">\(\mathit{x}\)</span></td>
</tr>
<tr class="odd">
<td>Typewritter Font</td>
<td><code>\mathtt&#123;&#125;</code></td>
<td><span class="math inline">\(\mathtt{x}\)</span></td>
</tr>
<tr class="even">
<td>Blackboard Bold Font</td>
<td><code>\mathbb&#123;&#125;</code></td>
<td><span class="math inline">\(\mathbb{X}\)</span></td>
</tr>
<tr class="odd">
<td>Eular Calligraphic Font</td>
<td><code>\mathscr&#123;&#125;</code></td>
<td><span class="math inline">\(\mathscr{X}\)</span></td>
</tr>
<tr class="even">
<td>Fraktur(Gothic) Font</td>
<td><code>\mathfrak&#123;&#125;</code></td>
<td><span class="math inline">\(\mathfrak{X}\)</span></td>
</tr>
</tbody>
</table>
<p>注：</p>
<ol type="1">
<li>Calligraphic 表示书法体（花体），Euler Calligraphic
为欧拉手稿字体</li>
<li>Sans Serif 表示非衬线字体（不包含其他多余的笔画）</li>
<li>Boldface 表示粗体</li>
<li>Typewriter Font 是等宽字体</li>
<li>如果不加任何标注，默认的字体就是 Normal Italic Font，也就是 Roman
字体的斜体形式，如 <span class="math inline">\(hello\)</span></li>
</ol>
<h1 id="常用公式写法">常用公式写法</h1>
<h2 id="三角函数-1">三角函数</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\cos</span> (2<span class="keyword">\theta</span>) = <span class="keyword">\cos</span><span class="built_in">^</span>2 <span class="keyword">\theta</span> - <span class="keyword">\sin</span><span class="built_in">^</span>2 <span class="keyword">\theta</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\cos (2\theta) = \cos^2 \theta - \sin^2 \theta
\]</span></p>
<h2 id="极限">极限</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\lim</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;x <span class="keyword">\to</span> <span class="keyword">\infty</span>&#125; <span class="keyword">\exp</span>(-x) = 0</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\lim\limits_{x \to \infty} \exp(-x) = 0
\]</span></p>
<p><code>\limits</code> 指令将后续紧跟的上标 <code>^</code> 和下标
<code>_</code>
放置在当前符号的上方（不写的其实也可以正常渲染，但是加上比较符合我们的观察）</p>
<h2 id="取模">取模</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">&amp;</span> a <span class="keyword">\bmod</span> b <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> x <span class="keyword">\equiv</span> a <span class="keyword">\pmod</span>&#123;b&#125; </span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
&amp; a \bmod b \\
&amp; x \equiv a \pmod{b}
\end{align}
\]</span></p>
<h2 id="上下标">上下标</h2>
<p>通过 <code>_</code> 表示下标，<code>^</code>
表示上标，如果需要将一块一整体进行上标，需要使用 <code>&#123;&#125;</code>
进行包裹</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">n<span class="built_in">^</span>&#123;22&#125; <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line">k<span class="built_in">_</span>&#123;n+1&#125; <span class="built_in">&amp;</span> = n<span class="built_in">^</span>2 + k<span class="built_in">_</span>n<span class="built_in">^</span>2 - k<span class="built_in">_</span>&#123;n-1&#125; <span class="keyword">\\</span></span><br><span class="line">f(n) <span class="built_in">&amp;</span> = <span class="keyword">\left</span>. n<span class="built_in">^</span>5 + 4n<span class="built_in">^</span>2 + 2 <span class="keyword">\right</span>|<span class="built_in">_</span>&#123;n=17&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
n^{22} &amp; \\
k_{n+1} &amp; = n^2 + k_n^2 - k_{n-1} \\
f(n) &amp; = \left. n^5 + 4n^2 + 2 \right|_{n=17}
\end{align}
\]</span></p>
<h2 id="分数和二项式系数">分数和二项式系数</h2>
<p>使用 <code>\frac&#123;numerator&#125;&#123;denominator&#125;</code>
来表示分数（numerator表示分子，denominator表示分母）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;n!&#125;&#123;k!(n-k)!&#125; = <span class="keyword">\binom</span>&#123;n&#125;&#123;k&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\frac{n!}{k!(n-k)!} = \binom{n}{k}
\]</span></p>
<p>分数也可以进行嵌套</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\frac</span>&#123;1&#125;&#123;x&#125;+<span class="keyword">\frac</span>&#123;1&#125;&#123;y&#125;&#125;&#123;y-z&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\frac{\frac{1}{x}+\frac{1}{y}}{y-z}
\]</span></p>
<p>为了在一行表示分数，我们也可以将分数表示为斜线形式</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">^</span>3/<span class="built_in">_</span>7 <span class="keyword">\quad</span> 3 / 7</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
^3/_7 \quad 3 / 7
\]</span> 使用 <code>\frac&#123;...&#125;&#123;...&#125;</code>
我们也可以表示其他内容，例如乘法和加法公式</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;array&#125;[b]&#123;r&#125;</span><br><span class="line">		<span class="keyword">\left</span>( x<span class="built_in">_</span>1 x<span class="built_in">_</span>2 <span class="keyword">\right</span>) <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\times</span> <span class="keyword">\left</span>( x&#x27;<span class="built_in">_</span>1 x&#x27;<span class="built_in">_</span>2 <span class="keyword">\right</span>)</span><br><span class="line">	<span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line">&#125;&#123;</span><br><span class="line">	<span class="keyword">\left</span>( y<span class="built_in">_</span>1 y<span class="built_in">_</span>2 y<span class="built_in">_</span>3 y<span class="built_in">_</span>4 <span class="keyword">\right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\frac{
\begin{array}[b]{r}
\left( x_1 x_2 \right)\\
\times \left(x&#39;_1 x&#39;_2\right)
\end{array}
}{
\left( y_1y_2y_3y_4 \right)
}
\]</span></p>
<p>其中对齐公式使用的 <code>\align</code> 以及
<code>\begin&#123;&#125;...\end&#123;&#125;</code> 会单独进行详细地介绍。</p>
<h2 id="根式">根式</h2>
<p>使用 <code>\sqrt&#123;...&#125;</code>
来表示根号，默认为2，也可以指定为其他幂次，通过<code>\sqrt[n]&#123;&#125;</code>
来指定</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span>[n]&#123;1 + x + x<span class="built_in">^</span>2 + x<span class="built_in">^</span>3 +<span class="keyword">\cdots</span> + x<span class="built_in">^</span>n&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\sqrt[n]{1+x+x^2+x^3+\cdots+x^n}
\]</span></p>
<h2 id="求和乘积与积分">求和、乘积与积分</h2>
<p>通过 <code>\sum _&#123;&#125; ^&#123;&#125; &#123;&#125;</code> 来表示大型加法表达式，如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\sum</span> <span class="built_in">_</span>&#123;i=1&#125; <span class="built_in">^</span>&#123;<span class="keyword">\infty</span>&#125; x<span class="built_in">^</span>i</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\sum _{i=1} ^{\infty} x^i
\]</span></p>
<p>对于连乘也是类似 <code>\prod _&#123;&#125; ^&#123;&#125; &#123;&#125;</code>
来表示大型乘法表达式，如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\prod</span> <span class="built_in">_</span>&#123;i=1&#125; <span class="built_in">^</span>&#123;n&#125; x<span class="built_in">^</span>i</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\prod _{i=1} ^{n} x^i
\]</span></p>
<p>积分（integral），通过 <code>\int _&#123;&#125; ^&#123;&#125; &#123;&#125;</code>
来表示积分符号</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\int</span> <span class="built_in">_</span>&#123;0&#125; <span class="built_in">^</span>&#123;<span class="keyword">\pi</span>&#125; <span class="keyword">\sin</span> x <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;x</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\int _{0} ^{\pi} \sin x \,\mathrm{d}x
\]</span></p>
<p>除了一重积分外，我们还有各种各样的积分符号，如二重积分、三重积分、曲面积分等等，其使用的积分符号也有相应的变化</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\iint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(u,v) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;v</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\iiint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(u,v,w) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;v<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;w</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\iiiint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(t,u,v,w) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;t<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;v<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;w</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\idotsint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(u<span class="built_in">_</span>1,<span class="keyword">\dots</span>,u<span class="built_in">_</span>k) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="built_in">_</span>1 <span class="keyword">\dots</span> <span class="keyword">\mathrm</span>&#123;d&#125;u<span class="built_in">_</span>k</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
&amp; \iint \limits _V \mu(u,v) \,\mathrm{d}u\,\mathrm{d}v
\\
&amp; \iiint \limits _V \mu(u,v,w)
\,\mathrm{d}u\,\mathrm{d}v\,\mathrm{d}w
\\
&amp; \iiiint \limits _V \mu(t,u,v,w)
\,\mathrm{d}t\,\mathrm{d}u\,\mathrm{d}v\,\mathrm{d}w
\\
&amp; \idotsint \limits _V \mu(u_1,\dots,u_k) \,\mathrm{d}u_1 \dots
\mathrm{d}u_k
\end{align}
\]</span></p>
<h2 id="矩阵">矩阵</h2>
<p>对于矩阵而言，需要使用 <code>\begin&#123;&#125;...\end&#123;&#125;</code>
来包裹（对齐）</p>
<p>普通矩阵</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{matrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{matrix}
\]</span></p>
<p>括号矩阵（<code>pmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{pmatrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{pmatrix}
\]</span></p>
<p>方括号矩阵（<code>bmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{bmatrix}
\]</span></p>
<p>花括号矩阵（<code>Bmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Bmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{Bmatrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{Bmatrix}
\]</span></p>
<p>竖线矩阵（<code>vmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6<span class="keyword">\\</span></span><br><span class="line">7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{vmatrix}
1 &amp; 2 &amp; 3\\
4 &amp; 5 &amp; 6\\
7 &amp; 8 &amp; 9
\end{vmatrix}
\]</span></p>
<p>双数竖线矩阵（<code>Vmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Vmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6<span class="keyword">\\</span></span><br><span class="line">7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{Vmatrix}
1 &amp; 2 &amp; 3\\
4 &amp; 5 &amp; 6\\
7 &amp; 8 &amp; 9
\end{Vmatrix}
\]</span></p>
<p>我们也可以使用其他分界符搭配 <code>\left ... \right</code>
来构造其他形式，例如</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\left</span><span class="keyword">\langle</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\right</span><span class="keyword">\rangle</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left\langle
\begin{matrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{matrix}
\right\rangle
\]</span></p>
<p>如果想在一行显示矩阵，我们可以使用 <code>smallmatrix</code> 布局</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span> <span class="keyword">\big</span>(<span class="keyword">\begin</span>&#123;smallmatrix&#125;</span><br><span class="line">  a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">  c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;smallmatrix&#125;<span class="keyword">\big</span>)<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>这一行包含矩阵公式：<span
class="math inline">\(\big(\begin{smallmatrix}a&amp;b\\c&amp;d\end{smallmatrix}\big)\)</span></p>
<p>注：在 markdown 中，内联公式必须在同一行</p>
<p>(但是这一行不是很好写捏:(</p>
<h1 id="公式的对齐">公式的对齐</h1>
<h2 id="对齐显示">对齐显示</h2>
<p>使用 <code>align</code> 来表示多行对齐公式（还有一个
<code>align</code> ，其效果和 <code>align</code>
类似，只不过二者使用场景不一样，在 markdown 需要对齐的话使用
<code>align</code> 基本就可以了），使用 <code>\\</code>
来换行，<code>&amp;</code> 来指示需要对齐的位置</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">A <span class="built_in">&amp;</span> = <span class="keyword">\frac</span>&#123;<span class="keyword">\pi</span> r<span class="built_in">^</span>2&#125;&#123;2&#125; <span class="keyword">\\</span></span><br><span class="line">  <span class="built_in">&amp;</span> = <span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125; <span class="keyword">\pi</span> r<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
A &amp; = \frac{\pi r^2}{2} \\
&amp; = \frac{1}{2} \pi r^2
\end{align}
\]</span></p>
<p>这样就可以在等号处对齐了。</p>
<p>我们也可以使用 <code>align</code> 实现表格式的对齐，示例如下：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) = a x<span class="built_in">^</span>2 + b x + c <span class="keyword">\quad</span>  g(x) = d x<span class="built_in">^</span>3 <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) = 2 a x + b  <span class="keyword">\quad</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2 </span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) = a x^2 + b x + c \quad  g(x) = d x^3 \\
f&#39;(x) = 2 a x + b  \quad g&#39;(x) = 3 d x ^2
\end{align}
\]</span></p>
<p>我们的目标是将两个公式分别在等号处对齐。</p>
<p>首先观察一下其对齐情况，可以看到两行公式目前在末尾处是对齐的，这就相当于我们在末尾加上了一个
<code>&amp;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) = a x<span class="built_in">^</span>2 + b x + c <span class="keyword">\quad</span>  g(x) = d x<span class="built_in">^</span>3 <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) = 2 a x + b  <span class="keyword">\quad</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2 <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) = a x^2 + b x + c \quad  g(x) = d x^3 &amp; \\
f&#39;(x) = 2 a x + b  \quad g&#39;(x) = 3 d x ^2 &amp;
\end{align}
\]</span></p>
<p>如果用表格来描述这个公式，如下所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;"><span class="math inline">\(f(x) = a x^2
+ b x + c \quad  g(x) = d x^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span class="math inline">\(f&#39;(x) = 2
a x + b  \quad g&#39;(x) = 3 d x ^2\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>如果我们想要公式在第一个等于号时对齐，那么在等号前加上
<code>&amp;</code>，如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= a x<span class="built_in">^</span>2 + b x + c <span class="keyword">\quad</span>  g(x) = d x<span class="built_in">^</span>3 <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) <span class="built_in">&amp;</span>= 2 a x + b  <span class="keyword">\quad</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2 <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) &amp;= a x^2 + b x + c \quad  g(x) = d x^3 &amp; \\
f&#39;(x) &amp;= 2 a x + b  \quad g&#39;(x) = 3 d x ^2 &amp;
\end{align}
\]</span></p>
<p>可以观察到，此时在 <span class="math inline">\(f(x)\)</span> 和 <span
class="math inline">\(f&#39;(x)\)</span>
后的等号对齐了，但是其末尾处并不对齐了</p>
<p>此时我们将其表格化，如下所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th style="text-align: left;"><span
class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">$f(x) $</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><span class="math inline">\(=a x^2 + b x +
c \quad  g(x) = d x^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span
class="math inline">\(f&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><span class="math inline">\(= 2 a x +
b  \quad g&#39;(x) = 3 d x ^2\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>可以看到，我们插入的 <code>&amp;</code> 将公式划分成了两列，而在
<code>&amp;</code> 左侧的列为右对齐，右侧的列为左对齐，这样就形成了在
<code>&amp;</code>
处对齐的效果，由于后半部所在的列已经左对齐了，自然也就不能在末尾处对齐了。</p>
<p>我们继续对公式进行修改，将 <code>\quad</code> 替换为
<code>&amp;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= a x<span class="built_in">^</span>2 + b x + c <span class="built_in">&amp;</span>  g(x) = d x<span class="built_in">^</span>3 <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) <span class="built_in">&amp;</span>= 2 a x + b  <span class="built_in">&amp;</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) &amp;= a x^2 + b x + c &amp;  g(x) = d x^3 \\
f&#39;(x) &amp;= 2 a x + b  &amp; g&#39;(x) = 3 d x ^2
\end{align}
\]</span></p>
<p>此时可以发现公式又在末尾处对齐了，将其转化成表格</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th><span class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">$f(x) $</td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=a x^2 + b x + c\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span class="math inline">\(g(x) = d
x^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span
class="math inline">\(f&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(= 2 a x + b\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span class="math inline">\(g&#39;(x) = 3
d x ^2\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>最后我们在 <span class="math inline">\(g(x)\)</span> 和 <span
class="math inline">\(g&#39;(x)\)</span> 后添加 <code>&amp;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= a x<span class="built_in">^</span>2 + b x + c <span class="built_in">&amp;</span>  g(x) <span class="built_in">&amp;</span> = d x<span class="built_in">^</span>3 <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) <span class="built_in">&amp;</span>= 2 a x + b  <span class="built_in">&amp;</span> g&#x27;(x)  <span class="built_in">&amp;</span> = 3 d x <span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) &amp;= a x^2 + b x + c &amp;  g(x) &amp; = d x^3 \\
f&#39;(x) &amp;= 2 a x + b  &amp; g&#39;(x)  &amp; = 3 d x ^2
\end{align}
\]</span></p>
<p>最终的表格如下所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th><span class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th><span class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;"><span
class="math inline">\(f(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=ax^2+bx+c\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span
class="math inline">\(g(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=dx^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span
class="math inline">\(f&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(= 2 a x + b\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span
class="math inline">\(g&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=3dx^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>从上面的解析中可以看出，<code>&amp;</code> 有两个作用</p>
<ol type="1">
<li>分块，以 <code>&amp;</code> 为中心划分成左右两部分</li>
<li>如果左侧列没有对齐的话，优先右对齐，对于右侧列同理，优先左对齐</li>
</ol>
<p>这样我们参照上面的表格，第一个和第三个 <code>&amp;</code>
左右两侧都是如此，但是第二个 <code>&amp;</code>
由于其左侧块已经有对齐方式了（左对齐），无法再进行布局安排，因此这个
<code>&amp;</code> 只起到了第一个作用，第二个已经自动忽略了。</p>
<p>Tips：如果想实现列表形式的公式展示，可以将 <code>&amp;</code>
作为列的分割符，对于一列，我们直接使用 <code>&amp; a &amp;</code>
包裹即可（左对齐）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">&amp;</span> a <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> c <span class="built_in">&amp;</span> d <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> e <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> g <span class="built_in">&amp;</span> h <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
&amp; a &amp; &amp; b &amp; &amp; c &amp; d &amp; \\
&amp; e &amp; &amp; f &amp; &amp; g &amp; h &amp;
\end{align}
\]</span></p>
<p>这样虽然有些冗余，但是使用起来比较简单，无需思考 <code>&amp;</code>
放置的位置</p>
<h2 id="居中显示">居中显示</h2>
<p>相比于自定义对齐，居中显示就显得简单很多，使用 <code>gather</code>
即可</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;gather&#125;</span><br><span class="line">2x - 5y =  8 <span class="keyword">\\</span> </span><br><span class="line">3x<span class="built_in">^</span>2 + 9y =  3a + c</span><br><span class="line"><span class="keyword">\end</span>&#123;gather&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{gather}
2x - 5y =  8 \\
3x^2 + 9y =  3a + c
\end{gather}
\]</span></p>
<h1 id="导入其他包">导入其他包</h1>
<p>有时候我们想要在 MathJax 中使用其他宏包，例如 Physics
宏，我们可以直接在 LaTex 代码中使用 <code>require&#123;...&#125;</code>
来添加扩展。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\require</span>&#123;physics&#125;</span><br><span class="line"><span class="keyword">\abs</span>&#123;a&#125; <span class="keyword">\quad</span> <span class="keyword">\grad</span>&#123;x&#125; <span class="keyword">\quad</span> <span class="keyword">\order</span>&#123;1&#125; <span class="keyword">\quad</span> <span class="keyword">\cross</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>开启 Physics 宏之后渲染结果 <span class="math display">\[
\require{physics}
\abs{a} \quad \grad{x} \quad \order{1} \quad \cross
\]</span> 如果加载失败，将会显示如下结果</p>
<p><img data-src="/posts/caff/no-physics-error.svg" /></p>
<p>不过感觉 <code>require&#123;&#125;</code> 功能在 mathjax
中还有点问题，最好还是在设置中手动开启。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://en.wikibooks.org/wiki/LaTeX/Mathematics">LaTeX/Mathematics
- Wikibooks, open books for an open world</a></li>
<li><a
href="https://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics">LaTeX/Advanced
Mathematics - Wikibooks, open books for an open world</a></li>
<li><a
href="https://kapeli.com/cheat_sheets/LaTeX_Math_Symbols.docset/Contents/Resources/Documents/index">LaTeX
Math Symbols Cheat Sheet - Kapeli</a></li>
<li><a
href="https://www.overleaf.com/learn/latex/Mathematical_expressions">Mathematical
expressions - Overleaf, Online LaTeX Editor</a></li>
</ol>
]]></content>
      <categories>
        <category>Hexo使用记录</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo自定义插件</title>
    <url>/posts/9a20/</url>
    <content><![CDATA[<h1 id="hexo-plugin">Hexo Plugin</h1>
<p>参考官方<a
href="https://hexo.io/zh-cn/docs/plugins">文档</a>，我们有两种创建插件方式</p>
<ol type="1">
<li>以脚本（Scripts）形式（单个文件）</li>
<li>以 npm package 形式创建（支持多文件）</li>
</ol>
<p>对于一般的插件而言，如果代码并不复杂且依赖较少，可以直接写成脚本形式，放在
hexo 根目录下的 <code>scripts</code>
文件夹即可（不存在直接创建一个即可），在介绍插件具体写法之前，先看一个简单的例子：</p>
<p>文件：<code>scripts/test.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line">  log.<span class="title function_">debug</span>(<span class="string">&quot;hello from test.js!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后执行下列命令查看效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate --debug</span><br></pre></td></tr></table></figure>

<p>这一条命令包含两个子命令，<code>hexo clean</code>
清除之前的生成文件，之后的 <code>hexo generate</code>
用来生成静态页面文件。</p>
<p>（<code>--debug</code> 标志会使 hexo 在终端显示调试信息，在所有的
hexo-cli 命令中都可以使用）</p>
<span id="more"></span>

<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; hexo clean &amp;&amp; hexo generate --debug</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deleted database.</span><br><span class="line">INFO  Deleted public folder.</span><br><span class="line">03:05:12.393 DEBUG Writing database to D:\hexo-temp\db.json</span><br><span class="line">03:05:12.401 DEBUG Hexo version: 6.3.0</span><br><span class="line">...</span><br><span class="line">03:05:12.483 INFO  Validating config</span><br><span class="line">...</span><br><span class="line">03:05:12.651 DEBUG Script loaded: scripts\test.js</span><br><span class="line">03:05:12.652 INFO  Start processing</span><br><span class="line">...</span><br><span class="line">03:05:12.717 DEBUG hello from test.js!!!</span><br><span class="line">...</span><br><span class="line">03:05:12.742 INFO  Files loaded <span class="keyword">in</span> 90 ms</span><br><span class="line">...</span><br><span class="line">03:05:12.915 INFO  Generated: archives/2023/index.html</span><br><span class="line">...</span><br><span class="line">03:05:12.922 INFO  17 files generated <span class="keyword">in</span> 180 ms</span><br><span class="line">03:05:12.924 DEBUG Database saved</span><br></pre></td></tr></table></figure>

<p>从输出中我们可以看到，在 <code>Validating config</code>
过程中加载了我们创建的脚本，而在 <code>Start processing</code>
后执行了我们的脚本，并通过 debug 输出了对应的语句。</p>
<p>这样我们就实现了一个简单的 hexo
插件（十分简单，没有对输入的数据做任何处理，打印一条语句后就退出了）。</p>
<h2 id="plugin-写法">plugin 写法</h2>
<p>参考官方<a
href="https://hexo.io/zh-cn/api">文档</a>的扩展部分，其给出了所有插件的种类</p>
<p><img data-src="/posts/9a20/image-20230116112529108.png"
style="zoom: 50%;" /></p>
<p>例如我们之前写的 filter 插件，其<a
href="https://hexo.io/zh-cn/api/filter">文档</a>如下</p>
<p><img data-src="/posts/9a20/image-20230116113313750.png"
style="zoom:50%;" /></p>
<p>所有的插件都可以采用类似的方式实现，通过
<code>hexo.extend.xxx.register</code>
来注册插件，指定好对应的处理函数即可。</p>
<h2 id="基本模板">基本模板</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.&lt;extend-type&gt;.<span class="title function_">register</span>(name,&lt;args&gt;,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;,&lt;extend-args&gt;)</span><br></pre></td></tr></table></figure>

<p>考虑到箭头函数和普通函数的区别，在函数内部我们获取 hexo
变量的方式不一样，在箭头函数中没有 this 指针，我们需要通过一个全局 hexo
变量进行访问即可，而普通函数会包含 this 指针，而 hexo
在调用函数时会将自身绑定到 this 指针上，这样我们可以直接通过 this 访问
hexo 相关变量。</p>
<p>对应代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrow_function1</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = <span class="variable language_">this</span>;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from arrow_function1!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrow_function2</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from arrow_function2!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> normal_function1 = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = <span class="variable language_">this</span>;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from normal_function1!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> normal_function2 = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from normal_function2!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, arrow_function1);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, arrow_function2);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, normal_function1);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, normal_function2);</span><br></pre></td></tr></table></figure>

<p>对应执行结果（<code>hexo clean &amp;&amp; hexo generate --debug</code>
)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">03</span>:<span class="number">55</span>:<span class="number">44.819</span> <span class="variable constant_">DEBUG</span> hello <span class="keyword">from</span> arrow_function2!!!</span><br><span class="line"><span class="number">03</span>:<span class="number">55</span>:<span class="number">44.819</span> <span class="variable constant_">DEBUG</span> hello <span class="keyword">from</span> vanilla_function1!!!</span><br><span class="line"><span class="number">03</span>:<span class="number">55</span>:<span class="number">44.820</span> <span class="variable constant_">DEBUG</span> hello <span class="keyword">from</span> vanilla_function2!!!</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>从执行结果中可以看到，在箭头函数（arrow function）中不包含 this
指针，我们无法通过 this 来访问 hexo 的变量，但是可以直接通过 hexo
全局变量来访问，对于普通函数（normal function）而言，可以通过 this
来访问 hexo，也可以直接通过全局变量 hexo 来访问。</p>
<p>由于脚本模式实际上实在 js 中通过字符串形式执行的，最好在开头处添加
<code>use strict</code> 来标识，确保插件能正常执行。</p>
<p>注：导入包的时候我们只能使用 common js 的包，并不支持 es6
模式的包，即我们不能通过一下模式导入包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unified &#125; <span class="keyword">from</span> <span class="string">&#x27;unified&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>(unified 是一个<a
href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">纯
es6 模块</a>，不支持 comman js 导入)</p>
<p>而必须使用 common js 的导包方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; red &#125; = <span class="built_in">require</span>(<span class="string">&#x27;picocolors&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="日志输出">日志输出</h2>
<p>通过 <code>hexo.log</code> 我们可以拿到 hexo
的日志输出对象，其具体实现在 <a
href="https://github.com/hexojs/hexo-log">hexo-log</a>
中，和普通的日志输出模块类似，其也支持不同级别的日志输出和颜色输出，具体通过
<code>picocolors</code> 库来控制输出的颜色，示例如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line"><span class="keyword">const</span> &#123;red,green,blue,magenta,cyan&#125; = <span class="built_in">require</span>(<span class="string">&#x27;picocolors&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  log.<span class="title function_">trace</span>(<span class="string">&quot;this is a trace message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">debug</span>(<span class="string">&quot;this is a debug message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a info message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">warn</span>(<span class="string">&quot;this is a warn message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">error</span>(<span class="string">&quot;this is a error message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">fatal</span>(<span class="string">&quot;this is a fatal message&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a red&quot;</span>,<span class="title function_">red</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a green&quot;</span>,<span class="title function_">green</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a blue&quot;</span>,<span class="title function_">blue</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a magenta&quot;</span>,<span class="title function_">magenta</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a cyan&quot;</span>,<span class="title function_">cyan</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对应输出结果</p>
<p><img data-src="/posts/9a20/image-20230116121200965.png"
style="zoom:67%;" /></p>
<h1 id="pandoc-renderer">Pandoc Renderer</h1>
<h2 id="目的">目的</h2>
<p>在前一篇文章中，我们配置好了 hexo
的静态文件处理方式，将所有的图片都放置在了 <code>source/images</code>
路径下，并通过设置 markdown 的 front matter 使得 typora
可以正确显示图片。</p>
<p>但是这种方法<strong>耦合性太强</strong>，所有图片都放在 images
文件夹不说，如果我们换一个 markdown 编辑器，就无法实现正确的预览了。</p>
<p>为此，我们需要调整 hexo 中图片资源管理方式，将 markdown
文件中图片链接全部替换为相对路径。</p>
<h2 id="问题">问题</h2>
<p>首先我们需要对之前的配置进行一些调整，修改
<code>_config.yaml</code>，开启资源文件后处理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>参考官方文档，其会在创建 post文件 的同时创建和 post文件
同名的文件夹，用来存储资源文件，而后在生成站点时将图片拷贝到默认文件夹下。</p>
<p>修改配置后，我们创建一个 post 来查看一下效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;c++学习笔记&quot;</span></span><br></pre></td></tr></table></figure>

<p>（取这个名字还有一个就是文件名实际上和文章的标题不一定会对应，如果包含特殊的字符会进行调整）</p>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; hexo new post <span class="string">&quot;c++学习笔记&quot;</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: D:\hexo-temp\<span class="built_in">source</span>\_posts\c-学习笔记.md</span><br></pre></td></tr></table></figure>

<p>可以看到 markdown 文件名变成了 <code>c-学习笔记</code>，将
<code>++</code> 替换成了 <code>-</code>，同时在当前目录下也创建了
<code>c-学习笔记</code> 文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp\<span class="built_in">source</span>\_posts&gt; tree /F</span><br><span class="line">卷 Data 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 4000-728D</span><br><span class="line">D:.</span><br><span class="line">│  c-学习笔记.md</span><br><span class="line">│  hello-world.md</span><br><span class="line">│</span><br><span class="line">└─c-学习笔记</span><br><span class="line">        hexo.png</span><br></pre></td></tr></table></figure>

<p>（在 powershell 中也提供了 <code>tree</code> 命令，使用方式和 linux
下的差别较大，传参居然是用 <code>/&lt;argument&gt;</code>
的形式，怪怪的，查看帮助使用 <code>/?</code> 而不是 linux 中的
<code>--help</code> 或 <code>-h</code>）</p>
<p>此时我们在 markdown 文档中插入一张图片测试一下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: c++学习笔记</span><br><span class="line">date: 2023-01-16 13:30:31</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">测试图片：</span><br><span class="line"></span><br><span class="line">![<span class="string">测试图片</span>](<span class="link">c-学习笔记/hexo.png</span>)</span><br></pre></td></tr></table></figure>

<p>本地预览结果</p>
<p><img data-src="/posts/9a20/image-20230116134147690.png"
style="zoom:50%;" /></p>
<p>生成静态页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate</span><br></pre></td></tr></table></figure>

<p>生成的文件位于根目录的 <code>public</code> 下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; tree /F public</span><br><span class="line">卷 Data 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 00000048 4000:728D</span><br><span class="line">D:\HEXO-TEMP\PUBLIC</span><br><span class="line">│  index.html</span><br><span class="line">│</span><br><span class="line">├─2023</span><br><span class="line">│  └─01</span><br><span class="line">│      ├─15</span><br><span class="line">│      │  └─hello-world</span><br><span class="line">│      │          index.html</span><br><span class="line">│      │</span><br><span class="line">│      └─16</span><br><span class="line">│          └─c-学习笔记</span><br><span class="line">│                  hexo.png</span><br><span class="line">│                  index.html</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，我们插入的图片也被拷贝到了 public
下的同名文件中，但是在生成的 <code>index.html</code>
中我们可以看到，图片链接不对，在网页中自然无法正确显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;e-content article-entry&quot;</span> <span class="attr">itemprop</span>=<span class="string">&quot;articleBody&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>测试图片：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/hexo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;测试图片&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</code> 是中文
<code>学习笔记</code> 进行 UTF-8 编码后的 URL 表示形式 (urlencode)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; python</span><br><span class="line">Python 3.9.12 (main, Apr  4 2022, 05:22:27) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; s = <span class="string">&quot;学习笔记&quot;</span></span><br><span class="line">&gt;&gt;&gt; s.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;\xe5\xad\xa6\xe4\xb9\xa0\xe7\xac\x94\xe8\xae\xb0&#x27;</span></span><br><span class="line">&gt;&gt;&gt; from urllib.parse import quote    </span><br><span class="line">&gt;&gt;&gt; quote(s)</span><br><span class="line"><span class="string">&#x27;%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果我们对文章采用了永久编码，例如 <code>hexo-abbrlink</code> 等，在
public 下文章名就会对应变成永久链接名称。</p>
<p>此时我们已经发现问题了，<strong>图片对应的URI应该是
<code>&lt;post-perm-link&gt;/&lt;pic-name&gt;</code>，但是我们在
markdown
中填写的路径是<code>&lt;post-md-name&gt;/&lt;pic-name&gt;</code></strong>，如果直接转
html 就会出现问题。</p>
<p>特别的，在 typora 中，当我们调整过图片大小后，其会将原始的 markdown
图片语法切换为 html 的 img 标签形式。</p>
<p>hexo-renderer-marked 可以对 markdown 中图片链接进行转换，但是对于
HTML 文档而言就无能为力了，毕竟 html 此时就相当于是纯文本了。</p>
<p>要想完美实现图片链接的处理，就需要我们通过插件方式进行自行实现</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: c++学习笔记</span><br><span class="line">date: 2023-01-16 13:30:31</span><br><span class="line"><span class="section">tag:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">markdown 图片：</span><br><span class="line"></span><br><span class="line">![<span class="string">测试图片</span>](<span class="link">c-学习笔记/hexo.png</span>)</span><br><span class="line"></span><br><span class="line">html 图片</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;c-学习笔记/hexo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;测试图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>预览效果</p>
<p><img data-src="/posts/9a20/image-20230116144123563.png"
style="zoom: 50%;" /></p>
<h2 id="解决思路">解决思路</h2>
<p>搞清楚问题后，我们就可以考虑如何解决问题了，主要问题有两个</p>
<ol type="1">
<li>无法实现自动图片链接转换</li>
<li>对于 img 标签形式的图片链接也需要进行转换</li>
</ol>
<p>此时通过正则表达式进行替换的方式实现起来太复杂，不够稳定。例如，对于
markdown
文本中的代码段，如果在代码段中也包含一段图片链接，采用文本替换的方式也会对这个链接进行替换，虽然95%情况下能用，但是还是有5%的不适用场景，个人不推荐这样实现。</p>
<p>另一个比较好的解决思路就是通过<strong>语法分析</strong>获取到
markdown 文档的抽象语法树，对于 html
部分的图片链接也同样进行处理（毕竟我们最终目标是将 markdown 转换成
html，对 html 文档进行解析生成抽象语法树也是一样的）。</p>
<p>拿到抽象语法树之后，我们只需要调整 img 标签对应的 src
属性即可，此时进行替换可以确保我们一定是替换的图片链接，而不会错误地替换代码段中的链接。</p>
<p>这样我们的思路就很清楚了：</p>
<ol type="1">
<li>通过 markdown 语法分析器进行语法分析，生成抽象语法树</li>
<li>遍历抽象语法树，调整 img 节点对应链接属性，修改为永久链接</li>
<li>将抽象语法树转换成 html 文档</li>
</ol>
<p>目前有很多 js 实现的 markdown 分析器，但是根据我们的需求</p>
<ol type="1">
<li>能同时进行 markdown 和 html 文档的语法分析</li>
<li>markdown 和 html 文件能具有统一的中间表示形式</li>
</ol>
<p>纯 js 的解决方案目前只找到 <a
href="https://github.com/remarkjs/remark">remark.js</a>
一个，但是其仅支持 es6，在 hexo 中仅支持 common js 导入。</p>
<p>最后查到 pandoc 支持通过 lua 脚本的形式进行后处理（也就是 pandoc
filter），似乎完美契合我们需求，那么接下来只需要学习如何编写 pandoc
filter 即可。</p>
<blockquote>
<p><a href="https://pandoc.org/filters.html">Pandoc - Pandoc
filters</a></p>
<p>转换流程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INPUT -&gt; reader -&gt; AST -&gt; filter -&gt; AST -&gt; writer -&gt; OUTPUT</span><br></pre></td></tr></table></figure>

</blockquote>
<h2 id="plugin">plugin</h2>
<p>在调用 filter 之前，我们首先将 pandoc 集成到 hexo
中。幸运的是已经有大佬写了相关调用插件了（<a
href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a>），其代码也很简单，不到200行，可以直接通过脚本集成到
hexo 中。</p>
<p>由于 pandoc 是一个单独的可执行文件，在 js 中实际上就是调用 pandoc
可执行文件，并获取其输出。在 node.js 调用其他命令需要
<code>child_process</code> 库的 <code>spawn</code>，<code>exec</code> 或
<code>fork</code></p>
<p>这三类都可以实现外部命令的执行，由于我们需要对 pandoc 提供 markdown
文本输入并获取 html 输出，数据量较大，<code>spawn</code>
是最符合我们需求的，为了满足跨平台要求，我们可以使用
<code>cross-spawn</code>来执行命令。</p>
<p><code>spawn</code> 是一个异步函数，其输入和输出是通过
<code>stdin</code>、<code>stdout</code> 以及 <code>stderr</code>
三个<code>Stream</code> 实现的，我们需要注册相应回调才能拿到结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;node:child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> task = <span class="title function_">spawn</span>(<span class="string">&#x27;pandoc&#x27;</span>, [<span class="string">&#x27;--version&#x27;</span>], &#123;</span><br><span class="line">      <span class="attr">env</span>: process.<span class="property">env</span>,</span><br><span class="line">      <span class="attr">cwd</span>: process.<span class="title function_">cwd</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> encoding = <span class="string">&#x27;utf-8&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> stdout_chunks = [];</span><br><span class="line">    <span class="keyword">const</span> stderr_chunks = [];</span><br><span class="line">    task.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> stdout_chunks.<span class="title function_">push</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(chunk)));</span><br><span class="line">    task.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> log.<span class="title function_">error</span>(err));</span><br><span class="line">    task.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> stderr_chunks.<span class="title function_">push</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(chunk)));</span><br><span class="line">    task.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> log.<span class="title function_">error</span>(err));</span><br><span class="line">    <span class="comment">// task.stdin.end(data.text, encoding);</span></span><br><span class="line">    task.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> stderr_msg = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(stderr_chunks).<span class="title function_">toString</span>(encoding);</span><br><span class="line">      <span class="keyword">if</span> (code) &#123;</span><br><span class="line">        <span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`pandoc process exited with code <span class="subst">$&#123;code&#125;</span>.<span class="subst">$&#123;stderr_msg.length &gt; <span class="number">0</span> ? <span class="string">`\n<span class="subst">$&#123;stderr_msg&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">        e.<span class="property">code</span> = code;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (stderr_msg.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        log.<span class="title function_">debug</span>(<span class="string">`Pandoc:\n%s`</span>, stderr_msg.<span class="title function_">trim</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> stdout_msg = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(stdout_chunks).<span class="title function_">toString</span>(encoding);</span><br><span class="line">      <span class="title function_">resolve</span>(stdout_msg);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>().<span class="title function_">then</span>(<span class="function"><span class="params">output</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`output from spawn:\n<span class="subst">$&#123;output.trim()&#125;</span>`</span>)).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Node node test.js</span><br><span class="line">output from spawn:</span><br><span class="line">pandoc 3.0.1</span><br><span class="line">Features: +server +lua</span><br><span class="line">Scripting engine: Lua 5.4</span><br><span class="line">User data directory: /home/xiao/.local/share/pandoc</span><br><span class="line">Copyright (C) 2006-2023 John MacFarlane. Web:  https://pandoc.org</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions. There is no</span><br><span class="line">warranty, not even <span class="keyword">for</span> merchantability or fitness <span class="keyword">for</span> a particular purpose.</span><br></pre></td></tr></table></figure>

<p>上面的代码实际上就是调用了 <code>pandoc --version</code> 命令，并通过
CacheStream 获取到了调用命令后的输出结果，以便进行下一步的调用。</p>
<p>如果我们需要向 pandoc 传输数据（例如待处理的 markdown
文本流），我们可以直接在 <code>stdin</code>
中直接写入，同时注意写入完成后<strong>记得关闭输入流</strong>，否则
pandoc 进程会一直等待输入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">task.<span class="property">stdin</span>.<span class="title function_">end</span>(data.<span class="property">text</span>, encoding);</span><br></pre></td></tr></table></figure>

<p>在 pandoc 进行 markdown 转换的命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --from=gfm --to=html5 --mathjax</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol type="1">
<li><code>--from</code> 表示输入格式</li>
<li><code>--to</code> 表示输出格式</li>
<li><code>--mathjax</code> 表示开启 mathjax 公式支持</li>
</ol>
<p>输入后 pandoc 就会等待 stdin 输入，输出到 stdout
中，同时将错误信息输出到 stderr 中。</p>
<p>例如我们写一个简单的 <code>h1</code> 标题，其 markdown 代码为
<code># This is h1</code> ，对应 html 代码为
<code>&lt;h1&gt;This is h1&lt;/h1&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task = <span class="title function_">spawn</span>(<span class="string">&#x27;pandoc&#x27;</span>, [<span class="string">&#x27;--from=gfm&#x27;</span>,<span class="string">&#x27;--to=html5&#x27;</span>,<span class="string">&#x27;--mathjax&#x27;</span>], &#123;</span><br><span class="line">    <span class="attr">env</span>: process.<span class="property">env</span>,</span><br><span class="line">    <span class="attr">cwd</span>: process.<span class="title function_">cwd</span>()</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">task.<span class="property">stdin</span>.<span class="title function_">end</span>(<span class="string">&#x27;# This is h1&#x27;</span>, encoding);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Node node test.js</span><br><span class="line">output from spawn:</span><br><span class="line">&lt;h1 <span class="built_in">id</span>=<span class="string">&quot;this-is-h1&quot;</span>&gt;This is h1&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过 spawn 我们可以正确调用 pandoc 并实现从 markdown 到
html 的转换。最后只需要编写 pandoc filter 就可以完成插件了。</p>
<h2 id="pandoc-filter">pandoc filter</h2>
<h3 id="hellolua-filter">hello，lua filter</h3>
<p>在 <a href="https://pandoc.org/lua-filters.html">Pandoc 官网</a>
中给出了一个简单的示例</p>
<p>文件：<code>smallcaps.lua</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    Strong = <span class="function"><span class="keyword">function</span> <span class="params">(elem)</span></span></span><br><span class="line">      <span class="keyword">return</span> pandoc.SmallCaps(elem.c)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其将所有的 Strong 标签（粗体，在 markdown 就是
<code>**A**</code>，<strong>A</strong>）转换 Small Caps 形式，测试
markdown 如下</p>
<p>将其保存为 <code>test.md</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**hello world!**</span></span><br></pre></td></tr></table></figure>

<p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --lua-filter=smallcaps.lua -o test.html test.md</span><br></pre></td></tr></table></figure>

<p>如果不指定输出格式，其默认使用 html 格式输出，对应输出结果如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;smallcaps&quot;</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在 html 中并不能原生支持 smallcaps 样式，但是 pandoc
为其指定了一个 css 类名，通过类名这个我们可以手动实现 smallcaps
效果。</p>
<h3 id="filter-写法">filter 写法</h3>
<p>上面的代码第一眼看上有点奇怪，怎么以来就是一个 <code>return</code>
语句，返回的 <code>&#123;&#125;</code> 怎么直接套了一个
<code>&#123;xxx = xxx&#125;</code></p>
<p>首先解释后面一点，在 lua 中，列表和字典都使用 <code>&#123;&#125;</code>
表示，那么最外层的就是一个列表，然后内层的是一个字典，我们可以看到其指定了一个键为
<code>Strong</code> 的函数，表示对 <code>Strong</code>
这个节点的处理函数。</p>
<p>那么最开始的 <code>return</code>
就表示这个脚本可以作为包被外部使用，就有点类似于 common js
中模块写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> =&#123;</span><br><span class="line">	<span class="title class_">Strong</span> = <span class="keyword">function</span>(<span class="params">elem</span>)&#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在 pandoc 内部调用时，直接使用下面语句</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">require</span>(<span class="string">&quot;smallcaps&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>即可导入使用</p>
<p>在 Pandoc 中定义了很多种抽象语法树的节点类型，例如
Block、String、Inline等，对于每一个节点类型我们都可以编写对应的处理函数对其进行处理，同时根据列表的顺序还可以控制抽象语法树的遍历方式。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Meta</span><span class="params">(meta)</span></span> </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;process meta&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Para</span><span class="params">(para)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;process para&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Image</span><span class="params">(image)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;process image&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123;Meta = Meta&#125;,</span><br><span class="line">    &#123;Para = Para&#125;,</span><br><span class="line">    &#123;Image = Image&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 markdown</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">title: 测试 markdown</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">![<span class="string">test-image</span>](<span class="link">url-to-image</span>)</span><br></pre></td></tr></table></figure>

<p>测试命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --lua-filter test.lua -o test.html test.md</span><br></pre></td></tr></table></figure>

<p>在控制台的输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Lua\pandoc-filter&gt; pandoc --lua-filter test.lua -o test.html test.md</span><br><span class="line">process meta</span><br><span class="line">process para</span><br><span class="line">process para</span><br><span class="line">process image</span><br></pre></td></tr></table></figure>

<p>从输出结果上我们可以看到，首先处理的是 meta，之后是两个 para，最后是
image，其对应的文档结构如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span>...<span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;url-to-image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;test-image&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：<strong>如果函数中没有返回任何值（或者返回
nil），表示该函数不会对抽象语法树进行修改</strong>。</p>
<h2 id="final-filter">final filter</h2>
<p>参考 pandoc 对于 <a
href="https://pandoc.org/lua-filters.html#type-image">image</a>
标签的描述，通过 <code>src</code>
字段可以读取到图片的链接信息，我们只需要修改 url
值即可，根据之前的描述，我们可以编写一个简单的 filter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local url_prefix</span><br><span class="line"></span><br><span class="line">local function Meta(meta) </span><br><span class="line">  url_prefix = meta.url_prefix </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function Image(image)</span><br><span class="line">   image.src = url_prefix ..&#x27;/&#x27;.. image.src</span><br><span class="line">   print(&quot;image.src: &quot;,image.src)</span><br><span class="line">   return image</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">   &#123;Meta = Meta&#125;,</span><br><span class="line">   &#123;Image = Image&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在命令行中通过 <code>--metadata=key:value</code>
来指定元数据信息</p>
<p>转换命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --metadata=url_prefix:<span class="built_in">test</span> --lua-filter test.lua -o test.html test.md</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">image.src:      <span class="built_in">test</span>/test.jpg</span><br></pre></td></tr></table></figure>

<p>转换后的 html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test/url-to-image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;test-image&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span>test-image<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>src</code>
部分已经替换成了我们需要的链接，并且还对图片添加了 figcaption</p>
<p>之前我们提到，在 markdown 文档中可能存在 html
代码，对于这一部分我们也想要进行处理，默认 pandoc 会将其解析为
RawBlock，即不做任何处理，但也可以使用 <code>pandoc.read</code>
进行解析，生成抽象语法树，这样我们就可以对 html
形式的图片进行解析了。</p>
<p>完整代码如下</p>
<p>文件：<code>image-asset.lua</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    Reference: </span></span><br><span class="line"><span class="comment">    [1] https://pandoc.org/lua-filters.html</span></span><br><span class="line"><span class="comment">    [2] http://www.lua.org/manual/5.4/</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> logging = <span class="built_in">require</span>(<span class="string">&#x27;logging&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> new_path</span><br><span class="line"><span class="keyword">local</span> path_prefix</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Meta</span><span class="params">(meta)</span></span></span><br><span class="line">    <span class="comment">-- logging.temp(&#x27;Meta&#x27;,meta)</span></span><br><span class="line">    <span class="keyword">local</span> meta_path = meta[<span class="string">&#x27;path&#x27;</span>]</span><br><span class="line">    <span class="keyword">local</span> meta_title = meta[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> (meta_path == <span class="literal">nil</span> <span class="keyword">or</span> meta_title == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        logging.temp(<span class="string">&#x27;Meta&#x27;</span>,<span class="string">&#x27;no meta data found, ignored.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    new_path = pandoc.utils.stringify(meta_path)</span><br><span class="line">    path_prefix = pandoc.utils.stringify(meta_title) .. <span class="string">&#x27;/&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Image</span><span class="params">(image)</span></span></span><br><span class="line">    <span class="keyword">if</span> (new_path == <span class="literal">nil</span> <span class="keyword">or</span> path_prefix == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> length = pandoc.text.<span class="built_in">len</span>(path_prefix)</span><br><span class="line">    <span class="keyword">local</span> prefix = pandoc.text.<span class="built_in">sub</span>(image.src,<span class="number">1</span>,length)</span><br><span class="line">    <span class="keyword">local</span> postfix = pandoc.text.<span class="built_in">sub</span>(image.src,length+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (prefix == path_prefix) <span class="keyword">then</span></span><br><span class="line">        image.src = new_path .. postfix</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- delete image caption info and title (just a hack)</span></span><br><span class="line">    image.caption = &#123;&#125;</span><br><span class="line">    image.title = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">RawBlock</span> <span class="params">(raw)</span></span></span><br><span class="line">    <span class="keyword">if</span> raw.<span class="built_in">format</span>:<span class="built_in">match</span>(<span class="string">&#x27;html&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> res = pandoc.<span class="built_in">read</span>(raw.text,<span class="string">&#x27;html&#x27;</span>)</span><br><span class="line">        <span class="comment">-- https://pandoc.org/lua-filters.html#type-blocks</span></span><br><span class="line">        <span class="keyword">if</span> ( #res.blocks == <span class="number">1</span> ) <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- convert Plain to Para</span></span><br><span class="line">            <span class="keyword">return</span> pandoc.Para(res.blocks[<span class="number">1</span>].content)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- function Pandoc(pandoc)</span></span><br><span class="line"><span class="comment">--     logging.temp(&#x27;Pandoc&#x27;,pandoc)</span></span><br><span class="line"><span class="comment">-- end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- return in global scope (can be loaded via `require`)</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123; RawBlock = RawBlock &#125;,</span><br><span class="line">    &#123; Meta = Meta &#125;,</span><br><span class="line">    &#123; Image = Image &#125;,</span><br><span class="line">    <span class="comment">-- &#123; Pandoc = Pandoc &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后给出完整的插件代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code modified from https://github.com/wzpan/hexo-renderer-pandoc/blob/master/index.js</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;node:child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;node:path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;node:assert&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; yellow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;picocolors&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">config</span>.<span class="property">pandoc</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;</span><br><span class="line">    <span class="attr">pandoc_bin</span>: <span class="string">&#x27;pandoc&#x27;</span>,</span><br><span class="line">    <span class="attr">math_engine</span>: <span class="string">&#x27;mathjax&#x27;</span>,</span><br><span class="line">    <span class="attr">markdown_mode</span>: <span class="string">&#x27;gfm&#x27;</span>,</span><br><span class="line">    <span class="attr">filters</span>: [],</span><br><span class="line">    <span class="attr">lua_filters</span>: [],</span><br><span class="line">    <span class="attr">extra</span>: [],</span><br><span class="line">&#125;, hexo.<span class="property">config</span>.<span class="property">pandoc</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// must have the `?.lua` specified!</span></span><br><span class="line"><span class="keyword">const</span> pandoc_env = &#123; ...process.<span class="property">env</span>, <span class="attr">LUA_PATH</span>: path.<span class="title function_">join</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;lua&#x27;</span>, <span class="string">&#x27;?.lua&#x27;</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">argument</span> = (<span class="params">name, value = <span class="literal">undefined</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`--<span class="subst">$&#123;name&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`--<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is_string</span> = obj =&gt; <span class="keyword">typeof</span> (obj) === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is_array</span> = obj =&gt; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is_object</span> = obj =&gt; <span class="keyword">typeof</span> (obj) === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get_cache</span> = (<span class="params">stream, encoding</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> buf = stream.<span class="title function_">getCache</span>();</span><br><span class="line">    stream.<span class="title function_">destroy</span>();</span><br><span class="line">    <span class="keyword">if</span> (!encoding) <span class="keyword">return</span> buf;</span><br><span class="line">    <span class="keyword">return</span> buf.<span class="title function_">toString</span>(encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">renderer</span> = (<span class="params">data, options</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; log &#125; = hexo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = hexo.<span class="property">config</span>.<span class="property">pandoc</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> filters = [];</span><br><span class="line">    <span class="keyword">const</span> lua_filters = [];</span><br><span class="line">    <span class="keyword">const</span> extra = [<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">&#x27;pagetitle:ignored&#x27;</span>)];</span><br><span class="line">    <span class="comment">// To satisfy pandoc&#x27;s requirement that html5 must have a title.</span></span><br><span class="line">    <span class="comment">// Since the markdown file is only rendered as body part,</span></span><br><span class="line">    <span class="comment">// the title is never used and thus does not matter</span></span><br><span class="line">    <span class="keyword">const</span> pandoc_bin = config.<span class="property">pandoc_bin</span>;</span><br><span class="line">    <span class="keyword">const</span> math_engine = <span class="title function_">argument</span>(config.<span class="property">math_engine</span>);</span><br><span class="line">    <span class="keyword">const</span> markdown_mode = config.<span class="property">markdown_mode</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is_array</span>(config.<span class="property">filters</span>)) &#123;</span><br><span class="line">        config.<span class="property">filters</span> = [config.<span class="property">filters</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is_array</span>(config.<span class="property">lua_filters</span>)) &#123;</span><br><span class="line">        config.<span class="property">lua_filters</span> = [config.<span class="property">lua_filters</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is_array</span>(config.<span class="property">extra</span>)) &#123;</span><br><span class="line">        config.<span class="property">extra</span> = [config.<span class="property">extra</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    config.<span class="property">filters</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line">        filters.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;filter&#x27;</span>, filter));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    config.<span class="property">lua_filters</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line">        lua_filters.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;lua-filter&#x27;</span>, filter));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    config.<span class="property">extra</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_string</span>(item)) &#123;</span><br><span class="line">            extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(item));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">is_object</span>(item)) &#123;</span><br><span class="line">            <span class="title function_">assert</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(item).<span class="property">length</span> === <span class="number">1</span>, <span class="string">`item in extra must be a key-value tuple or string`</span>);</span><br><span class="line">            <span class="keyword">const</span> [key, value] = <span class="title class_">Object</span>.<span class="title function_">entries</span>(item)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">is_array</span>(value)) &#123;</span><br><span class="line">                value.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                    extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(key, v));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(key, value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`unknown extra config for pandoc: <span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">POST_MODEL</span> = hexo.<span class="title function_">model</span>(<span class="string">&#x27;Post&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> source = data.<span class="property">path</span>.<span class="title function_">substring</span>(hexo.<span class="property">source_dir</span>.<span class="property">length</span>).<span class="title function_">replace</span>(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> current_post = <span class="variable constant_">POST_MODEL</span>.<span class="title function_">findOne</span>(&#123; source &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_post) &#123;</span><br><span class="line">        <span class="comment">// manually add root path</span></span><br><span class="line">        <span class="keyword">const</span> post_path = <span class="string">`/<span class="subst">$&#123;current_post.path&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">// the filename (xxx.md) may not correspond to title field in Markdown Front Matter</span></span><br><span class="line">        <span class="keyword">const</span> filename = path.<span class="title function_">basename</span>(data.<span class="property">path</span>, <span class="string">&#x27;.md&#x27;</span>);</span><br><span class="line">        log.<span class="title function_">debug</span>(<span class="string">&#x27;Filename: %s&#x27;</span>, <span class="title function_">yellow</span>(filename));</span><br><span class="line">        <span class="comment">// const title = current_post.title;</span></span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">`path:<span class="subst">$&#123;post_path&#125;</span>`</span>));</span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">`title:<span class="subst">$&#123;filename&#125;</span>`</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we are rendering a post,</span></span><br><span class="line">    <span class="comment">// `data` has the key `path`</span></span><br><span class="line">    <span class="comment">// https://github.com/hexojs/hexo/blob/2ed17cd105768df379dad8bbbe4df30964fe8f2d/lib/hexo/post.js#L269</span></span><br><span class="line">    <span class="comment">// otherwise (e.g., rendering a tag),</span></span><br><span class="line">    <span class="comment">// `path` is not present in `data`.</span></span><br><span class="line">    <span class="comment">// https://github.com/hexojs/hexo/blob/2ed17cd105768df379dad8bbbe4df30964fe8f2d/lib/extend/tag.js#L173</span></span><br><span class="line">    <span class="comment">// https://github.com/hexojs/hexo/blob/a6dc0ea28dddad1b5f1bad7c6f86f1e0627b564a/lib/plugins/tag/blockquote.js#L64</span></span><br><span class="line">    <span class="comment">// are we rendering a standalone post?</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">path</span>) &#123;</span><br><span class="line">        <span class="comment">// only apply template when rendering post, not tags</span></span><br><span class="line">        <span class="keyword">if</span> (config.<span class="property">template</span>) &#123;</span><br><span class="line">            extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;template&#x27;</span>, config.<span class="property">template</span>, <span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do not apply `--standalone`,</span></span><br><span class="line">        <span class="comment">// header/footer are to be added by Hexo</span></span><br><span class="line">        <span class="comment">// also set a metavariable to let concerned</span></span><br><span class="line">        <span class="comment">// pandoc filters know</span></span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">&#x27;standalone:true&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// or some thing to be embedded in a post,</span></span><br><span class="line">        <span class="comment">// like tags?</span></span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">&#x27;standalone:false&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> args = [</span><br><span class="line">        <span class="title function_">argument</span>(<span class="string">&#x27;from&#x27;</span>, markdown_mode),</span><br><span class="line">        <span class="title function_">argument</span>(<span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;html5&#x27;</span>),</span><br><span class="line">        math_engine,</span><br><span class="line">        ...extra,</span><br><span class="line">        ...lua_filters,</span><br><span class="line">        ...filters,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    log.<span class="title function_">debug</span>(<span class="string">&#x27;Pandoc command: %s&#x27;</span>, <span class="title function_">yellow</span>(<span class="string">`<span class="subst">$&#123;pandoc_bin&#125;</span> <span class="subst">$&#123;args.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> task = <span class="title function_">spawn</span>(pandoc_bin, args, &#123;</span><br><span class="line">            <span class="attr">env</span>: pandoc_env,</span><br><span class="line">            <span class="attr">cwd</span>: process.<span class="title function_">cwd</span>(),</span><br><span class="line">            <span class="attr">stdio</span>: <span class="string">&#x27;pipe&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> encoding = <span class="string">&#x27;utf-8&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> stdout_chunks = [];</span><br><span class="line">        <span class="keyword">const</span> stderr_chunks = [];</span><br><span class="line"></span><br><span class="line">        task.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> stdout_chunks.<span class="title function_">push</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(chunk)));</span><br><span class="line">        task.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> log.<span class="title function_">error</span>(err));</span><br><span class="line"></span><br><span class="line">        task.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> stderr_chunks.<span class="title function_">push</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(chunk)));</span><br><span class="line">        task.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> log.<span class="title function_">error</span>(err));</span><br><span class="line"></span><br><span class="line">        task.<span class="property">stdin</span>.<span class="title function_">end</span>(data.<span class="property">text</span>, encoding);</span><br><span class="line"></span><br><span class="line">        task.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> stderr_msg = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(stderr_chunks).<span class="title function_">toString</span>(encoding);</span><br><span class="line">            <span class="keyword">if</span> (code) &#123;</span><br><span class="line">                <span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`pandoc process exited with code <span class="subst">$&#123;code&#125;</span>.<span class="subst">$&#123;stderr_msg.length &gt; <span class="number">0</span> ? <span class="string">`\n<span class="subst">$&#123;stderr_msg&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">                e.<span class="property">code</span> = code;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stderr_msg.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.<span class="title function_">debug</span>(<span class="string">`Pandoc:\n%s`</span>, <span class="title function_">yellow</span>(stderr_msg.<span class="title function_">trim</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> output = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(stdout_chunks).<span class="title function_">toString</span>(encoding);</span><br><span class="line">            <span class="keyword">const</span> length = output.<span class="property">length</span>;</span><br><span class="line">            log.<span class="title function_">debug</span>(<span class="string">`Pandoc Output Size: <span class="subst">$&#123;length&#125;</span> bytes`</span>);</span><br><span class="line">            log.<span class="title function_">debug</span>(<span class="string">`Pandoc Output Preview:\n%s`</span>, <span class="title function_">yellow</span>(length &gt; <span class="number">100</span> ? output.<span class="title function_">substring</span>(length - <span class="number">100</span>, length).<span class="title function_">trim</span>() : output.<span class="title function_">trim</span>()));</span><br><span class="line">            <span class="title function_">resolve</span>(output);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;md&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;markdown&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mkd&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mkdn&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mdwn&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mdtxt&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mdtext&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h1 id="总结">总结</h1>
<p>写了很多，大概记录了一下 hexo
自定义插件过程，还有很多没有详细介绍的，有兴趣的话参照下方的链接自行编写即可，弄清楚逻辑后代码写起来还是很快的。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://hexo.io/zh-cn/docs/plugins">插件 | Hexo</a></li>
<li><a
href="https://github.com/wzpan/hexo-renderer-pandoc">wzpan/hexo-renderer-pandoc:
A pandoc-markdown-flavor renderer for hexo. (github.com)</a></li>
<li><a
href="https://nodejs.org/docs/latest-v18.x/api/child_process.html#child_processspawncommand-args-options">Child
process | Node.js v18.13.0 Documentation (nodejs.org)</a></li>
<li><a href="https://pandoc.org/lua-filters.html">Pandoc - Pandoc Lua
Filters</a></li>
<li><a
href="https://github.com/wlupton/pandoc-lua-logging">wlupton/pandoc-lua-logging:
Pandoc lua filter logging support (github.com)</a></li>
<li><a href="http://www.lua.org/manual/5.4/">Lua 5.4 Reference Manual -
contents</a></li>
</ol>
]]></content>
      <categories>
        <category>Hexo使用记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>pandoc</tag>
        <tag>node.js</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串编码</title>
    <url>/posts/c4ef/</url>
    <content><![CDATA[<h1 id="字符串编码">字符串编码</h1>
<p><em><strong>Encodings should be known, not divined.</strong></em></p>
<h2 id="问题描述">问题描述</h2>
<p>在前一篇我们使用 pandoc 的 lua filter 解决了 markdown 转 html
中链接问题，但是在调试代码的过程中发现了一个问题，在不同的 shell 中执行
lua
脚本时，输出中文有时会乱码，有时又不会乱码，搞得有点烦，本篇就针对字符串问题做一个探究，搞清楚乱码的源头以及解决方案。</p>
<p>首先看一个简单的示例，下面是一段简单的 c 语言 hello world</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你好，世界！😉&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件保存格式为：<code>UTF-8</code>（注意看 vscode 的右下角，写着
UTF-8）</p>
<p><img data-src="/posts/c4ef/image-20230117150536045.png"
style="zoom:50%;" /></p>
<span id="more"></span>

<p>使用 msvc 编译后，分别在 git
bash、msys2、powershell上运行后输出结果如下</p>
<p><img data-src="/posts/c4ef/image-20230117150241891.png"
style="zoom: 67%;" /></p>
<blockquote>
<p>注：使用 msvc 编译 UTF-8 文件时，需要添加 <code>/utf-8</code>
参数，否则会使用本机默认编码进行编译，有可能导致编译失败。</p>
<p><img data-src="/posts/c4ef/image-20230119233748271.png" /></p>
</blockquote>
<p>可以看到，仅在 git bash 中能正确输出中文，如果我们将编码保存为
GBK，再编译运行</p>
<p><img data-src="/posts/c4ef/image-20230117151454957.png"
style="zoom:50%;" /></p>
<p>输出结果如下：</p>
<p><img data-src="/posts/c4ef/image-20230117152301608.png"
style="zoom: 67%;" /></p>
<p>可以看到此时在 Git Bash 中输出乱码了，而在 msys2 和 powershell
中可以正确输出中文了，但是 emoji 的输出还是有问题（变成了问号）</p>
<p>再使用 python 输出上面那句话看看效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你好，世界！😉&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>分别在三个终端中进行测试，输出结果如下</p>
<p><img data-src="/posts/c4ef/image-20230117154659021.png"
style="zoom: 67%;" /></p>
<p>此时 git bash 中直接报错，说 GBK 无法解析 <code>U+1F609</code>
也就是笑脸 😉 ，而在 msys2 和 powershell 中均可以正确输出中文，但是
powershell 中无法输出 emoji 表情，而 msys2 可以正确输出。</p>
<p>这个结果更令人费解了，C 语言和 Python
输出结果不一致，在不同终端下输出也不一样。</p>
<h2 id="编码简史">编码简史</h2>
<p>关于编码的发展过程，下面这篇文章做了很好的介绍</p>
<blockquote>
<p><a
href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">The
Absolute Minimum Every Software Developer Absolutely, Positively Must
Know About Unicode and Character Sets (No Excuses!) – Joel on
Software</a></p>
</blockquote>
<p>参考这篇文章，我们做一个简单的总结。</p>
<h3 id="ascii">ASCII</h3>
<p>在计算机中，所有数据都是以二进制形式存储的，我们在屏幕上阅读的文字如
“A”，“你好”
等也需要以二进制形式存储。<strong>编码描述的就是我们如何将可阅读的字符存储在计算机中</strong>。
ASCII ( /ˈæski/ )
编码是早期常用的一种编码（现在也很常用，只不过是其他编码兼容该编码罢了）。其包含128个字符，使用
8 位存储（剩下的 128 - 255 部分称为扩展 ASCII
编码，不过并不常用），下图展示了所有的ASCII字符及其对应的编码值（图片来自：<a
href="http://www.asciicharstable.com/"><span>http://www.asciicharstable.com/</span></a>）</p>
<p><img data-src="/posts/c4ef/ascii-chars-table-landscape.jpg"
style="zoom: 25%;" /></p>
<p>例如大写字母 <code>A</code> 对应的 ASCII 十进制编码就是
<code>65</code>，也即二进制的 <code>0b01000001</code> 和十六进制的
<code>0x41</code>。</p>
<p>从表中可以看到，仅包含大小写字母，而中文、俄语等文字并不包括在内。为了解决这个问题，一些厂家就自定义了一套编码格式，从而支持其他语言的字符显示。但是厂家自定义的编码并不能跨平台，例如在
IBM 上编写的文档就有可能无法在 Mach 上打开，因为他们使用的编码不同。</p>
<h3 id="ansi">ANSI</h3>
<p>厂家自定义编码太杂乱，为了实现跨平台，后来就统一了编码（车同轨，书同文？），称为
ANSI 编码。ANSI 编码并不将所有的字符都编码到一张表上，其仅确保前 128
个字符（也就是 ASCII 编码部分）是一致的，后面部分的编码由代码页（code
page）决定，不同地区使用不同的代码页，从而在不同地区显示不同的文字。目前
Windows
仍然支持的这种编码方式，可以在控制面板的时钟和区域中进行设置。</p>
<p><img data-src="/posts/c4ef/image-20230118163241733.png"
style="zoom:50%;" /></p>
<p>对于中日韩文而言，其使用的是表意文字（ideograph），可能包含数万个字符，仅使用
8 位显然是无法表示这些字符的。后面就将 ANSI 编码扩展到了两个字节，其中
<code>0x80</code> 至 <code>0xFFFF</code>
部分由代码页来决定编码。中文对应的编码方式有 GB 2312 及其扩展
GBK（<strong>G</strong>uo jia <strong>B</strong>iao zhun
<strong>K</strong>uo zhan，国家标准扩展）。</p>
<blockquote>
<p>注：GBK 和 ANSI 的关系：GBK 属于 ANSI
的一部分，其专门负责对中文进行编码，而其他字母等仍使用 ASCII
编码，例如一段话</p>
<p><code>Hi, 你好</code>，对应的 GBK ANSI 编码为，其中 <code>Hi,</code>
仍是单字节编码，而后面的 <code>你好</code> 则是双字节编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0x48,0x69,0x20,0xC4,0xE3,0xBA,0xC3]</span><br></pre></td></tr></table></figure>

<p>GBK 实际上是一个定长编码，其描述的所有字符都是双字节，但是此时 ANSI
就是一个变长编码，其既包含单字节字符，也包含双字节字符。</p>
</blockquote>
<p>在 Windows 下，可以使用 <code>chcp</code> 命令查看当前控制台使用的
ANSI 代码页（同时也可以使用该命令切换控制台使用的代码页）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Users\xiao&gt; chcp</span><br><span class="line">活动代码页: 936</span><br></pre></td></tr></table></figure>

<p>在程序中可以使用 <code>GetACP()</code>
函数来查询程序中使用的代码页（需要调用 Windows API）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winnls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current Windows ANSI code page identifier is: %u&quot;</span>,<span class="built_in">GetACP</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Cpp\encoding-demo\bin&gt; .\test.exe    </span><br><span class="line">current Windows ANSI code page identifier is: 936</span><br></pre></td></tr></table></figure>

<p>在微软 win32 文档中给出了代码页标识符的相关描述：<a
href="https://learn.microsoft.com/en-us/windows/win32/intl/code-page-identifiers">Code
Page Identifiers - Win32 apps | Microsoft Learn</a></p>
<p><img data-src="/posts/c4ef/image-20230118172323075.png"
style="zoom:50%;" /></p>
<p>可以看到，本机 Windows 的ANSI代码页编号为 936，对应 GB2312
编码，而后续 GBK 发布后更新了 GBK 部分的字符，因此也常称为 GBK
编码。</p>
<p>采用代码页的方式在单语言场景下足够使用了，但是有时我们可能会浏览其他语言的网站，或接收到其他语言的邮件，我们的系统上就无法显示这些字符了（代码页并不能随便切换）。</p>
<p><strong>彩蛋：”烫烫烫烫烫烫烫烫...“？</strong></p>
<p>在 GBK 编码中，烫的编码为 <code>[0xCC,0xCC]</code>，在 MSVC
的调试模式下，会自动将未初始化的内存设置为
<code>0xCC</code>（字节），用来进行 <a
href="https://learn.microsoft.com/zh-cn/cpp/build/reference/rtc-run-time-error-checks?view=msvc-170">运行时错误检查</a>。</p>
<p>添加 <code>/RTC1</code>
编译标志即可开启检查功能，我们进行调试时，就会看到如下字样</p>
<p><img data-src="/posts/c4ef/image-20230120002426547.png"
style="zoom: 50%;" /></p>
<p>下面是测试代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处故意不初始化</span></span><br><span class="line"><span class="type">uint32_t</span> v;</span><br><span class="line"><span class="type">uint8_t</span> *arr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(&amp;v);</span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出结果就为 <code>烫烫</code></p>
<p>除了 <code>烫</code>，还有可能出现 <code>屯屯屯屯</code>，因为 MSVC
在调试时会将动态分配的内存值初始化为 <code>0xCD</code>，而
<code>屯</code> 的 GBK 编码刚好是 <code>[0xCD,0xCD]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;烫&quot;</span>.encode(<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;\xcc\xcc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;屯&#x27;</span>.encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;\xcd\xcd&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="unicode">Unicode</h3>
<p>为了解决在同一系统上的跨语言显示问题，就只能将全部字符编码到一张表上，这种表示方式称为
Unicode，中文称为 <strong>统一码</strong>，不过一般直接说 Unicode
即可。注意这里我们用的表述是
字符的<strong>表示方式</strong>，而不是编码方式。Unicode
为每一个字符分配一个 code point（码点），就唯一表示一个字符，例如
<code>你</code> 的 Unicode 码点为 <code>U+4F60</code>，<code>U+</code>
前缀就表示这是一个 Unicode 码点，后面的十六进制就表示具体的代码值。</p>
<p><strong>码点和编码之间并不是一一对应关系，码点只是一个形式化的表示方式（可以理解为字符在字符空间中的一个坐标），其并不关心具体如何在计算机中存储的</strong>。UTF
(<strong>U</strong>nicode <strong>T</strong>ransformation
<strong>F</strong>ormat，Unicode 传输格式)
才是决定具体如何在计算机中存储和传输的，根据使用场景不同，包含以下六类：</p>
<ul>
<li>UTF-8</li>
<li>UTF-8 with BOM</li>
<li>UTF-16 LE</li>
<li>UTF-16 BE</li>
<li>UTF-32 BE</li>
<li>UTF-32 LE</li>
</ul>
<p>注：BOM 表示 <strong>B</strong>yte <strong>O</strong>rder
<strong>M</strong>ark，字节顺序标志，LE 和 BE 分别代表 Little Endian
（小端）以及 Big Endian （大端）</p>
<h4 id="大小端与字节顺序">大小端与字节顺序</h4>
<p>大小端描述的是字节在多字节数据中的存储顺序，例如一个
<code>uint32_t</code> 是 4 个字节，例如
<code>0x1f2f3f4f</code>，其各字节信息如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Value(uint32_t): 0x1f2f3f4f</span><br><span class="line">Byte View:</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">| bits |   0..7   |   8..15  |  16..23  |  24..31  |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">| byte |  byte[0] |  byte[1] |  byte[2] |  byte[3] |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">|  hex |    4f    |    3f    |    2f    |    1f    |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">|  bin | 01001111 | 00111111 | 00101111 | 00011111 |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>而其实际在内存中存储按字节顺序可以分为两种存储顺序</p>
<ul>
<li><p><strong>按内存地址从低到高，字节顺序从低字节到高字节存储</strong></p>
<p>这种字节排列顺序称为小端，因为低位字节（小值）优先存储</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Little Endian Memory View:</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">| addr | 0x1fdd3356050 | 0x1fdd3356051 | 0x1fdd3356052 | 0x1fdd3356053 |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  hex |       4f      |       3f      |       2f      |       1f      |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  bin |    01001111   |    00111111   |    00101111   |    00011111   |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>按内存地址从低到高，字节顺序从高字节到低字节存储</strong></p>
<p>这种字节排列顺序称为大端，因为高位字节（大值）优先存储</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Big Endian Memory View:</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">| addr | 0x1fdd3356550 | 0x1fdd3356551 | 0x1fdd3356552 | 0x1fdd3356553 |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  hex |       1f      |       2f      |       3f      |       4f      |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  bin |    00011111   |    00101111   |    00111111   |    01001111   |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注：<strong>无论是大端还是小端，一个字节中的 bit
的排列顺序永远都是从低位到高位</strong></p>
<blockquote>
<p>大端和小端出自 Jonathan Swift 的《格列佛游记》（Gulliver's
Trabels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。</p>
<p>一下是 Jonathan Swift 在1726年关于大小端之争的历史描述：</p>
<p><em>“......下面要告诉你的是，Lilliput 和 Blefuscu
这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋是碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由
Blefuscu
的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。”</em></p>
<p><em>（此段译文摘自网上蒋剑锋译的
《格列佛游记》第一卷第4章。）</em></p>
<p><img data-src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHCBIUEhcVEhUYFxcZGRoXGRoZGhocIB0aGBciHRgaIBoaICwkICEpIhoZJDYkKS0vNDMzGSI4PjgzPSwyMzUBCwsLDw4PHhISHTMjIiM6Ly8vMzM6Mi8yOjIvMjI0LzQ0LzIyMi8yMjIzLzIyMjo7MjQyLzQ0MjIzMjIyMjIvL//AABEIAJ8BPgMBIgACEQEDEQH/xAAbAAEBAAMBAQEAAAAAAAAAAAAABgEEBQMHAv/EAEcQAAEDAgQDBQMICAMHBQAAAAEAAgMEEQUSITEGQVETIjJhcRSBkQcjM0JSYqGxFSQ0Q1NyksGisvEWF0Rjg8LRNoKT0vD/xAAaAQEAAwEBAQAAAAAAAAAAAAAAAQIDBAUG/8QALhEBAAICAQMCBAMJAAAAAAAAAAECAxEEEiExQVEiYYGRE6HwFCMyQmJxscHx/9oADAMBAAIRAxEAPwD7MiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiIMIpziDjKiozkkkzynwwxjPITyGUbX+8QuGcVxqr/Z4Y6CI7ST9+W1tCIho0+Th71S161jdp0a2vS4AXOgXEr+LsOhJEtXC0jdoe1zv6W3Km/wDYNkuuIVVTVnS7XyFkd/KNm3xXYoeFsPht2VJC0jmY2ud/U+5/FctubjjxuV4pLSf8qOE7MlfIfuQyn82hef8AvQouUNWR17A/+VTsaG+EBvoLfkv3nPUrOef7V/M6EzH8qGFbPlkjP34ZB/laV38N4loanSCpikP2Q8Zv6Tr+C9HsDtHAOHmAfzXDxLg/DqgHtKWK5+sxuR39Udj8VavPr6wdCvRfOxw/iFH3sOrHSRjU09Wc7bdGybs05aDqVv8ACPyhUta7sX2hqAS3s3ODmvI37N40d6b9LjVddMtckbrKsxpbIiLRAiIgIiICIiAiIgIi5eMY7S0jc1VMyIcg494/ytHed7gg6aKDPHss+mG0E9QOUkloYzfmHP39NF+XRY/P46ilpAdhFGZXgdCZO78Cs75aV8ymImV8sr587g+pf9Pitc4/8pzYh8G3WBwBTfWqa5x6mod/9VjPMxR6p6ZfQUXz48AQj6Orr4z1bUH+7Vn/AGbxKK3suKzG31ahjZQfIuOvvsleXin10dMvoCKBbxFi9L+20bamMby0Zu4AczE7U+6wVJgHE9JWtvTShzh4mHuvb/Mw6j12810VtW0bidqu2iIrAiIgIiICwsqR4o4uFO8U1LH7RWP8MTTowH68jvqtG9ufkNVEzodnHMcpqOIy1MgY3YX1c49GtGpPoo51TimJ+HNh9IeZ/aJGnoPqA9d/ULawXhQ9r7ViL/aao6i+scXPLGw6afat/dVS4M3M9KfdpWvu4+A8NUlGPmIwHnxSu70jidyXnXXoLDyXXRF51rTadzO1ojQiIqJEREBfmWRrGlzyGtaCXOJsABqSSdgv0of5RMPqpBG9rXTUcZDqinjJbI8A3vmF87RvlFtve3XFSL21M6RM6edRUTYy90VO50WHtOWWYaPqCN42X2byJ58+i79fwlRS0raYxBjGD5tzNHsd9tr9819Te9+d1tcPYjS1FO11G5vZABoa0BuSw8BZ9UjoumtL5bVnVfh1+u6NJThvHaimqG4diTsznD9VqdhM0fUd0kGnrsdbF16pfibA462ndE/uu8UTxuyQeB4I19fK68+A8dfUwvhqNKqmd2U4+0R4ZB5OAOvUG2ll6XGz/i17+YUtGlaiIulUREQEREGFyce4gpaKPtKmRrB9UbucejWjUqexvjGR8xpMKjFRUDR8h+ih5Xe4bnfujpzOi4OKYdHh8Zq6h5rcRlIjhdIL/Ou0aI49mtbe/wCAteyyvlrWdeZn0TEMxcW4jidU+mo2miiYA6WV7c0oafCMp7rXO5DewJvou9hPBVFA7tHNNRMdTLUHtHk9e9oPcL+a2OEcC9jpgxxzzSEyzv3LpH6uN+YGw+PMruLzeRybWtqs9l61ZWERca4iIoBERBlTuPcJQVLhKwugqW6sni7rwfvW8Y9dbc1QotKXtSd1lExtM4BxRNFO2ixUNbOfoZm6MnA/Br+o015C4vcKa4gwOGsgdDMNN2OHiY8eF7TyI/EaLR4IxyYukoK4/rVPazv40P1ZRfc6gH1HO4Hr8fkRljXrDOY0tERF0qiIo/5QMaliiipqQ/rVW/soz9hv7yTyyg78r35KJnQ1OIOJ5ppnUOF2dONJpzqynGx12c/ew69SDbf4b4chomEMu+R/elmfq+R25JJ1tfl+ZuV7cPYJDRU7YYRoNXuPie8+J7jzJ/AWHJdNeRyOTN51Xw0rXQiIuNcREQEREBERAWVhEEljXC8rJTV4Y9sNT+8jP0c43s9uwd978jqt3hviiOqLoXtMFVHpLA/RwI3LftN53HIjqCtjiXiGGiiD33fI85YomavkfsGtHS5Fz58zYHlcOcPSun9vxCzqpwtGweGnZrZjertTc8rnzK6/4se8n0n1/wCKevZWqNx39SxOlrW6RzkUdT0u76GQ+YIsSeTLc1ZLgcd4f7RhtTHa5EZkb1zR99tvXLb3qvGydGSJ+ibRuFki5HC2Impoaec7yRMc7+a1n/4gV117bIREQeUkjWtLnEAAEkk2AA3JJ2C+eV2L1OLSOgoHGGjack1UNHSW8UcXl97z6aO866WTGal8THubhsDsshYbGplbqWh32B1G+/MFtpTU7I2NjjYGMYA1rWiwAHIBcXJ5P4favn/C9a7a2D4RBSRCKnjDGD4uP2nO3cfMqV4l+Yxajq6jv05a6BhO0Ez9nn+ba52segVwuBxpLReySR10rIo5GkC+rsw1a5jBcuINjoOS4MN5m/fvvtPv3WmOygWFMfJ5ic89Cz2hjw9ncD3tLe1YPA8ZtTcWBPUX5qnWeSnRaa+yYERFmkREQEREBERAUhx7SPjbFiNOPnqN2Zw2zwHSRhPSxJ8hmVevzJG17S1wu1wLXA82kWI94WuHJOO8TCJjcNvD6xk0TJYzdkjGvafuuFx+a2lC/JhK6OKooXm7qOd8bb7mJ5Lo3H179vIK5XvRO42xF89wv9axqsqHaspWMpIugeQXSkeYOZvo5fQl8++TkXjrXnxPr6ku/wAP/wC965+VbpxStXyr0RF4jUREQEREBERAREQFxOJuI46Nje6ZJnnLDCzV73nbQahvV3wudF21xeJOG4K2MB+ZkjDmjmZpIx3Ihw3F92/kbEa4ujq+Pwid+jm8M8NSCU1uIuElY8aDdkDT+7YNr2Ni71sTcudWKMwviOelmbSYtZrzpDVDSOYcg47Mf1/G2hdaK2eL9W5+ntr5FdMI5gcC07HQ+h0KJmA1Ow1PuWMeUpv5I3H9FRsP7uSaP4SuP/crdQ/yRAnC2PP7yWZ498pH/aVcL6NgwpP5R8WfT0LhD9NO9tNFbfPLoSDyIaHWPWyrFCcXfO4vhkJ8LO3qHD7zGDIfcR+Kra2qzPsO1gWFMpKaOnj8MbQ0n7Tt3u9S4k+9b5Om1/Ic/LVEXgWmZnctnzXiDjarFQKbJ+jWO09oqWOeTt4AwOj573I+8FQcPcKULSKnP7bK7X2iR4lufu6lrbctyOqpqiBkjCyRjXsdoWvaHNPq06FStVwHA15koJZaKQ7mFxLHdM0bjYjyBA12XTGWk16Y+H9fdXUq5FCYHxBiArzQythq8gBkniLmdm374y5c/wBxoGp33tdrDLjmk6laJ2IiLJIiIgIiICIiAiIglMI+a4hqWDaoo45j/NE4RjT0zFXqgXf+o4bbigfm9O2db8VfFe/gneOv9mM+RfPeEfmK/EqN2h7f2tn3mTgE28mnI2/Ur6EojjrC5mSRYlRszT04LZIx+9gOr2abltyR6ncgBM2PrpNSJ1KlRaGC4xDVwNmp35mu+LXc2OHJw6e/Zb68K1ZrOpbbERFUEREBERAREQERCeqDUxPDYamJ0VQwSRu3B68iDuCORGqh48VlwaaOlqZDUUshtA+4dPHrYMdGO89mtgQPTk1dGv4rlqZHU2ENEsg0kqXfQx+h+u7oBcfzarocPcJxUzzNI91RVO1fPJq6/MMB8LeWmttL20XZX93XWTxPp/v5KeZ7KIFcHjnEvZsOqJL2d2ZjZ1zydxtvTNf3LvKNxke3YrT0bdYqUirqTyzj6GM+etyDuHHoqcbH15I+6bdoVnCmGmloaeAixZEwO/nIu/8AxErsoi9tkwoTic5Maw158MjKiG/R2S7R7yQrtSnyhYRJUUmen/aKd7aiG25fHqW+dxfTmQFW9eqsx7ph2lhczh3Go6ymZURbPHebza8eNh9D8RY81018/es1nUtYkUlxLjsz5vYMP1qXC8sm7aeM7vcftkEWHmOZCrVIcZ4bLHIzEqQXngFpGD99B9dp6lo1H/kBaYOnr7/T236Is7XDuBQ0UAiiBJJzPe7xPed3uPXy5LqrTwnEYqmCOeF2Zj25genItPQg3BHULcVLzabT1eUwIiKiRERAREQEREBEWrileynhkmk8ETHPd55RoB5k2A8yrREzOoE/w+O2x2slA7tPBFSg8i557R3vBaR/qrxR3yZYe9lD2030tXI+qk/6h7g9MoBt94qxXv0r01iPZgyiIriFxng+WOZ1XhLxDM7WSF30M3q0eFx6jz2JJX5wfjGN8ns9ZG6jqtuzk0a/zZJ4XA8vwvurtczGsDpquPs6qJsjeVxq09WuGrT5grDLgpk8+fdMWmH6WFHuwHFMP1oZPbKcf8PO60jR0jl/sdPIrawzjeklf2U+ekn2MVQMhuTbuvPddflsT0Xm5OJenzhpF4lTIiLlWERFAIiIChPlKZKDA6V7xh+cMqmx91/eNmuc7csvYED8SRa7XlU07JGOjkaHMe0tc07FpFiFthv0XiyJ7vLDKSGKJjKdjWRgAsDPDY65vO+9zqbraUXwdPJTVM2FvcZGRN7WB+5bE46Rv6OGYW8vKy7XEnEkFEwdpd8j9I4Wd573HYBo2F+f5nRWyYrTfUd9oiezHFWPso4M9s8ryI4YxqZJHaNAA5AkE/Dche3BHD7qSnLpzmqZnGWof1e7XLfo29ul7nmtDhjhyd8/6QxKxqCLRRDVtOw8h1eb6nzKtl6nHwRir858qWnbKIi6FRERBAY1gNVRzvrMMb2jZDmqaTYPPOSPo/fTnrvey6nD/ElNWtPYvs9uj4njK9hGhDmHodLi4VUpniPg2lrHCXvQ1DdWTxHK8EdbeIctdbbELmzcauXv4laLadRfmWRrGlz3BrRqXOIAA6knRR0mM4jh3dxGI1EA2q4BqB1kj5eZFh6rgcTshqJWYg2R1fQtt21O2RwMP/MEYI0G5a4A9dDdvDHEtFtT2hbqbnDGKRRYpJT0BdPRzHO7s2OLaeY+KzrZezdYbaC46a/Rlo4NJTOgjdSdn2LhdvZgNbb0Gx5EHUHdbyxz3i1vGk1ERFgsIiICIiAiIgKK4hccRrmYZHcwxFs1a4bZWm8cN+pNiR6fZK3+J+IXxvbSUTe0rZBZjRqImneR52AA1AP+vY4S4dZQ0/ZhxfK9xkmlO75Haucb625Af3JK9Licfv12+il7ejvMaAAALAaADkv2iL0mYiIgIiIC52KYPT1TMlTCyRvLO0Ej0O4PmCuiiCCdwJLT64XWywD+DJ87F6AO1b66lef6Wxim0qqBtQ0by0j7n/4394n4L6AiyvhpfzCYmYQMHyhYeSGzOkpn/Yniewj3gEfiu3SY9Ry/RVML/wCWVl/he67tRTskGV7GuHRzQ4fArhVfA2FSXzUcNz9luT/JZc1uDjnxMwt1y6LXA7G/pqv1lPQqZPyX4UPBHJH/ACTSj83FY/3Z0P8AEqrdO3es/wBg/q/JPWo5JGtF3uDR1cQB+Knca43oKZjvn45JADljjdnc59u63uXAubbr9R/JjhQIL4XyEfxJZHfhmAVBhuAUdN+z08UZ6tY0H+q1/wAVenBrE952ibvl/CFPjEjJHwwCCSokMs1XUDXc5WxxEXytB0zXGp2FlecO8GwUrzM9zqiqd455Tmd5hoOjR6a20uqhF2xWIncQoyiIrAiIgIiICIiDBCkMX4BpJZO2gz0s/wDFgOS998zPC4HntdWCIPkWFYBi+ESvdE0VtNIS6SOOzHB322sPhd5NuCNOQIoqHjygkdkle6mk5x1DDGR7z3fxV0tLEMMp6huWeKOVvSRjXfC40XPl41Mk7nytFphrwyNe3MxzXtPNpDh8Qv2puo+TWguXUzp6R5+tBK5v4OuPhZeR4WxaP9nxUuA2bPCx/wAXjX8FyX4E/wAsrRdUrKlDBxEw/wDASj/qsJ/sgqsfG9FSn0nI/NZTwcnyT1wqkUsZuIHaNpKOPzfK93+VY/QWOzW7augpxzFPEXH0DpLEeqmvByT51B1woq+uhgaXzyMjYPrPcGj3X3PkFJu4gq8QJjwmMsjJs+slaWsA59mwi73eo9w3XVw/5PaJjxJUmSsl+3UvMnwZ4beoKrmMDQA0AAaADQAei68fDpWdz3lWbzLhcL8LwULHZC6SV5vLNIbvkPmTsPL8zqqFEXYoIiICIiAiIgIiIOXX47SwPyTTMY4NDyHG1mkkBxOwF2nU9CtptZGXOYHtLmsbI4X2Y8nK4+Ryu18ionia4raoGofTiSjhYCyLtM5zz3aBkcbjMNG698eS8J6KeVk7Wwlj3YfQgxC/1JJXSwAu3JZdmp+sLoK+i4io5niOKdj3OuWgHxBuriwnR4H3br3xDF6eBzWzSNY5wLmg3JIaQHGwGwzD4rhP4lD5qVlLZzXSZJWOglDo2lhIJdcNiILcuVwJObTYr88STOZiFO8S9iPZqhucx5xcywkMtyJyk/8AtKChgxSB72xtkaXujEzW37xiJsH2Otr6LynxylY3M+VoHaOhvqfnGXzM0G4yu+BUziVC+pre1p3DtY6SKWnlIIaXiWW7HaeB7TlcN7OB3AWlRVVm0s0rHxD9JVUj2vabx54pxZ2W/wBZwF9jcdUFpHjVK6J0zZmGJhIc8OuGkGxDrbG5Gh6rYlrY2SMic9ofIHFjCdXBgu+w52BCh8YvM2vnhjeInwwxgmNzO1lZI8ue1rgHOAa5jc9tbaXAWcabWPnqKuGFrm074xGS94kLaYl84jiEZDu07SSPxi+UeSC3irY3SPia9pfHlL2g6tDxdhI6EA/BelLUslY2SNwcxwu1w2IUY+nkNXU1lM0uljdC4NAt20LoGl8Vzz0zN6PaORK7fBQP6Pp7hzfm9nCxGp0I5FB30REBERAREQEREBa8VUxz3sa4FzMudvNuYXbf1Gq2FKU2IxQ19YJXZM5gy3a6zrRWNiBbdB1KriGkjBMkzGgF7STewMZs8E20sd15v4oomtzunaG66kOA0AJ1I8wuBVxOOF4o0Nddz66wsbm5daw53Xb4zaXYZVhoJJp5QANSSYzoAEG7S4zTSFojka4uJa0ai5a3M4C45NN0rsapoXiOWVrHlucNNyct7XsBtfRcvH6hsdVRSPJDGmbM6xIGaKwvYG1yubiOIg17ZY6jsmOpbB5iLw4iZ3d1GhFigrKrEYYo+1keGx93vG9u+QG/EkD3rXbjlKWB4laGukbECbtBkd4WagalcvjSTPQtex1h21I8PDS6zRUxuz5dyAO9byWliwjq4II3vFS01bGyEMLBlcx/1eVrjXrYoKmpxGGMuD5GtLIzK+5tljF7vPlofgvCgxymmdkimY91s2W9nZftBp1I81EV0dTavima9748NlibJl0maTIY3i277ENcPtNJGhC7E9UyqkomU4c58UrZXyZHBsbGxua8F7gBd+bJkBJ1vawugopcWp2wGofKxsQuDITZos/Jufvaeq9Zq6Jj42Pe1r5cwjaTq4tGZwb1sNVCQQzywUtMyFsgDqieVkrnRsLGzPZGxzhG83Ln5wMv7rdI6KSpbRQVAcyWEVMLpBqWSwtYIpWuIFyQGPBsL3ItqQgvo6ljnvY1wLmWDwN2lwzC/qNVsKT4QkndPWGojLJc8TX6Wa5zIQ0vYebXWzDmAbHUKsQEREBERAREQEREGLJZZRBiyyiIMWSyyiDFllEQYssoiAiIgIiICIiAiIgIiICIiDFkssogxZZREGLJZZRBiyWWUQEREBERB//Z" /></p>
</blockquote>
<p>大小端在日常使用中两者都有可能遇到，但在网络传输中 TCP/IP
规定数据包字节序为大端，如果是小端机器，那么在传输过程中就需要先将小端数据转换成大端数据再进行发送，同时在接受数据时也需要先将数据转换成小端再进行读取（仅针对多字节数据，例如
<code>short</code>，<code>int</code>，<code>double</code>等
），字节序和字符串编码一样，<strong>我们在使用前必须提前知道处理的数据字节序情况</strong>，否则就会出问题。</p>
<h4 id="utf-8--utf-8-with-bom">UTF-8 &amp; UTF-8 with BOM</h4>
<p>前面提到，UTF-8 后面的 8 表示其编码单位是 8 位，即我们可以使用
<code>char</code> 来存储 UTF-8 字符串，但是很明显 8 位存不下所有的
Unicode 字符，那么就使用多个编码单位来表示一个字符。</p>
<p>为了确保我们可以从字节流中准确还原出 Unicode 字符，UTF-8
编码规则如下（RFC3629）</p>
<ol type="1">
<li>确定 Unicode 字符所需要的字节数</li>
<li>在首字节中添加长度标识前缀（<code>110</code>，<code>1110</code>，<code>11110</code>)，在剩下字节中添加标识前缀（<code>10</code>）</li>
<li>对于单字节字符，直接使用 ASCII
编码，对于多字节字符，从低位到高位开始，每次选取 6
位填入编码中（从后向前）</li>
</ol>
<p>下表展示了 Code 和 UTF-8 编码之间的转换关系</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">UTF-8 &lt;-&gt; Unicode Conversion</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|    Unicode Range    |  Byte[0] |  Byte[1] |  Byte[2] |  Byte[3] |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+000000 ~ U+00007F | 0xxxxxxx |          |          |          |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+000080 ~ U+0007FF | 110xxxxx | 10xxxxxx |          |          |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |          |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+010000 ~ U+10FFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：实际上使用 4 个字节的 UTF-8 编码最大可以表示到 U+1FFFFF（21位的
Unicode 字符），且 UTF-8 最多可以使用 6 个字节来表示一个 Unicode
字符，但是为了和 UTF-16 的表示范围一致，其将最大可表示范围限制到了
<code>U+10FFFF</code>（也就是 20 位的 Unicode 字符）</p>
</blockquote>
<p>下面来几个转换样例（编码）：</p>
<p><code>A</code>：U+0041</p>
<p>对于在 <code>U+0000</code> 到 <code>U+007F</code>
之间的字符，直接使用 ASCII 码即可</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">| U+000000 ~ U+00007F | 0xxxxxxx |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">|       U+000041      |  1000001 |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">|       U+000041      | 01000001 |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">|       U+000041      |   \x41   |</span><br><span class="line">+---------------------+----------+</span><br></pre></td></tr></table></figure>

<p><code>α</code>：U+03B1</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">| U+000080 ~ U+0007FF | 110xxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       U+0003B1      |    01110 |   110001 |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       U+0003B1      | 11001110 | 10110001 |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       U+0003B1      |   \xce   |   \xb1   |</span><br><span class="line">+---------------------+----------+----------+</span><br></pre></td></tr></table></figure>

<p><code>你</code>：U+4F60</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+004F60      |     0100 |   111101 |   100000 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+004F60      | 11100100 | 10111101 | 10100000 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+004F60      |   \xe4   |   \xbd   |   \xa0   |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p><code>🧐</code>：U+1F9D0</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |  Byte[3] |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+010000 ~ U+1FFFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       U+01F9D0      |      000 |   011111 |   100111 |   010000 |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       U+01F9D0      | 11110000 | 10011111 | 10100111 | 10010000 |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       U+01F9D0      |   \xf0   |   \x9f   |   \xa7   |   \x90   |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>Unicode 转 UTF-8 代码实现（C++），通过简单的位运算就可以实现了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">encode_utf8</span><span class="params">(<span class="type">uint32_t</span> u)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint8_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span> (u &lt; <span class="number">0x80</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(u);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &lt; <span class="number">0x800</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xc0</span> | (u &gt;&gt; <span class="number">6</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | (u &amp; <span class="number">0x3f</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &lt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xe0</span> | (u &gt;&gt; <span class="number">12</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | (u &amp; <span class="number">0x3f</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &lt; <span class="number">0x10ffff</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xf0</span> | (u &gt;&gt; <span class="number">18</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | ((u &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3f</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | (u &amp; <span class="number">0x3f</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; fmt::format(<span class="string">&quot;Failed to encode &#123;&#125; to UTF-8, replaced with U+FFFD&quot;</span>,</span><br><span class="line">                             <span class="built_in">unicode</span>(u))</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xef</span>);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xbf</span>);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xbd</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 UTF-8
字符串的解码，也是类似，我们首先判断当前字节流前缀信息，得出当前字符的字节位数，然后根据这个信息读取后续的字节数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> one_byte = (curr_byte &gt;&gt; <span class="number">7</span>) == <span class="number">0x0</span>; </span><br><span class="line"><span class="type">bool</span> two_bytes = (curr_byte &gt;&gt; <span class="number">5</span>) == <span class="number">0x6</span>;</span><br><span class="line"><span class="type">bool</span> three_bytes = (curr_byte &gt;&gt; <span class="number">4</span>) == <span class="number">0xE</span>;</span><br><span class="line"><span class="type">bool</span> four_bytes = (curr_byte &gt;&gt; <span class="number">3</span>) == <span class="number">0x1E</span>;</span><br></pre></td></tr></table></figure>

<p>完整 UTF-8 转 Unicode 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">decode_utf8</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint32_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> curr = *it;</span><br><span class="line">    <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">7</span>) == <span class="number">0x0</span>) &#123;</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">5</span>) == <span class="number">0x6</span>) &#123;</span><br><span class="line">      c |= (curr &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">6</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>);</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">4</span>) == <span class="number">0xE</span>) &#123;</span><br><span class="line">      c |= (curr &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">12</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">6</span>;  <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>);</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">3</span>) == <span class="number">0x1E</span>) &#123;</span><br><span class="line">      <span class="comment">// get 3 bit from value</span></span><br><span class="line">      c |= (curr &amp; <span class="number">0x7</span>) &lt;&lt; <span class="number">18</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">12</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">6</span>;  <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>);</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cerr &lt;&lt; fmt::format(<span class="string">&quot;Failed to decode byte &#123;&#125; at index: &#123;&#125;&quot;</span>,</span><br><span class="line">                               <span class="built_in">hex</span>(*it), it - s.<span class="built_in">begin</span>())</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">      <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：对于 UTF-8
的解码，还有很多加速算法，这里就不做过多的介绍了，详细可以参考这篇博客：<a
href="https://nullprogram.com/blog/2017/10/06/">A Branchless UTF-8
Decoder (nullprogram.com)</a></p>
</blockquote>
<p>最后我们再简单介绍一下 UTF-8 with BOM，从名字上就可以知道，UTF-8 with
BOM 就是在 UTF-8 的基础之上添加了一个 BOM（字节序标志），这个标志的
Unicode code point为 <code>U+FEFF</code> ，表示
”零宽无间断间隔“，仅在传输过程中用来确认字节顺序，打印时不占字宽，（但在控制台打印等宽表格中会计算其长度，导致输出有问题，这一点需要注意）。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">UTF-8 encoding of U+00FEFF</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FEFF      |     1111 |   111011 |   111111 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FEFF      | 11101111 | 10111011 | 10111111 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FEFF      |   \xef   |   \xbb   |   \xbf   |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>将文件手动保存为 UTF-8 with BOM</p>
<p><img data-src="/posts/c4ef/image-20230127221806025.png"
style="zoom:50%;" /></p>
<p>以二进制形式读取文件（<code>rb</code>），我们可以看到文件的前三个字节为固定的
<code>[0xEF,0xBB,0xBF]</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+----------------+--------------+-----------------+</span><br><span class="line">|      file      | size (bytes) |  first 3 bytes  |</span><br><span class="line">+----------------+--------------+-----------------+</span><br><span class="line">| UTF-8 with BOM |     207      | b&#x27;\xef\xbb\xbf&#x27; |</span><br><span class="line">|     UTF-8      |     204      | b&#x27;\xe3\x80\x8e&#x27; |</span><br><span class="line">+----------------+--------------+-----------------+</span><br></pre></td></tr></table></figure>

<p>由于 UTF-8
的编码单位为字节，实际上完全没必要考虑字节顺序的问题，因此并不推荐使用
UTF-8 with BOM ，甚至在某些情况下 UTF-8 with BOM
还会导致代码无法运行（例如 PHP）。</p>
<p><strong>彩蛋：”锟斤拷“ 是怎么来的？</strong></p>
<p>对于编码失败的情况，UTF-8 编码器会直接将其转换成 <code>U+FFFD</code>
，显示为 <code>�</code>，其对应的 UTF-8 编码如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">UTF-8 encoding of U+00FFFD</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FFFD      |     1111 |   111111 |   111101 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FFFD      | 11101111 | 10111111 | 10111101 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FFFD      |   \xef   |   \xbf   |   \xbd   |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>即
<code>[0xEF,0xBF,0xBD]</code>，在编码错误的情况下，就可能会连着出现，也就是</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[...,0xEF,0xBF,0xBD,0xEF,0xBF,0xBD,...]</span><br></pre></td></tr></table></figure>

<p>由于 <strong>GBK
编码是双字节编码</strong>，其会将其解析为三个汉字，而这三个字就是
<code>锟斤拷</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;\xef\xbf\xbd\xef\xbf\xbd&#x27;</span>.decode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;锟斤拷&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在中文环境下，出现 <code>锟斤拷</code>
就基本上就表示我们将一个原本是正常编码的文件<strong>采用 UTF-8
编码打开并以 UTF-8 保存</strong>，由于 UTF-8
编码无法对文件中字符进行编码，就全部替换成了
<code>�</code>，此时我们再通过 GBK 打开时就会出现满屏的
<code>锟斤拷</code>
了，而且这种错误是不可逆的，因为无法编码的字符已经被替换成了
<code>�</code>，我们再也无法找回之前的编码了。</p>
<p>下面给出了一个具体示例：</p>
<p>文件初始内容：</p>
<p><img data-src="/posts/c4ef/image-20230120000459771.png"
style="zoom:50%;" /></p>
<p>我们原本的文件是 GBK 编码的，我们将窗口关闭，再打开。由于 VS Code
并不知道文件的编码，便默认使用 UTF-8 编码打开，内容如下：</p>
<p><img data-src="/posts/c4ef/image-20230120000558448.png" /></p>
<p>如果此时我们手贱，将文件保存的话（<kbd>Ctrl</kbd> +
<kbd>S</kbd>），文件就会以 UTF-8 编码保存，而其中 <code>�</code>
就会直接写入到文件中。</p>
<p>假如我们又看到了文件名中的
<code>文本-gbk</code>，知道文件的正确编码为 GBK，再次使用 GBK
编码打开时，文件内容如下：<img data-src="/posts/c4ef/image-20230120000912272.png" /></p>
<p>我们永远也不知道文件里写了什么了！😭</p>
<blockquote>
<p><em>“白色相簿”什么的，已经无所谓了。</em></p>
<p><em>因为已经不再有歌，值得去唱了。</em></p>
<p><em>传达不了的恋情，已经不需要了。</em></p>
<p><em>因为已经不再有人，值得去爱了。</em></p>
</blockquote>
<p>血的教训告诉我们：<strong>当打开不知道编码的文件时，千万不要手贱按下保存，保存后很有可能无法还原了！</strong></p>
<h4 id="utf-16--utf-32">UTF-16 &amp; UTF-32</h4>
<p>UTF-16 的编码单位为 16 位，即 2 字节，而 UTF-32 的编码单位为 32
位，4字节。</p>
<blockquote>
<p>注：编码单位（code
uint）是编码中每个字符编码的基本元素，对于定长编码中，编码单位大小就等于字符大小，例如
GBK 中编码单位为 2 字节，其可表示的所有字符都是 2
字节；对于变长编码，一个字符的编码可以由多个编码单位进行表示。</p>
</blockquote>
<p>由于 UTF-16 和 UTF-32
的编码单位为多字节，必定要考虑字节顺序问题。我们可以手动指定字节顺序（和
UTF-8 with BOM 类似，在文件开头添加 <code>U+FEFF</code>
来自动判断编码），也可以直接使用 <code>LE</code>
后缀或<code>BE</code>后缀的编码来表示，例如 UTF-16LE 和 UTF-16BE。</p>
<p>在 UTF-16 编码中，一个字符由1个或2个16位整数表示，最大可表示字符为
<code>U+10FFFF</code>，<strong>参考 UTF-16
规范（RFC2781）</strong>，其编码和解码规则如下：</p>
<ol type="1">
<li>对于 <code>U+0000 ~ U+FFFF</code>
的字符，其直接使用1个16位整数表示即可，且值等于 Unicode Code Point
值。</li>
<li>对于 <code>U+010000 ~ U+10FFFF</code>
的字符，使用2个16位整数表示（称为 surrogate
pair，代理对，意为16位整数对表示一个字符），每个部分存储 Unicode Code
Point 的10 位（需要进行特殊处理），再在前面添加前缀（6
位），第一个前缀为 <code>110110</code>，第二个前缀为
<code>110111</code></li>
<li>对于 <code>&gt; U+10FFFF</code> 的字符无法使用 UTF-16
编码表示（目前并不存在）</li>
</ol>
<blockquote>
<p>为了保证 UTF-16 解码的唯一性，对于 <code>U+D800 ~ U+DFFF</code> 的
Unicode 字符不做编码。</p>
</blockquote>
<p>同样，下面给出了一个转换示例</p>
<p><code>🧐</code>：U+1F9D0</p>
<ol type="1">
<li><p>首先减去 <code>0x10000</code>，确保 <code>U'</code> 的范围在
<code>0xFFFFF</code> 之间（最多支持 20 位）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">U&#x27; = U - 0x10000</span><br><span class="line">   = 0xf9d0</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别取出 <code>U'</code> 的
前10位和后10位，填充到两个16位整数中</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">w0 = (U&#x27; &gt;&gt; 10) &amp; 0x3ff</span><br><span class="line">   = 0b0000111110</span><br><span class="line">w1 = U&#x27; &amp; 0x3ff</span><br><span class="line">   = 0b0111010000</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后添加6位的前缀</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">w0 = w0 | 0xd800</span><br><span class="line">   = 0b1101100000111110</span><br><span class="line">   = 0xd83e</span><br><span class="line">w1 = w1 | 0xdc00</span><br><span class="line">   = 0b1101110111010000 </span><br><span class="line">   = 0xddd0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终得到 <code>🧐</code> 的 UTF-16 编码为
<code>[0xd83e,0xddd0]</code></p>
<ul>
<li>UTF-16LE： <code>b'\x3e\xd8\xd0\xdd'</code></li>
<li>UTF-16BE： <code>b'\xd8\x3e\xdd\xd0'</code></li>
</ul>
<p>代码写起来就十分简单了，将上面的过程翻译成 C++ 位运算即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint16_t</span>&gt; <span class="title">encode_utf16</span><span class="params">(<span class="type">uint32_t</span> u)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint16_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span> (u &lt; <span class="number">0xd800</span> || (u &gt; <span class="number">0xdfff</span> &amp;&amp; u &lt;= <span class="number">0xffff</span>)) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(u);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &gt; <span class="number">0xffff</span> &amp;&amp; u &lt;= <span class="number">0x10ffff</span>) &#123;</span><br><span class="line">    u -= <span class="number">0x10000</span>;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(((u &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x3ff</span>) | <span class="number">0xd800</span>);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>((u &amp; <span class="number">0x3ff</span>) | <span class="number">0xdc00</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; fmt::format(</span><br><span class="line">                     <span class="string">&quot;Failed to encode &#123;&#125; to UTF-16, replaced with U+FFFD&quot;</span>,</span><br><span class="line">                     <span class="built_in">unicode</span>(u))</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xfffd</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于解码也是一样，不过我们需要验证一下 surrogate
的有效性（必须成对存在）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">decode_utf16</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint16_t</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint32_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="type">uint16_t</span> w0 = *it;</span><br><span class="line">    <span class="keyword">if</span> (w0 &lt; <span class="number">0xd800</span> || w0 &gt; <span class="number">0xdfff</span>) &#123;</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(w0);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">uint16_t</span> w1 = *it;</span><br><span class="line">    <span class="keyword">if</span> (w1 &lt; <span class="number">0xdc00</span> || w1 &gt; <span class="number">0xdfff</span>) &#123;</span><br><span class="line">      std::cerr &lt;&lt; fmt::format(<span class="string">&quot;Failed to decode word &#123;:#04x&#125; at index &#123;&#125;&quot;</span>, w1,</span><br><span class="line">                               it - s.<span class="built_in">begin</span>())</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">      <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x10000</span> + ((w0 &amp; <span class="number">0x3ff</span>) &lt;&lt; <span class="number">10</span>) | (w1 &amp; <span class="number">0x3ff</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：UTF-16、UTF-16LE、UTF-16BE 的区别：</p>
<ul>
<li>UTF-16 类似于 UTF-8 with BOM，在文件开头添加 <code>U+FEFF</code>
标记，用来标识存储内容的字节顺序</li>
<li>而 UTF-16LE 和 UTF-16BE则是在编码时就约定好字节顺序，不需要通过 BOM
来确定。</li>
</ul>
<p>对于 UTF-32、UTF-32LE、UTF-32BE 也是类似，和 UTF-8 with BOM
类似，一般直接使用 LE 或 BE 版本即可，最好不要在文件开头添加
BOM（有可能影响文件解析）</p>
</blockquote>
<p>而对于 UTF-32 编码，就简单很多了，目前最大的 Unicode 字符也就到
<code>U+10FFFF</code>，使用 32 位来表示完全足够了（即 Unicode code point
就是 UTF-32 编码值）。但是代价也很明显，存储代价太大了，对于纯 ASCII
的代码，需要 4 倍的存储空间。而在 Python 中就采用了
Latin-1（ASCII）、UTF-16 和 UTF-32
的混合表示方式（代价是性能，但是其字符串操作上十分便捷）。</p>
<h2 id="unicode-in-c">Unicode in C++</h2>
<p>目前 Windows 并不支持 UTF-8（使用的 UTF-16），如果我们编写了一段 c++
程序输出 UTF-8
字符串，我们会看到乱码的结果。<strong>除此之外，对于文件的读写、命令行参数的传递也会出现同样的问题</strong>。如果我们想编写跨平台应用程序，最好保证使用的所有字符串都是
UTF-8。通过 <code>Boost.Nowide</code>
库可以实现这个转换。（单纯输出乱码的话可以使用 <code>fmt::print</code>
来解决乱码问题）</p>
<p>使用时我们需要<strong>确保在程序中使用的 <code>char*</code> 和
<code>std::string</code> 都是 UTF-8
编码的</strong>，进行文件I/O、解析命令行命令以及 stdout、stdin、stderr
时统一使用nowide库进行操作，就基本可以屏蔽掉大部分的坑。</p>
<p>对于命令行命令的解析，有一点小坑，我们需要手动链接
<code>shell32.dll</code> ，这个在 Windows SDK
中自带，只需要链接上即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/nowide/args.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/nowide/iostream.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/ranges.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> nw = boost::nowide;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  nw::args _(argc, argv);</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">args</span><span class="params">(argv, argv + argc)</span></span>;</span><br><span class="line">  nw::cout &lt;&lt; fmt::format(<span class="string">&quot;arguments: &#123;&#125;&quot;</span>, args) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 xmake</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">target(<span class="string">&quot;nw&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    set_languages(<span class="string">&quot;cxx17&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/nw.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;fmt&quot;</span>,<span class="string">&quot;tabulate&quot;</span>,<span class="string">&quot;boost&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">        add_cxxflags(<span class="string">&quot;/utf-8&quot;</span>,&#123;tools=<span class="string">&quot;cl&quot;</span>&#125;)</span><br><span class="line">        add_cxxflags(<span class="string">&quot;/RTC1&quot;</span>,&#123;tools=<span class="string">&quot;cl&quot;</span>&#125;)</span><br><span class="line">        add_defines(<span class="string">&quot;BOOST_USE_WINDOWS_H&quot;</span>,<span class="string">&quot;NOMINMAX&quot;</span>)</span><br><span class="line">        add_links(<span class="string">&quot;shell32&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set_installdir(<span class="built_in">path</span>.join(<span class="built_in">os</span>.scriptdir()))</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img data-src="/posts/c4ef/image-20230129173623164.png"
style="zoom:50%;" /></p>
<p>此处链接 <code>shell32.dll</code> 十分关键，如果没有就会报错
LNK2019：无法解析的外部符号 <code>__imp_CommandLineToArgvW</code></p>
<p><img data-src="/posts/c4ef/image-20230129173845768.png"
style="zoom:50%;" /></p>
<p>这个函数实际上就是 Windows
提供的命令行参数编码转换函数，具体可以参考：<a
href="https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw">CommandLineToArgvW
function (shellapi.h) - Win32 apps | Microsoft Learn</a></p>
<p>还有另外一种解决方案，就是开启 UTF-8 实验性功能，这样 Windows
强制所有编码都是
UTF-8，就是对一些老应用不友好，特别是之前编译的中文应用，因为其使用的可能是
GBK 编码。</p>
<p><img data-src="/posts/c4ef/image-20230118163241733.png"
style="zoom:50%;" /></p>
<p>将其勾上然后重启电脑就可以了，这样我们直接通过 <code>std::cout</code>
以及 <code>std::fstream</code>
打开文件时就不会乱码了，但是无法确保其他人也这么做，所以还是老老实实使用
Nowide 库比较靠谱。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">The
Absolute Minimum Every Software Developer Absolutely, Positively Must
Know About Unicode and Character Sets (No Excuses!) – Joel on
Software</a></li>
<li><a href="https://utf8everywhere.org/zh-cn">UTF-8 遍地开花
(utf8everywhere.org)</a></li>
<li><a
href="https://www.boost.org/doc/libs/1_81_0/libs/nowide/doc/html/index.html">Boost.Nowide:
Boost.Nowide - 1.81.0</a></li>
<li><a
href="https://learn.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getacp">GetACP
function (winnls.h) - Win32 apps | Microsoft Learn</a></li>
<li><a
href="https://learn.microsoft.com/en-us/windows/win32/intl/code-pages?source=recommendations">Code
Pages - Win32 apps | Microsoft Learn</a></li>
<li><a
href="https://learn.microsoft.com/en-us/windows/win32/intl/code-page-identifiers">Code
Page Identifiers - Win32 apps | Microsoft Learn</a></li>
<li><a
href="https://stackoverflow.com/questions/61449854/getting-error-lnk2019-unresolved-external-symbol-when-compiling-sdl2-code-in-wi">visual
c++ - Getting error LNK2019: unresolved external symbol when compiling
SDL2 code in Windows using MSVC - Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/56419639/what-does-beta-use-unicode-utf-8-for-worldwide-language-support-actually-do">c#
- What does "Beta: Use Unicode UTF-8 for worldwide language support"
actually do? - Stack Overflow</a></li>
</ol>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>Unicode</tag>
        <tag>UTF-8</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数执行原理理解</title>
    <url>/posts/55c5/</url>
    <content><![CDATA[<h1 id="虚函数执行原理理解">虚函数执行原理理解</h1>
<p>刷牛客时经常能刷到面向对象相关的题目，多态作为面向对象中的一个重要特性（封装，继承和多态），在八股中经常考察其实现原理。为了方便理解，我们给出一个简单的多态样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value + v; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value - v; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value * v; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> v * <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> value&#123;<span class="number">0xfeff</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> value + <span class="number">2</span> * v; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value * <span class="number">2</span> * v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> value&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就是经典调用函数写输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.value = <span class="number">2</span>;</span><br><span class="line">  A *a = &amp;b;</span><br><span class="line">  a-&gt;value = <span class="number">4</span>;</span><br><span class="line">  <span class="type">int</span> v = <span class="number">20</span>;</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;b.A::value=&#123;&#125;\nb.B::value=&#123;&#125;\n&quot;</span>, b.A::value, b.B::value);</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func1(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func1</span>(v));</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func2(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func2</span>(v));</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func3(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func3</span>(v));</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func4(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func4</span>(v));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>执行如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Cpp\learn-git&gt; xmake -brv learn-git &amp;&amp; xmake run learn-git</span><br><span class="line">[100%]: build ok!</span><br><span class="line">b.A::value=4</span><br><span class="line">b.B::value=2</span><br><span class="line">a-&gt;func1(20) = 42</span><br><span class="line">a-&gt;func2(20) = -16</span><br><span class="line">a-&gt;func3(20) = 80</span><br><span class="line">a-&gt;func4(20) = 40</span><br></pre></td></tr></table></figure>

<p>执行结果不难想到，根据虚函数运行时绑定的特性（晚绑定），通过基类调用虚函数时会根据实际类型调用对应的函数。对于非虚函数则是直接调用普通的成员函数（是
A 类时调用 <code>A::func3</code>，是 B 类时调用
<code>B::func3</code>），且需要调用的函数在编译期间就已经确定好了。</p>
<h2 id="成员函数指针">成员函数指针</h2>
<p>例子就介绍到这，下面我们要简单理解 C++
中实现原理，首先从成员函数指针来看，对于任意一个类别的成员函数，我们可以使用类似与函数指针的表达方式，即<code>void(T::*)()</code>，写成模板形式的话如下（当然，使用
<code>auto</code> 是最简单的，就是容易变成 auto
script，然后导致代码理解起来有困难）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">R</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如 <code>A::func1</code> 就可以采用如下的定义方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type ptr_test = &amp;A::test;</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/55c5/image-20230202162248754.png"
style="zoom: 67%;" /></p>
<p>可以看到，其实际上就是
<code>void (A::*)()</code>，但是这样比写函数指针稍微舒服一点，我们可以通过
<code>.*</code> 和 <code>-&gt;*</code> 的方式来调用成员函数指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(a-&gt;*ptr_test)();</span><br><span class="line">((*a).*ptr_test)();</span><br></pre></td></tr></table></figure>

<p>除此之外，我们也可以使用 <code>std::function</code>
的方式来封装封装成员函数，在函数的入参添加 <code>A*</code> 或
<code>A&amp;</code> 参数接口（对于 <code>const</code> 的函数还需要添加
<code>const</code> 修饰符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>(A*)&gt; std_ptr_test = &amp;A::test;</span><br></pre></td></tr></table></figure>

<p>然后在调用这个函数时将对象指针也作为参数传递过去即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std_ptr_test</span>(a);</span><br></pre></td></tr></table></figure>

<p>最后总结一下调用成员函数的几种方式（<em><strong>”茴“字的 4
种写法</strong></em>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常版</span></span><br><span class="line">a-&gt;<span class="built_in">test</span>();</span><br><span class="line"><span class="comment">// 指针版</span></span><br><span class="line">MemberFuncPtr&lt;A,<span class="type">void</span>&gt;::type ptr_test = &amp;A::test;</span><br><span class="line">(a-&gt;*ptr_test)();</span><br><span class="line"><span class="comment">// std::function 版</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(A*)&gt; std_ptr_test = &amp;A::test;</span><br></pre></td></tr></table></figure>

<p>之所以出现后面两种写法，主要就是为了实现
<code>Delegate</code>，当我们需要由代码来决定成员函数的调用时机时（例如事件响应等），我们就可以使用后面两种调用方式，不过在我们这里主要是探究虚函数的调用机制。</p>
<h2 id="成员函数指针的大小">成员函数指针的大小？</h2>
<p>当我们通过 <code>&amp;A::test</code>
拿到成员函数的地址时，我们自然将其联想到和普通函数指针大小一致，但是不然，<strong>其大小与不同的编译器有关（或者更准确的说，与
C++ Compiler ABI 有关）。</strong></p>
<p>我们在 <a href="https://godbolt.org">Compiler Explorer</a>
中进行运行测试（不支持 MSVC Compiler 的运行测试，但是可以测试 Clang 和
GCC）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof &amp;A::func = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(&amp;A::func) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下表所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Compiler</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">x86-64 gcc 9.4</td>
<td>16</td>
</tr>
<tr class="even">
<td style="text-align: left;">x86-64 clang 15.0.0</td>
<td>16</td>
</tr>
<tr class="odd">
<td style="text-align: left;">x86-64 msvc v19.25.28614 (default)</td>
<td>8</td>
</tr>
<tr class="even">
<td style="text-align: left;">x86-64 msvc v19.25.28614
(single_inheritance)</td>
<td>8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">x86-64 msvc v19.25.28614
(multiple_inheritance)</td>
<td>16</td>
</tr>
<tr class="even">
<td style="text-align: left;">x86-64 msvc v19.25.28614
(virtual_inheritance)</td>
<td>24</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：关于 MSVC 的成员函数指针大小的设置，参考<a
href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/pointers-to-members?view=msvc-160">pointers_to_members
pragma | Microsoft Learn</a>，可以手动指定成员函数指针形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pointers_to_members( full_generality, virtual_inheritance )</span><br></pre></td></tr></table></figure>

<ul>
<li>single_inheritance 表示单继承</li>
<li>multiple_inheritance 表示多继承</li>
<li>virtual_inheritance 表示虚继承</li>
</ul>
<p>如果不指定，就是根据函数类型自动选择空间最小的表示方式（也就是混合上面三种表示方式）</p>
</blockquote>
<h2 id="虚表和虚指针">虚表和虚指针</h2>
<p>对于一个包含虚函数的类而言，其会在类的起始处添加一个指向虚表的指针（vtable），称为虚指针（vptr）（在
MSVC C++ 中称为 vftable 和 vfptr）</p>
<p>虚表中存储了各种各样的类别数据信息（RTTI等），也存储了虚函数的实际地址，通过虚指针和虚表，我们就可以在运行过程中动态解析函数地址并进行调用。</p>
<p>MSVC、Clang 以及 GCC 中都提供了类内存布局查看的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gcc 调用命令</span></span><br><span class="line">g++ -fdump-lang-class=- test.cpp</span><br><span class="line"><span class="comment"># clang 查看命令 （-Xclang 表示传递后面的参数给 clang compiler） </span></span><br><span class="line">clang++-15 -Xclang -fdump-record-layouts test.cpp</span><br><span class="line">clang++-15 -Xclang -fdump-vtable-layouts test.cpp</span><br><span class="line"><span class="comment"># msvc 查看命令</span></span><br><span class="line">cl /d1 reportAllClassLayout test.cpp</span><br></pre></td></tr></table></figure>

<p>我们可以使用一个简单的类测试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>x86-64 gcc 9.4 输出结果</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">➜  src g++ -fdump-lang-class=- test.cpp</span><br><span class="line">Vtable for A</span><br><span class="line">A::_ZTV1A: 3 entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">8     (int (*)(...))(&amp; _ZTI1A)</span><br><span class="line">16    (int (*)(...))A::func</span><br><span class="line"></span><br><span class="line">Class A</span><br><span class="line">   size=16 align=8</span><br><span class="line">   base size=12 base align=8</span><br><span class="line">A (0x0x7ff174281420) 0</span><br><span class="line">    vptr=((&amp; A::_ZTV1A) + 16)</span><br></pre></td></tr></table></figure>

<p>x86-64 clang 15.0.7 输出结果</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">➜  src clang++-15 -Xclang -fdump-record-layouts test.cpp</span><br><span class="line"></span><br><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         0 | class A</span><br><span class="line">         0 |   (A vtable pointer)</span><br><span class="line">         8 |   int n</span><br><span class="line">           | [sizeof=16, dsize=12, align=8,</span><br><span class="line">           |  nvsize=12, nvalign=8]</span><br><span class="line">             </span><br><span class="line">*** Dumping IRgen Record Layout    </span><br><span class="line">...</span><br><span class="line">➜  src clang++-15 -Xclang -fdump-vtable-layouts test.cpp</span><br><span class="line">Vtable for &#x27;A&#x27; (3 entries).</span><br><span class="line">   0 | offset_to_top (0)</span><br><span class="line">   1 | A RTTI</span><br><span class="line">       -- (A, 0) vtable address --</span><br><span class="line">   2 | void A::func()</span><br><span class="line"></span><br><span class="line">VTable indices for &#x27;A&#x27; (1 entries).</span><br><span class="line">   0 | void A::func()</span><br></pre></td></tr></table></figure>

<p>x86-64 msvc 19.25.28614 输出结果</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Cpp\learn-git&gt; cl /d1 reportAllClassLayout test.cpp</span><br><span class="line">...</span><br><span class="line">class A size(16):</span><br><span class="line">        +---</span><br><span class="line"> 0      | &#123;vfptr&#125;</span><br><span class="line"> 8      | n</span><br><span class="line">        | &lt;alignment member&gt; (size=4)</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">A::$vftable@:</span><br><span class="line">        | &amp;A_meta</span><br><span class="line">        |  0</span><br><span class="line"> 0      | &amp;A::func</span><br><span class="line"></span><br><span class="line">A::func this adjustor: 0</span><br></pre></td></tr></table></figure>

<p>从图中我们可以看出，三个编译器给出的虚表结构以及内存布局基本一致，虚指针都位于类的前8字节，可以使用
<code>reinterpret_cast</code>
来读取，而虚表本质上是一个指针数组。我们可以尝试直接从虚表中拿到虚函数的真实地址进行调用。代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> v + <span class="number">20</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="comment">// 读取类的前8字节，拿到虚表指针</span></span><br><span class="line">  <span class="type">uintptr_t</span> *vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span> **&gt;(&amp;a);</span><br><span class="line">  <span class="comment">// 从虚表中拿到虚函数的地址</span></span><br><span class="line">  <span class="type">uintptr_t</span> ptr_func = vptr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">using</span> Func = <span class="built_in">int</span> (*)(A *, <span class="type">int</span>);</span><br><span class="line">  Func f = <span class="built_in">reinterpret_cast</span>&lt;Func&gt;(ptr_func);</span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">f</span>(&amp;a, <span class="number">20</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a.func(20) = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  res = a.<span class="built_in">func</span>(<span class="number">20</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a.func(20) = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>uintptr_t</code> 表示和指针大小一致的整型数，在 64 位平台上就为
<code>uint64_t</code>，使用这个方便跨平台使用</p>
</blockquote>
<p>如果调用调用正确，我们可以看到两行一样的输出</p>
<p><img data-src="/posts/55c5/image-20230202183658979.png" /></p>
<p>输出的确如我们所愿（x86-64 msvc 19.25.28614）</p>
<p>再在 compiler explorer 上跑下 GCC 和 Clang 的结果</p>
<p><img data-src="/posts/55c5/image-20230202190619327.png"
style="zoom:67%;" /></p>
<p>GCC 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202190941102.png"
style="zoom:67%;" /></p>
<p>这个例子比较简单，没有考虑继承情况，以及最关键的 this
指针问题，下面给一个稍微复杂一点的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v = &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> v + n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> n&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> n, <span class="type">int</span> f) : <span class="built_in">A</span>(n), <span class="built_in">f</span>(f) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v = &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f = &quot;</span> &lt;&lt; f &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> v + n + f;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> f&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  A *a = &amp;b;</span><br><span class="line">  <span class="type">uintptr_t</span> *vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span> **&gt;(&amp;b);</span><br><span class="line">  <span class="type">uintptr_t</span> ptr_func = vptr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">using</span> Func = <span class="built_in">int</span> (*)(A *, <span class="type">int</span>);</span><br><span class="line">  Func f = <span class="built_in">reinterpret_cast</span>&lt;Func&gt;(ptr_func);</span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">f</span>(a, <span class="number">30</span>);</span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  res = a-&gt;<span class="built_in">func</span>(<span class="number">30</span>);</span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MSVC 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202192352189.png"
style="zoom:67%;" /></p>
<p>GCC 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202192817764.png"
style="zoom:67%;" /></p>
<p>Clang 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202192847211.png"
style="zoom:67%;" /></p>
<h2 id="虚函数调用过程">虚函数调用过程</h2>
<p>最后，我们尝试理解成员函数指针到底是什么？为什么其比寻常的函数指针更大？</p>
<p>我们直接将其转换成字节数组，然后读取其值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">Ret</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> size_a = <span class="built_in">sizeof</span>(&amp;A::func);</span><br><span class="line">  <span class="type">uint8_t</span> bytes[size_a];</span><br><span class="line">  MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type ptr = &amp;A::func;</span><br><span class="line">  std::<span class="built_in">copy</span>(&amp;ptr, &amp;ptr + size_a, bytes);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint8_t</span> v : bytes) &#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; (<span class="type">uint32_t</span>)v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结果会随着编译器不同有所改变，在 MSVC 下，输出结果如下</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[ 4d 40 8c 7a f7 7f  0  0 ]</span><br></pre></td></tr></table></figure>

<p>而在 Clang 和 GCC 下，二者输出都是</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br></pre></td></tr></table></figure>

<p>一个好像看不出什么结果，我们多弄点类和继承，再来看看效果</p>
<p>测试代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">Ret</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_bytes</span><span class="params">(<span class="keyword">typename</span> MemberFuncPtr&lt;T, Ret, Args...&gt;::type func_ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(func_ptr);</span><br><span class="line">  std::array&lt;<span class="type">uint8_t</span>, size&gt; content;</span><br><span class="line">  <span class="type">uint8_t</span> *arr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(&amp;func_ptr);</span><br><span class="line">  std::<span class="built_in">copy</span>(arr, arr + size, content.<span class="built_in">begin</span>());</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint8_t</span> v : content) &#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; (<span class="type">uint32_t</span>)v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;A::func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(&amp;A::func1);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;A::func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(&amp;A::func2);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;B::func3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;B, <span class="type">void</span>&gt;(&amp;B::func3);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;B::func4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;B, <span class="type">void</span>&gt;(&amp;B::func4);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func1);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func2);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func3);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>msvc （添加 <code>/RTC1</code> 标志，将所有未初始化的栈上内存标记为
<code>0xcc</code> ）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&amp;A::func1</span><br><span class="line">[ a2 40 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;A::func2</span><br><span class="line">[ 87 1a 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;B::func3</span><br><span class="line">[ b8 2a 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;B::func4</span><br><span class="line">[ bf 3c 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;C::func1</span><br><span class="line">[ a2 40 4e 34 f6 7f  0  0  0  0  0  0 cc cc cc cc ]</span><br><span class="line">&amp;C::func2</span><br><span class="line">[ 87 1a 4e 34 f6 7f  0  0  0  0  0  0 cc cc cc cc ]</span><br><span class="line">&amp;C::func3</span><br><span class="line">[ b8 2a 4e 34 f6 7f  0  0  8  0  0  0 cc cc cc cc ]</span><br><span class="line">&amp;C::func4</span><br><span class="line">[ bf 3c 4e 34 f6 7f  0  0  8  0  0  0 cc cc cc cc ]</span><br></pre></td></tr></table></figure>

<p>GCC / Clang</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&amp;A::func1</span><br><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;A::func2</span><br><span class="line">[  9  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;B::func3</span><br><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;B::func4</span><br><span class="line">[  9  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func1</span><br><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func2</span><br><span class="line">[  9  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func3</span><br><span class="line">[  1  0  0  0  0  0  0  0  8  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func4</span><br><span class="line">[  9  0  0  0  0  0  0  0  8  0  0  0  0  0  0  0 ]</span><br></pre></td></tr></table></figure>

<p>C++ 代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(&amp;A::func1);</span><br></pre></td></tr></table></figure>

<p>可以对应到下面的汇编</p>
<p>MSVC</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lea     rcx, OFFSET FLAT:[thunk]:A::`vcall<span class="number">&#x27;</span>&#123;<span class="number">0</span>,&#123;flat&#125;&#125;<span class="string">&#x27; &#125;&#x27;</span>            ; A::`vcall<span class="number">&#x27;</span>&#123;<span class="number">0</span>&#125;&#x27;</span><br><span class="line">call    <span class="type">void</span> <span class="built_in">print_bytes</span>&lt;A,<span class="type">void</span>&gt;(<span class="built_in">void</span> (__cdecl A::*)(<span class="type">void</span>)) ; print_bytes&lt;A,<span class="type">void</span>&gt;</span><br></pre></td></tr></table></figure>

<p>GCC 对应调用的汇编</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mov     r12d, <span class="number">1</span></span><br><span class="line">mov     r13d, <span class="number">0</span></span><br><span class="line">mov     rcx, r12</span><br><span class="line">mov     rbx, r13</span><br><span class="line">mov     rax, r12</span><br><span class="line">mov     rdx, r13</span><br><span class="line">mov     rax, rdx</span><br><span class="line"># 最终 rdi = <span class="number">1</span>, rsi = <span class="number">0</span>，也就是输入到函数的参数</span><br><span class="line">mov     rdi, rcx</span><br><span class="line">mov     rsi, rax</span><br><span class="line">call    <span class="type">void</span> <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type)</span><br></pre></td></tr></table></figure>

<p>Clang 对应汇编</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mov     qword ptr [rbp - <span class="number">24</span>], <span class="number">0</span></span><br><span class="line">mov     qword ptr [rbp - <span class="number">32</span>], <span class="number">1</span></span><br><span class="line"># 最终 rdi = <span class="number">1</span>, rsi = <span class="number">0</span>，也就是输入到函数的参数 </span><br><span class="line">mov     rdi, qword ptr [rbp - <span class="number">32</span>]</span><br><span class="line">mov     rsi, qword ptr [rbp - <span class="number">24</span>]</span><br><span class="line">call    <span class="type">void</span> <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type)</span><br><span class="line">mov     rdi, qword ptr [rbp - <span class="number">160</span>]      # <span class="number">8</span>-byte Reload</span><br></pre></td></tr></table></figure>

<p>从结果中可以很清楚的看到，MSVC 和 GCC、Clang
的输出结果完全不一样，但从 MSVC
的结果上来看，存储的确实应该是一个指针，对于多继承情况下还包含一个4字节（<code>uint32_t</code>）的偏移量，而
GCC 和 Clang 是两个64位的值。</p>
<p>根据网上搜集的资料，我们可以得到这两个结构体的含义</p>
<ul>
<li><p><a href="https://rants.vastheman.com/2021/09/21/msvc/">MSVC C++
ABI Member Function Pointers « Rants from Vas
(vastheman.com)</a></p></li>
<li><p><a
href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#member-pointers">Itanium
C++ ABI (itanium-cxx-abi.github.io)</a></p></li>
</ul>
<p>MSVC C++ ABI member function pointer 结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// single inheritance</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">  <span class="comment">// thunk function pointer</span></span><br><span class="line">  <span class="type">uintptr_t</span> ptr;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// muiltiple inheritance</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">    <span class="comment">// thunk function pointer</span></span><br><span class="line">    <span class="type">uintptr_t</span> ptr;</span><br><span class="line">    <span class="comment">// adjustor</span></span><br><span class="line">    <span class="type">uint32_t</span> adj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GCC / Clang Itanium C++ ABI member function pointer 结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc / clang</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">    <span class="comment">// function pointer / vtable offset in bytes</span></span><br><span class="line">    <span class="type">uintptr_t</span> ptr;</span><br><span class="line">    <span class="comment">// adjustor</span></span><br><span class="line">    <span class="type">ptrdiff_t</span> adj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在 x86-64 上，通过 ptr
的最后一位判断是否是虚函数，因为虚函数指针大小为 8 字节，也就是说 ptr
的值一定是偶数，即 ptr 的最后一位永远都是
0，这样对于普通函数而言，这个值就为偶数，而虚函数则是奇数。</strong></p>
<p><strong>在 arm 上，对于虚函数的判断方式转换成了 adj，通过 adj
的最后一位标识是否是虚函数</strong></p>
<blockquote>
<p>这一点我们同样可以从汇编代码上看出来</p>
<p>C++代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print_bytes&lt;A, void&gt;(&amp;A::func1);</span><br></pre></td></tr></table></figure>

<p>对应 ARM64 汇编</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">movs    r3, #0</span><br><span class="line">str     r3, [r7, #8]</span><br><span class="line">movs    r3, #1</span><br><span class="line">str     r3, [r7, #12]</span><br><span class="line">add     r3, r7, #8</span><br><span class="line">ldm     r3, &#123;r0, r1&#125;</span><br><span class="line"># 最终传入的值为 &#123;0x0,0x1&#125;</span><br><span class="line">bl      void print_bytes&lt;A, void&gt;(MemberFuncPtr&lt;A, void&gt;::type)</span><br></pre></td></tr></table></figure>

</blockquote>
<p>这样，我们可以尝试解析成员函数指针并进行调用（仅限于 Itanium C++
ABI，也就是 GCC 和 Clang，对于 MSVC
实在是没办法，居然是又新增了一段跳转函数，属实是恶心人了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> n + v; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> n - v; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">Ret</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr;</span><br><span class="line">  <span class="type">ptrdiff_t</span> adj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">member_func_info</span></span><br><span class="line"><span class="function"><span class="title">from_raw</span><span class="params">(<span class="keyword">typename</span> MemberFuncPtr&lt;T, Ret, Args...&gt;::type func_ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;member_func_info *&gt;(&amp;func_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">Ret <span class="title">invoke</span><span class="params">(T *obj, <span class="keyword">typename</span> MemberFuncPtr&lt;T, Ret, Args...&gt;::type func_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">           Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr_this = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(obj);</span><br><span class="line">  member_func_info func_info = <span class="built_in">from_raw</span>&lt;T, Ret, Args...&gt;(func_ptr);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&lt;ptr=&quot;</span> &lt;&lt; func_info.ptr &lt;&lt; <span class="string">&quot;,adj=&quot;</span> &lt;&lt; func_info.adj &lt;&lt; <span class="string">&quot;&gt;&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">uintptr_t</span> adj_this = ptr_this + func_info.adj;</span><br><span class="line">  <span class="type">uintptr_t</span> vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span> *&gt;(adj_this);</span><br><span class="line">  <span class="type">uintptr_t</span> func_address = vptr + func_info.ptr &amp; (~<span class="number">0x1</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  // arm case</span></span><br><span class="line"><span class="comment">  uintptr_t adj_this = ptr_this + func_info.adj &gt;&gt; 1;</span></span><br><span class="line"><span class="comment">  uintptr_t vptr = *reinterpret_cast&lt;uintptr_t *&gt;(adj_this);</span></span><br><span class="line"><span class="comment">  uintptr_t func_address = vptr + func_info.ptr;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// call function</span></span><br><span class="line">  <span class="keyword">using</span> Func = <span class="built_in">Ret</span> (*)(T *, Args...);</span><br><span class="line">  Func f = *<span class="built_in">reinterpret_cast</span>&lt;Func *&gt;(func_address);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>(obj, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">  <span class="comment">// 主打的就是一个脱裤子放屁</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">invoke</span>&lt;A, <span class="type">int</span>&gt;(&amp;a, &amp;A::func2, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// 等价于 a.func2(20);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img data-src="/posts/55c5/image-20230202221518873.png" /></p>
<p>对于 clang 也是一样</p>
<p><img data-src="/posts/55c5/image-20230202223902378.png" /></p>
<h2 id="总结">总结</h2>
<p><strong>虚函数的出现是因为我们无法在静态编译过程中确定要执行的函数，需要动态查找待执行的函数</strong>。具体而言就是通过对象示例中存储的一个指向虚函数表（vtable）的虚指针（vptr），结合待调用的虚函数信息（在
vtable 上的偏移量）获取到实际的函数地址，最后调用函数。</p>
<p>对于普通的函数而言，在静态编译过程中能够获取到函数地址，而虚函数则多了一个查找的过程（虚继承情况可能还要再多一次虚基的寻址过程）。</p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 易错点整理(一)</title>
    <url>/posts/764b/</url>
    <content><![CDATA[<h1 id="c-易错点整理一">C++ 易错点整理（一）</h1>
<p>最近刷牛客的 C++ 语言专项练习（选择题），本来以为 C++
掌握的还不错吧，一做题就全露馅了，细节太多了（ C++ 本身的
<strong>未定义行为 undefined behavior</strong> 以及
C++这么多年来的更新带来的包袱太多了）</p>
<p>基本上所有的问题都可以在 <a
href="https://en.cppreference.com/w/">cppreference.com</a>
上面找到答案，还有样例，比较权威，然后实现相关的可以使用 <a
href="https://godbolt.org/">Compiler Explorer (godbolt.org)</a>
查看编译细节。</p>
<h2 id="c-语法细节">C++ 语法细节</h2>
<h3 id="自增自减运算符的重载">自增/自减运算符的重载</h3>
<p><em><strong>题1</strong></em>：如果定义了一个类myclass,
则为myclass类对象以成员函数形式重载 <strong>后 ++ 运算符</strong>
的声明应该是：</p>
<p>A. <code>myclass operator++()</code></p>
<p>B. <code>myclass operator++(int)</code></p>
<p>C. <code>myclass &amp;operator++()</code></p>
<p>D. <code>myclass &amp;operator(int)</code></p>
<p><em><strong>答案</strong></em>：B</p>
<p><em><strong>解析</strong></em>：这题纯纯考察自增/自减的重载，没什么难点，单纯是不记得这个写法了</p>
<span id="more"></span>

<blockquote>
<h4 id="increment-and-decrement">Increment and decrement</h4>
<p>When the postfix increment or decrement operator appears in an
expression, the corresponding user-defined function (operator++ or
operator--) is called with an integer argument <code>0</code>.
Typically, it is implemented as T operator++(int) or T operator--(int),
where the argument is ignored. The postfix increment and decrement
operators are usually implemented in terms of the prefix versions:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前置自增</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called ++A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置自增，相比前置版本的函数签名，就差了一个 int</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called A++&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a++;</span><br><span class="line">    ++a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230209205555494.png" /></p>
<p>关键点就是：<strong>后置自增函数相比于前置自增函数需要添加一个
<code>int</code> 参数进行区别</strong></p>
<p>注：对于前置自增/自减和后置自增/自减运算符本身也是常考察的内容：</p>
<ul>
<li><p><code>i++</code> 的含义是 <strong>将 i 增加
1，返回加之前的值</strong>，用一个函数来表示就是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_increment</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = v;</span><br><span class="line">    v += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>++i</code> 的含义是 <strong>将 i 增加
1，返回加之后的值</strong>，用于用函数来表示就是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">postfix_increment</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v+= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从我们代码实现上也可以看出，<em><strong>在未优化的情况下</strong></em>，后置自增会比前置自增多用一个临时变量，从而造成性能开销，<strong>但是现在的编译器都很智能了，对于这个基本上都会直接优化掉</strong>（开启
<code>-O2</code>
优化）。<em><strong>所以在平时写的时候怎么舒服怎么来就行，只要确保可读性就行</strong></em>。</p>
<h3 id="转义字符">转义字符</h3>
<p><em><strong>题2</strong></em>：有转义字符如下：<code>'\0X41'</code>、<code>'\0x41'</code>、<code>'\X41'</code>、<code>'\x41'</code>、<code>'\a'</code>、<code>'\b'</code>、<code>'\c'</code>、<code>'\r'</code>
其中错误的转义字符个数是（</p>
<p><em><strong>解析</strong></em>：这题也是考察的 C++ 语法，错误的有 4
个，<code>\0X41</code>、<code>\0x41</code>、<code>\X41</code>、<code>\c</code></p>
<p>详细参考：<a
href="https://en.cppreference.com/w/cpp/language/escape">Escape
sequences - cppreference.com</a></p>
<p><strong>1. 简单转义字符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\&#x27; 表示 &#x27;</span><br><span class="line">\&quot; 表示 &quot;</span><br><span class="line">\\ 表示 \</span><br><span class="line">\? 表示 ?</span><br><span class="line">\a 表示 蜂鸣器（主板上）</span><br><span class="line">\b 表示 退格</span><br><span class="line">\f 表示 新一页</span><br><span class="line">\n 表示 换行 (Line Feed)</span><br><span class="line">\r 表示 回车 (Carriage Return)</span><br><span class="line">\t 表示 水平制表符</span><br><span class="line">\v 表示 垂直制表符</span><br></pre></td></tr></table></figure>

<p>注：<code>\n\r</code> 在 CRLF （Carriage Return / Line
Feed）表示回车换行，一般在 Windows 下的纯文本中常用，而在 Unix
系统下常用 <code>\n</code> 即 换行，在 VS Code 中也可以进行设置</p>
<p><img data-src="/posts/764b/image-20230209221937788.png"
style="zoom: 33%;" /></p>
<p><strong>2. 数值表示形式</strong></p>
<p>char 本质上也是一个整数，那么我们可以使用数值编码也是一样的</p>
<ul>
<li>八进制形式：<code>\&lt;nnn&gt;</code>，例如 <code>\141</code> 表示
ASCII 字符 <code>'a'</code></li>
<li>十六进制形式：<code>\x&lt;nn&gt;</code>，例如 <code>\x61</code> 表示
ASCII 字符
<code>'a'</code>（这个是区分大小写的，只能使用小写的<code>\x</code>，但是后面的十六进制大小写都可以），例如
<code>\x3F</code> 和 <code>\x3f</code> 都行</li>
</ul>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v0 = <span class="string">&quot;\x61&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v1 = <span class="string">&quot;\141&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v2 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; v0 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. Unicode 表示形式</strong></p>
<ul>
<li><code>\u&lt;nnnn&gt;</code>，表示 <code>U+&lt;nnnn&gt;</code>的
Unicode，这种方式只能表示到 <code>U+FFFF</code>，对于 Emoji
等只能使用下面这种完整形式了</li>
<li><code>\U&lt;nnnnnnnn&gt;</code>，表示
<code>U+&lt;nnnnnnnn&gt;</code>的 Unicode，可以完整的表示
Unicode（<code>U+FFFFFFFF</code>），就是表示起来比较麻烦</li>
</ul>
<p>而对于上面提到的 <code>\c</code> ，其在 C++
中有定义，但是具体实现有关，没有一个统一的含义，因此不能算在转义字符行列中</p>
<h3 id="域解析操作符">域解析操作符</h3>
<p><em><strong>题3</strong></em>：外部变量可以供其所在的程序文件中的任何函数使用（）</p>
<ol type="1">
<li><p>正确</p></li>
<li><p>错误</p></li>
</ol>
<p><em><strong>解析</strong></em>：这一题一眼
<strong>错误</strong>，因为在函数中使用同名的变量就会将其覆盖掉，这样就无法使用外部变量了，但是看到评论中提到可以使用
<code>::&lt;variable&gt;</code>来访问外面作用域。这个查了一下，称为
Scope Resolution Operator（作用域解析运算符），那么我们可以写成这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> v = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; ::v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230209234348279.png" /></p>
<p>对于命名空间、类空间中定义的变量和静态函数都可以使用这个方式访问</p>
<h3 id="纯虚函数的函数体">纯虚函数的函数体</h3>
<p><em><strong>题4</strong></em>：（多选）c/c++中，有关纯虚函数说法正确的是（
）</p>
<ol type="1">
<li><p>子类中必须覆盖基类的纯虚函数</p></li>
<li><p>含有纯虚函数的类不能被实例化</p></li>
<li><p>基类的纯虚函数没有函数体</p></li>
<li><p>含有纯虚函数的类一定是抽象类</p></li>
</ol>
<p><em><strong>解析</strong></em>：这题主要考察
<em><strong>虚函数</strong></em> 相关的一些概念，正确的有 2，4</p>
<p>对于 1
，如果我们需要层层抽象的话，就可能会在子类中包含纯虚函数，因此子类不一定需要覆盖基类的纯虚函数</p>
<p>对于 4 ，乍一看好像是对的，我们都 <em><strong>声明</strong></em>
其是纯虚函数了，为啥还要 <em><strong>定义</strong></em> 函数方法呢？</p>
<p>这一部分其实在 cppreference 上也有介绍</p>
<blockquote>
<p>The definition of a pure virtual function may be provided (and must
be provided if the pure virtual is the <a
href="https://en.cppreference.com/w/cpp/language/destructor">destructor</a>):
the member functions of the derived class are free to call the abstract
base's pure virtual function using qualified function id. This
definition must be provided outside of the class body (the syntax of a
function declaration doesn't allow both the pure specifier
<strong><code>= 0</code></strong> and a function body).</p>
<p>Making a virtual call to a pure virtual function from a constructor
or the destructor of the abstract class is undefined behavior
(regardless of whether it has a definition or not).</p>
<p><a
href="https://en.cppreference.com/w/cpp/language/abstract_class">Abstract
class - cppreference.com</a></p>
<p>翻译一下就是：</p>
<p>纯虚函数可以提供函数定义（如果是析构函数的话必须要提供），但是不能以类内的方式存在，需要在类外部进行定义。<code>=0</code>
语法就已经禁止函数定义了。</p>
<p>并且在抽象类的构造/析构函数中调用 <strong>纯虚函数</strong> 是
<em><strong>未定义行为</strong></em> ,千万不要这么做。</p>
</blockquote>
<p>说起来有点抽象，举个例子吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstract</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 只能采用类外定义的方式进行定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Abstract::func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;calling Abstract::func\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Abstract &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 子类要么继续保持抽象类，要么重写 func</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;calling Derived::func\n&quot;</span>;</span><br><span class="line">        Abstract::<span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Abstract* a = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result of a-&gt;Abstract::func():\n&quot;</span>;</span><br><span class="line">    a-&gt;Abstract::<span class="built_in">func</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result of a-&gt;func():\n&quot;</span>;</span><br><span class="line">    a-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230210110358443.png"
style="zoom:50%;" /></p>
<p>由于 C++ 中没有引入类似 <code>abstract</code>
这类的关键字，我们只能通过声明虚函数的方式来讲一个类设置为抽象类，并且我们需要强制子类实现某个函数，但是有时为了代码复用，又想提供一个默认的函数实现时，就可以采用这种方法。</p>
<h3 id="void-的大小">void 的大小？</h3>
<p><em><strong>题5</strong></em>：32位编译器下，<code>sizeof(void)</code>
的值是多少？</p>
<p><em><strong>解析</strong></em>：void
的大小和编译器以及语言有关在。</p>
<ul>
<li><p>C 中，<code>sizeof(void)</code>
值和编译器有关，有可能为0，有可能为1</p></li>
<li><p>C++ 中，<code>sizeof(void)</code> 会直接报错</p>
<p><img data-src="/posts/764b/image-20230210111608942.png"
style="zoom: 50%;" /></p></li>
</ul>
<p>那么对于 <code>void*</code>
指针而言，我们将其自增，地址值会如何变化呢？</p>
<p>由于我们无法取得 <code>void</code>
的大小，<strong>自然也就无法对其进行指针运算了</strong>，要想实现运算，只能通过强制类型转换。</p>
<p><img data-src="/posts/764b/image-20230210112209205.png"
style="zoom:50%;" /></p>
<p>为了跨平台方便，在头文件 <code>cstdint</code> 中定义了
<code>uintptr_t</code>来表示和指针同样大小的整形类型，用来显式表示地址值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> size = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span>* v = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">    <span class="type">void</span>* v1 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(v);</span><br><span class="line">    <span class="type">uintptr_t</span> v2 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(v1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of v1 = &quot;</span></span><br><span class="line">              &lt;&lt; v1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of v2 = &quot;</span> </span><br><span class="line">              &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>)</span><br><span class="line">              &lt;&lt; std::showbase</span><br><span class="line">              &lt;&lt; v2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of v2 + 1 = &quot;</span> </span><br><span class="line">              &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>)</span><br><span class="line">              &lt;&lt; std::showbase</span><br><span class="line">              &lt;&lt; v2 + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（std::cout 这张流式输出方式真的太繁琐了，还不如使用 <code>fmt</code>
库）</p>
<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230210114206263.png"
style="zoom:50%;" /></p>
<p>当然，我们也可以将 <code>uintptr_t</code>
强制类型转换到指针，然后读取其内容，不过十分危险，容易出错，日常不推荐这样使用。</p>
<h3 id="类变量初始化和析构顺序">类变量初始化和析构顺序</h3>
<p><em><strong>题6</strong></em>：给出下列代码的实际运行结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">const</span> <span class="type">char</span>* p_szName):<span class="built_in">m_szName</span>(p_szName) &#123;std::cout &lt;&lt; m_szName &lt;&lt; <span class="string">&quot;,&quot;</span>;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt;<span class="string">&quot;~&quot;</span>&lt;&lt;m_szName &lt;&lt; <span class="string">&quot;, &quot;</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* m_szName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> <span class="type">char</span>*p_szName)</span><br><span class="line">      :<span class="built_in">m_szName</span>(p_szName)</span><br><span class="line">      ,<span class="built_in">m_objA</span>((<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;A&quot;</span>)</span><br><span class="line">      ,<span class="built_in">m_objB</span>((<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;B&quot;</span>)</span><br><span class="line">      ,<span class="built_in">Base</span>((<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;C&quot;</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; m_szName &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;~&quot;</span>&lt;&lt;m_szName &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* m_szName;</span><br><span class="line">	Base m_objB;</span><br><span class="line">	Base m_objA;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>解析</strong></em>：这道题就考察的类变量初始化和析构的顺序问题，如果没有写代码测试的话确实不知道运行结果是怎么样的。</p>
<p>同样在 cppreference 上有详细的介绍：<a
href="https://en.cppreference.com/w/cpp/language/constructor">Constructors
and member initializer lists - cppreference.com</a></p>
<blockquote>
<h4 id="initialization-order">Initialization order</h4>
<p>The order of member initializers in the list is irrelevant: the
actual order of initialization is as follows:</p>
<ol type="1">
<li>If the constructor is for the most-derived class, virtual bases are
initialized in the order in which they appear in depth-first
left-to-right traversal of the base class declarations (left-to-right
refers to the appearance in base-specifier lists)</li>
<li>Then, direct bases are initialized in left-to-right order as they
appear in this class's base-specifier list</li>
<li>Then, non-static data member are initialized in order of declaration
in the class definition.</li>
<li>Finally, the body of the constructor is executed</li>
</ol>
<p>(Note: if initialization order was controlled by the appearance in
the member initializer lists of different constructors, then the <a
href="https://en.cppreference.com/w/cpp/language/destructor">destructor</a>
wouldn't be able to ensure that the order of destruction is the reverse
of the order of construction)</p>
<p>简单翻译一下就是：</p>
<p><em><strong>类成员初始化的顺序</strong></em> 与在类构造函数中
<em><strong>成员初始化列表</strong></em>
的顺序<em><strong>没有任何关系</strong></em>，其取决于以下四点：</p>
<ol type="1">
<li>对于多层嵌套继承，使用DFS，从左到右的顺序初始化基类（继承树的遍历）</li>
<li>对于直接基类按从左到右的顺序初始化基类</li>
<li>对于非静态的数据成员将会按照
<em><strong>类定义时的声明顺序</strong></em> 进行初始化</li>
<li>最终执行构造函数体</li>
</ol>
<p>注：如果 <strong>成员初始化顺序</strong> 由
<strong>成员初始化列表</strong> 来控制的话，就无法确保析构顺序为
<strong>构造顺序的逆序</strong> 了</p>
</blockquote>
<p>讲了这么多，关键就一点：<strong>类内非静态成员的初始化顺序是按照声明时的顺序进行初始化，在析构时则按照相反的顺序进行析构</strong></p>
<p>由此，我们可以轻松知道代码执行的结果了</p>
<p><code>Derived</code> 继承了
<code>Base</code>，那么在初始化之前必须要初始化基类，因此首先初始化
<code>Base</code>，那么首先就会输出 <code>C</code>，之后按顺序初始化
<code>B</code>、初始化 <code>A</code>，最终执行函数体
<code>D</code>，</p>
<p>那么在析构时则按照构造的相反顺序，首先执行函数体<code>D</code>，后析构<code>A</code>，再析构
<code>B</code>，最后析构基类 <code>C</code></p>
<p>最终输出如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C,B,A,D,~D,~A,~B,~C,</span><br></pre></td></tr></table></figure>

<p>而带代码实际运行结果也是如此</p>
<p><img data-src="/posts/764b/image-20230210121645460.png"
style="zoom:50%;" /></p>
<h3 id="函数重载方式">函数重载方式</h3>
<p><em><strong>题7</strong></em>：以下不是double
compare(int,int)的重载函数的是()</p>
<ol type="1">
<li><code>int compare(double,double)</code></li>
<li><code>double compare(double,double)</code></li>
<li><code>double compare(double,int)</code></li>
<li><code>int compare(int,int)</code></li>
</ol>
<p><em><strong>解析</strong></em>：这题考察的是函数重载的定义方式，在
C++ 中支持同名函数，使用不同的参数调用不同的重载函数。具体通过 name
mangling
实现。<strong>而重载函数的区别主要在于函数入参数量以及入参类型</strong>。</p>
<p>而 1 和 2
仅在函数返回类型上不一致，调用时我们就不知道如何调用了。</p>
<p><img data-src="/posts/764b/image-20230210141729168.png"
style="zoom:50%;" /></p>
<h3 id="指针和引用">指针和引用</h3>
<p><em><strong>题8</strong></em>：关于引用以下说法错误的是（）。</p>
<ol type="1">
<li>引用必须初始化，指针可以不初始化</li>
<li>引用初始化以后不能被改变，而指针可以改变指向</li>
<li>不存在指向空值的引用，但是存在指向空值的指针</li>
<li>一个引用可以看作是某个变量的一个“别名”</li>
<li>引用传值，指针传地址</li>
<li>函数参数可以声明为引用或指针类型</li>
</ol>
<p><em><strong>解析</strong></em>：答案是
5，传递引用实际上就是传递指针，这一点从汇编代码上可以看出来</p>
<p>通过 compiler explorer 查看输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>* a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用 GCC 12.2 编译代码如下</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">func1(int&amp;):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        nop</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">func2(int*):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        nop</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h3 id="数组入参">数组入参</h3>
<p><em><strong>题8</strong></em>：在32位环境下，以下程序的输出结果是？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> x[<span class="number">14</span>])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sizeof</span>(x) + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> x[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sizeof</span>(x) + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived stDerived;</span><br><span class="line">    Base *pstBase = &amp;stDerived;</span><br><span class="line">    <span class="type">char</span> x[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pstBase-&gt;<span class="built_in">foo</span>(<span class="number">100</span>) + pstBase-&gt;<span class="built_in">foo</span>(x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>解析</strong></em>：这题主要考察的是虚函数调用以及数组作为参数调用函数的一些细节：</p>
<p>这一部分在 cppreference 上有介绍：<a
href="https://en.cppreference.com/w/cpp/language/array">Array
declaration - cppreference.com</a></p>
<blockquote>
<h4 id="array-to-pointer-decay">Array-to-pointer decay</h4>
<p>There is an <a
href="https://en.cppreference.com/w/cpp/language/implicit_conversion">implicit
conversion</a> from lvalues and rvalues of array type to rvalues of
pointer type: it constructs a pointer to the first element of an array.
This conversion is used whenever arrays appear in context where arrays
are not expected, but pointers are:</p>
<p>翻译一下就是：当我们使用数组作为入参调用函数时，数组会隐式退化成指针</p>
</blockquote>
<p>那么如果我们有一个函数，想要遍历数组的所有元素时，<strong>我们是绝对不能使用
<code>sizeof</code>
来获取数组的长度的，因此此时数组已经退化为指针了！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_array</span><span class="params">(<span class="type">int</span> x[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(x) / <span class="built_in">sizeof</span>(x[<span class="number">0</span>]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(print_array) sizeof(x) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(print_array) length(x) = &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; x[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(x) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(x) / <span class="built_in">sizeof</span>(x[<span class="number">0</span>]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;length(x) = &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">print_array</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并不会如我们期待的输出数组中所有的元素，而是输出前 8 个元素值</p>
<p><img data-src="/posts/764b/image-20230210150327901.png"
style="zoom:50%;" /></p>
<p>（不过我们都用数组了，数组的长度肯定是已知的，这样低级错误应该还是不会犯的，况且现代编译器都会提示这个问题）</p>
<p><img data-src="/posts/764b/image-20230210150530111.png"
style="zoom: 33%;" /></p>
<p>回到这一题，前一个函数符合虚函数调用，会调用子类的
<code>int foo(int)</code>，输出结果
2000，而后面一个由于不是虚函数，则会直接调用父类定义的
<code>int foo(int x[14])</code>，并且在其中使用
<code>sizeof(x)</code>，32位环境下指针大小为 4，那么最终结果就是 2000+14
= 2014</p>
<h3 id="函数入参求值顺序">函数入参求值顺序</h3>
<p><em><strong>题9</strong></em>：阅读C语言代码输出（）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p=arr;</span><br><span class="line">    *(p++)+=<span class="number">89</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,*p,*(++p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>解析</strong></em>：这一题直接考察 printf
的求值顺序，但是实际上这是一个
<em><strong>未定义行为</strong></em>，不同编译器下结果不一致，这题的目的在于：<strong>我们不能理所当然的假设参数的求值顺序就是从左到右或从右到左，也千万不要写出类似的代码</strong></p>
<p>GCC 下输出为</p>
<p><img data-src="/posts/764b/image-20230210153919168.png"
style="zoom:50%;" /></p>
<p>Clang下输出如下，还对我们的调用给出了警告（这说明编译器的警告有时候还是要看看的，不是说编译过了就行）</p>
<p><img data-src="/posts/764b/image-20230210153955611.png"
style="zoom:50%;" /></p>
<p>同样，在函数调用时的参数求值顺序也不能假设，示例如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">arg0</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called argument0\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">arg1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called argument1\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">arg2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called argument2\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">arg0</span>(),<span class="built_in">arg1</span>(),<span class="built_in">arg2</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不同的编译器下输出结果不一致，我们不能假定其一定是从左到右进行求值，也有可能从右向左求值。</p>
<p>Clang 15.0 输出结果</p>
<p><img data-src="/posts/764b/image-20230210152746441.png"
style="zoom:50%;" /></p>
<p>GCC 12.2 输出结果</p>
<p><img data-src="/posts/764b/image-20230210152810621.png"
style="zoom:50%;" /></p>
<h2 id="stl">STL</h2>
<h3 id="迭代器失效">迭代器失效</h3>
<p><em><strong>题9</strong></em>：会导致下列的代码片段崩溃的
<code>CONTAINER</code> 类型是？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CONTAINER::iterator iter, tempIt;</span><br><span class="line"><span class="keyword">for</span> (iter = cont.<span class="built_in">begin</span>(); iter != cont.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    tempIt = iter;</span><br><span class="line">    ++iter;</span><br><span class="line">    cont.<span class="built_in">erase</span>(tempIt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设cont是一个 <code>CONTAINER</code>
的实例，里面包含数个元素，那么当 <code>CONTAINER</code> 为：</p>
<p>1、vector 2、list 3、map 4、deque</p>
<p>会导致上面的代码片段崩溃的 <code>CONTAINER</code> 类型是？</p>
<p><em><strong>解析</strong></em>：这题考察的是STL容器的迭代器，我们尝试对容器进行修改然后继续使用修改之前的迭代器，这样子的操作非常容易出问题，因为对于
vector 和 deque 这样的顺序存储容器而言，其数据存储是连续的，当我们进行
remove
的时候有可能影响迭代器，从而使迭代器失效，而访问一个失效的迭代器就会使程序崩溃。</p>
<p>对于任何一种迭代器，我们都不要尝试对其修改后再使用之前的迭代器，实际上
<code>erase</code>
函数会返回修改后的迭代器，我们要写代码可以正确运行，直接使用这个即可。即</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CONTAINER::iterator iter, tempIt;</span><br><span class="line"><span class="keyword">for</span> (iter = cont.<span class="built_in">begin</span>(); iter != cont.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    iter = cont.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以保证代码的正确运行</p>
<h2 id="c-库函数">C 库函数</h2>
<h3 id="查找字符串">查找字符串</h3>
<p><em><strong>题6</strong></em>：从字符串中寻找一串字符的函数是（）</p>
<p>A. <code>strcmp</code></p>
<p>B. <code>strstr</code></p>
<p>C. <code>strcat</code></p>
<p>D. <code>strfind</code></p>
<p><strong>解析</strong>：看函数名字就想选
<code>strfind</code>，但是这个函数实际上是 matlab 的字符串查找函数，而在
C 库中对应的是 <code>strstr</code>。</p>
<p>（主要还是没用过，不知道）</p>
<p>其函数签名如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strstr</span><span class="params">(<span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span>* s2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其作用就是返回 s2 在 s1 中第一次出现的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sub = <span class="string">&quot;foobar&quot;</span>;</span><br><span class="line">    <span class="comment">// 此处我们拿到的 v 就是 sub 中的一个指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v = <span class="built_in">strstr</span>(sub,s);</span><br><span class="line">    <span class="type">uintptr_t</span> s0 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(sub);</span><br><span class="line">    <span class="type">uintptr_t</span> v0 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of sub = &quot;</span> &lt;&lt; s0 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of strstr(sub,s) = &quot;</span> &lt;&lt; v0 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230210115052441.png"
style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行切换MSVC版本</title>
    <url>/posts/30a2/</url>
    <content><![CDATA[<h1 id="命令行切换-msvc-版本">命令行切换 MSVC 版本</h1>
<p>在 WIndows 下跑 Python 深度学习代码时，需要编译 C++ 库（点名
Pytorch3d），但是使用最新版本的 MSVC 进行编译的时候会报错，去 Github 看
Issue 时有提到降级可能有效，我们可以通过添加组件的方式直接下载指定版本的
MSVC
编译器。然后手动修改进行切换。为了怕后面遇到类似问题时忘记怎么搞，还是简单记录一下吧，具体操作如下：</p>
<ol type="1">
<li><p>首先打开 Visual Studio Installer，点击 <code>修改</code> 按钮</p>
<p><img data-src="/posts/30a2/image-20230220223924979.png" /></p>
<span id="more"></span>
</li>
<li><p>在 <code>单个组件</code> 菜单中，找到指定版本的 MSVC</p>
<p>注意编译器的名称是
<code>MSVC v&lt;xxx&gt; - VS &lt;xxxx&gt; C++ x64/86 生成工具(v&lt;xx&gt;.&lt;xx&gt;)</code>，千万不要下错了</p>
<p><img data-src="/posts/30a2/image-20230220224128371.png" /></p></li>
<li><p>下载完成后，我们找到 Visual Studio 的安装目录， 其中
<code>VC</code> 目录就包含了 MSVC 相关的文件</p>
<p><img data-src="/posts/30a2/image-20230220224414127.png" /></p></li>
<li><p>进入 <code>VC</code> 目录，在 <code>Tools\MSVC</code>
我们就可以找到安装的所有 MSVC 编译器</p>
<p><img data-src="/posts/30a2/image-20230220224544477.png" /></p></li>
<li><p>我们可以进入一个子目录，进入 <code>bin\Hostx64\x64</code>
文件夹，然后在这个文件夹下打开 Developer PowerShell，输入
<code>.\cl.exe</code> 查看版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\bin\Hostx64\x64&gt; cl</span><br><span class="line">用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.25.28614 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">用法: cl [ 选项... ] 文件名... [ /link 链接选项... ]</span><br><span class="line">(base) PS C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\bin\Hostx64\x64&gt; .\cl.exe</span><br><span class="line">用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.29.30147 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">用法: cl [ 选项... ] 文件名... [ /link 链接选项... ]</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们直接输入 <code>cl</code> 时，调用的是环境变量中设置的
MSVC 编译器，而输入 <code>.\cl.exe</code> 直接调用当前目录下的
<code>cl.exe</code> 时就会调用当前目录的 MSVC 编译器</p></li>
<li><p>最后我们只需要切换当前环境变量中使用的 <code>cl</code>
就行，这里需要进入 <code>&lt;vs-path&gt;\VC\Auxiliary\Build</code>
路径，在这个路径下面就制定了默认使用的 MSVC 版本</p></li>
</ol>
<p><img data-src="/posts/30a2/image-20230220225257590.png" /></p>
<p>我们只需要修改其中的包含 <code>VCToolsVersion</code> 和
<code>VCRedistVersion</code>
字样的文件，将其中对应版本全部替换成我们需要的 MSVC 版本即可</p>
<p><code>Microsoft.VCToolsVersion.default.props</code></p>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = <span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">ToolsVersion</span> = <span class="string">&quot;4.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">VCToolsVersion</span> <span class="attr">Condition</span> = <span class="string">&quot;&#x27;$(VCToolsVersion)&#x27; == &#x27;&#x27;&quot;</span> &gt;</span>14.25.28610<span class="tag">&lt;/<span class="name">VCToolsVersion</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">VCToolsRedistVersion</span> <span class="attr">Condition</span> = <span class="string">&quot;&#x27;$(VCToolsRedistVersion)&#x27; == &#x27;&#x27;&quot;</span> &gt;</span>14.25.28508<span class="tag">&lt;/<span class="name">VCToolsRedistVersion</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span>     </span><br></pre></td></tr></table></figure>

<p><code>Microsoft.VCToolsVersion.default.txt</code>（这个文件实际上就一个版本号，直接改掉就可以）</p>
   <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">14.25.28610</span><br></pre></td></tr></table></figure>

<ol start="7" type="1">
<li>切换完成后，我们再使用 Developer Powershell
打开时就不会出问题了</li>
</ol>
<p>注：上面的更改仅适用于命令行，在 Visual Studio
中可以直接手动更换，具体参考官方教程：<a
href="https://learn.microsoft.com/en-us/cpp/build/how-to-modify-the-target-framework-and-platform-toolset?view=msvc-170">How
to: Modify the Target Framework and Platform Toolset | Microsoft
Learn</a></p>
<p>使用命令行是因为 Python 编译 C
库需要从命令行调用，所以只能这样修改，而 cmake
等编译工具实际上也只需要指定版本即可，具体可以参考官方文档：<a
href="https://cmake.org/cmake/help/latest/variable/MSVC_VERSION.html">MSVC_VERSION
— CMake 3.26.0-rc4 Documentation</a></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>MSVC</tag>
      </tags>
  </entry>
  <entry>
    <title>zerotier实现内网穿透</title>
    <url>/posts/f9ab/</url>
    <content><![CDATA[<h1 id="zerotier-实现内网穿透">zerotier 实现内网穿透</h1>
<p>zerotier
可以将不同局域网下的主机连接到同一个虚拟局域网内（即内网穿透），使用之前需要注册一个
zerotier账号，所有对虚拟网络的操作（设备管理、ip设置等）都需要在 web
端进行。官方网址：<a
href="https://www.zerotier.com/">https://www.zerotier.com/</a></p>
<h2 id="注册-zerotier-账号">注册 Zerotier 账号</h2>
<blockquote>
<p>注：zerotier 服务器在国外，访问的时候可能需要挂梯子。</p>
</blockquote>
<p>进入<a href="https://www.zerotier.com/">官网</a></p>
<p><img data-src="/posts/f9ab/zerotier-website.jpg" style="zoom:50%;" /></p>
<p>点击右上角的 Sign Up 按钮就可以进入注册页面</p>
<span id="more"></span>

<p><img data-src="/posts/f9ab/zerotier-signup.jpg" style="zoom:50%;" /></p>
<p>填写好相关信息后就会收到确认邮件，点击邮件中的链接即可激活账号。之后就可以创建虚拟网络进行相关配置了。</p>
<h2 id="创建虚拟局域网">创建虚拟局域网</h2>
<p>登入账号后我们会直接进入虚拟网络管理界面：<a
href="https://my.zerotier.com/">ZeroTier Central</a></p>
<p><img data-src="/posts/f9ab/zerotier-center.jpg" style="zoom:50%;" /></p>
<p>点击黄色按钮就可以创建一个新的虚拟局域网</p>
<p><img data-src="/posts/f9ab/zerotier-center-after.jpg"
style="zoom:50%;" /></p>
<p>网络名称是随机生成的，但网络ID是唯一的。点击网络名称便可以进入网络管理页面，我们可以进行相关的设置</p>
<p><img data-src="/posts/f9ab/zerotier-network-info.jpg"
style="zoom:50%;" /></p>
<p>主要包括：</p>
<ul>
<li>网络相关信息修改（名称，描述，IP区段）</li>
<li>节点的添加和删除</li>
<li>路由规则</li>
</ul>
<p>一般而言，如果不需要将虚拟网络和外网联通，并不需要设置路由规则，因此只需要管理成员的加入（分配
ip 地址）即可</p>
<h2 id="客户端安装">客户端安装</h2>
<p>对 windows 端和 macos
端，安装起来很方便，只需要从官网下载对应的安装包即可。</p>
<p>对于 Linux
端而言，稍微复杂一点，不过官网也直接给出了安装命令，我们按照命令进行安装即可。</p>
<p>option 1: ssl 命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://install.zerotier.com | sudo bash</span><br></pre></td></tr></table></figure>

<p>option 2: 添加 apt 软件源安装（支持更新）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">&#x27;https://raw.githubusercontent.com/zerotier/ZeroTierOne/master/doc/contact%40zerotier.com.gpg&#x27;</span> | gpg --import &amp;&amp; \</span><br><span class="line"><span class="keyword">if</span> z=$(curl -s <span class="string">&#x27;https://install.zerotier.com/&#x27;</span> | gpg); <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$z</span>&quot;</span> | sudo bash; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>第二种方式我们可以通过 apt 进行软件的更新，因此较为推荐使用。</p>
<p>添加软件源之后使用 <code>sudo apt update</code>
更新软件源，然后使用下列命令搜索 zerotier</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt search zerotier</span><br></pre></td></tr></table></figure>

<p>如果运行结果类似如下，则说明我们添加成功，使用
<code>sudo apt install zerotier-one</code> 即可完成安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) ➜  ~ sudo apt search zerotier</span><br><span class="line">Sorting... Done</span><br><span class="line">Full Text Search... Done</span><br><span class="line">zerotier-one/bionic,now 1.10.3 amd64 [installed]</span><br><span class="line">  ZeroTier network virtualization service</span><br></pre></td></tr></table></figure>

<p>安装完成后我们可以使用下列命令查看（必须要添加 sudo，否则会报错）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo zerotier-cli info</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) ➜  ~ sudo zerotier-cli info</span><br><span class="line">200 info 86dcfa11b5 1.10.3 ONLINE</span><br></pre></td></tr></table></figure>

<p>如果不添加 sudo，运行如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) ➜  ~ zerotier-cli info</span><br><span class="line">zerotier-cli: authtoken.secret not found or readable <span class="keyword">in</span> /var/lib/zerotier-one (try again as root)</span><br></pre></td></tr></table></figure>

<p>提示我们无法读取 <code>authtoken.secret</code> 文件，要求使用 root
再次尝试</p>
<h2 id="加入虚拟局域网">加入虚拟局域网</h2>
<p>zerotier上加入网络也十分简单，需要两步</p>
<ol type="1">
<li>客户端发起加入网络请求</li>
<li>web 端网络管理界面通过请求</li>
</ol>
<p>在任意一个平台下都可以使用下面命令发起加入网络请求（linux 和 macos
有可能需要添加 sudo）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-cli <span class="built_in">join</span> &lt;network ID&gt;</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-0-17-ubuntu:/home/ubuntu# zerotier-cli join e5cd7a9e1c0f9729</span><br><span class="line">200 join OK</span><br></pre></td></tr></table></figure>

<p>然后需要在web端同意加入网络</p>
<p><img data-src="/posts/f9ab/zerotier-members.jpg" style="zoom:50%;" /></p>
<p>其中没有打勾的那一个节点就是等待添加的节点，打上勾就会自动添加并分配ip地址，在主机上使用<code>ifconfig</code>
（linux,macos）/ <code>ipconfig</code> (windows)
命令查看分配到的ip地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-17-ubuntu:/home/ubuntu<span class="comment"># ifconfig</span></span><br><span class="line">...</span><br><span class="line">ztppixkcjv: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 2800</span><br><span class="line">        inet 172.27.98.228  netmask 255.255.0.0  broadcast 172.27.255.255</span><br><span class="line">        inet6 fe80::fa:60ff:fe11:d5b3  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 2a:c8:16:2e:89:37  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 11  bytes 866 (866.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>其中那个 zt
开头的就是我们添加的虚拟网络了，我们可以查看到分配好的虚拟网络地址，此时我们可以使用
ping 来测试虚拟区域网中设备的连通性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-17-ubuntu:/home/ubuntu<span class="comment"># ping 172.27.58.47</span></span><br><span class="line">PING 172.27.58.47 (172.27.58.47) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=1 ttl=64 time=1729 ms</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=2 ttl=64 time=728 ms</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=3 ttl=64 time=353 ms</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=4 ttl=64 time=349 ms</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=5 ttl=64 time=346 ms</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=6 ttl=64 time=344 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.27.58.47 ping statistics ---</span><br><span class="line">7 packets transmitted, 6 received, 14.2857% packet loss, time 6007ms</span><br><span class="line">rtt min/avg/max/mdev = 343.977/641.470/1728.966/505.726 ms, pipe 2</span><br></pre></td></tr></table></figure>

<p>其中 <code>172.27.58.47</code>
是运行在本地虚拟机的节点，由于zerotier根服务器设置在国外，第一次连接时需要通过根服务器找到对应主机信息，通过
UDP 建立连接，建立 P2P
网络，因此第一次连接较慢，但整体时延仍然很高，国内可以通过添加
<code>MOON</code> 节点来加速网络连接。</p>
<h2 id="optional-添加-moon-节点">(optional) 添加 MOON 节点</h2>
<h3 id="云服务器配置">云服务器配置</h3>
<p>由于zerotier的根服务器设置在国外，在国内组网时网络时延较高，因此可以通过设置
<strong>带有公网IP的云服务器</strong> 作为 <code>MOON</code>
节点作为根节点，降低网络时延</p>
<p>官网教程：<a href="https://docs.zerotier.com/zerotier/moons/">Private
Root Servers | ZeroTier
Documentation</a>（有一说一，官网这个教程写的真是...，第一次搞硬是没搞对，看了别人的教程才知道哪里有问题）</p>
<p>对于云服务器的配置和带宽，由于 MOON
节点仅用来建立连接，并不参与实际的网络数据交换，选择最丐的1核2G+1mbps带宽足够了。</p>
<p>配置过程分为以下4步：（在 zerotier 根目录下执行，全程 sudo）</p>
<ol type="1">
<li><p>根据本机 <code>identity.public</code>生成
<code>moon.json</code></p></li>
<li><p>修改 <code>moon.json</code> 文件，添加主机公网IP</p></li>
<li><p>从 <code>moon.json</code> 生成 <code>moon</code> 文件，并拷贝到
<code>moons.d</code> 文件夹下</p></li>
<li><p>重启 zerotier 服务</p></li>
</ol>
<p>zerotier应用的根目录（linux下）位于<code>/var/lib/zerotier</code>，其目录内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">ls</span> /var/lib/zerotier-one</span><br><span class="line">authtoken.secret  identity.public  moons.d     peers.d  zerotier-cli     zerotier-one      zerotier-one.port</span><br><span class="line">controller.d      identity.secret  networks.d  planet   zerotier-idtool  zerotier-one.pid  zerotier-one.te</span><br></pre></td></tr></table></figure>

<p>其中 <code>identity.public</code> 以及 <code>identity.secret</code>
就是用来表示本机的公钥和私钥了，使用这个 <code>identity.public</code>
我们就可以生成 <code>moon.json</code>，调用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo zerotier-idtool initmoon identity.public &gt;&gt; moon.json</span><br></pre></td></tr></table></figure>

<p>生成的 moon.json 内容如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;id&quot;</span>: <span class="string">&quot;5f1932174d&quot;</span>,</span><br><span class="line"> <span class="string">&quot;objtype&quot;</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line"> <span class="string">&quot;roots&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;identity&quot;</span>: <span class="string">&quot;5f1932174d:0:cf7728b3e66e4f207e537bfdee885c736d3430806c6cb279ce345103cef2302f42891547b73425793d0ea5cd7f18fd4c4a3aabf75193a23a609641d472ca01c6&quot;</span>,</span><br><span class="line">   <span class="string">&quot;stableEndpoints&quot;</span>: []</span><br><span class="line">  &#125;</span><br><span class="line"> ],</span><br><span class="line"> <span class="string">&quot;signingKey&quot;</span>: <span class="string">&quot;03f731a23d88171014e862dc222745b02f263eb58f72637a12a00a60175cd41dac20b91be0dc69ac233da8d8f119a3d4397228f89036d651d179469e373a8285&quot;</span>,</span><br><span class="line"> <span class="string">&quot;signingKey_SECRET&quot;</span>: <span class="string">&quot;76e23ef7ba06eeec08c85592bff86415143fd27c89efd0009a64ae0be864a9ba5ba592a8262cfe55210371499849a6c725eecaaf17e88d9ee2293a9eceb50dad&quot;</span>,</span><br><span class="line"> <span class="string">&quot;updatesMustBeSignedBy&quot;</span>: <span class="string">&quot;03f731a23d88171014e862dc222745b02f263eb58f72637a12a00a60175cd41dac20b91be0dc69ac233da8d8f119a3d4397228f89036d651d179469e373a8285&quot;</span>,</span><br><span class="line"> <span class="string">&quot;worldType&quot;</span>: <span class="string">&quot;moon&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>stableEndpoints</code>
一栏处填写服务器的公网IP以及端口号（一定要在云服务器中放通端口，具体百度即可，关键词：<strong>服务器安全组</strong>）</p>
<p>数据格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;xxx.xxx.xxx.xxx/xxxx&quot;</span><br></pre></td></tr></table></figure>

<p>完整示例如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;id&quot;</span>: <span class="string">&quot;5f1932174d&quot;</span>,</span><br><span class="line"> <span class="string">&quot;objtype&quot;</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line"> <span class="string">&quot;roots&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;identity&quot;</span>: <span class="string">&quot;5f1932174d:0:cf7728b3e66e4f207e537bfdee885c736d3430806c6cb279ce345103cef2302f42891547b73425793d0ea5cd7f18fd4c4a3aabf75193a23a609641d472ca01c6&quot;</span>,</span><br><span class="line">   <span class="string">&quot;stableEndpoints&quot;</span>: [<span class="string">&quot;49.235.186.44/9993&quot;</span>]    &lt;-- 修改此处</span><br><span class="line">  &#125;</span><br><span class="line"> ],</span><br><span class="line"> <span class="string">&quot;signingKey&quot;</span>: <span class="string">&quot;03f731a23d88171014e862dc222745b02f263eb58f72637a12a00a60175cd41dac20b91be0dc69ac233da8d8f119a3d4397228f89036d651d179469e373a8285&quot;</span>,</span><br><span class="line"> <span class="string">&quot;signingKey_SECRET&quot;</span>: <span class="string">&quot;76e23ef7ba06eeec08c85592bff86415143fd27c89efd0009a64ae0be864a9ba5ba592a8262cfe55210371499849a6c725eecaaf17e88d9ee2293a9eceb50dad&quot;</span>,</span><br><span class="line"> <span class="string">&quot;updatesMustBeSignedBy&quot;</span>: <span class="string">&quot;03f731a23d88171014e862dc222745b02f263eb58f72637a12a00a60175cd41dac20b91be0dc69ac233da8d8f119a3d4397228f89036d651d179469e373a8285&quot;</span>,</span><br><span class="line"> <span class="string">&quot;worldType&quot;</span>: <span class="string">&quot;moon&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后保存，使用下列命令生成 moon 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-idtool genmoon moon.json </span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-17-ubuntu:/var/lib/zerotier-one<span class="comment"># zerotier-idtool genmoon moon.json </span></span><br><span class="line">wrote 0000005f1932174d.moon (signed world with timestamp 1617851943432)</span><br></pre></td></tr></table></figure>

<p>然后将该文件拷贝到 <code>moons.d</code> 文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p moons.d &amp;&amp; <span class="built_in">mv</span> moon moons.d/</span><br></pre></td></tr></table></figure>

<p>最后重启一下服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service zerotier-one restart</span><br></pre></td></tr></table></figure>

<h3 id="客户端配置">客户端配置</h3>
<p>在客户端上直接使用 <code>orbit</code> 即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-cli orbit 5f1932174d 5f1932174d</span><br></pre></td></tr></table></figure>

<p>然后使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-cli peers</span><br></pre></td></tr></table></figure>

<p>查看我们是否配置成功（是否有 MOON 节点出现，且能否显示 MOON
节点的公网 IP）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-4-ubuntu:/var/lib/zerotier-one<span class="comment"># zerotier-cli orbit 5f1932174d 5f1932174d</span></span><br><span class="line">200 orbit OK</span><br><span class="line">root@VM-0-4-ubuntu:/var/lib/zerotier-one<span class="comment"># zerotier-cli peers</span></span><br><span class="line">200 peers</span><br><span class="line">&lt;ztaddr&gt;   &lt;ver&gt;  &lt;role&gt; &lt;lat&gt; &lt;<span class="built_in">link</span>&gt; &lt;lastTX&gt; &lt;lastRX&gt; &lt;path&gt;</span><br><span class="line">3a46f1bf30 -      PLANET   135 DIRECT 2209     2073     185.180.13.82/9993</span><br><span class="line">5f1932174d 1.6.4  MOON       4 DIRECT 159      155      49.235.186.44/38167</span><br><span class="line">62f865ae71 -      PLANET   206 DIRECT 2209     2007     50.7.252.138/9993</span><br><span class="line">778cde7190 -      PLANET   213 DIRECT 2209     1995     103.195.103.66/9993</span><br><span class="line">992fcf1db7 -      PLANET   225 DIRECT 2209     1968     195.181.173.159/9993</span><br><span class="line">c3a0da579a 1.6.4  LEAF      42 DIRECT 2560     2516     222.178.10.188/48425</span><br><span class="line">e5cd7a9e1c 1.6.4  LEAF     329 DIRECT 2209     10660    35.236.84.174/32150</span><br><span class="line">fa2671ab8a 1.6.4  LEAF      41 DIRECT 2943     2902     222.178.10.188/63370</span><br></pre></td></tr></table></figure>

<p>可以看到peers中第二个的role已经变成了MOON，此时再来ping，可以发现网络延时降低很多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-17-ubuntu:/var/lib/zerotier-one<span class="comment"># ping 172.27.126.84</span></span><br><span class="line">PING 172.27.126.84 (172.27.126.84) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.27.126.84: icmp_seq=1 ttl=64 time=16.8 ms</span><br><span class="line">64 bytes from 172.27.126.84: icmp_seq=2 ttl=64 time=4.37 ms</span><br><span class="line">64 bytes from 172.27.126.84: icmp_seq=3 ttl=64 time=4.49 ms</span><br><span class="line">64 bytes from 172.27.126.84: icmp_seq=4 ttl=64 time=4.53 ms</span><br><span class="line">64 bytes from 172.27.126.84: icmp_seq=5 ttl=64 time=4.55 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.27.126.84 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4009ms</span><br><span class="line">rtt min/avg/max/mdev = 4.368/6.955/16.842/4.943 ms</span><br></pre></td></tr></table></figure>

<p>原本 ping 是 300+ ms 的时延，配置了 moon 节点后直接 10ms 以内</p>
<p><strong>注：两个 MOON 节点不要互相 orbit</strong></p>
<p>使用 zerotier-one
的主要目的就是在宿舍远程控制实验室的服务器（虽然有很多现成的远程控制软件，但是大多都是远程图形界面的，写起来还是卡卡的，这种搞法既支持远程控制，也支持
ssh 直连）</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>nohup命令使用</title>
    <url>/posts/80b6/</url>
    <content><![CDATA[<h1 id="nohup-命令使用">nohup 命令使用</h1>
<p>最近需要在服务器上跑模型，需要长时间运行，但是服务器是通过 ssh
连接的，如果我们中途断开连接，正在跑的代码也会自动关闭。实在是有点整蛊，要想
ssh 断开连接后代码还可以继续执行，需要使用 <code>nohup</code> 命令。</p>
<p>使用 <code>nohup --help</code>，我们可以得到帮助信息</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(base) ➜  ~ nohup --help</span><br><span class="line">Usage: nohup COMMAND [ARG]...</span><br><span class="line">  or:  nohup OPTION</span><br><span class="line">Run COMMAND, ignoring hangup signals.</span><br><span class="line"></span><br><span class="line">      --help     display this help and exit</span><br><span class="line">      --version  output version information and exit</span><br><span class="line"></span><br><span class="line">If standard input is a terminal, redirect it from an unreadable file.</span><br><span class="line">If standard output is a terminal, append output to &#x27;nohup.out&#x27; if possible,</span><br><span class="line">&#x27;$HOME/nohup.out&#x27; otherwise.</span><br><span class="line">If standard error is a terminal, redirect it to standard output.</span><br><span class="line">To save output to FILE, use &#x27;nohup COMMAND &gt; FILE&#x27;.</span><br><span class="line"></span><br><span class="line">NOTE: your shell may have its own version of nohup, which usually supersedes</span><br><span class="line">the version described here.  Please refer to your shell&#x27;s documentation</span><br><span class="line">for details about the options it supports.</span><br><span class="line"></span><br><span class="line">GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">Report nohup translation bugs to &lt;https://translationproject.org/team/&gt;</span><br><span class="line">Full documentation at: &lt;https://www.gnu.org/software/coreutils/nohup&gt;</span><br><span class="line">or available locally via: info &#x27;(coreutils) nohup invocation&#x27;</span><br></pre></td></tr></table></figure>

<p>其中第三行解释了 nohup 命令的作用</p>
<blockquote>
<p><em>Run COMMAND, ignoring hangup signals.</em></p>
</blockquote>
<p>从描述中我们可以看到，其作用其实很简单，就是忽略 <code>hup</code>
信号。那么现在问题来了，<code>hup</code> 信号是什么？有什么作用？</p>
<span id="more"></span>

<h2 id="signal">SIGNAL</h2>
<p>信号可以理解成一种操作系统和进程之间的交互方式（IPC），当用户进程接收到信号时，其需要对信号进行响应，例如停止运行等（因此也可以理解为软件中断）</p>
<p>通过 <code>kill -l</code>
命令，我们可以查询到当前系统支持的所有信号（前 15
个信号为固定语义信号，后面的和具体实现有关，不同的 linux
之间不一致。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(base) ➜  test-nohup kill -l</span><br><span class="line">HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体信号含义以及对应的数字值可以参考：</p>
<p><a
href="https://www.man7.org/linux/man-pages/man7/signal.7.html">signal(7)
- Linux manual page (man7.org)</a> 中 Standard signals 部分</p>
</blockquote>
<p>也可以使用 <code>kill</code> 命令向进程发送信号，例如
<code>kill -9 &lt;PID&gt; </code> 就表示强制杀死进程号为
<code>PID</code> 的进程</p>
<p>下面展示几个比较常用的信号</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">signal name</th>
<th style="text-align: center;">signal number</th>
<th style="text-align: left;">description</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SIGHUP</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">Hangup detected on controlling terminal or
death of controlling process</td>
<td>检测到控制程序或命令行挂起</td>
</tr>
<tr class="even">
<td style="text-align: left;">SIGINT</td>
<td style="text-align: center;">2</td>
<td style="text-align: left;">Interrupt from keyboard</td>
<td>键盘中断（<kbd>Ctrl</kbd> + <kbd>C</kbd>）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SIGKILL</td>
<td style="text-align: center;">9</td>
<td style="text-align: left;">Kill signal</td>
<td>杀死信号</td>
</tr>
<tr class="even">
<td style="text-align: left;">SIGSEGV</td>
<td style="text-align: center;">11</td>
<td style="text-align: left;">Invalid memory reference</td>
<td>无效的内存引用（访问）</td>
</tr>
</tbody>
</table>
<p>在 python 中，我们可以使用 <code>signal</code>
库来响应信号（也可以用来忽略信号，但是跨平台就难做了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stderr&#x27;</span>,file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_signal</span>(<span class="params">signum:<span class="built_in">int</span>,frame</span>):</span><br><span class="line">    _signal = signal.Signals(signum)</span><br><span class="line">    e = OSError()</span><br><span class="line">    e.errno = <span class="number">0</span></span><br><span class="line">    e.strerror = <span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] received signal: <span class="subst">&#123;_signal.name&#125;</span>(<span class="subst">&#123;_signal.value&#125;</span>)&#x27;</span></span><br><span class="line">    <span class="keyword">raise</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGINT,on_signal)</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p>通过 <code>python main.py</code> 运行后，再通过键盘输入
<kbd>Ctrl</kbd> +
<kbd>C</kbd>，就可以看到响应输出，同时程序也结束了（手动抛出了一个异常）</p>
<p><img data-src="/posts/80b6/image-20230312232908661.png"
style="zoom: 67%;" /></p>
<p>对于 SIGHUP
信号，我们也可以同样进行测试，<strong>通过终端运行代码，然后关闭终端</strong>，就可以在输出中看到结果。稍微修改一下代码，将
stdout 和 stderr 重定向到文件中便于查看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stderr&#x27;</span>,file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_signal</span>(<span class="params">signum:<span class="built_in">int</span>,frame</span>):</span><br><span class="line">    _signal = signal.Signals(signum)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] received signal: <span class="subst">&#123;_signal.name&#125;</span>(<span class="subst">&#123;_signal.value&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGHUP,on_signal)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.log&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        sys.stdout = f</span><br><span class="line">        sys.stderr = f</span><br><span class="line">        asyncio.run(main())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img data-src="/posts/80b6/image-20230312233524825.png"
style="zoom:50%;" /></p>
<p>我们的代码只是接受信号并输出一句话，并没有看到预期的
exit，说明程序被操作系统关闭了，如果需要命令在终端关闭后还能继续执行，就需要通过
<code>nohup</code> 命令来确保进程能在后台继续执行。</p>
<h2 id="nohup-简单使用">nohup 简单使用</h2>
<p><code>nohuo</code> 命令使用起来很简单，在待执行的命令之前添加一个
<code>nohup</code> 即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> &lt;your-command&gt;</span><br></pre></td></tr></table></figure>

<p>示例如下，还是之前的 python 代码，但是我们通过 <code>nohup</code>
来执行，然后关闭终端，测试运行效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> python main.py</span><br></pre></td></tr></table></figure>

<p>运行后终端会提示一句话</p>
<p><img data-src="/posts/80b6/image-20230312235648581.png"
style="zoom:67%;" /></p>
<p>同时我们会在当前目录下看到 <code>nohup.out</code>
文件，虽然里面没有任何东西（因为我们将 python 的输出重定向到了
<code>output.log</code>）</p>
<p><img data-src="/posts/80b6/image-20230312235934838.png"
style="zoom:50%;" /></p>
<p>我们可以看到程序是执行完循环后主动退出的，而不是由操作系统关闭，说明
<code>nohup</code> 命令起作用了。</p>
<p>为了更清楚的看到 <code>nohup</code> 的作用，我们将 python
代码中的输出重定向去掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stderr&#x27;</span>,file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_signal</span>(<span class="params">signum:<span class="built_in">int</span>,frame</span>):</span><br><span class="line">    _signal = signal.Signals(signum)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] received signal: <span class="subst">&#123;_signal.name&#125;</span>(<span class="subst">&#123;_signal.value&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGHUP,on_signal)</span><br><span class="line">    <span class="comment"># with open(&#x27;output.log&#x27;,&#x27;w&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#     sys.stdout = f</span></span><br><span class="line">    <span class="comment">#     sys.stderr = f</span></span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>然后再次执行，并关闭命令行</p>
<p>命令行输出如下</p>
<p><img data-src="/posts/80b6/image-20230313000446837.png"
style="zoom: 67%;" /></p>
<p>但是程序本身的输出并没有出现在这里，查看
<code>nohup.out</code>，我们可以在 <code>nohup.out</code>
中看到完整的输出结果</p>
<p><img data-src="/posts/80b6/image-20230313225021012.png"
style="zoom:50%;" /></p>
<p>可以看到程序最后输出了
<code>exit</code>，表示程序正常退出，但我们同样接受到了
<code>SIGHUP</code> 信号，此时却没有被系统杀死，这就是
<code>nohup</code> 在起作用了。</p>
<h2 id="后台运行程序">后台运行程序</h2>
<p>当我们通过 <code>nohup</code>
执行应用程序时，当前终端并不能进行交互，但是我们也看不到进程的任何输出（因为
<code>nohup</code> 将其重定向到 <code>nohup.out</code>
里了），与其让终端等待进程执行完，不如将进程放在后台执行，然后使用终端进行其他操作。</p>
<p>后台执行程序也十分简单，只需要在命令后添加一个 <code>&amp;</code>
即可，然后在终端中就会输出后台执行命令的 <code>PID</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stderr&#x27;</span>,file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_signal</span>(<span class="params">signum:<span class="built_in">int</span>,frame</span>):</span><br><span class="line">    _signal = signal.Signals(signum)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] received signal: <span class="subst">&#123;_signal.name&#125;</span>(<span class="subst">&#123;_signal.value&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGHUP,on_signal)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.log&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        sys.stdout = f</span><br><span class="line">        sys.stderr = f</span><br><span class="line">        asyncio.run(main())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/80b6/image-20230313225834031.png"
style="zoom:67%;" /></p>
<p>此时终端就可以不等待进程执行完，立即返回了，<strong>但是如果进程有输出的话，还是会继续输出到命令行中，让我们无法进行交互，因此后台执行的进程最好将输出都给重定向一下</strong></p>
<p>我们也可以对其进行测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stderr&#x27;</span>,file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_signal</span>(<span class="params">signum:<span class="built_in">int</span>,frame</span>):</span><br><span class="line">    _signal = signal.Signals(signum)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] received signal: <span class="subst">&#123;_signal.name&#125;</span>(<span class="subst">&#123;_signal.value&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGHUP,on_signal)</span><br><span class="line">    <span class="comment"># with open(&#x27;output.log&#x27;,&#x27;w&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#     sys.stdout = f</span></span><br><span class="line">    <span class="comment">#     sys.stderr = f</span></span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/80b6/image-20230313230232701.png"
style="zoom:67%;" /></p>
<p>此时我们按什么都没用，因为我们无法直接和进程交互，可以通过
<code>kill</code> 方式向进程发送信号，然后停止进程（由于 stdout
一直有输出，命令行交互的体验极差，让人想直接把他 kill 掉）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP 1688</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/80b6/image-20230313230446035.png"
style="zoom:67%;" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 1850</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/80b6/image-20230313230618924.png"
style="zoom:67%;" /></p>
<p>此时我们可以发现，<code>nohup</code>
命令和后台运行简直是绝配，既可以将输出重定向到文件，且可以保证终端关闭后代码也能继续执行，完整代码就是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> &lt;your-command&gt; &amp;</span><br></pre></td></tr></table></figure>

<h2 id="输出重定向pipe操作">输出重定向（pipe操作）</h2>
<p><code>nohup</code>
命令自动帮我们配置好了输出重定向，有时候我们也想将输出保存到文件，从而便于我们观察输出结果（尤其是
gcc 编译结果，一报错出特别多，stdout
溢出了也看不到结果），此时我们就需要手动进行输入输出的重定向了。</p>
<p>在代码中，有三个特殊的文件，分别是
<code>stdin</code>、<code>stdout</code> 以及 <code>stderr</code>，在
python 中可以使用 <code>sys.stdin</code> 以及 <code>sys.stdout</code> 和
<code>sys.stderr</code> (之前的代码中也有使用，我们分别向 stderr 和
stdout 中输出了结果)</p>
<p>由于这三个是特殊的文件，自然也可以使用其他文件来代替，此时就是重定向了，而在
unix 环境下（其实 powershell
目前也支持了）可以在操作系统层面进行重定向，这样我们就不需要修改代码了。</p>
<p>下面列举了常用的重定向操作符</p>
<table>
<thead>
<tr class="header">
<th>operator</th>
<th>name</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[a]&gt;[b]</code></td>
<td>output to</td>
<td>将 a 的内容输出到 b 中</td>
</tr>
<tr class="even">
<td><code>[a]&gt;&gt;[b]</code></td>
<td>append to</td>
<td>将 a 的内容追加到 b 中</td>
</tr>
<tr class="odd">
<td><code>[a]&lt;[b]</code></td>
<td>read from</td>
<td>将 b 的内容读取到 a 中</td>
</tr>
<tr class="even">
<td>`[a]</td>
<td>[b]`</td>
<td>pipeing</td>
</tr>
</tbody>
</table>
<p>实例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello to stderr&#x27;</span>,file=sys.stderr)</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py &gt; stdout.log</span><br></pre></td></tr></table></figure>

<p>如果不加上任何符号，则默认将 stdout 重定向到 stdout.log 中，但是
stderr 还是会在终端中输出</p>
<p>运行结果</p>
<p><img data-src="/posts/80b6/image-20230313232650321.png"
style="zoom:67%;" /></p>
<p>同时 <code>stdout.log</code> 结果</p>
<p><img data-src="/posts/80b6/image-20230313232709124.png"
style="zoom:67%;" /></p>
<p>和我们的预期结果一样</p>
<p>要想指定输入输出流的文件，我们可以使用数字来代指（可以理解为指针），其中
<code>0</code> 表示 <code>stdin</code>， <code>1</code> 表示
<code>stdout</code>，<code>2</code> 表示 <code>stderr</code></p>
<p>还是上面的代码，但是我们调整一下调用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py 1&gt;stdout.log 2&gt;stderr.log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： 数字和符号之间没有空格，即
<code>1&gt;</code>，<code>0&lt;</code> 的形式</p>
</blockquote>
<p>运行结果</p>
<p><img data-src="/posts/80b6/image-20230313233059684.png"
style="zoom:67%;" /></p>
<p>两个文件结果</p>
<p><img data-src="/posts/80b6/image-20230313233205333.png" /></p>
<p>最后，我们可以将 stderr 重定向到
stdout，不过写法稍微特殊一点，可以理解为 C
语言的取地址（<code>&amp;1</code> 相当于是拿到 stdout 实际输出地址）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py &gt; stdout.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>这样 stdout 和 stderr 的结果就都会出现在 stdout.log 里面了</p>
<p><img data-src="/posts/80b6/image-20230313233726388.png"
style="zoom: 67%;" /></p>
<p>而对于 <code>|</code> ，一个很常用的例子就是检索（通过
<code>grep</code> 实现），例如我们想查询当前 python 环境中是否安装
<code>numpy</code>，可以使用一下命令进行查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip list | grep numpy</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/80b6/image-20230313233446900.png" /></p>
<p>还有很多高级用法，但是基本使用就介绍到这里</p>
<blockquote>
<p>注：为什么要有两个输出 <code>stdout</code> 和
<code>stderr</code>？</p>
<p>例如 pandoc 程序 ，其可以接受一个 md 文档并将其转换成
html，如果我们只是使用 pandoc
做其中一步操作，还需要后续操作的话，我们就可以使用 stdout
读取其输出结果，而通过 stderr
拿到其日志输出、警告的信息。这也是为什么即使我们优先输出到
stdout，然后再输出到 stderr，最终仍然是 stderr 的结果优先输出，因为
stderr 是<strong>无缓冲的</strong>，有结果就直接输出了。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile常见环境使用</title>
    <url>/posts/4a2b/</url>
    <content><![CDATA[<h1 id="dockerfile常见环境使用">Dockerfile常见环境使用</h1>
<h2 id="ubuntu国内镜像">ubuntu(国内镜像)</h2>
<p>由于网内网络环境的问题，ubuntu不换源的话基本没法用，我们首先参考普通
ubuntu 系统如何换源，然后将其转换成命令形式，便于应用于 Dockerfile
中。</p>
<p>随便在网上搜
"ubuntu换源"，可以搜出一大堆教程，这里我们直接参考阿里云开源镜像站的<a
href="https://developer.aliyun.com/mirror/ubuntu">官方教程</a>，官方教程中给出了操作办法，就是手动将所有的源地址替换为阿里云的镜像地址：</p>
<p><img data-src="/posts/4a2b/image-20230626220459741.png"
style="zoom:67%;" /></p>
<p>首先我们使用 docker 跑一个 ubuntu 的镜像看下基本情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> ubuntu:20.04 /bin/bash</span><br></pre></td></tr></table></figure>

<p>注：后面也会出写一个笔记记录常用的 docker 命令。</p>
<p>在 ubuntu 下使用 <code>sudo apt-get install xxx</code> 安装软件，所有
<code>apt</code> 相关的配置项存储在 <code>/etc/apt</code>
文件夹下，其内容如下</p>
<p><img data-src="/posts/4a2b/image-20230626215508213.png"
style="zoom:67%;" /></p>
<span id="more"></span>

<p>其中 <code>sources.list</code> 以及 <code>sources.list.d</code>
就涉及软件源的配置信息，<code>sources.list</code>
用来存储默认的软件源信息（或者说官方源），而 <code>sources.list.d</code>
则用来存储第三方软件源，例如 docker 软件源、nvidia
驱动源等，一般安装软件我们只需要配置 <code>sources.list</code>
即可，第三方源的配置和官方源的配置差不太多。</p>
<p>使用 <code>cat</code> 命令查看 <code>sources.list</code>
文件内容（较长，可能显示不全）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">root@302e32342092:/etc/apt# cat sources.list</span><br><span class="line"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span><br><span class="line"># newer versions of the distribution.</span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal main restricted</span><br><span class="line"># deb-src http://archive.ubuntu.com/ubuntu/ focal main restricted</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ focal-security main restricted</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ focal-security main restricted</span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ focal-security universe</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ focal-security universe</span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ focal-security multiverse</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ focal-security multiverse</span><br></pre></td></tr></table></figure>

<p>我们可以看到其软件源就是通过以下格式指定的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb &lt;apt source&gt;</span><br></pre></td></tr></table></figure>

<p>从源的URL链接中不难发现，这些链接实际上都是同一个域名底下的，我们换源是可以只更换前面的域名（即最后一个<code>/</code>之前的所有即可）。</p>
<p>既然都是替换了，那么肯定不能使用文本编辑器一个一个替换，最好的办法就是通过
<code>sed</code> 命令进行替换</p>
<h3 id="sed-命令简单介绍"><code>sed</code> 命令简单介绍</h3>
<p>from <a href="https://www.gnu.org/software/sed/">GNU sed - GNU
Project - Free Software Foundation</a></p>
<blockquote>
<p>sed (stream editor) is a non-interactive command-line text
editor.</p>
</blockquote>
<p>其功能十分强大，目前我们只用到了其 <code>s</code> 命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s/regexp/replacement/[flags]</span><br><span class="line">(substitute) Match the regular-expression against the content of the pattern space. </span><br><span class="line">If found, replace matched string with replacement.</span><br></pre></td></tr></table></figure>

<p>例如将文本中所所有的<code>foo</code>替换成<code>bar</code>就可以使用如命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s/foo/bar/g test.txt</span><br></pre></td></tr></table></figure>

<p>测试如下</p>
<p><img data-src="/posts/4a2b/image-20230626225050330.png" /></p>
<p>其中 <code>-i</code> 表示 inplace，即直接在当前文件中替换文本，最后的
<code>g</code> 表示对所有的匹配项进行替换</p>
<p>对于某些特殊字符，我们可以通过随意指定分隔符来避免频繁的转义，其格式如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">s&lt;delimiter&gt;regexp&lt;delimiter&gt;replacement&lt;delimiter&gt;[flags]</span><br></pre></td></tr></table></figure>

<p>例如我们需要替换文本中所有的 <code>a/b/c</code> 为
<code>e/f/g</code>，就可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s@a/f/g@e/f/g@g test.txt</span><br></pre></td></tr></table></figure>

<p>测试如下</p>
<p><img data-src="/posts/4a2b/image-20230626225349769.png" /></p>
<h3 id="替换链接">替换链接</h3>
<p>那么这样我们就可以我们通过文本替换实现换源，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s/archive.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>这条命令将所有的 <code>archive.ubuntu.com</code> 替换为
<code>mirrors.aliyun.com</code>，对于<code>security.ubuntu.com</code>也是一样，虽然我们并不会对容器中的
ubuntu 进行安全更新，但是 <code>security.ubuntu.com</code>
会严重影响软件源的更新速度，因此也需要一同替换掉，最终完整的换源命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s/archive.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">sed -i s/security.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>通过 <code>&amp;&amp;</code> 将两条命令合并成一条执行，最后执行
<code>apt-get update</code> 更新软件源即可</p>
<p><img data-src="/posts/4a2b/image-20230626230105000.png"
style="zoom: 67%;" /></p>
<p>此时可以看到软件源更新速度就很快了。</p>
<blockquote>
<p>注：上面的方法仅适用于 ubuntu x86_64
架构的版本，对于其他版本（arm64、RISC-V等）则需要使用另外的软件源，不过替换方法都是一致的，找到需要替换的链接，然后通过
<code>sed</code> 进行替换即可。</p>
<p>例如在 arm 版的 ubuntu 中，其软件源为
<code>http://ports.ubuntu.com/ubuntu-ports/</code>，其对应的阿里云镜像为
<code>https://mirrors.aliyun.com/ubuntu-ports/</code>，我们同样使用
<code>sed</code> 进行替换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s/ports.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>(阿里云镜像地址来自： <a
href="https://developer.aliyun.com/mirror/ubuntu-ports">https://developer.aliyun.com/mirror/ubuntu-ports</a>)</p>
</blockquote>
<h2 id="ssh-服务器">ssh 服务器</h2>
<p>启动 docker
容器后，有可能需要连接到容器中修改代码什么的（一般用于深度学习模型训练环境，部署代码的话最好不要这么做），最朴素的办法就是安装一个命令行的文本编辑器，例如
vi，vim，nano 等，命令用熟了还是很轻松的，但是学习成本太高了，后面发现
vscode 的 Remote SSH 插件可以通过 SSH
连接到主机，之后就像本地代码一样进行调试运行等，简直不要太方便（实际上还有更好的办法，直接通过
vscode 的 Dev Containers 插件直接连接到容器中），不过设置 SSH
通用性更高，例如搭建 hadoop 等环境进行测试时就可以使用。</p>
<p><img data-src="/posts/4a2b/image-20230626232514059.png"
style="zoom:50%;" /></p>
<p><img data-src="/posts/4a2b/image-20230626232428553.png"
style="zoom:50%;" /></p>
<p>在配置脚本安装之前，我们首先看看手动如何安装 ssh
服务器（openssh-server），直接通过apt安装即可，运行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>之后提示我们具体需要安装哪些包，以及是否确定安装</p>
<p><img data-src="/posts/4a2b/image-20230626232955966.png"
style="zoom: 67%;" /></p>
<p>但是我们可以看到，建议安装了一堆包，实际上有些包我们可以不装的，可以通过参数
<code>--no-install-recommends</code> 来取消安装这些包，运行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install openssh-server --no-install-recommends</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img data-src="/posts/4a2b/image-20230626233651500.png"
style="zoom: 67%;" /></p>
<p>相比之前我们所需要安装的依赖就少多了</p>
<p>但是还有一个问题，安装过程中有一个
<code>Do you want to continue? [Y/n]</code>
，提示我们是否确定，但是我们需要用命令完成自动化安装过程，安装过程中是完全无交互的，因此需要默认安装，可以通过
<code>-y</code> 来进行默认安装（具体可以参考 apt-get 的 <a
href="https://linux.die.net/man/8/apt-get">man 页面</a>）</p>
<p><img data-src="/posts/4a2b/image-20230626233919076.png"
style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install openssh-server --no-install-recommends -y</span><br></pre></td></tr></table></figure>

<p>这样当我们输入命令后就会自动安装了。</p>
<p>可以编写一个完整的安装 ssh 的 Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i s/archive.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    sed -i s/security.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install --no-install-recommends -y -q \</span></span><br><span class="line"><span class="language-bash">    openssh-server &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;service&quot;</span>,<span class="string">&quot;ssh&quot;</span>,<span class="string">&quot;start&quot;</span>,<span class="string">&quot;-D&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>其暴露一个端口 22（SSH的默认端口），而且使用
<code>service ssh start -D</code>
来确保命令前台运行（保证容器不会被杀死）</p>
<p>我们先尝试能否成功构建镜像，使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t openssh-server:ubuntu20.04 .</span><br></pre></td></tr></table></figure>

<p>进行构建，然后通过以下命令创建容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --<span class="built_in">rm</span> -p 54132:22 openssh-server:ubuntu20.04</span><br></pre></td></tr></table></figure>

<p>其中 <code>-d</code> 表示 detach，将容器列入后台运行，由于我们在
<code>CMD</code>
中已经指定了一个前台应用，容器不会立刻被docker杀死，<code>--rm</code>
表示容器运行结束后会被直接删除（常用于测试场景），<code>-p 54132:22</code>
表示将宿主机的54132端口绑定到容器的22端口（即SSH端口上，这样我们就可以通过
54132端口连接到容器的SSH服务了）。</p>
<p><img data-src="/posts/4a2b/image-20230626235528936.png"
style="zoom:80%;" /></p>
<p>最后我们使用 ssh 连接命令尝试连接到容器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -p 54132 root@localhost</span><br></pre></td></tr></table></figure>

<p>首先会提示我们是否需要建立连接（这一步可以说明SSH端口是通的）</p>
<p><img data-src="/posts/4a2b/image-20230626235851436.png"
style="zoom:80%;" /></p>
<p>但是此时直接提示我们输入密码，但是我们似乎并没有设置过 root
账户的密码，这就意味着我们永远无法连接到容器</p>
<p><img data-src="/posts/4a2b/image-20230627000040652.png"
style="zoom:80%;" /></p>
<p>我们可以通过一下命令连接到容器进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it &lt;container-id&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p>然后输入一下命令设置明文密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;root:123&quot; | chpasswd</span><br></pre></td></tr></table></figure>

<p>之后我们再尝试通过 SSH 进行连接，结果如下</p>
<p><img data-src="/posts/4a2b/image-20230627000800488.png"
style="zoom: 67%;" /></p>
<p>提示我们 Permission denied，这是因为 SSH 默认是不允许 root
用户通过密码登录的，我们需要修改 <code>/etc/ssh/sshd_config</code></p>
<p>通过 <code>cat /etc/ssh/sshd_config</code> 可以看到这一点</p>
<p><img data-src="/posts/4a2b/image-20230627085934013.png"
style="zoom:67%;" /></p>
<p>再查看 sshd_config 的相关配置选项（查看其相关的 <a
href="https://man7.org/linux/man-pages/man5/sshd_config.5.html">man
页面</a> 即可，注意查看版本，我们使用的 ubuntu
版本比较新，老的配置文档不一定适用）</p>
<p><img data-src="/posts/4a2b/image-20230627091111102.png"
style="zoom:67%;" /></p>
<p>可以看到 <code>PermitRootLogin</code>
的可选参数有四个：<code>yes</code>，<code>prohibit-password</code>，<code>forced-commands-only</code>，<code>no</code></p>
<blockquote>
<p>注：其中 <code>yes</code>，<code>prohibit-password</code>以及
<code>no</code> 的含义比较直观，但是 <code>forced-commands-only</code>
还不太理解，其限定 <code>root</code>
用户通过秘钥进行登录，但是只能执行特定的 <code>command</code> ，这个
<code>command</code> 实际上需要在 ssh 登录的时候指定，即
<code>authorized_keys</code> 中指定，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command=”/bin/ps” ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAt0BETg9J6hZb5Kqxy+yfNtKHfwxUELz7PqGtGiM5eNb8DHC8kj02SCFoql5rpaecMGybWRiSK8/k+EsK7TMgd4O+p6WkNyLD3WZrmVzUEPaxAdYf1eeCQooTJ+B1TKXDNlF9t8xTVsHd67HmPWYU6i3+kaDSX7cbrz2ds2zUGSozj1UQ8AJDJMbGOqpjs3nVh2EpSDgY7znqmUDnygVPiM4c3OfEzs5iCxVd4ggpPhH8d0bwy8RmPsooxJYUY4rE1C5iWCvB7P810yUFB0OilxiX9AfZa9shC3n5bqaX0ioY1eC44hFFPL602fJyKMj6w/zxN5aIeFO03Sl9+FU4YQ== root@iZ23wan41azZ</span><br></pre></td></tr></table></figure>

<p>就限定通过 <code>root</code> 私钥登录的时候只能执行
<code>/bin/ps</code>，无法执行其他命令，在运维场景下较为实用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PermitRootLogin yes&quot;</span> &gt;&gt; /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/4a2b/image-20230627091955121.png"
style="zoom:67%;" /></p>
<p>然后重启一下 ssh 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>

<p>（此处重启时由于没有前台应用，容器会被 docker
给杀死，再重启一下容器即可）</p>
<p>再尝试登录的时候就可以成功了，提示我们输入密码</p>
<p><img data-src="/posts/4a2b/image-20230627093607706.png"
style="zoom:67%;" /></p>
<p>每次登录都输入密码还是有点麻烦（可以通过 <code>sshd_config</code>
设置密码可为空来绕过，但是还会提示用户进行交互，无法实现自动化远程登录），为此我们需要配置远程登录，首先通过
<code>ssh-keygen</code> 创建一对秘钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/key -N <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/4a2b/image-20230627094530454.png"
style="zoom:67%;" /></p>
<p>其中 <code>-t rsa</code> 指定加密算法为 rsa，<code>-N ""</code>
表示私钥密码为空 ，输出私钥路径为 <code>~/key</code>
，公钥路径会在私钥后添加 <code>.pub</code>，即 <code>~/key.pub</code>
，此处创建的秘钥是可以复用的，不过不推荐这么做，安全性较低。</p>
<p>然后将公钥信息拷贝到 <code>~/.ssh/authorized_keys</code> 里即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.ssh</span><br><span class="line"><span class="built_in">cat</span> ~/key.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>然后再重启一下 ssh，最终使用私钥登录测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 54132 -i key root@localhost</span><br></pre></td></tr></table></figure>

<p>测试结果如下</p>
<p><img data-src="/posts/4a2b/image-20230627100723208.png"
style="zoom:67%;" /></p>
<p>提示我们权限不对，需要调整 key
的权限，按照下面的方式调整权限即可（适用于Windows，对于 macos 直接使用
<code>chmod</code> 命令修改权限即可）</p>
<p><img data-src="/posts/4a2b/modify-windows-privilege.png" /></p>
<p>再尝试登录的时候就可以登陆了</p>
<p><img data-src="/posts/4a2b/image-20230627101433963.png"
style="zoom:67%;" /></p>
<p>最后给出完整的 Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 ubuntu 软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i s/archive.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    sed -i s/security.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install --no-install-recommends -y \</span></span><br><span class="line"><span class="language-bash">    openssh-server &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝公钥和私钥，便于后续使用</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> public-key.pem /root/public-key.pem</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> private-key.pem /root/private-key.pem</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将公钥拷贝到 authorized_keys 中，其中设置权限是必须的</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /root/.ssh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">touch</span> /root/.ssh/authorized_keys &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 700 /root/.ssh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 600 /root/.ssh/authorized_keys &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cat</span> /root/public-key.pem &gt;&gt; /root/.ssh/authorized_keys</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 ssh 前台运行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;service&quot;</span>,<span class="string">&quot;ssh&quot;</span>,<span class="string">&quot;start&quot;</span>,<span class="string">&quot;-D&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<h2 id="minicondapython">miniconda(python)</h2>
<p>跑深度学习时经常需要配环境，需要安装 cuda 驱动、pytorch
等必要的软件库，虽然使用 anaconda 已经可以很好的管理 python 环境，使用
docker 来运行可以确保代码的可移植性，便于在另外一台机器上跑代码。</p>
<p>anaconda 官方起始有 docker 镜像，但是只有 debian 和
alpine，且通常我们会在 nvidia 的 cuda
容器中进行安装，可以参考官方的安装脚本进行配置，仓库地址：<a
href="https://github.com/ContinuumIO/docker-images/blob/master/miniconda3/debian/Dockerfile">docker-images/miniconda3/debian/Dockerfile
at master · ContinuumIO/docker-images · GitHub</a></p>
<p>代码如下</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:bullseye-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;Anaconda, Inc&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LANG=C.UTF-<span class="number">8</span> LC_ALL=C.UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hadolint ignore=DL3008</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update -q &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -q -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">        bzip2 \</span></span><br><span class="line"><span class="language-bash">        ca-certificates \</span></span><br><span class="line"><span class="language-bash">        git \</span></span><br><span class="line"><span class="language-bash">        libglib2.0-0 \</span></span><br><span class="line"><span class="language-bash">        libsm6 \</span></span><br><span class="line"><span class="language-bash">        libxext6 \</span></span><br><span class="line"><span class="language-bash">        libxrender1 \</span></span><br><span class="line"><span class="language-bash">        mercurial \</span></span><br><span class="line"><span class="language-bash">        openssh-client \</span></span><br><span class="line"><span class="language-bash">        procps \</span></span><br><span class="line"><span class="language-bash">        subversion \</span></span><br><span class="line"><span class="language-bash">        wget \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get clean \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH /opt/conda/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;/bin/bash&quot;</span> ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Leave these args here to better use the Docker build cache</span></span><br><span class="line"><span class="keyword">ARG</span> CONDA_VERSION=py310_23.<span class="number">3.1</span>-<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    UNAME_M=<span class="string">&quot;<span class="subst">$(uname -m)</span>&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;x86_64&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-x86_64.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;aef279d6baea7f67940f16aad17ebe5f6aac97487c7c03466ff01f4819e5a651&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;s390x&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-s390x.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;ed4f51afc967e921ff5721151f567a4c43c4288ac93ec2393c6238b8c4891de8&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;aarch64&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-aarch64.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;6950c7b1f4f65ce9b87ee1a2d684837771ae7b2e6044e0da9e915d1dee6c924c&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;ppc64le&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-ppc64le.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;b3de538cd542bc4f5a2f2d2a79386288d6e04f0e1459755f3cefe64763e51d16&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">fi</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    wget <span class="string">&quot;<span class="variable">$&#123;MINICONDA_URL&#125;</span>&quot;</span> -O miniconda.sh -q &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;SHA256SUM&#125;</span> miniconda.sh&quot;</span> &gt; shasum &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;CONDA_VERSION&#125;</span>&quot;</span> != <span class="string">&quot;latest&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">sha256sum</span> --check --status shasum; <span class="keyword">fi</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p /opt &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    bash miniconda.sh -b -p /opt/conda &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> miniconda.sh shasum &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">ln</span> -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;. /opt/conda/etc/profile.d/conda.sh&quot;</span> &gt;&gt; ~/.bashrc &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;conda activate base&quot;</span> &gt;&gt; ~/.bashrc &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    find /opt/conda/ -follow -<span class="built_in">type</span> f -name <span class="string">&#x27;*.a&#x27;</span> -delete &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    find /opt/conda/ -follow -<span class="built_in">type</span> f -name <span class="string">&#x27;*.js.map&#x27;</span> -delete &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    /opt/conda/bin/conda clean -afy</span></span><br></pre></td></tr></table></figure>

<p>理解起来很简单，第一步安装 miniconda
的依赖（有些依赖我们并不需要，可根据自己需要调整），第二步根据系统版本选择对应的
miniconda 安装脚本进行安装，将其添加到 <code>/etc/profile.d</code> 和
<code>~/.bashrc</code>中（确保 miniconda
的初始化脚本在用户登录或用户交互前自动执行），最后清理掉无用的数据即可</p>
<h3 id="miniconda-换源">miniconda 换源</h3>
<p>国内 miniconda 也很慢，同样可以对其进行换源，这里参考清华源的<a
href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">换源教程</a>，直接在用户目录下创建
`.condarc`，然后填写如下信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">default_channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span></span><br><span class="line"><span class="attr">custom_channels:</span></span><br><span class="line">  <span class="attr">conda-forge:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">msys2:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">bioconda:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">menpo:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch-lts:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">simpleitk:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">deepmodeling:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/</span></span><br></pre></td></tr></table></figure>

<p>这一部分最好直接通过 <code>COPY</code>
命令的方式，将本地文件拷贝至容器中进行替换</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> .condarc /root/.condarc</span></span><br></pre></td></tr></table></figure>

<h3 id="创建新环境并安装包">创建新环境并安装包</h3>
<p>配置好 miniconda 后我们就可以安装指定版本的 python
并配置我们需要的依赖包了，现在的问题在于，创建新环境后需要激活环境，然后再进行安装，那么如何在
dockerfile 中激活环境呢？可以通过 <code>Dockerfile</code> 中的
<code>SHELL</code> 命令指定所需要使用的 shell。</p>
<p>首先给出完整的 Dockerfile，然后再进行解析</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> continuumio/miniconda3:<span class="number">23.3</span>.<span class="number">1</span>-<span class="number">0</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> .condarc /root/.condarc</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [ <span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;--login&quot;</span>,<span class="string">&quot;-c&quot;</span> ]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> conda create -n <span class="built_in">test</span> python=3.9 -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    conda activate <span class="built_in">test</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    conda install numpy -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&#x27;conda activate test&#x27;</span> &gt;&gt; ~/.bashrc</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>其中的关键在于下面这条语句：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [ <span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;--login&quot;</span>,<span class="string">&quot;-c&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>这一条语句的含义就是我们后面所执行的所有命令，都会通过 SHELL 指定的
shell 进行调用，例如我们后面有语句
<code>RUN conda activate base</code>，其会就等价于</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash --login -c <span class="string">&quot;conda activate base&quot;</span></span><br></pre></td></tr></table></figure>

<p>关键在于 <code>--login</code> 参数，其强制 Shell
以登录模式调用命令，其关键在于 <code>--login</code> 在启动 shell
时会加载 <code>/etc/profile</code> 以及 <code>/etc/profile.d</code>
中指定的脚本文件，从前面的 Dockerfile 中我们也可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh</span><br></pre></td></tr></table></figure>

<p>这个 <code>conda.sh</code> 就是用来激活环境的脚本，我们可以通过
<code>/bin/bash --noprofile --norc</code> 来测试</p>
<p><img data-src="/posts/4a2b/image-20230702111917783.png"
style="zoom:50%;" /></p>
<p>可以看到当我们加载 <code>/etc/profile</code>
后就可以激活环境了，在非交互模式下也是如此。</p>
<p>下面给出一个完整的 pytorch + cuda 的环境</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nvidia/cuda:<span class="number">11.3</span>.<span class="number">1</span>-cudnn8-runtime-ubuntu20.<span class="number">04</span></span><br><span class="line"><span class="comment"># 环境变量设置，设置 console 的语言、时区以及 nvidia 驱动</span></span><br><span class="line"><span class="keyword">ENV</span> LANG=$&#123;LANG:-C.UTF-<span class="number">8</span>&#125; LC_ALL=$&#123;LC_ALL:-C.UTF-<span class="number">8</span>&#125; TZ=$&#123;TZ:-Asia/Shanghai&#125; \</span><br><span class="line">    NVIDIA_DRIVER_CAPABILITIES=$&#123;NVIDIA_DRIVER_CAPABILITIES:-compute,utility&#125; </span><br><span class="line"><span class="comment"># 安装 ubuntu 依赖    </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -ex &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    sed -i s@/security.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /etc/apt/sources.list.d &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean -q &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get update -q &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -q -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">        bzip2 \</span></span><br><span class="line"><span class="language-bash">        ca-certificates \</span></span><br><span class="line"><span class="language-bash">        git \</span></span><br><span class="line"><span class="language-bash">        wget \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get clean \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="comment"># 安装 miniconda，这一段直接复制的官方的 dockerfile</span></span><br><span class="line"><span class="keyword">ENV</span> PATH /opt/conda/bin:$PATH</span><br><span class="line"><span class="comment"># Leave these args here to better use the Docker build cache</span></span><br><span class="line"><span class="keyword">ARG</span> CONDA_VERSION=py310_23.<span class="number">3.1</span>-<span class="number">0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    UNAME_M=<span class="string">&quot;<span class="subst">$(uname -m)</span>&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;x86_64&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-x86_64.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;aef279d6baea7f67940f16aad17ebe5f6aac97487c7c03466ff01f4819e5a651&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;s390x&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-s390x.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;ed4f51afc967e921ff5721151f567a4c43c4288ac93ec2393c6238b8c4891de8&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;aarch64&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-aarch64.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;6950c7b1f4f65ce9b87ee1a2d684837771ae7b2e6044e0da9e915d1dee6c924c&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;ppc64le&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-ppc64le.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;b3de538cd542bc4f5a2f2d2a79386288d6e04f0e1459755f3cefe64763e51d16&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">fi</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    wget <span class="string">&quot;<span class="variable">$&#123;MINICONDA_URL&#125;</span>&quot;</span> -O miniconda.sh -q &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;SHA256SUM&#125;</span> miniconda.sh&quot;</span> &gt; shasum &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;CONDA_VERSION&#125;</span>&quot;</span> != <span class="string">&quot;latest&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">sha256sum</span> --check --status shasum; <span class="keyword">fi</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p /opt &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    bash miniconda.sh -b -p /opt/conda &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> miniconda.sh shasum &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">ln</span> -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;. /opt/conda/etc/profile.d/conda.sh&quot;</span> &gt;&gt; ~/.bashrc &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;conda activate base&quot;</span> &gt;&gt; ~/.bashrc &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    find /opt/conda/ -follow -<span class="built_in">type</span> f -name <span class="string">&#x27;*.a&#x27;</span> -delete &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    find /opt/conda/ -follow -<span class="built_in">type</span> f -name <span class="string">&#x27;*.js.map&#x27;</span> -delete &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    /opt/conda/bin/conda clean -afy</span></span><br><span class="line"><span class="comment"># 创建指定版本的环境   </span></span><br><span class="line"><span class="keyword">ARG</span> CONDA_ENV_NAME=ml</span><br><span class="line"><span class="keyword">ARG</span> CONDA_ENV_PY_VER=<span class="number">3.9</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./condarc /root/.condarc</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    conda create -n <span class="variable">$&#123;CONDA_ENV_NAME&#125;</span> python=<span class="variable">$&#123;CONDA_ENV_PY_VER&#125;</span> -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;conda activate <span class="variable">$&#123;CONDA_ENV_NAME&#125;</span>&quot;</span> &gt;&gt; ~/.bashrc &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    conda clean -afy</span></span><br><span class="line"><span class="comment"># 激活环境，配置清华源并安装库</span></span><br><span class="line"><span class="comment"># 通过 pip 进行安装，如果通过 conda 安装还会手动安装 cudnn、cuda 等包，实际上我们已经有了</span></span><br><span class="line"><span class="comment"># 推荐使用 pip install -r requirements 进行安装</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;--login&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> conda activate <span class="variable">$&#123;CONDA_ENV_NAME&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install torch==1.12.1+cu113 torchvision==0.13.1+cu113 \</span></span><br><span class="line"><span class="language-bash">                torchaudio==0.12.1 --extra-index-url https://download.pytorch.org/whl/cu113 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /root/.cache/pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    conda clean -afy</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>构建时间可能较长（pytorch 包太大了），启动时注意参数
<code>--shm_size</code> ，尤其是在多线程数据加载中</p>
<h2 id="总结">总结</h2>
<p>个人理解 dockerfile
实际上就是运维脚本的另外一种形式，关键还是在于脚本语言的熟悉程度，linux
命令较为熟悉的话就可以很轻松的构建出合适的镜像。</p>
<p>参考资料</p>
<ol type="1">
<li><a
href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11uhvFDQ">ubuntu镜像_ubuntu下载地址_ubuntu安装教程-阿里巴巴开源镜像站
(aliyun.com)</a></li>
<li><a href="https://linux.die.net/man/8/apt-get">apt-get(8) - Linux man
page (die.net)</a></li>
<li><a
href="https://www.man7.org/linux/man-pages/man5/sshd_config.5.html">sshd_config(5)
- Linux manual page (man7.org)</a></li>
<li><a
href="https://blog.csdn.net/huigher/article/details/52972013">sshd_config
中 PermitRootLogin 的探讨_huigher的博客-CSDN博客</a></li>
<li><a
href="https://blog.csdn.net/u011095110/article/details/81020839">Linux下service
xxx start/stop/restart启动服务、关闭服务、重启服务深入理解@_service
start_King-Long的博客-CSDN博客</a></li>
<li><a
href="https://blog.csdn.net/weixin_40415591/article/details/121661857">windows
ssh Permissions for “xxx“ are too
open错误详细解决方案_菜到不知所措的博客-CSDN博客</a></li>
<li><a
href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">anaconda |
镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source
Mirror</a></li>
<li>LPIC Shell 基础：<a
href="https://learning.lpi.org/en/learning-materials/102-500/105/105.1/105.1_01/">105.1
Lesson 1 (lpi.org)</a></li>
<li><a
href="https://blog.csdn.net/weixin_44966641/article/details/123930747">共享内存简介及docker容器的shm设置与修改_docker
shm_Adenialzz的博客-CSDN博客</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake项目结构模版</title>
    <url>/posts/d235/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC实践</title>
    <url>/posts/ac0d/</url>
    <content><![CDATA[<h1 id="webrtc实践">WebRTC实践</h1>
<p><a href="https://webrtc.org/">WebRTC</a></p>
<p>WebRTC 表示 Web <strong>R</strong>eal-<strong>T</strong>ime
<strong>C</strong>ommunication，通过建立端到端的P2P连接，实现高效的数据传输</p>
<p>由于两个客户端并不能直接连通，需要借助一个服务器来完成建立连接的工作，下面展示了一个最简单的WebRTC交互模型，包含两个客户端以及一个服务端</p>
<ul>
<li><p>Client1</p></li>
<li><p>Client2</p></li>
<li><p>Signalling Server</p>
<p>establish p2p connection</p>
<p>hand shaking</p></li>
</ul>
<blockquote>
<p>both clients need to provide an ICE Server configuration. This is
either a STUN or a TURN-server, and their role is to provide ICE
candidates to each client which is then transferred to the remote peer.
This transferring of ICE candidates is commonly called signaling.</p>
<p>ICE Server stands for <strong>I</strong>nternet
<strong>C</strong>onnectivity <strong>E</strong>stablishment
Server（中文翻译就是用于建立互联网连接的服务器）</p>
<p>Passing SDP objects to remote peers is called signaling and is not
covered by the WebRTC specification.</p>
</blockquote>
<p>名词解释</p>
<ul>
<li>WebRTC</li>
<li>P2P</li>
<li>ICE</li>
<li>STUN</li>
<li>TURN</li>
<li>SDP</li>
<li>NAT</li>
</ul>
<blockquote>
<p>Before two peers can communitcate using WebRTC, they need to exchange
connectivity information. Since the network conditions can vary
depending on a number of factors, an external service is usually used
for discovering the possible candidates for connecting to a peer. This
service is called ICE and is using either a STUN or a TURN server.
<em><strong>STUN stands for Session Traversal Utilities for NAT, and is
usually used indirectly in most WebRTC applications.</strong></em></p>
<p><em><strong>TURN (Traversal Using Relay NAT) is the more advanced
solution that incorporates the STUN protocols and most commercial WebRTC
based services use a TURN server for establishing connections between
peers.</strong></em> The WebRTC API supports both STUN and TURN
directly, and it is gathered under the more complete term Internet
Connectivity Establishment. When creating a WebRTC connection, we
usually provide one or several ICE servers in the configuration for the
<code>RTCPeerConnection</code> object.</p>
</blockquote>
<span id="more"></span>

<p>client1 -&gt; TURN -&gt; client2 (fake p2p, relay)</p>
<p>client1 -&gt; client2 (real p2p)</p>
<blockquote>
<p>But sometimes this would not be sufficient because there are
possibilities where some users might face connectivity issues because of
different IP networks where Firewalls and NATs (Network Address
Translators) could include specific network policies that will not allow
RTC communications.</p>
<p>In order to solve this kind of network connection scenario, we need
to use ICE (Interactive Connectivity Establishment) protocol and it
defines a systematic way of finding possible communication options
between a peer and the Video Gateway (WebRTC).</p>
<p>ICE (INTERACTIVE CONNECTIVITY ESTABLISHMENT) is a protocol used to
generate media traversal candidates that can be used in WebRTC
applications, and it can be successfully sent and received through
Network Address Translation (NAT)s using STUN and TURN.</p>
</blockquote>
<h2 id="基本概念">基本概念</h2>
<h2 id="年轻人的第一个-webrtc-应用">年轻人的第一个 WebRTC 应用</h2>
<h2 id="其他应用场景">其他应用场景</h2>
<p>通过 webrtc 可以是两个应用端之间的p2p
交互（这也是为什么腾讯会议在两个人的时候不限时，而在超过两个人的时候限时了，两个人的时候用的是
p2p
连接，腾讯会议的服务器只需要建立p2p连接就行，其他不管，但是多人情况下可能需要服务端进行推流，需要消耗大量服务器资源，因此要收费）</p>
<p>也可以实现前端后后端的交互（例如深度学习应用的部署）</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 易错点整理</title>
    <url>/posts/17bc/</url>
    <content><![CDATA[<h1 id="python-易错点整理">Python 易错点整理</h1>
<h2 id="魔法方法和内置属性">魔法方法和内置属性</h2>
<h3 id="容器类型">容器类型</h3>
<blockquote>
<p>链接：<a
href="https://www.nowcoder.com/questionTerminal/c2380f6992814490b7f5b6e446b72ed7">https://www.nowcoder.com/questionTerminal/c2380f6992814490b7f5b6e446b72ed7</a>
来源：牛客网</p>
</blockquote>
<p>根据以下程序，下列选项中，说法正确的是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(): </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,pos</span>): </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">30</span>,<span class="number">10</span>)[pos] </span><br><span class="line">foo = Foo() </span><br></pre></td></tr></table></figure>

<ol type="1">
<li><code>foo</code> 对象表现得像个序列</li>
<li>可以使用 <code>len(foo)</code> 来查看对象 <code>foo</code>
的元素个数</li>
<li>可以使用 <code>for i in foo:print(i)</code> 来遍历 <code>foo</code>
的元素</li>
<li>不能使用 <code>foo[0]</code> 来访问对象 <code>foo</code>
的第一个元素</li>
</ol>
<p>对于第一个选项，<a
href="https://docs.python.org/3.9/glossary.html#term-sequence">Python文档</a>中定义序列必须实现两个方法，`__getitem__`
以及 `__len__`，即支持通过整数的索引以及返回序列的长度，而
<code>Foo</code> 仅实现了整数索引功能，因此不是序列。</p>
<p>对于第二个选项，<code>len(foo)</code> 实际上会调用
<code>__len__</code> 方法来获取序列长度，类没实现该方法故不行</p>
<p>对于第三个选项，<code>for</code> 语句支持两种，一种为通过
<code>__iter__</code> 进行调用，另一种则为
<code>__getitem__</code>，因此<strong>正确</strong></p>
<p>对于第四个选项，由于我们定义了 <code>__getitem__</code>
方法，我们是可以通过 <code>foo[0]</code> 来访问 <code>foo</code>
的第一个元素的</p>
<span id="more"></span>

<h2 id="__slots__"><code>__slots__</code></h2>
<blockquote>
<p><a
href="https://docs.python.org/3.9/reference/datamodel.html?highlight=__slots__#slots">3.
Data model — Python 3.9.17 documentation #_<em>slots</em></a>_</p>
</blockquote>
<p><code>__slots__</code>
属性用来<strong>显式指定对象所包含的属性</strong>，相比
<code>__dict__</code> 效率更高，但是使用上有很多细节需要注意</p>
<p>只有 <code>__slots__</code>
中指定的属性可以被赋值，其他的会报错，示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">f = Foo()</span><br><span class="line">f.foo = <span class="string">&#x27;foo&#x27;</span>   <span class="comment"># ✓</span></span><br><span class="line">f.bar = <span class="string">&#x27;bar&#x27;</span>   <span class="comment"># ✓</span></span><br><span class="line">f.fooo = <span class="string">&#x27;fooo&#x27;</span> <span class="comment"># ✗</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/null/image-20230729210618254.png"
style="zoom:50%;" /></p>
<h2 id="__init__-和-__new__"><code>__init__</code> 和
<code>__new__</code></h2>
<blockquote>
<p><a
href="https://docs.python.org/3.9/reference/datamodel.html?highlight=__new__#basic-customization">3.
Data model — Python 3.9.17 documentation #basic-customization</a></p>
</blockquote>
<p>在 Python 中，对象的创建和初始化是两个分开的过程，</p>
<ul>
<li><code>__new__</code>
负责对象的创建，为类的<strong>静态方法</strong>，其返回一个类实例对象</li>
<li><code>__init__</code>
负责对象的初始化，<strong>其不需要返回任何值</strong>，当存在继承时，不会自动调用父类的
<code>__init__</code>，需要手动通过
<code>super()__init__([args...])</code> 进行调用</li>
</ul>
<h2 id="列表生成式和-">列表生成式和 <code>*</code></h2>
<blockquote>
<p>链接：<a
href="https://www.nowcoder.com/questionTerminal/26cc96e5eb1f40dca9b1987a0944eff1">https://www.nowcoder.com/questionTerminal/26cc96e5eb1f40dca9b1987a0944eff1</a>
来源：牛客网</p>
</blockquote>
<p>执行以下程序，输出结果为？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">b = [[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]] * <span class="number">2</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span></span><br><span class="line">b[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;4&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a,b) </span><br></pre></td></tr></table></figure>

<p>乍一看两个都可完成列表的重复，但关键在于复制的<strong>深浅</strong>，具体可以参考官方文档对于
<a
href="https://docs.python.org/3.9/tutorial/datastructures.html?highlight=list">list
的介绍</a></p>
<ul>
<li>使用列表生成式（Generator
Statement）创建列表式会创建多个对象，使用时更灵活</li>
<li>使用 <code>*</code>
来重复对象时将<strong>指向同一个内存地址</strong></li>
</ul>
<p>我们可以测试 <code>*</code> 的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> [[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]] * <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(v))</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img data-src="/posts/null/image-20230729201613453.png"
style="zoom:50%;" /></p>
<p>因此上面的结果就显而易见了</p>
<p><code>a[0][1]</code> 就仅会修改列表第一个元素，而
<code>b[0][0]</code>
由于两个元素实际上指向同一个内存地址，会同步进行修改</p>
<p>最终结果为
<code>[['1', '3'], ['1', '2']] [['4', '2'], ['4', '2']]</code></p>
<h2 id="切片">切片</h2>
<h3 id="元组和列表">元组<code>[:]</code>和列表<code>[:]</code></h3>
<p>这个有点细节了，<strong>由于元组是不可变的（immutable）</strong>，其切片就是其本身，而列表可变，其切片将会复制一个列表</p>
<p><img data-src="/posts/null/image-20230729205320321.png"
style="zoom:50%;" /></p>
<p>可以通过<code>id</code>来观察内存地址，其中元组切片内存地址不变，列表切片会复制一个，内存地址发生变化</p>
<h2 id="类与继承">类与继承</h2>
<h2 id="字符串操作">字符串操作</h2>
<h3 id="strip">strip</h3>
<p><em>str.strip([chars])</em>：删除字符串首尾所有在 <code>chars</code>
中的字符，例如 <code>'abbacabb'.strip('ab')</code> 就会删除首尾的
<code>a</code> 和 <code>b</code> 最终就只剩下 <code>c</code> 了</p>
<h3 id="split">split</h3>
<p><em>str.split(sep=None, maxsplit=-1)</em>：使用 <code>sep</code>
中指定的字符串分割字符串，<code>maxsplit</code>
用来限制分割字符串的数目</p>
<p>这个函数有点坑的在于首尾出现 <code>sep</code> 时，例如
<code>'&lt;&gt;A&lt;&gt;B&lt;&gt;C&lt;&gt;'.split('&lt;&gt;')</code>，其结果为
<code>['','A','B','C','']</code></p>
<p>不过这么输出也合理，因为 <code>sep</code> 需要用来分割两个字符串</p>
<h2 id="布尔判断">布尔判断</h2>
<p>除了显式的 <code>bool</code>
类型外，以下三种情况应用于条件判断语句时也为 <code>False</code></p>
<blockquote>
<p><a
href="https://docs.python.org/3.9/library/stdtypes.html?highlight=strip#truth-value-testing">Truth
Value Testing</a></p>
</blockquote>
<ul>
<li><p>值为 <code>None</code></p></li>
<li><p>任意一种数值类型的0：<code>0</code>，<code>0.0</code>，<code>0j</code>（复数），<code>Decimal(0)</code>，<code>Fraction(0,1)</code></p></li>
<li><p>空序列/容器：<code>''</code>（空字符串），<code>()</code>（空元组），<code>[]</code>（空列表），<code>&#123;&#125;</code>（空字典），<code>set()</code>（空集合），<code>range(0)</code>（空范围）</p></li>
</ul>
<p>这个还是值得注意的，下面表达式就是等价的，可以让代码看起来不那么冗余</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> Obj &lt;==&gt; <span class="keyword">if</span> Obj <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="type">List</span> &lt;==&gt; <span class="keyword">if</span> <span class="built_in">len</span>(<span class="type">List</span>) != <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符优先级">运算符优先级</h2>
<h2 id="作用域">作用域</h2>
<h2 id="nonlocal-和-global">nonlocal 和 global</h2>
<p>当我们需要<strong>修改全局或者外部作用域的变量</strong>时，就需要使用
<code>global</code> 或 <code>nonlocal</code>
关键字来说明，否则就会报错，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">global_v = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    global_v += <span class="number">10</span></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(global_v)</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/null/image-20230729212519574.png"
style="zoom:50%;" /></p>
<h2 id="lambda-和函数闭包">lambda 和函数闭包</h2>
<p>可以通过函数闭包的方式实现静态变量（也可以使用<code>hasattr</code>、<code>setattr</code>
和 <code>getattr</code> 来设置），例如实现一个计数器（这个实际上有点像
<code>JavaScript</code> 的写法，函数式编程）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counter</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count_value</span>():</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> increment, count_value</span><br></pre></td></tr></table></figure>

<p>在函数内使用外部变量是以<strong>引用方式</strong>读取（C++中的lambda可以指定不同变量捕获方式，比较灵活），因此会在<strong>执行函数才会读取变量的值。</strong></p>
<h2 id="函数默认参数">函数默认参数</h2>
<blockquote>
<p>链接：<a
href="https://www.nowcoder.com/questionTerminal/0f7fb713fb8f46548f38177c3b3d47ba">https://www.nowcoder.com/questionTerminal/0f7fb713fb8f46548f38177c3b3d47ba</a>
来源：牛客网</p>
</blockquote>
<p>执行下列程序，输出结果为？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a=(<span class="params"></span>),b=[]</span>):</span><br><span class="line">    a += (<span class="number">1</span>,)</span><br><span class="line">    b.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a,b</span><br><span class="line"></span><br><span class="line">fun()</span><br><span class="line"><span class="built_in">print</span>(fun())</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a
href="https://docs.python.org/3/reference/compound_stmts.html#function">8.
Compound statements — Python 3.11.4 documentation</a></p>
<p>参考官方文档：<strong>Default parameter values are evaluated from
left to right when the function definition is executed.</strong> This
means that the expression is evaluated once, when the function is
defined, and that the same “pre-computed” value is used for each call.
<strong>This is especially important to understand when a default
parameter value is a mutable object</strong>, such as a list or a
dictionary: if the function modifies the object (e.g. by appending an
item to a list), the default parameter value is in effect modified. This
is generally not what was intended. A way around this is to use
<code>None</code> as the default, and explicitly test for it in the body
of the function.</p>
<p>函数默认参数将在函数定义时就初始完成，然后在后续的调用中一直使用这个”预计算好的“默认值，这就会带来很多坑</p>
</blockquote>
<p>对于不可变的对象，例如元组和字符串而言，<strong>在函数中的修改并不会修改默认值</strong>，因为他们的值是不可变的（immutable），但是对于列表和字典这样的可变对象而言，<strong>就相当于全局变量一样会一直更新</strong>。</p>
<p>虽然 <code>a</code> 为一个元组，但是 <code>a += (1,)</code> 等价于
<code>a = a + (1,)</code> 即我们对 a
重新设置了一个值（其实对b重新赋值的话也不会有影响，但是 append
是直接修改 b 的元素）</p>
<p>因此最终输出为
<code>((1,), [1, 1])</code>（函数多个返回值会合并为一个元组统一输出）</p>
<h2 id="装饰器">装饰器</h2>
<blockquote>
<p><a
href="https://docs.python.org/3/glossary.html#term-decorator">Glossary —
Python 3.11.4 documentation #term-decorator</a></p>
<p>Decorator expressions are evaluated when the function is defined, in
the scope that contains the function definition.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@f1(<span class="params">arg</span>)</span></span><br><span class="line"><span class="meta">@f2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(): <span class="keyword">pass</span></span><br><span class="line">func = f1(arg)(f2(func))</span><br></pre></td></tr></table></figure>

<p>上面例子可能有点抽象，举个实际一点的例子，计时器以及重复执行（带参数的装饰器如何实现）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> perf_counter_ns</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="comment"># 统计函数的运行时间</span></span><br><span class="line">        start = perf_counter_ns()</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">        end = perf_counter_ns()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;cost: <span class="subst">&#123;(end-start)/<span class="number">1e6</span>:<span class="number">03.3</span>f&#125;</span> ms&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Repeat</span>(<span class="params">count</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">            <span class="comment"># 将函数执行 count 次</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">                func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">            </span><br><span class="line"><span class="meta">@Timer</span></span><br><span class="line"><span class="meta">@Repeat(<span class="params">count=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_func1</span>():</span><br><span class="line">    <span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">    sleep(<span class="number">0.25</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_func2</span>():</span><br><span class="line">    <span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">    sleep(<span class="number">0.25</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_func1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">test_func2 = Timer(Repeat(count=<span class="number">5</span>)(test_func2))</span><br><span class="line">test_func2()</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/null/image-20230729215357790.png"
style="zoom:50%;" /></p>
<h2 id="else-语句">else 语句</h2>
<p>这里的 else 语句并不是 <code>if ... else ...</code> 的 else，其为
<code>while ...</code>、<code>try ... except ...</code>
、<code>for ...</code> 语句的 else 语句</p>
<p>示例如下</p>
<p>对于 <code>while</code> 和 <code>for</code>
两个循环而言，<code>else</code> 语句将会在循环顺利执行完后调用（即不碰到
<code>break</code>，<code>return</code>就更不用说了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;for(without break) done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;for(with break) done&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    i-=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;while(without break) done&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    i-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;while(with break) done&#x27;</span>)    </span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img data-src="/posts/null/image-20230729221242531.png"
style="zoom:50%;" /></p>
<p>对于 <code>try ... except ...</code> 语句而言，else
语句会在没有任何异常时执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func_with_exception</span>():</span><br><span class="line">    a = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_without_exception</span>():</span><br><span class="line">    a = <span class="number">0</span> / <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    func_with_exception()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">import</span> traceback</span><br><span class="line">    traceback.print_exc()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;execute safely!&#x27;</span>)   </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    func_without_exception()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">import</span> traceback</span><br><span class="line">    traceback.print_exc()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;execute safely!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果（第一个抛出异常，第二没有异常顺利执行）</p>
<p><img data-src="/posts/null/image-20230729222813033.png"
style="zoom:50%;" /></p>
<h2 id="finally-作用"><code>finally</code> 作用</h2>
<p><strong>无论什么情况都会执行！</strong></p>
<blockquote>
<p>If a <a
href="https://docs.python.org/3/reference/compound_stmts.html#finally"><code>finally</code></a>
clause is present, the <code>finally</code> clause will execute as the
last task <strong>before</strong> the <a
href="https://docs.python.org/3/reference/compound_stmts.html#try"><code>try</code></a>
statement completes. The <code>finally</code> clause runs whether or not
the <code>try</code> statement produces an exception. The following
points discuss more complex cases when an exception occurs:</p>
<ul>
<li>If an exception occurs during execution of the <code>try</code>
clause, the exception may be handled by an <a
href="https://docs.python.org/3/reference/compound_stmts.html#except"><code>except</code></a>
clause. <strong>If the exception is not handled by an
<code>except</code> clause, the exception is re-raised after the
<code>finally</code> clause has been executed.</strong></li>
<li>An exception could occur during execution of an <code>except</code>
or <code>else</code> clause. <strong>Again, the exception is re-raised
after the <code>finally</code> clause has been executed.</strong></li>
<li>If the <code>finally</code> clause executes a <a
href="https://docs.python.org/3/reference/simple_stmts.html#break"><code>break</code></a>,
<a
href="https://docs.python.org/3/reference/simple_stmts.html#continue"><code>continue</code></a>
or <a
href="https://docs.python.org/3/reference/simple_stmts.html#return"><code>return</code></a>
statement, exceptions are not re-raised.</li>
<li>If the <code>try</code> statement reaches a <a
href="https://docs.python.org/3/reference/simple_stmts.html#break"><code>break</code></a>,
<a
href="https://docs.python.org/3/reference/simple_stmts.html#continue"><code>continue</code></a>
or <a
href="https://docs.python.org/3/reference/simple_stmts.html#return"><code>return</code></a>
statement, <strong>the <code>finally</code> clause will execute just
prior to the <code>break</code>, <code>continue</code> or
<code>return</code> statement’s execution.</strong></li>
<li>If a <code>finally</code> clause includes a <code>return</code>
statement, <strong>the returned value will be the one from the
<code>finally</code> clause’s <code>return</code> statement</strong>,
not the value from the <code>try</code> clause’s <code>return</code>
statement.</li>
</ul>
</blockquote>
<p>引入 <code>finally</code>
后函数的执行流比较复杂，不熟情况少用，容易整蛊感觉</p>
<h2 id="正则表达式">正则表达式</h2>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历二叉树的n种方式</title>
    <url>/posts/7a74/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="遍历二叉树的n种方式">遍历二叉树的n种方式</h1>
<h2 id="递归">递归</h2>
<h2 id="迭代">迭代</h2>
<h2 id="莫里斯遍历">🐮莫里斯遍历</h2>
<h2 id="序列化和反序列化">序列化和反序列化</h2>
]]></content>
      <categories>
        <category>算法模版</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
