<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人博客搭建记录</title>
    <url>/posts/96e0/</url>
    <content><![CDATA[<p>之前都是在知乎上写博客，这样看的人也多，方便讨论，但是知乎的 markdown
编辑器不是很好用，本地写完后还需要一张一张上传图片，太麻烦了，就自己搭一个博客，又不想进行域名备案啥的，服务器也要出钱
:( 。最后搜到 Github 有提供免费的静态页面部署功能，这样写完 markdown
笔记可以直接上传到
Github，还可以通过网页访问，nice！(白嫖的感觉真好)</p>
<h1 id="github-pages">Github Pages</h1>
<h2 id="创建主页仓库">创建主页仓库</h2>
<p>通过 <a href="https://pages.github.com/">Github Pages</a>，我们可以将
markdown
撰写的笔记转换成静态网页，并进行部署。其创建流程也十分简单，只需要创建一个名为
<code>&lt;username&gt;.github.io</code> 的仓库，如下图所示</p>
<p><img data-src="/posts/96e0/image-20230102151015131.png"
style="zoom:50%;" /></p>
<p>此处我们选择的是 Private
仓库，只有我们能进行修改，但是主页是公开访问的，这样可以保证笔记源文件安全
:) 。</p>
<span id="more"></span>

<p>创建完成后仓库中什么都没有</p>
<p><img data-src="/posts/96e0/image-20230102151942075.png"
style="zoom:33%;" /></p>
<p>此时我们在浏览器中输入 <a
href="https://purewhitevk.github.io"><span>https://purewhitevk.github.io</span></a>
（URL不区分大小写，直接用小写即可），显示404，页面不存在。</p>
<p><img data-src="/posts/96e0/image-20230102152125799.png"
style="zoom: 50%;" /></p>
<p>别心急，很快就可以看到博客页面了。</p>
<h2 id="静态博客框架">静态博客框架</h2>
<p>在网上搜了一下，有很多博客框架，例如 wordpress 等，但是 wordpress
需要数据库，还需要单独配服务器进行部署，太麻烦了，满足我们需求的有三个</p>
<ul>
<li><p>Jekyll（Github 原生支持）</p>
<p>使用 Ruby 实现</p></li>
<li><p>Hexo</p>
<p>使用 Node.js 实现</p></li>
<li><p>Hugo</p>
<p>使用 Go 实现</p></li>
</ul>
<p>三者在功能上大同小异，都可以直接将 <code>.md</code>
文件转换成<code>html</code> 文件，且支持部署在 Github Pages
上。个人比较推荐 <a
href="https://hexo.io/">Hexo</a>，其环境搭建起来比较方便，且插件较多，操作起来比较简单。</p>
<p><img data-src="/posts/96e0/image-20230102153212301.png"
style="zoom:50%;" /></p>
<h1 id="hexo环境配置">hexo环境配置</h1>
<h2 id="安装">安装</h2>
<ol type="1">
<li><p>全局安装 hexo-cli，这样我们可以直接调用 hexo 的命令行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>将我们的主页仓库 clone 到本地，此处我们将其放到文件夹
<code>Note</code> 下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/PureWhiteVK/PureWhiteVK.github.io.git Note</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载 <a
href="https://github.com/hexojs/hexo-starter">hexo-starter</a>
并解压到本地仓库中</p>
<p>点击右侧 <code>Code</code> 按钮，直接下载 ZIP
压缩包即可（其实我们也可以直接 fork 这个仓库，但是这样我们的仓库就不能是
private 了）</p>
<p><img data-src="/posts/96e0/image-20230102154426653.png"
style="zoom:50%;" /></p></li>
<li><p>使用 <code>npm install</code> 安装依赖</p></li>
<li><p>输入 <code>hexo server</code> 进行运行本地服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Note&gt; hexo server</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  hexois running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>在浏览器中打开
<code>localhost:4000</code>，就可以预览生成后的静态页面效果了</p>
<p><img data-src="/posts/96e0/image-20230102161237387.png"
style="zoom:50%;" /></p></li>
</ol>
<h2 id="主题">主题</h2>
<p>hexo 上有很多精美的主题，这里我们选择 <a
href="https://github.com/theme-next/hexo-theme-next">next</a>
作为博客主题，其比较稳定，功能也很全。</p>
<p>直接使用 npm 进行安装即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>安装之后，我们需要将主题配置文件
<code>node_modules/hexo-theme-next/_config.yml</code>
拷贝至根目录下，并重命名为 <code>_config.next.yml</code></p>
<p>最终修改根目录下的 <code>_config.yml</code>
即可，将其更换为我们需要的主题</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>最后清理之前生成的文件，并重建部署一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo server</span><br></pre></td></tr></table></figure>

<p>主题效果如下</p>
<p><img data-src="/posts/96e0/image-20230102163251257.png"
style="zoom:50%;" /></p>
<h2 id="插件">插件</h2>
<p>hexo 提供了很多插件来简化我们的操作，并提供一些其他的功能。由于 hexo
是基于 node.js 实现的，我们可以通过 npm 来安装和卸载 hexo 插件。</p>
<p>安装插件命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save &lt;plugin-name&gt;</span><br></pre></td></tr></table></figure>

<p>删除插件命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall --save &lt;plugin-name&gt;</span><br></pre></td></tr></table></figure>

<p>我们使用了以下几个插件（具体配置可以直接参考 hexo-next-theme
的插件使用文档：<a
href="https://theme-next.js.org/docs/third-party-services/">Third-party
Plugins | NexT</a> 即可）</p>
<ul>
<li>hexo-generator-searchdb：实现搜索功能，支持html文件检索</li>
<li>hexo-abbrlink：自动生成文章的永久链接</li>
<li>hexo-word-counter：统计文章字数</li>
</ul>
<h2 id="配置">配置</h2>
<p>hexo的配置文件位于根目录下的
<code>_config.yml</code>，下面列举了我们需要修改的一些关键配置项</p>
<h3 id="网站基本设置">网站基本设置</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">&quot;PureWhite&#x27;s Blog&quot;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">PureWhiteVK</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="url设置">URL设置</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://purewhitevk.github.io</span></span><br><span class="line"><span class="comment"># 这样我们笔记永久链接为 https://purewhitevk.github.io/posts/43fc/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span> </span><br><span class="line"><span class="comment"># 我们使用了 hexo-abbrlink 插件，其通过对名称以及时间戳使用 crc16 算法，生成四位的一个唯一编码</span></span><br><span class="line"><span class="comment"># 四位十六进制可以表示 65536 篇文章，这对于我们博客而言已经绰绰有余了</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc16</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="comment"># 末尾的index后缀</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 末尾的.html后缀</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="写作相关配置">写作相关配置</h3>
<p>这里我们主要调整生成 hexo 生成的 markdown 文件名称</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year/:month/:day/:title.md</span></span><br></pre></td></tr></table></figure>

<p>hexo 添加 post 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Note&gt; hexo new post <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: D:\Code\Note\<span class="built_in">source</span>\_posts\2023\01\02\Hello-World.md</span><br></pre></td></tr></table></figure>

<p>markdown 文件内容如下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2023-01-02 17:03:17</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>其会默认包含一些内容，其中用三横线包裹起来的是 Front
Matter，其用来标识 markdown
文档的一些属性，例如标题、创建日期、标签（tags）、类别（categories）、永久链接等，hexo
通过读取 Front Matter 来控制生成的 html 文件。</p>
<h3 id="next-主题配置">next 主题配置</h3>
<p>前面提到，我们从 <code>node_modules</code> 中将 next
的配置拷贝至了根目录，并重命名为
<code>_config.next.yml</code>，主题相关的配置直接在这个文件中进行修改即可，next
中提供了非常多的配置项，就不一一介绍了，详细可以直接参考Next主题文档：<a
href="https://theme-next.js.org/">NexT - Theme for Hexo</a></p>
<h2 id="图片">图片</h2>
<p>由于 markdown 和 html 在使用上的区别（markdown 本地，html
网络），我们在 markdown 中插入图片</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">image-description</span>](<span class="link">/local/path/to/image</span>)</span><br></pre></td></tr></table></figure>

<p>会被直接转换成 html 的 <code>img</code> 标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/local/path/to/image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image-description&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是一个是本地路径，一个是网络 URI，直接这么转换肯定会问题。</p>
<p>参考 hexo 的[资源管理文档](<a
href="https://hexo.io/docs/asset-folders">Asset Folders | Hexo</a>)，在
hexo 中，最简单的图片管理方式就是将图片文件放置在
<code>source/images</code> 文件夹下，这样在网页中我们可以直接通过
<code>/images/&lt;image-name&gt;</code> 进行访问。</p>
<blockquote>
<p>Assets are non-post files in the <code>source</code> folder, such as
images, CSS or JavaScript files. For instance, If you are only going to
have a few images in the hexoproject, then <strong>the easiest way is to
keep them in a <code>source/images</code> directory.</strong> Then, you
can access them using something like</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">/images/image.jpg</span>)</span><br></pre></td></tr></table></figure>

</blockquote>
<p>markdown 写法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">/images/image.jpg</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意images前面的 <code>/</code>
，必须包含这个斜杠，否则图片路径就变成了相对当前URL的路径，会导致图片访问出错。加上<code>/</code>
就表示是相对域名的URL，即
<code>https://purewhitevk.github.io/images/image.jpg</code>；而不加<code>/</code>时就是相对当前网址的URL，假设我们当前网址为
<code>https://purewhitevk.github.io/posts/abcd</code>
，那么对应的图片URL为
<code>https://purewhitevk.github.io/posts/abcd/images/image.jpg</code>，这样就会导致找不到图片。（通过相对路径读取图片文件也是一种可行的方式）</p>
</blockquote>
<p>对应生成的 html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/image.jpg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是这样我们在本地使用 typora 编写 markdown 时就会有问题，好在 typora
也给出了解决方案：<a
href="https://support.typora.io/Images/#relative-path-to-certain-folder">Images
in Typora - Typora Support</a>。只需要在 markdown 的 Front Matter
中添加两个属性，将 markdown
中所有的图片路径都修改成相对某个路径的绝对路径即可（也就是<code>/relative/to/some-image.png</code>的形式）。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置相对的路径，设置根目录为 source</span></span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../../../../</span></span><br><span class="line"><span class="comment"># 插入图片时自动拷贝图片到 source/images/ 下</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> <span class="string">../../../../images</span></span><br></pre></td></tr></table></figure>

<p>我们的文章都位于
<code>source/_posts/&lt;year&gt;/&lt;month&gt;/&lt;day&gt;</code>
路径下，图片存储路径为<code>source/images</code>下，通过设置<code>typora-root-url</code>，当我们在markdown中插入一张路径为
<code>/images/image.jpg</code> 时，其会自动将
<code>typora-root-url</code>和该路径进行拼接，最终结果就是
<code>../../../../images/image.jpg</code>，正确读取到图片。另外一个便捷的功能就是插入图片时自动拷贝到指定文件夹，这样我们可以丝滑的添加图片了，不需要手动上传并设置链接。</p>
<p>我们可以将这两个配置项添加到 markdown 模板中（hexo 中称为
scaffold，脚手架），就不用每次都手动添加，修改
<code>scaffolds/post.md</code> 如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">category:</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../../../../</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> <span class="string">../../../../images</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 此处 more 标签用于 next 主题显示摘要</span></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">more</span> <span class="string">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们通过 <code>hexo new post &lt;title&gt;</code>
时就会默认配置好 typora。</p>
<p>附：typora的图像存储相关设置</p>
<p><img data-src="/posts/96e0/image-20230105230235058.png"
style="zoom:50%;" /></p>
<p>由于我们使用 Front Matter 进行配置，在图像处就不需要任何配置了。</p>
<h2 id="公式">公式</h2>
<p>另外一个比较令人头疼的就是公式渲染问题，latex 公式在语法上和 markdown
存在一些冲突，如果使用默认的 <code>hexo-renderer-marked </code>
渲染引擎进行生成会导致最终渲染出来的 latex 公式是错误的，我们需要将
markdown 渲染引擎替换为 <code>hexo-renderer-pandoc</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先删除原来的渲染器</span></span><br><span class="line">npm uninstall --save hexo-renderer-marked</span><br><span class="line"><span class="comment"># 安装新的渲染器</span></span><br><span class="line">npm install --save hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>

<p>然后在 next 主题的配置文件 <code>_config.next.yml</code> 中开启
mathjax 的支持</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># &lt;--- 将此处 false 修改为 true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>写一个简单的公式测试一下效果</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\int</span> <span class="built_in">_</span>0 <span class="built_in">^</span><span class="keyword">\pi</span> <span class="keyword">\sin</span> x <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125; x = 2</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>对应渲染结果 <span class="math display">\[
\int _0 ^\pi \sin x \,\mathrm{d} x = 2
\]</span> 如果可以正确看到公式就说明公式配置成功。</p>
<h2 id="部署">部署</h2>
<p>在 hexo 官网中给出了 Github Pages 的部署方式：<a
href="https://hexo.io/docs/github-pages">GitHub Pages |
Hexo</a>，由于我们会将源代码也上传至 Github 仓库，我们使用 Github
Workflow 的方式来自动执行部署过程。</p>
<p>其部署过程很简单</p>
<ol type="1">
<li>提交代码 （push）</li>
<li>执行 workflow 中指定的操作，安装
node.js，执行相关命令生成静态页面</li>
<li>通过 Github Pages 展示静态页面</li>
</ol>
<p>由于我们将hexo的markdown渲染器修改为<code>hexo-renderer-pandoc</code>，其需要提前安装好
pandoc
并添加到环境变量，我们需要在官方提供的workflow中修改一下，在容器中安装好
pandoc，网上一搜发现也有大佬已经分享了 pandoc 的配置命令：<a
href="https://github.com/nikeee/setup-pandoc">nikeee/setup-pandoc</a>，直接拿过来用即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">nikeee/setup-pandoc@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">pandoc-version:</span> <span class="string">&#x27;2.7.3&#x27;</span> <span class="comment"># The pandoc version to download (if necessary) and use.</span></span><br></pre></td></tr></table></figure>

<p>最后根据本地使用的 node.js 和 pandoc
版本，将其修改成对应的版本即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Note&gt; node --version</span><br><span class="line">v18.12.1</span><br><span class="line">(base) PS D:\Code\Note&gt; pandoc --version</span><br><span class="line">pandoc.exe 2.19.2</span><br><span class="line">Compiled with pandoc-types 1.22.2.1, texmath 0.12.5.2, skylighting 0.13,</span><br><span class="line">citeproc 0.8.0.1, ipynb 0.2, hslua 2.2.1</span><br><span class="line">Scripting engine: Lua 5.4</span><br><span class="line">User data directory: C:\Users\xiao\AppData\Roaming\pandoc</span><br><span class="line">Copyright (C) 2006-2022 John MacFarlane. Web:  https://pandoc.org</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions. There is no</span><br><span class="line">warranty, not even <span class="keyword">for</span> merchantability or fitness <span class="keyword">for</span> a particular purpose.</span><br></pre></td></tr></table></figure>

<p>完整的 workflow 配置代码如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span>  <span class="comment"># default branch</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="string">recursive</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Pandoc</span> <span class="number">2.19</span><span class="number">.2</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">nikeee/setup-pandoc@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">pandoc-version:</span> <span class="string">&quot;2.19.2&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">18.12</span><span class="number">.1</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18.12.1&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure>

<p>由于我们仓库实际上还没有初始化，需要使用 git
初始化一下仓库再进行提交，初始化命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/PureWhiteVK/PureWhiteVK.github.io.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p>提交之后代码后，我们可以在 Actions 面板中看到正在执行的 Workflows</p>
<p><img data-src="/posts/96e0/image-20230102185759306.png"
style="zoom:50%;" /></p>
<p>第一次 pages build and deployment 一定会执行失败，因为我们还没设置
Github Page 部署时使用的分支，hexo 的 workflow
在执行后会单独创建一个分支（gh-pages）来存放静态网页，我们在设置中切换一下即可。</p>
<p><img data-src="/posts/96e0/image-20230102190220044.png"
style="zoom:50%;" /></p>
<p>调整完成后，可以看到提示我们网站已经上线了（Your site is live at <a
href="https://purewhitevk.github.io"><span>https://purewhitevk.github.io</span></a>），进入
<a
href="https://purewhitevk.github.io"><span>https://purewhitevk.github.io</span></a>
就可以访问到部署好的博客页面了。（github.io访问速度可能较慢，最好挂梯子）</p>
<p><img data-src="/posts/96e0/image-20230102190311710.png"
style="zoom: 25%;" /></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex公式学习笔记</title>
    <url>/posts/caff/</url>
    <content><![CDATA[<p>之前我们已经配置好了 hexo 对 LaTex 公式的支持（在 markdown 的 Front
Matter 中添加 <code>mathjax: true</code> 开启 LaTex
公式渲染支持），支持两种形式的公式输入</p>
<ul>
<li><p>内联公式（inline），通过 <code>$...$</code>
进行包裹（必须在同一行）</p>
<p>例：markdown 代码 <code>$\phi = 30$</code> 对应内联公式渲染结果 <span
class="math inline">\(\phi = 30\)</span></p>
<p>在 <code>$</code>
和公式之间不能存在空格，也就是说，对于<code>$ \phi = 30 $</code>
并不能得到正确的渲染结果</p></li>
<li><p>块公式（block），通过 <code>$$...$$</code>
进行包裹（两个<code>$$</code>必须在不同行）</p>
<p>例：markdown 代码</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\int</span> <span class="built_in">_</span>0 <span class="built_in">^</span><span class="keyword">\pi</span> <span class="keyword">\sin</span>(x) = 2</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>对应块渲染结果 <span class="math display">\[
\int _0 ^ \pi \sin x = 2
\]</span></p></li>
</ul>
<p>现在我们可以在 markdown
文档中添加并渲染公式了，那么下一步就是如何正确书写公式，以及一些常用公式符号。</p>
<span id="more"></span>

<h1 id="常用符号">常用符号</h1>
<p>可以使用在线的<a
href="https://www.latexlive.com/">LaTex公式编辑器</a>来手动选取，下面列举了一些常用的符号</p>
<h2 id="关系和运算符号">关系和运算符号</h2>
<p><span class="math display">\[
\begin{align}
&amp; &lt; &amp; &amp; \mathtt{&lt;} &amp;
&amp; \leq &amp; &amp; \mathtt{\backslash leq} &amp;
&amp; \ll &amp; &amp; \mathtt{\backslash ll} &amp;
\\
&amp; &gt; &amp; &amp; \mathtt{&gt;} &amp;
&amp; \geq &amp; &amp; \mathtt{\backslash geq} &amp;
&amp; \gg &amp; &amp; \mathtt{\backslash gg} &amp;
\\
\\
&amp; \in &amp; &amp; \mathtt{\backslash in} &amp;
&amp; \subset &amp; &amp; \mathtt{\backslash subset} &amp;
&amp; \subseteq &amp; &amp; \mathtt{\backslash subseteq} &amp;
\\
&amp; \ni &amp; &amp; \mathtt{\backslash ni} &amp;
&amp; \supset &amp; &amp; \mathtt{\backslash supset} &amp;
&amp; \supseteq &amp; &amp; \mathtt{\backslash supseteq} &amp;
\\
&amp; \notin &amp; &amp; \mathtt{\backslash notin} &amp;
\\
\\
&amp; = &amp; &amp; \mathtt{=} &amp;
&amp; \neq &amp; &amp; \mathtt{\backslash neq} &amp;
&amp; \equiv &amp; &amp; \mathtt{\backslash equiv} &amp;
\\
&amp; \approx &amp; &amp; \mathtt{\backslash approx} &amp;
&amp; \propto &amp; &amp; \mathtt{\backslash propto} &amp;
\\
\\
&amp; \parallel &amp; &amp; \mathtt{\backslash parallel} &amp;
&amp; \nparallel &amp; &amp; \mathtt{\backslash nparallel} &amp;
&amp; \sim &amp; &amp; \mathtt{\backslash sim} &amp;
\\
&amp; \perp &amp; &amp; \mathtt{\backslash perp} &amp;
\\
\\
&amp; + &amp; &amp; \text{+} &amp;
&amp; - &amp; &amp; \text{-} &amp;
&amp; \star &amp; &amp; \mathtt{\backslash star} &amp;
\\
&amp; \times &amp; &amp; \mathtt{\backslash times} &amp;
&amp; \div &amp; &amp; \mathtt{\backslash div} &amp;
&amp; \cdot &amp; &amp; \mathtt{\backslash cdot} &amp;
\\
&amp; \cup &amp; &amp; \mathtt{\backslash cup} &amp;
&amp; \cap &amp; &amp; \mathtt{\backslash cap} &amp;
&amp; \ast &amp; &amp; \mathtt{\backslash ast} &amp;
\\
&amp; \vee &amp; &amp; \mathtt{\backslash vee} &amp;
&amp; \wedge &amp; &amp; \mathtt{\backslash wedge} &amp;
&amp; \oplus &amp; &amp; \mathtt{\backslash oplus} &amp;
\\
&amp; \otimes &amp; &amp; \mathtt{\backslash otimes} &amp;
&amp; \ominus &amp; &amp; \mathtt{\backslash ominus} &amp;
&amp; \odot &amp; &amp; \mathtt{\backslash odot} &amp;
\end{align}
\]</span></p>
<h2 id="箭头符号">箭头符号</h2>
<p><span class="math display">\[
\begin{align}
&amp; \leftarrow &amp; &amp; \mathtt{\backslash leftarrow} &amp;
&amp; \rightarrow &amp; &amp; \mathtt{\backslash rightarrow} &amp;
\\
&amp; \uparrow &amp; &amp; \mathtt{\backslash uparrow} &amp;
&amp; \downarrow &amp; &amp; \mathtt{\backslash downarrow} &amp;
\\
&amp; \updownarrow &amp; &amp; \mathtt{\backslash updownarrow} &amp;
&amp; \leftrightarrow &amp; &amp; \mathtt{\backslash leftrightarrow}
&amp;
\\
\\
&amp; \nwarrow &amp; &amp; \mathtt{\backslash nwarrow} &amp;
&amp; \nearrow &amp; &amp; \mathtt{\backslash nearrow} &amp;
\\
&amp; \swarrow &amp; &amp; \mathtt{\backslash swarrow} &amp;
&amp; \searrow &amp; &amp; \mathtt{\backslash searrow} &amp;
\\
\\
&amp; \mapsto &amp; &amp; \mathtt{\backslash mapsto} &amp;
&amp; \rightleftharpoons &amp; &amp; \mathtt{\backslash
rightleftharpoons} &amp;
\\
&amp; \leftharpoonup &amp; &amp; \mathtt{\backslash leftharpoonup} &amp;
&amp; \rightharpoonup &amp; &amp; \mathtt{\backslash rightharpoonup}
&amp;
\\
&amp; \leftharpoondown &amp; &amp; \mathtt{\backslash leftharpoondown}
&amp;
&amp; \rightharpoondown &amp; &amp; \mathtt{\backslash rightharpoondown}
&amp;
\\
\\
&amp; \longleftarrow &amp; &amp; \mathtt{\backslash longleftarrow} &amp;
&amp; \longrightarrow &amp; &amp; \mathtt{\backslash longrightarrow}
&amp;
\\
&amp; \longleftrightarrow &amp; &amp; \mathtt{\backslash
longleftrightarrow} &amp;
&amp; \longmapsto &amp; &amp; \mathtt{\backslash longmapsto} &amp;
\\
\\
&amp; \Leftarrow &amp; &amp; \mathtt{\backslash Leftarrow} &amp;
&amp; \Rightarrow &amp; &amp; \mathtt{\backslash Rightarrow} &amp;
\\
&amp; \Uparrow &amp; &amp; \mathtt{\backslash Uparrow} &amp;
&amp; \Downarrow &amp; &amp; \mathtt{\backslash Downarrow} &amp;
\\
&amp; \Updownarrow &amp; &amp; \mathtt{\backslash Updownarrow} &amp;
&amp; \Leftrightarrow &amp; &amp; \mathtt{\backslash Leftrightarrow}
&amp;
\\
&amp; \Longleftarrow &amp; &amp; \mathtt{\backslash Longleftarrow} &amp;
&amp; \Longrightarrow &amp; &amp; \mathtt{\backslash Longrightarrow}
&amp;
\\
&amp; \Longleftrightarrow &amp; &amp; \mathtt{\backslash
Longleftrightarrow} &amp;
\end{align}
\]</span></p>
<p>注：当我们需要表示当且仅当关系是常用 <code>\Longleftrightarrow</code>
，为了简写，也可以使用 <code>\iff</code> （if and only if, 当且仅当)
来简化</p>
<h2 id="希腊字母">希腊字母</h2>
<p><span class="math display">\[
\begin{align}
&amp;\alpha &amp; &amp; \mathtt{\backslash alpha}&amp;  
&amp;\beta &amp; &amp; \mathtt{\backslash beta}&amp;
&amp;\gamma &amp; &amp; \mathtt{\backslash gamma}&amp;
\\
&amp;\delta &amp; &amp; \mathtt{\backslash delta}&amp;
&amp;\epsilon &amp; &amp; \mathtt{\backslash epsilon}&amp;
&amp;\zeta &amp; &amp; \mathtt{\backslash zeta}&amp;
\\
&amp;\eta &amp; &amp; \mathtt{\backslash eta}&amp;
&amp;\theta &amp; &amp; \mathtt{\backslash theta}&amp;
&amp;\iota &amp; &amp; \mathtt{\backslash iota}&amp;
\\
&amp;\kappa &amp; &amp; \mathtt{\backslash kappa}&amp;
&amp;\lambda &amp; &amp; \mathtt{\backslash lambda}&amp;
&amp;\mu &amp; &amp; \mathtt{\backslash mu}&amp;
\\
&amp;\nu &amp; &amp; \mathtt{\backslash nu}&amp;
&amp;\xi &amp; &amp; \mathtt{\backslash xi}&amp;
&amp;\omicron &amp; &amp; \mathtt{\backslash omicron}&amp;
\\
&amp;\pi &amp; &amp; \mathtt{\backslash pi}&amp;
&amp;\rho &amp; &amp; \mathtt{\backslash rho}&amp;
&amp;\sigma &amp; &amp; \mathtt{\backslash sigma}&amp;
\\
&amp;\tau &amp; &amp; \mathtt{\backslash tau}&amp;
&amp;\upsilon &amp; &amp; \mathtt{\backslash upsilon}&amp;
&amp;\phi &amp; &amp; \mathtt{\backslash phi}&amp;
\\
&amp;\chi &amp; &amp; \mathtt{\backslash chi}&amp;
&amp;\psi &amp; &amp; \mathtt{\backslash psi}&amp;
&amp;\omega &amp; &amp; \mathtt{\backslash omega}&amp;
\\
\\
&amp; \varepsilon &amp; &amp; \mathtt{\backslash varepsilon} &amp;
&amp; \vartheta &amp; &amp; \mathtt{\backslash vartheta} &amp;
&amp; \varpi &amp; &amp; \mathtt{\backslash varpi} &amp;
\\
&amp; \varrho &amp; &amp; \mathtt{\backslash varrho} &amp;
&amp; \varsigma &amp; &amp; \mathtt{\backslash varsigma} &amp;
&amp; \varphi &amp; &amp; \mathtt{\backslash varphi} &amp;
\\
&amp; \varkappa &amp; &amp; \mathtt{\backslash varkappa} &amp;
\\
\\
&amp;\Gamma &amp; &amp; \mathtt{\backslash Gamma}&amp;  
&amp; \Lambda &amp; &amp; \mathtt{\backslash Lambda} &amp;
&amp;\Sigma &amp; &amp; \mathtt{\backslash Sigma}&amp;  
\\
&amp; \Psi &amp; &amp; \mathtt{\backslash Psi} &amp;
&amp;\Delta &amp; &amp; \mathtt{\backslash Delta}&amp;  
&amp; \Xi &amp; &amp; \mathtt{\backslash Xi} &amp;
\\
&amp;\Upsilon &amp; &amp; \mathtt{\backslash Upsilon}&amp;  
&amp; \Omega &amp; &amp; \mathtt{\backslash Omega} &amp;
&amp;\Theta &amp; &amp; \mathtt{\backslash Theta}&amp;  
\\
&amp; \Pi &amp; &amp; \mathtt{\backslash Pi} &amp;
&amp;\Phi &amp; &amp; \mathtt{\backslash Phi}&amp;  
\end{align}
\]</span></p>
<h2 id="三角函数">三角函数</h2>
<p><span class="math display">\[
\begin{align}
&amp;\sin&amp; &amp;\mathtt{\backslash sin}&amp;
&amp;\cos&amp; &amp;\mathtt{\backslash cos}&amp;
\\
&amp;\tan&amp; &amp;\mathtt{\backslash tan}&amp;
&amp;\cot&amp; &amp;\mathtt{\backslash cot}&amp;
\\
&amp;\sec&amp; &amp;\mathtt{\backslash sec}&amp;
&amp;\csc&amp; &amp;\mathtt{\backslash csc}&amp;
\\
\\
&amp;\arcsin&amp; &amp;\mathtt{\backslash arcsin}&amp;
&amp;\arccos&amp; &amp;\mathtt{\backslash arccos}&amp;
\\
&amp;\arctan&amp; &amp;\mathtt{\backslash arctan}&amp;
\\
\\
&amp;\sinh&amp; &amp;\mathtt{\backslash sinh}&amp;
&amp;\cosh&amp; &amp;\mathtt{\backslash cosh}&amp;
\\
&amp;\tanh&amp; &amp;\mathtt{\backslash tanh}&amp;
&amp;\coth&amp; &amp;\mathtt{\backslash coth}&amp;
\\
\end{align}
\]</span></p>
<h2 id="其他符号">其他符号</h2>
<p><span class="math display">\[
\begin{align}
&amp; \infty &amp; &amp; \mathtt{\backslash infty} &amp;
&amp; \Re &amp; &amp; \mathtt{\backslash Re} &amp;
\\
&amp; \forall &amp; &amp; \mathtt{\backslash forall} &amp;
&amp; \exists &amp; &amp; \mathtt{\backslash exists} &amp;
\\
&amp; \nexists &amp; &amp; \mathtt{\backslash nexists} &amp;
&amp; \emptyset &amp; &amp; \mathtt{\backslash emptyset} &amp;
\\
&amp; \varnothing &amp; &amp; \mathtt{\backslash varnothing} &amp;
&amp; \top &amp; &amp; \mathtt{\backslash top} &amp;
\\
&amp; \partial &amp; &amp; \mathtt{\backslash partial} &amp;
&amp; \nabla &amp; &amp; \mathtt{\backslash nabla} &amp;
\end{align}
\]</span></p>
<h2 id="标识符号">标识符号</h2>
<p>有时我们可能需要在字母上添加上标（例如平均数 <span
class="math inline">\(\bar{x}\)</span>，估计值 <span
class="math inline">\(\hat{x}\)</span> 等），下标（下划线 <span
class="math inline">\(\underline{x}\)</span> ）等</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Result</th>
<th>Code</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a'</code> or <code>a^&#123;\prime&#125;</code></td>
<td><span class="math inline">\(a&#39;\)</span></td>
<td><code>a''</code></td>
<td><span class="math inline">\(a&#39;&#39;\)</span></td>
</tr>
<tr class="even">
<td><code>\hat&#123;a&#125;</code></td>
<td><span class="math inline">\(\hat{a}\)</span></td>
<td><code>\bar&#123;a&#125;</code></td>
<td><span class="math inline">\(\bar{a}\)</span></td>
</tr>
<tr class="odd">
<td><code>\acute&#123;a&#125;</code></td>
<td><span class="math inline">\(\acute{a}\)</span></td>
<td><code>\check&#123;a&#125;</code></td>
<td><span class="math inline">\(\check{a}\)</span></td>
</tr>
<tr class="even">
<td><code>\grave&#123;a&#125;</code></td>
<td><span class="math inline">\(\grave{a}\)</span></td>
<td><code>\dot&#123;a&#125;</code></td>
<td><span class="math inline">\(\dot{a}\)</span></td>
</tr>
<tr class="odd">
<td><code>\mathring&#123;a&#125;</code></td>
<td><span class="math inline">\(\mathring{a}\)</span></td>
<td><code>\breve&#123;a&#125;</code></td>
<td><span class="math inline">\(\breve{a}\)</span></td>
</tr>
<tr class="even">
<td><code>\tilde&#123;a&#125;</code></td>
<td><span class="math inline">\(\tilde{a}\)</span></td>
<td><code>\vec&#123;a&#125;</code></td>
<td><span class="math inline">\(\vec{a}\)</span></td>
</tr>
<tr class="odd">
<td><code>\underline&#123;a&#125;</code></td>
<td><span class="math inline">\(\underline{a}\)</span></td>
<td><code>\overline&#123;a&#125;</code></td>
<td><span class="math inline">\(\overline{a}\)</span></td>
</tr>
<tr class="even">
<td><code>\overrightarrow&#123;AB&#125;</code></td>
<td><span class="math inline">\(\overrightarrow{AB}\)</span></td>
<td><code>\overleftarrow&#123;AB&#125;</code></td>
<td><span class="math inline">\(\overleftarrow{AB}\)</span></td>
</tr>
<tr class="odd">
<td><code>\widehat&#123;AB&#125;</code></td>
<td><span class="math inline">\(\widehat{AB}\)</span></td>
<td><code>\widetilde&#123;AB&#125;</code></td>
<td><span class="math inline">\(\widetilde{AB}\)</span></td>
</tr>
</tbody>
</table>
<h2 id="括号">括号</h2>
<p>常见的括号 <code>()</code>、中括号 <code>[]</code>、以及大括号
<code>&#123;&#125;</code> 都可以直接在键盘中输入，由于大括号在 LaTex
中的特殊含义（用来包裹一段公式），我们使用时需要添加 <code>\</code>
进行转义，即 <code>\&#123;</code> 和 <code>\&#125;</code></p>
<p>对于竖线 <code>|</code> ，我们可以直接从键盘中输入，也可以使用
<code>\mid</code> 来表示，双竖线（范数的表示）可以使用 <code>\|</code>
来表示（不能使用两个竖线，因为双竖线应该表示为一个字符），示例如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\|</span>x<span class="keyword">\|</span><span class="built_in">_</span>2</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\|x\|_2
\]</span></p>
<p>其他分隔符表示如下 <span class="math display">\[
\begin{align}
&amp; / &amp; &amp; \mathtt{/} &amp;
&amp; \backslash &amp; &amp; \mathtt{\backslash backslash} &amp;
\\
&amp; \langle &amp; &amp; \mathtt{\backslash langle} &amp;
&amp; \rangle &amp; &amp; \mathtt{\backslash rangle} &amp;
\\
&amp; \lceil &amp; &amp; \mathtt{\backslash lceil} &amp;
&amp; \rceil &amp; &amp; \mathtt{\backslash rceil} &amp;
\\
&amp; \lfloor &amp; &amp; \mathtt{\backslash lfloor} &amp;
&amp; \rfloor &amp; &amp; \mathtt{\backslash rfloor} &amp;
\end{align}
\]</span></p>
<p>当我们使用这些括号包裹一个大的公式时，如下所示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2&#125;&#123;y<span class="built_in">^</span>3&#125;)</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
(\frac{x^2}{y^3})
\]</span></p>
<p>我们可以发现这个括号（parentheses）不能完全的包裹住公式，此时我们需要使用
<code>\left(...\right)</code> 来自动调整括号的大小</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>(<span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2&#125;&#123;y<span class="built_in">^</span>3&#125;<span class="keyword">\right</span>)</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left(\frac{x^2}{y^3}\right)
\]</span></p>
<p>除此之外，在中间表示时还可以使用 <code>\middle</code>
来进行控制（条件概率时）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">P<span class="keyword">\left</span>(A=2<span class="keyword">\middle</span>|<span class="keyword">\frac</span>&#123;A<span class="built_in">^</span>2&#125;&#123;B&#125;&gt;4<span class="keyword">\right</span>)</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
P\left(A=2\middle| \frac{A^2}{B}&gt;4\right)
\]</span></p>
<p>而对于花括号（curly
braces）和方括号（brackets）时，需要使用转义符进行转义
<code>\&#123;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span><span class="keyword">\&#123;</span><span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2&#125;&#123;y<span class="built_in">^</span>3&#125;<span class="keyword">\right</span><span class="keyword">\&#125;</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left\{\frac{x^2}{y^3}\right\}
\]</span></p>
<p>我们还可以使用 <code>.</code> 来忽略左侧或右侧符号</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>. <span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>3&#125;&#123;3&#125; <span class="keyword">\right</span>| <span class="built_in">_</span>0 <span class="built_in">^</span>1</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left.\frac{x^3}{3}\right|_0^1
\]</span></p>
<p>最终，如果我们还是不满意，可以手动调整符号的大小</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">( <span class="keyword">\big</span>( <span class="keyword">\Big</span>( <span class="keyword">\bigg</span>( <span class="keyword">\Bigg</span>(</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
( \big( \Big( \bigg( \Bigg(
\]</span></p>
<h2 id="空格">空格</h2>
<p>如果我们直接在公式中输入空格，如果直接在字母中间插入空格，会被直接忽略掉，如果我们明确需要插入空格，需要通过指令形式显式给出，在
LaTex 中空格相关的指令总结如下</p>
<table>
<thead>
<tr class="header">
<th>指令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>（space）</td>
<td>默认空格</td>
<td><span class="math inline">\(abc \rightarrow \leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>\,</code></td>
<td>短空格(3/18 em)</td>
<td><span class="math inline">\(abc \rightarrow\,\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>\!</code></td>
<td>短负空格(-3/18 em)</td>
<td><span class="math inline">\(abc \rightarrow \! \leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>!:</code></td>
<td>中空格(4/18 em)</td>
<td><span class="math inline">\(abc \rightarrow\:\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>!;</code></td>
<td>大空格(5/18 em)</td>
<td><span class="math inline">\(abc \rightarrow\;\leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>\enspace</code></td>
<td>0.5字宽空格 (0.5 em)</td>
<td><span class="math inline">\(abc \rightarrow\enspace\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>\quad</code></td>
<td>1字宽空格(1 em)</td>
<td><span class="math inline">\(abc \rightarrow\quad\leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>\qquad</code></td>
<td>2字宽空格(2 em)</td>
<td><span class="math inline">\(abc \rightarrow\qquad\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>\hspace&#123;3em&#125;</code></td>
<td>自定义宽度空格</td>
<td><span class="math inline">\(abc \rightarrow\hspace{3em}\leftarrow
abc\)</span></td>
</tr>
</tbody>
</table>
<p>注：em 是一种长度单位，和 px 意义，但是其是相对字宽来度量的，1 em
就表示一个字宽</p>
<p>空格在积分公式的书写上十分有用，如果我们直接写的话，如下所示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\int</span> y <span class="keyword">\mathrm</span>&#123;d&#125; x</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\int y \mathrm{d} x
\]</span></p>
<p>我们可以看到被积函数 <span class="math inline">\(y\)</span> 和微元
<span class="math inline">\(\mathrm{d}x\)</span>
之间距离太短，看起来不是很自然，此时我们就可以在二者之间插入一个小的空白，如下所示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\int</span> y <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125; x</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\int y \,\mathrm{d} x
\]</span></p>
<p>这样看起来就十分自然了。</p>
<p>另外一个示例就是分段函数的表示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">f(n) = </span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">n / 2 <span class="built_in">&amp;</span> <span class="keyword">\quad</span> <span class="keyword">\text</span>&#123;if &#125; n <span class="keyword">\text</span>&#123; is even&#125; <span class="keyword">\\</span></span><br><span class="line">-(n+1)/2 <span class="built_in">&amp;</span> <span class="keyword">\quad</span> <span class="keyword">\text</span>&#123;if &#125; n <span class="keyword">\text</span>&#123; is odd&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
f(n) =
\begin{cases}
n / 2 &amp; \quad \text{if } n \text{ is even} \\
-(n+1)/2 &amp; \quad \text{if } n \text{ is odd}
\end{cases}
\]</span></p>
<h1 id="字体">字体</h1>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Command</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Upright Roman Font</td>
<td><code>\mathrm&#123;&#125;</code></td>
<td><span class="math inline">\(\mathrm{x}\)</span></td>
</tr>
<tr class="even">
<td>Normal Italic Font</td>
<td><code>\mathnormal&#123;&#125;</code></td>
<td><span class="math inline">\(\mathnormal{x}\)</span></td>
</tr>
<tr class="odd">
<td>Calligraphic Font</td>
<td><code>\mathcal&#123;&#125;</code></td>
<td><span class="math inline">\(\mathcal{X}\)</span></td>
</tr>
<tr class="even">
<td>Upright Roman Boldface</td>
<td><code>\mathbf&#123;&#125;</code></td>
<td><span class="math inline">\(\mathbf{x}\)</span></td>
</tr>
<tr class="odd">
<td>Upright Sans Serif</td>
<td><code>\mathsf&#123;&#125;</code></td>
<td><span class="math inline">\(\mathsf{x}\)</span></td>
</tr>
<tr class="even">
<td>Italic Font</td>
<td><code>\mathit&#123;&#125;</code></td>
<td><span class="math inline">\(\mathit{x}\)</span></td>
</tr>
<tr class="odd">
<td>Typewritter Font</td>
<td><code>\mathtt&#123;&#125;</code></td>
<td><span class="math inline">\(\mathtt{x}\)</span></td>
</tr>
<tr class="even">
<td>Blackboard Bold Font</td>
<td><code>\mathbb&#123;&#125;</code></td>
<td><span class="math inline">\(\mathbb{X}\)</span></td>
</tr>
<tr class="odd">
<td>Eular Calligraphic Font</td>
<td><code>\mathscr&#123;&#125;</code></td>
<td><span class="math inline">\(\mathscr{X}\)</span></td>
</tr>
<tr class="even">
<td>Fraktur(Gothic) Font</td>
<td><code>\mathfrak&#123;&#125;</code></td>
<td><span class="math inline">\(\mathfrak{X}\)</span></td>
</tr>
</tbody>
</table>
<p>注：</p>
<ol type="1">
<li>Calligraphic 表示书法体（花体），Euler Calligraphic
为欧拉手稿字体</li>
<li>Sans Serif 表示非衬线字体（不包含其他多余的笔画）</li>
<li>Boldface 表示粗体</li>
<li>Typewriter Font 是等宽字体</li>
<li>如果不加任何标注，默认的字体就是 Normal Italic Font，也就是 Roman
字体的斜体形式，如 <span class="math inline">\(hello\)</span></li>
</ol>
<h1 id="常用公式写法">常用公式写法</h1>
<h2 id="三角函数-1">三角函数</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\cos</span> (2<span class="keyword">\theta</span>) = <span class="keyword">\cos</span><span class="built_in">^</span>2 <span class="keyword">\theta</span> - <span class="keyword">\sin</span><span class="built_in">^</span>2 <span class="keyword">\theta</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\cos (2\theta) = \cos^2 \theta - \sin^2 \theta
\]</span></p>
<h2 id="极限">极限</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\lim</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;x <span class="keyword">\to</span> <span class="keyword">\infty</span>&#125; <span class="keyword">\exp</span>(-x) = 0</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\lim\limits_{x \to \infty} \exp(-x) = 0
\]</span></p>
<p><code>\limits</code> 指令将后续紧跟的上标 <code>^</code> 和下标
<code>_</code>
放置在当前符号的上方（不写的其实也可以正常渲染，但是加上比较符合我们的观察）</p>
<h2 id="取模">取模</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">&amp;</span> a <span class="keyword">\bmod</span> b <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> x <span class="keyword">\equiv</span> a <span class="keyword">\pmod</span>&#123;b&#125; </span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
&amp; a \bmod b \\
&amp; x \equiv a \pmod{b}
\end{align}
\]</span></p>
<h2 id="上下标">上下标</h2>
<p>通过 <code>_</code> 表示下标，<code>^</code>
表示上标，如果需要将一块一整体进行上标，需要使用 <code>&#123;&#125;</code>
进行包裹</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">n<span class="built_in">^</span>&#123;22&#125; <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line">k<span class="built_in">_</span>&#123;n+1&#125; <span class="built_in">&amp;</span> = n<span class="built_in">^</span>2 + k<span class="built_in">_</span>n<span class="built_in">^</span>2 - k<span class="built_in">_</span>&#123;n-1&#125; <span class="keyword">\\</span></span><br><span class="line">f(n) <span class="built_in">&amp;</span> = <span class="keyword">\left</span>. n<span class="built_in">^</span>5 + 4n<span class="built_in">^</span>2 + 2 <span class="keyword">\right</span>|<span class="built_in">_</span>&#123;n=17&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
n^{22} &amp; \\
k_{n+1} &amp; = n^2 + k_n^2 - k_{n-1} \\
f(n) &amp; = \left. n^5 + 4n^2 + 2 \right|_{n=17}
\end{align}
\]</span></p>
<h2 id="分数和二项式系数">分数和二项式系数</h2>
<p>使用 <code>\frac&#123;numerator&#125;&#123;denominator&#125;</code>
来表示分数（numerator表示分子，denominator表示分母）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;n!&#125;&#123;k!(n-k)!&#125; = <span class="keyword">\binom</span>&#123;n&#125;&#123;k&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\frac{n!}{k!(n-k)!} = \binom{n}{k}
\]</span></p>
<p>分数也可以进行嵌套</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\frac</span>&#123;1&#125;&#123;x&#125;+<span class="keyword">\frac</span>&#123;1&#125;&#123;y&#125;&#125;&#123;y-z&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\frac{\frac{1}{x}+\frac{1}{y}}{y-z}
\]</span></p>
<p>为了在一行表示分数，我们也可以将分数表示为斜线形式</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">^</span>3/<span class="built_in">_</span>7 <span class="keyword">\quad</span> 3 / 7</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
^3/_7 \quad 3 / 7
\]</span> 使用 <code>\frac&#123;...&#125;&#123;...&#125;</code>
我们也可以表示其他内容，例如乘法和加法公式</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;array&#125;[b]&#123;r&#125;</span><br><span class="line">		<span class="keyword">\left</span>( x<span class="built_in">_</span>1 x<span class="built_in">_</span>2 <span class="keyword">\right</span>) <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\times</span> <span class="keyword">\left</span>( x&#x27;<span class="built_in">_</span>1 x&#x27;<span class="built_in">_</span>2 <span class="keyword">\right</span>)</span><br><span class="line">	<span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line">&#125;&#123;</span><br><span class="line">	<span class="keyword">\left</span>( y<span class="built_in">_</span>1 y<span class="built_in">_</span>2 y<span class="built_in">_</span>3 y<span class="built_in">_</span>4 <span class="keyword">\right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\frac{
\begin{array}[b]{r}
\left( x_1 x_2 \right)\\
\times \left(x&#39;_1 x&#39;_2\right)
\end{array}
}{
\left( y_1y_2y_3y_4 \right)
}
\]</span></p>
<p>其中对齐公式使用的 <code>\align</code> 以及
<code>\begin&#123;&#125;...\end&#123;&#125;</code> 会单独进行详细地介绍。</p>
<h2 id="根式">根式</h2>
<p>使用 <code>\sqrt&#123;...&#125;</code>
来表示根号，默认为2，也可以指定为其他幂次，通过<code>\sqrt[n]&#123;&#125;</code>
来指定</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span>[n]&#123;1 + x + x<span class="built_in">^</span>2 + x<span class="built_in">^</span>3 +<span class="keyword">\cdots</span> + x<span class="built_in">^</span>n&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\sqrt[n]{1+x+x^2+x^3+\cdots+x^n}
\]</span></p>
<h2 id="求和乘积与积分">求和、乘积与积分</h2>
<p>通过 <code>\sum _&#123;&#125; ^&#123;&#125; &#123;&#125;</code> 来表示大型加法表达式，如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\sum</span> <span class="built_in">_</span>&#123;i=1&#125; <span class="built_in">^</span>&#123;<span class="keyword">\infty</span>&#125; x<span class="built_in">^</span>i</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\sum _{i=1} ^{\infty} x^i
\]</span></p>
<p>对于连乘也是类似 <code>\prod _&#123;&#125; ^&#123;&#125; &#123;&#125;</code>
来表示大型乘法表达式，如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\prod</span> <span class="built_in">_</span>&#123;i=1&#125; <span class="built_in">^</span>&#123;n&#125; x<span class="built_in">^</span>i</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\prod _{i=1} ^{n} x^i
\]</span></p>
<p>积分（integral），通过 <code>\int _&#123;&#125; ^&#123;&#125; &#123;&#125;</code>
来表示积分符号</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\int</span> <span class="built_in">_</span>&#123;0&#125; <span class="built_in">^</span>&#123;<span class="keyword">\pi</span>&#125; <span class="keyword">\sin</span> x <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;x</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\int _{0} ^{\pi} \sin x \,\mathrm{d}x
\]</span></p>
<p>除了一重积分外，我们还有各种各样的积分符号，如二重积分、三重积分、曲面积分等等，其使用的积分符号也有相应的变化</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\iint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(u,v) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;v</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\iiint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(u,v,w) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;v<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;w</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\iiiint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(t,u,v,w) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;t<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;v<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;w</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\idotsint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(u<span class="built_in">_</span>1,<span class="keyword">\dots</span>,u<span class="built_in">_</span>k) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="built_in">_</span>1 <span class="keyword">\dots</span> <span class="keyword">\mathrm</span>&#123;d&#125;u<span class="built_in">_</span>k</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
&amp; \iint \limits _V \mu(u,v) \,\mathrm{d}u\,\mathrm{d}v
\\
&amp; \iiint \limits _V \mu(u,v,w)
\,\mathrm{d}u\,\mathrm{d}v\,\mathrm{d}w
\\
&amp; \iiiint \limits _V \mu(t,u,v,w)
\,\mathrm{d}t\,\mathrm{d}u\,\mathrm{d}v\,\mathrm{d}w
\\
&amp; \idotsint \limits _V \mu(u_1,\dots,u_k) \,\mathrm{d}u_1 \dots
\mathrm{d}u_k
\end{align}
\]</span></p>
<h2 id="矩阵">矩阵</h2>
<p>对于矩阵而言，需要使用 <code>\begin&#123;&#125;...\end&#123;&#125;</code>
来包裹（对齐）</p>
<p>普通矩阵</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{matrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{matrix}
\]</span></p>
<p>括号矩阵（<code>pmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{pmatrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{pmatrix}
\]</span></p>
<p>方括号矩阵（<code>bmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{bmatrix}
\]</span></p>
<p>花括号矩阵（<code>Bmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Bmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{Bmatrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{Bmatrix}
\]</span></p>
<p>竖线矩阵（<code>vmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6<span class="keyword">\\</span></span><br><span class="line">7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{vmatrix}
1 &amp; 2 &amp; 3\\
4 &amp; 5 &amp; 6\\
7 &amp; 8 &amp; 9
\end{vmatrix}
\]</span></p>
<p>双数竖线矩阵（<code>Vmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Vmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6<span class="keyword">\\</span></span><br><span class="line">7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{Vmatrix}
1 &amp; 2 &amp; 3\\
4 &amp; 5 &amp; 6\\
7 &amp; 8 &amp; 9
\end{Vmatrix}
\]</span></p>
<p>我们也可以使用其他分界符搭配 <code>\left ... \right</code>
来构造其他形式，例如</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\left</span><span class="keyword">\langle</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\right</span><span class="keyword">\rangle</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left\langle
\begin{matrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{matrix}
\right\rangle
\]</span></p>
<p>如果想在一行显示矩阵，我们可以使用 <code>smallmatrix</code> 布局</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span> <span class="keyword">\big</span>(<span class="keyword">\begin</span>&#123;smallmatrix&#125;</span><br><span class="line">  a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">  c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;smallmatrix&#125;<span class="keyword">\big</span>)<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>这一行包含矩阵公式：<span
class="math inline">\(\big(\begin{smallmatrix}a&amp;b\\c&amp;d\end{smallmatrix}\big)\)</span></p>
<p>注：在 markdown 中，内联公式必须在同一行</p>
<p>(但是这一行不是很好写捏:(</p>
<h1 id="公式的对齐">公式的对齐</h1>
<h2 id="对齐显示">对齐显示</h2>
<p>使用 <code>align</code> 来表示多行对齐公式（还有一个
<code>align</code> ，其效果和 <code>align</code>
类似，只不过二者使用场景不一样，在 markdown 需要对齐的话使用
<code>align</code> 基本就可以了），使用 <code>\\</code>
来换行，<code>&amp;</code> 来指示需要对齐的位置</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">A <span class="built_in">&amp;</span> = <span class="keyword">\frac</span>&#123;<span class="keyword">\pi</span> r<span class="built_in">^</span>2&#125;&#123;2&#125; <span class="keyword">\\</span></span><br><span class="line">  <span class="built_in">&amp;</span> = <span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125; <span class="keyword">\pi</span> r<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
A &amp; = \frac{\pi r^2}{2} \\
&amp; = \frac{1}{2} \pi r^2
\end{align}
\]</span></p>
<p>这样就可以在等号处对齐了。</p>
<p>我们也可以使用 <code>align</code> 实现表格式的对齐，示例如下：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) = a x<span class="built_in">^</span>2 + b x + c <span class="keyword">\quad</span>  g(x) = d x<span class="built_in">^</span>3 <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) = 2 a x + b  <span class="keyword">\quad</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2 </span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) = a x^2 + b x + c \quad  g(x) = d x^3 \\
f&#39;(x) = 2 a x + b  \quad g&#39;(x) = 3 d x ^2
\end{align}
\]</span></p>
<p>我们的目标是将两个公式分别在等号处对齐。</p>
<p>首先观察一下其对齐情况，可以看到两行公式目前在末尾处是对齐的，这就相当于我们在末尾加上了一个
<code>&amp;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) = a x<span class="built_in">^</span>2 + b x + c <span class="keyword">\quad</span>  g(x) = d x<span class="built_in">^</span>3 <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) = 2 a x + b  <span class="keyword">\quad</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2 <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) = a x^2 + b x + c \quad  g(x) = d x^3 &amp; \\
f&#39;(x) = 2 a x + b  \quad g&#39;(x) = 3 d x ^2 &amp;
\end{align}
\]</span></p>
<p>如果用表格来描述这个公式，如下所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;"><span class="math inline">\(f(x) = a x^2
+ b x + c \quad  g(x) = d x^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span class="math inline">\(f&#39;(x) = 2
a x + b  \quad g&#39;(x) = 3 d x ^2\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>如果我们想要公式在第一个等于号时对齐，那么在等号前加上
<code>&amp;</code>，如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= a x<span class="built_in">^</span>2 + b x + c <span class="keyword">\quad</span>  g(x) = d x<span class="built_in">^</span>3 <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) <span class="built_in">&amp;</span>= 2 a x + b  <span class="keyword">\quad</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2 <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) &amp;= a x^2 + b x + c \quad  g(x) = d x^3 &amp; \\
f&#39;(x) &amp;= 2 a x + b  \quad g&#39;(x) = 3 d x ^2 &amp;
\end{align}
\]</span></p>
<p>可以观察到，此时在 <span class="math inline">\(f(x)\)</span> 和 <span
class="math inline">\(f&#39;(x)\)</span>
后的等号对齐了，但是其末尾处并不对齐了</p>
<p>此时我们将其表格化，如下所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th style="text-align: left;"><span
class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">$f(x) $</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><span class="math inline">\(=a x^2 + b x +
c \quad  g(x) = d x^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span
class="math inline">\(f&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><span class="math inline">\(= 2 a x +
b  \quad g&#39;(x) = 3 d x ^2\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>可以看到，我们插入的 <code>&amp;</code> 将公式划分成了两列，而在
<code>&amp;</code> 左侧的列为右对齐，右侧的列为左对齐，这样就形成了在
<code>&amp;</code>
处对齐的效果，由于后半部所在的列已经左对齐了，自然也就不能在末尾处对齐了。</p>
<p>我们继续对公式进行修改，将 <code>\quad</code> 替换为
<code>&amp;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= a x<span class="built_in">^</span>2 + b x + c <span class="built_in">&amp;</span>  g(x) = d x<span class="built_in">^</span>3 <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) <span class="built_in">&amp;</span>= 2 a x + b  <span class="built_in">&amp;</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) &amp;= a x^2 + b x + c &amp;  g(x) = d x^3 \\
f&#39;(x) &amp;= 2 a x + b  &amp; g&#39;(x) = 3 d x ^2
\end{align}
\]</span></p>
<p>此时可以发现公式又在末尾处对齐了，将其转化成表格</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th><span class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">$f(x) $</td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=a x^2 + b x + c\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span class="math inline">\(g(x) = d
x^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span
class="math inline">\(f&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(= 2 a x + b\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span class="math inline">\(g&#39;(x) = 3
d x ^2\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>最后我们在 <span class="math inline">\(g(x)\)</span> 和 <span
class="math inline">\(g&#39;(x)\)</span> 后添加 <code>&amp;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= a x<span class="built_in">^</span>2 + b x + c <span class="built_in">&amp;</span>  g(x) <span class="built_in">&amp;</span> = d x<span class="built_in">^</span>3 <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) <span class="built_in">&amp;</span>= 2 a x + b  <span class="built_in">&amp;</span> g&#x27;(x)  <span class="built_in">&amp;</span> = 3 d x <span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) &amp;= a x^2 + b x + c &amp;  g(x) &amp; = d x^3 \\
f&#39;(x) &amp;= 2 a x + b  &amp; g&#39;(x)  &amp; = 3 d x ^2
\end{align}
\]</span></p>
<p>最终的表格如下所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th><span class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th><span class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;"><span
class="math inline">\(f(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=ax^2+bx+c\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span
class="math inline">\(g(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=dx^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span
class="math inline">\(f&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(= 2 a x + b\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span
class="math inline">\(g&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=3dx^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>从上面的解析中可以看出，<code>&amp;</code> 有两个作用</p>
<ol type="1">
<li>分块，以 <code>&amp;</code> 为中心划分成左右两部分</li>
<li>如果左侧列没有对齐的话，优先右对齐，对于右侧列同理，优先左对齐</li>
</ol>
<p>这样我们参照上面的表格，第一个和第三个 <code>&amp;</code>
左右两侧都是如此，但是第二个 <code>&amp;</code>
由于其左侧块已经有对齐方式了（左对齐），无法再进行布局安排，因此这个
<code>&amp;</code> 只起到了第一个作用，第二个已经自动忽略了。</p>
<p>Tips：如果想实现列表形式的公式展示，可以将 <code>&amp;</code>
作为列的分割符，对于一列，我们直接使用 <code>&amp; a &amp;</code>
包裹即可（左对齐）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">&amp;</span> a <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> c <span class="built_in">&amp;</span> d <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> e <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> g <span class="built_in">&amp;</span> h <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
&amp; a &amp; &amp; b &amp; &amp; c &amp; d &amp; \\
&amp; e &amp; &amp; f &amp; &amp; g &amp; h &amp;
\end{align}
\]</span></p>
<p>这样虽然有些冗余，但是使用起来比较简单，无需思考 <code>&amp;</code>
放置的位置</p>
<h2 id="居中显示">居中显示</h2>
<p>相比于自定义对齐，居中显示就显得简单很多，使用 <code>gather</code>
即可</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;gather&#125;</span><br><span class="line">2x - 5y =  8 <span class="keyword">\\</span> </span><br><span class="line">3x<span class="built_in">^</span>2 + 9y =  3a + c</span><br><span class="line"><span class="keyword">\end</span>&#123;gather&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{gather}
2x - 5y =  8 \\
3x^2 + 9y =  3a + c
\end{gather}
\]</span></p>
<h1 id="导入其他包">导入其他包</h1>
<p>有时候我们想要在 MathJax 中使用其他宏包，例如 Physics
宏，我们可以直接在 LaTex 代码中使用 <code>require&#123;...&#125;</code>
来添加扩展。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\require</span>&#123;physics&#125;</span><br><span class="line"><span class="keyword">\abs</span>&#123;a&#125; <span class="keyword">\quad</span> <span class="keyword">\grad</span>&#123;x&#125; <span class="keyword">\quad</span> <span class="keyword">\order</span>&#123;1&#125; <span class="keyword">\quad</span> <span class="keyword">\cross</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>开启 Physics 宏之后渲染结果 <span class="math display">\[
\require{physics}
\abs{a} \quad \grad{x} \quad \order{1} \quad \cross
\]</span> 如果加载失败，将会显示如下结果</p>
<p><img data-src="/posts/caff/no-physics-error.svg" /></p>
<p>不过感觉 <code>require&#123;&#125;</code> 功能在 mathjax
中还有点问题，最好还是在设置中手动开启。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://en.wikibooks.org/wiki/LaTeX/Mathematics">LaTeX/Mathematics
- Wikibooks, open books for an open world</a></li>
<li><a
href="https://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics">LaTeX/Advanced
Mathematics - Wikibooks, open books for an open world</a></li>
<li><a
href="https://kapeli.com/cheat_sheets/LaTeX_Math_Symbols.docset/Contents/Resources/Documents/index">LaTeX
Math Symbols Cheat Sheet - Kapeli</a></li>
<li><a
href="https://www.overleaf.com/learn/latex/Mathematical_expressions">Mathematical
expressions - Overleaf, Online LaTeX Editor</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo自定义插件</title>
    <url>/posts/9a20/</url>
    <content><![CDATA[<h1 id="hexo-plugin">Hexo Plugin</h1>
<p>参考官方<a
href="https://hexo.io/zh-cn/docs/plugins">文档</a>，我们有两种创建插件方式</p>
<ol type="1">
<li>以脚本（Scripts）形式（单个文件）</li>
<li>以 npm package 形式创建（支持多文件）</li>
</ol>
<p>对于一般的插件而言，如果代码并不复杂且依赖较少，可以直接写成脚本形式，放在
hexo 根目录下的 <code>scripts</code>
文件夹即可（不存在直接创建一个即可），在介绍插件具体写法之前，先看一个简单的例子：</p>
<p>文件：<code>scripts/test.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line">  log.<span class="title function_">debug</span>(<span class="string">&quot;hello from test.js!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后执行下列命令查看效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate --debug</span><br></pre></td></tr></table></figure>

<p>这一条命令包含两个子命令，<code>hexo clean</code>
清除之前的生成文件，之后的 <code>hexo generate</code>
用来生成静态页面文件。</p>
<p>（<code>--debug</code> 标志会使 hexo 在终端显示调试信息，在所有的
hexo-cli 命令中都可以使用）</p>
<span id="more"></span>

<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; hexo clean &amp;&amp; hexo generate --debug</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deleted database.</span><br><span class="line">INFO  Deleted public folder.</span><br><span class="line">03:05:12.393 DEBUG Writing database to D:\hexo-temp\db.json</span><br><span class="line">03:05:12.401 DEBUG Hexo version: 6.3.0</span><br><span class="line">...</span><br><span class="line">03:05:12.483 INFO  Validating config</span><br><span class="line">...</span><br><span class="line">03:05:12.651 DEBUG Script loaded: scripts\test.js</span><br><span class="line">03:05:12.652 INFO  Start processing</span><br><span class="line">...</span><br><span class="line">03:05:12.717 DEBUG hello from test.js!!!</span><br><span class="line">...</span><br><span class="line">03:05:12.742 INFO  Files loaded <span class="keyword">in</span> 90 ms</span><br><span class="line">...</span><br><span class="line">03:05:12.915 INFO  Generated: archives/2023/index.html</span><br><span class="line">...</span><br><span class="line">03:05:12.922 INFO  17 files generated <span class="keyword">in</span> 180 ms</span><br><span class="line">03:05:12.924 DEBUG Database saved</span><br></pre></td></tr></table></figure>

<p>从输出中我们可以看到，在 <code>Validating config</code>
过程中加载了我们创建的脚本，而在 <code>Start processing</code>
后执行了我们的脚本，并通过 debug 输出了对应的语句。</p>
<p>这样我们就实现了一个简单的 hexo
插件（十分简单，没有对输入的数据做任何处理，打印一条语句后就退出了）。</p>
<h2 id="plugin-写法">plugin 写法</h2>
<p>参考官方<a
href="https://hexo.io/zh-cn/api">文档</a>的扩展部分，其给出了所有插件的种类</p>
<p><img data-src="/posts/9a20/image-20230116112529108.png"
style="zoom: 50%;" /></p>
<p>例如我们之前写的 filter 插件，其<a
href="https://hexo.io/zh-cn/api/filter">文档</a>如下</p>
<p><img data-src="/posts/9a20/image-20230116113313750.png"
style="zoom:50%;" /></p>
<p>所有的插件都可以采用类似的方式实现，通过
<code>hexo.extend.xxx.register</code>
来注册插件，指定好对应的处理函数即可。</p>
<h2 id="基本模板">基本模板</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.&lt;extend-type&gt;.<span class="title function_">register</span>(name,&lt;args&gt;,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;,&lt;extend-args&gt;)</span><br></pre></td></tr></table></figure>

<p>考虑到箭头函数和普通函数的区别，在函数内部我们获取 hexo
变量的方式不一样，在箭头函数中没有 this 指针，我们需要通过一个全局 hexo
变量进行访问即可，而普通函数会包含 this 指针，而 hexo
在调用函数时会将自身绑定到 this 指针上，这样我们可以直接通过 this 访问
hexo 相关变量。</p>
<p>对应代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrow_function1</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = <span class="variable language_">this</span>;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from arrow_function1!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrow_function2</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from arrow_function2!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> normal_function1 = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = <span class="variable language_">this</span>;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from normal_function1!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> normal_function2 = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from normal_function2!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, arrow_function1);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, arrow_function2);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, normal_function1);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, normal_function2);</span><br></pre></td></tr></table></figure>

<p>对应执行结果（<code>hexo clean &amp;&amp; hexo generate --debug</code>
)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">03</span>:<span class="number">55</span>:<span class="number">44.819</span> <span class="variable constant_">DEBUG</span> hello <span class="keyword">from</span> arrow_function2!!!</span><br><span class="line"><span class="number">03</span>:<span class="number">55</span>:<span class="number">44.819</span> <span class="variable constant_">DEBUG</span> hello <span class="keyword">from</span> vanilla_function1!!!</span><br><span class="line"><span class="number">03</span>:<span class="number">55</span>:<span class="number">44.820</span> <span class="variable constant_">DEBUG</span> hello <span class="keyword">from</span> vanilla_function2!!!</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>从执行结果中可以看到，在箭头函数（arrow function）中不包含 this
指针，我们无法通过 this 来访问 hexo 的变量，但是可以直接通过 hexo
全局变量来访问，对于普通函数（normal function）而言，可以通过 this
来访问 hexo，也可以直接通过全局变量 hexo 来访问。</p>
<p>由于脚本模式实际上实在 js 中通过字符串形式执行的，最好在开头处添加
<code>use strict</code> 来标识，确保插件能正常执行。</p>
<p>注：导入包的时候我们只能使用 common js 的包，并不支持 es6
模式的包，即我们不能通过一下模式导入包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unified &#125; <span class="keyword">from</span> <span class="string">&#x27;unified&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>(unified 是一个<a
href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">纯
es6 模块</a>，不支持 comman js 导入)</p>
<p>而必须使用 common js 的导包方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; red &#125; = <span class="built_in">require</span>(<span class="string">&#x27;picocolors&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="日志输出">日志输出</h2>
<p>通过 <code>hexo.log</code> 我们可以拿到 hexo
的日志输出对象，其具体实现在 <a
href="https://github.com/hexojs/hexo-log">hexo-log</a>
中，和普通的日志输出模块类似，其也支持不同级别的日志输出和颜色输出，具体通过
<code>picocolors</code> 库来控制输出的颜色，示例如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line"><span class="keyword">const</span> &#123;red,green,blue,magenta,cyan&#125; = <span class="built_in">require</span>(<span class="string">&#x27;picocolors&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  log.<span class="title function_">trace</span>(<span class="string">&quot;this is a trace message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">debug</span>(<span class="string">&quot;this is a debug message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a info message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">warn</span>(<span class="string">&quot;this is a warn message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">error</span>(<span class="string">&quot;this is a error message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">fatal</span>(<span class="string">&quot;this is a fatal message&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a red&quot;</span>,<span class="title function_">red</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a green&quot;</span>,<span class="title function_">green</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a blue&quot;</span>,<span class="title function_">blue</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a magenta&quot;</span>,<span class="title function_">magenta</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a cyan&quot;</span>,<span class="title function_">cyan</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对应输出结果</p>
<p><img data-src="/posts/9a20/image-20230116121200965.png"
style="zoom:67%;" /></p>
<h1 id="pandoc-renderer">Pandoc Renderer</h1>
<h2 id="目的">目的</h2>
<p>在前一篇文章中，我们配置好了 hexo
的静态文件处理方式，将所有的图片都放置在了 <code>source/images</code>
路径下，并通过设置 markdown 的 front matter 使得 typora
可以正确显示图片。</p>
<p>但是这种方法<strong>耦合性太强</strong>，所有图片都放在 images
文件夹不说，如果我们换一个 markdown 编辑器，就无法实现正确的预览了。</p>
<p>为此，我们需要调整 hexo 中图片资源管理方式，将 markdown
文件中图片链接全部替换为相对路径。</p>
<h2 id="问题">问题</h2>
<p>首先我们需要对之前的配置进行一些调整，修改
<code>_config.yaml</code>，开启资源文件后处理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>参考官方文档，其会在创建 post文件 的同时创建和 post文件
同名的文件夹，用来存储资源文件，而后在生成站点时将图片拷贝到默认文件夹下。</p>
<p>修改配置后，我们创建一个 post 来查看一下效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;c++学习笔记&quot;</span></span><br></pre></td></tr></table></figure>

<p>（取这个名字还有一个就是文件名实际上和文章的标题不一定会对应，如果包含特殊的字符会进行调整）</p>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; hexo new post <span class="string">&quot;c++学习笔记&quot;</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: D:\hexo-temp\<span class="built_in">source</span>\_posts\c-学习笔记.md</span><br></pre></td></tr></table></figure>

<p>可以看到 markdown 文件名变成了 <code>c-学习笔记</code>，将
<code>++</code> 替换成了 <code>-</code>，同时在当前目录下也创建了
<code>c-学习笔记</code> 文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp\<span class="built_in">source</span>\_posts&gt; tree /F</span><br><span class="line">卷 Data 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 4000-728D</span><br><span class="line">D:.</span><br><span class="line">│  c-学习笔记.md</span><br><span class="line">│  hello-world.md</span><br><span class="line">│</span><br><span class="line">└─c-学习笔记</span><br><span class="line">        hexo.png</span><br></pre></td></tr></table></figure>

<p>（在 powershell 中也提供了 <code>tree</code> 命令，使用方式和 linux
下的差别较大，传参居然是用 <code>/&lt;argument&gt;</code>
的形式，怪怪的，查看帮助使用 <code>/?</code> 而不是 linux 中的
<code>--help</code> 或 <code>-h</code>）</p>
<p>此时我们在 markdown 文档中插入一张图片测试一下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: c++学习笔记</span><br><span class="line">date: 2023-01-16 13:30:31</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">测试图片：</span><br><span class="line"></span><br><span class="line">![<span class="string">测试图片</span>](<span class="link">c-学习笔记/hexo.png</span>)</span><br></pre></td></tr></table></figure>

<p>本地预览结果</p>
<p><img data-src="/posts/9a20/image-20230116134147690.png"
style="zoom:50%;" /></p>
<p>生成静态页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate</span><br></pre></td></tr></table></figure>

<p>生成的文件位于根目录的 <code>public</code> 下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; tree /F public</span><br><span class="line">卷 Data 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 00000048 4000:728D</span><br><span class="line">D:\HEXO-TEMP\PUBLIC</span><br><span class="line">│  index.html</span><br><span class="line">│</span><br><span class="line">├─2023</span><br><span class="line">│  └─01</span><br><span class="line">│      ├─15</span><br><span class="line">│      │  └─hello-world</span><br><span class="line">│      │          index.html</span><br><span class="line">│      │</span><br><span class="line">│      └─16</span><br><span class="line">│          └─c-学习笔记</span><br><span class="line">│                  hexo.png</span><br><span class="line">│                  index.html</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，我们插入的图片也被拷贝到了 public
下的同名文件中，但是在生成的 <code>index.html</code>
中我们可以看到，图片链接不对，在网页中自然无法正确显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;e-content article-entry&quot;</span> <span class="attr">itemprop</span>=<span class="string">&quot;articleBody&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>测试图片：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/hexo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;测试图片&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</code> 是中文
<code>学习笔记</code> 进行 UTF-8 编码后的 URL 表示形式 (urlencode)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; python</span><br><span class="line">Python 3.9.12 (main, Apr  4 2022, 05:22:27) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; s = <span class="string">&quot;学习笔记&quot;</span></span><br><span class="line">&gt;&gt;&gt; s.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;\xe5\xad\xa6\xe4\xb9\xa0\xe7\xac\x94\xe8\xae\xb0&#x27;</span></span><br><span class="line">&gt;&gt;&gt; from urllib.parse import quote    </span><br><span class="line">&gt;&gt;&gt; quote(s)</span><br><span class="line"><span class="string">&#x27;%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果我们对文章采用了永久编码，例如 <code>hexo-abbrlink</code> 等，在
public 下文章名就会对应变成永久链接名称。</p>
<p>此时我们已经发现问题了，<strong>图片对应的URI应该是
<code>&lt;post-perm-link&gt;/&lt;pic-name&gt;</code>，但是我们在
markdown
中填写的路径是<code>&lt;post-md-name&gt;/&lt;pic-name&gt;</code></strong>，如果直接转
html 就会出现问题。</p>
<p>特别的，在 typora 中，当我们调整过图片大小后，其会将原始的 markdown
图片语法切换为 html 的 img 标签形式。</p>
<p>hexo-renderer-marked 可以对 markdown 中图片链接进行转换，但是对于
HTML 文档而言就无能为力了，毕竟 html 此时就相当于是纯文本了。</p>
<p>要想完美实现图片链接的处理，就需要我们通过插件方式进行自行实现</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: c++学习笔记</span><br><span class="line">date: 2023-01-16 13:30:31</span><br><span class="line"><span class="section">tag:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">markdown 图片：</span><br><span class="line"></span><br><span class="line">![<span class="string">测试图片</span>](<span class="link">c-学习笔记/hexo.png</span>)</span><br><span class="line"></span><br><span class="line">html 图片</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;c-学习笔记/hexo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;测试图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>预览效果</p>
<p><img data-src="/posts/9a20/image-20230116144123563.png"
style="zoom: 50%;" /></p>
<h2 id="解决思路">解决思路</h2>
<p>搞清楚问题后，我们就可以考虑如何解决问题了，主要问题有两个</p>
<ol type="1">
<li>无法实现自动图片链接转换</li>
<li>对于 img 标签形式的图片链接也需要进行转换</li>
</ol>
<p>此时通过正则表达式进行替换的方式实现起来太复杂，不够稳定。例如，对于
markdown
文本中的代码段，如果在代码段中也包含一段图片链接，采用文本替换的方式也会对这个链接进行替换，虽然95%情况下能用，但是还是有5%的不适用场景，个人不推荐这样实现。</p>
<p>另一个比较好的解决思路就是通过<strong>语法分析</strong>获取到
markdown 文档的抽象语法树，对于 html
部分的图片链接也同样进行处理（毕竟我们最终目标是将 markdown 转换成
html，对 html 文档进行解析生成抽象语法树也是一样的）。</p>
<p>拿到抽象语法树之后，我们只需要调整 img 标签对应的 src
属性即可，此时进行替换可以确保我们一定是替换的图片链接，而不会错误地替换代码段中的链接。</p>
<p>这样我们的思路就很清楚了：</p>
<ol type="1">
<li>通过 markdown 语法分析器进行语法分析，生成抽象语法树</li>
<li>遍历抽象语法树，调整 img 节点对应链接属性，修改为永久链接</li>
<li>将抽象语法树转换成 html 文档</li>
</ol>
<p>目前有很多 js 实现的 markdown 分析器，但是根据我们的需求</p>
<ol type="1">
<li>能同时进行 markdown 和 html 文档的语法分析</li>
<li>markdown 和 html 文件能具有统一的中间表示形式</li>
</ol>
<p>纯 js 的解决方案目前只找到 <a
href="https://github.com/remarkjs/remark">remark.js</a>
一个，但是其仅支持 es6，在 hexo 中仅支持 common js 导入。</p>
<p>最后查到 pandoc 支持通过 lua 脚本的形式进行后处理（也就是 pandoc
filter），似乎完美契合我们需求，那么接下来只需要学习如何编写 pandoc
filter 即可。</p>
<blockquote>
<p><a href="https://pandoc.org/filters.html">Pandoc - Pandoc
filters</a></p>
<p>转换流程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INPUT -&gt; reader -&gt; AST -&gt; filter -&gt; AST -&gt; writer -&gt; OUTPUT</span><br></pre></td></tr></table></figure>

</blockquote>
<h2 id="plugin">plugin</h2>
<p>在调用 filter 之前，我们首先将 pandoc 集成到 hexo
中。幸运的是已经有大佬写了相关调用插件了（<a
href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a>），其代码也很简单，不到200行，可以直接通过脚本集成到
hexo 中。</p>
<p>由于 pandoc 是一个单独的可执行文件，在 js 中实际上就是调用 pandoc
可执行文件，并获取其输出。在 node.js 调用其他命令需要
<code>child_process</code> 库的 <code>spawn</code>，<code>exec</code> 或
<code>fork</code></p>
<p>这三类都可以实现外部命令的执行，由于我们需要对 pandoc 提供 markdown
文本输入并获取 html 输出，数据量较大，<code>spawn</code>
是最符合我们需求的，为了满足跨平台要求，我们可以使用
<code>cross-spawn</code>来执行命令。</p>
<p><code>spawn</code>
是一个异步函数，我们需要提供一系列回调函数来获取其执行状态，在 <a
href="https://github.com/hexojs/hexo-util">hexo-utils</a> 中也提供了
<code>CacheStream</code>
来辅助我们获取子命令的输出结果，具体用法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;node:child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CacheStream</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;hexo-util&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get_cache</span> = (<span class="params">stream, encoding</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> buf = stream.<span class="title function_">getCache</span>();</span><br><span class="line">  stream.<span class="title function_">destroy</span>();</span><br><span class="line">  <span class="keyword">if</span> (!encoding) <span class="keyword">return</span> buf;</span><br><span class="line">  <span class="keyword">return</span> buf.<span class="title function_">toString</span>(encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> task = <span class="title function_">spawn</span>(<span class="string">&quot;pandoc&quot;</span>, [<span class="string">&quot;--version&quot;</span>], &#123;</span><br><span class="line">      <span class="attr">env</span>: process.<span class="property">env</span>,</span><br><span class="line">      <span class="attr">cwd</span>: process.<span class="title function_">cwd</span>()</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> encoding = <span class="string">&#x27;utf-8&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> stdout_cache = <span class="keyword">new</span> <span class="title class_">CacheStream</span>();</span><br><span class="line">    <span class="keyword">const</span> stderr_cache = <span class="keyword">new</span> <span class="title class_">CacheStream</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task.<span class="property">stdout</span>) &#123;</span><br><span class="line">      task.<span class="property">stdout</span>.<span class="title function_">setEncoding</span>(encoding);</span><br><span class="line">      task.<span class="property">stdout</span>.<span class="title function_">pipe</span>(stdout_cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (task.<span class="property">stderr</span>) &#123;</span><br><span class="line">      task.<span class="property">stderr</span>.<span class="title function_">setEncoding</span>(encoding);</span><br><span class="line">      task.<span class="property">stderr</span>.<span class="title function_">pipe</span>(stderr_cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (task.<span class="property">stdin</span>) &#123;</span><br><span class="line">      task.<span class="property">stdin</span>.<span class="title function_">setEncoding</span>(encoding);</span><br><span class="line">      <span class="comment">// task.stdin.write(data.text);</span></span><br><span class="line">      task.<span class="property">stdin</span>.<span class="title function_">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    task.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> stderr_msg = <span class="title function_">get_cache</span>(stderr_cache, encoding);</span><br><span class="line">      <span class="keyword">if</span> (code) &#123;</span><br><span class="line">        <span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`pandoc process exited with code <span class="subst">$&#123;code&#125;</span>.<span class="subst">$&#123;stderr_msg.length &gt; <span class="number">0</span> ? <span class="string">`\n<span class="subst">$&#123;stderr_msg&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">        e.<span class="property">code</span> = code;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (stderr_msg.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stderr_msg.<span class="title function_">endsWith</span>(<span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">          stderr_msg = stderr_msg.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        log.<span class="title function_">debug</span>(<span class="string">`Pandoc:\n%s`</span>, stderr_msg);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="title function_">get_cache</span>(stdout_cache, encoding));</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>().<span class="title function_">then</span>(<span class="function"><span class="params">output</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`output from spawn:\n<span class="subst">$&#123;output&#125;</span>`</span>)).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; node .\scripts\test.js</span><br><span class="line">output from pandoc:</span><br><span class="line">pandoc 2.19.2</span><br><span class="line">Compiled with pandoc-types 1.22.2.1, texmath 0.12.5.2, skylighting 0.13,</span><br><span class="line">citeproc 0.8.0.1, ipynb 0.2, hslua 2.2.1</span><br><span class="line">Scripting engine: Lua 5.4</span><br><span class="line">User data directory: C:\Users\xiao\AppData\Roaming\pandoc</span><br><span class="line">Copyright (C) 2006-2022 John MacFarlane. Web:  https://pandoc.org</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions. There is no</span><br><span class="line">warranty, not even <span class="keyword">for</span> merchantability or fitness <span class="keyword">for</span> a particular purpose.</span><br></pre></td></tr></table></figure>

<p>上面的代码实际上就是调用了 <code>pandoc --version</code> 命令，并通过
CacheStream 获取到了调用命令后的输出结果，以便进行下一步的调用。</p>
<p>如果我们需要向 pandoc 传输数据（例如待处理的 markdown
文本流），我们可以直接在 <code>stdin</code>
中直接写入，同时注意写入完成后<strong>记得关闭输入流</strong>，否则
pandoc 进程会一直等待输入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">task.<span class="property">stdin</span>.<span class="title function_">setEncoding</span>(encoding);</span><br><span class="line">task.<span class="property">stdin</span>.<span class="title function_">write</span>(&lt;some-data&gt;);</span><br><span class="line">task.<span class="property">stdin</span>.<span class="title function_">end</span>();</span><br></pre></td></tr></table></figure>

<p>在 pandoc 进行 markdown 转换的命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --from=gfm --to=html5 --mathjax</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol type="1">
<li><code>--from</code> 表示输入格式</li>
<li><code>--to</code> 表示输出格式</li>
<li><code>--mathjax</code> 表示开启 mathjax 公式支持</li>
</ol>
<p>输入后 pandoc 就会等待 stdin 输入，输出到 stdout
中，同时将错误信息输出到 stderr 中。</p>
<p>例如我们写一个简单的 <code>h1</code> 标题，其 markdown 代码为
<code># This is h1</code> ，对应 html 代码为
<code>&lt;h1&gt;This is h1&lt;/h1&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task = <span class="title function_">spawn</span>(<span class="string">&quot;pandoc&quot;</span>, [<span class="string">&quot;--from=gfm&quot;</span>,<span class="string">&quot;--to=html5&quot;</span>,<span class="string">&quot;--mathjax&quot;</span>], &#123;</span><br><span class="line">    <span class="attr">env</span>: process.<span class="property">env</span>,</span><br><span class="line">    <span class="attr">cwd</span>: process.<span class="title function_">cwd</span>()</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">task.<span class="property">stdin</span>.<span class="title function_">write</span>(<span class="string">&quot;# This is h1&quot;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; node .\scripts\test.js</span><br><span class="line">output from spawn:</span><br><span class="line">&lt;h1 <span class="built_in">id</span>=<span class="string">&quot;this-is-h1&quot;</span>&gt;This is h1&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过 spawn 我们可以正确调用 pandoc 并实现从 markdown 到
html 的转换。最后只需要编写 pandoc filter 就可以完成插件了。</p>
<h2 id="pandoc-filter">pandoc filter</h2>
<h3 id="hellolua-filter">hello，lua filter</h3>
<p>在 <a href="https://pandoc.org/lua-filters.html">Pandoc 官网</a>
中给出了一个简单的示例</p>
<p>文件：<code>smallcaps.lua</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    Strong = <span class="function"><span class="keyword">function</span> <span class="params">(elem)</span></span></span><br><span class="line">      <span class="keyword">return</span> pandoc.SmallCaps(elem.c)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其将所有的 Strong 标签（粗体，在 markdown 就是
<code>**A**</code>，<strong>A</strong>）转换 Small Caps 形式，测试
markdown 如下</p>
<p>将其保存为 <code>test.md</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**hello world!**</span></span><br></pre></td></tr></table></figure>

<p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --lua-filter=smallcaps.lua -o test.html test.md</span><br></pre></td></tr></table></figure>

<p>如果不指定输出格式，其默认使用 html 格式输出，对应输出结果如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;smallcaps&quot;</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在 html 中并不能原生支持 smallcaps 样式，但是 pandoc
为其指定了一个 css 类名，通过类名这个我们可以手动实现 smallcaps
效果。</p>
<h3 id="filter-写法">filter 写法</h3>
<p>上面的代码第一眼看上有点奇怪，怎么以来就是一个 <code>return</code>
语句，返回的 <code>&#123;&#125;</code> 怎么直接套了一个
<code>&#123;xxx = xxx&#125;</code></p>
<p>首先解释后面一点，在 lua 中，列表和字典都使用 <code>&#123;&#125;</code>
表示，那么最外层的就是一个列表，然后内层的是一个字典，我们可以看到其指定了一个键为
<code>Strong</code> 的函数，表示对 <code>Strong</code>
这个节点的处理函数。</p>
<p>那么最开始的 <code>return</code>
就表示这个脚本可以作为包被外部使用，就有点类似于 common js
中模块写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">export</span>.<span class="property">x</span> = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title class_">Strong</span> = <span class="keyword">function</span>(<span class="params">elem</span>)&#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>然后在 pandoc 内部调用时，直接使用下面语句</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">require</span>(<span class="string">&quot;smallcaps&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>即可导入使用</p>
<p>在 Pandoc 中定义了很多种抽象语法树的节点类型，例如
Block、String、Inline等，对于每一个节点类型我们都可以编写对应的处理函数对其进行处理，同时根据列表的顺序还可以控制抽象语法树的遍历方式。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Meta</span><span class="params">(meta)</span></span> </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;process meta&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Para</span><span class="params">(para)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;process para&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Image</span><span class="params">(image)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;process image&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123;Meta = Meta&#125;,</span><br><span class="line">    &#123;Para = Para&#125;,</span><br><span class="line">    &#123;Image = Image&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 markdown</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">title: 测试 markdown</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">![<span class="string">test-image</span>](<span class="link">url-to-image</span>)</span><br></pre></td></tr></table></figure>

<p>测试命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --lua-filter test.lua -o test.html test.md</span><br></pre></td></tr></table></figure>

<p>在控制台的输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Lua\pandoc-filter&gt; pandoc --lua-filter test.lua -o test.html test.md</span><br><span class="line">process meta</span><br><span class="line">process para</span><br><span class="line">process para</span><br><span class="line">process image</span><br></pre></td></tr></table></figure>

<p>从输出结果上我们可以看到，首先处理的是 meta，之后是两个 para，最后是
image，其对应的文档结构如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span>...<span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;url-to-image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;test-image&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：如果函数中没有返回任何值（或者返回
nil），表示该函数不会对抽象语法树进行修改</p>
<h2 id="final-filter">final filter</h2>
<p>参考 pandoc 对于 <a
href="https://pandoc.org/lua-filters.html#type-image">image</a>
节点的描述，通过 <code>src</code>
字段可以读取到图片的链接信息，我们只需要修改 url
值即可，根据之前的描述，我们可以编写一个简单的 filter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local url_prefix</span><br><span class="line"></span><br><span class="line">local function Meta(meta) </span><br><span class="line">  url_prefix = meta.url_prefix </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function Image(image)</span><br><span class="line">   image.src = url_prefix ..&#x27;/&#x27;.. image.src</span><br><span class="line">   print(&quot;image.src: &quot;,image.src)</span><br><span class="line">   return image</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">   &#123;Meta = Meta&#125;,</span><br><span class="line">   &#123;Image = Image&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在命令行中通过 <code>--metadata=key:value</code>
来指定元数据信息</p>
<p>转换命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --metadata=url_prefix:<span class="built_in">test</span> --lua-filter test.lua -o test.html test.md</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">image.src:      <span class="built_in">test</span>/test.jpg</span><br></pre></td></tr></table></figure>

<p>转换后的 html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test/url-to-image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;test-image&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span>test-image<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>src</code>
部分已经替换成了我们需要的链接，并且其还对图片添加了 figcaption</p>
<p>之前我们提到，在 markdown 文档中可能存在 html
代码，对于这一部分我们也想要进行处理，默认 pandoc 会将其解析为
RawBlock，即不做任何处理，但也可以使用 <code>pandoc.read</code>
进行解析，生成抽象语法树，这样我们就可以对 html
形式的图片进行解析了。</p>
<p>完整代码如下</p>
<p>文件：<code>image-asset.lua</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    Reference: </span></span><br><span class="line"><span class="comment">    [1] https://pandoc.org/lua-filters.html</span></span><br><span class="line"><span class="comment">    [2] http://www.lua.org/manual/5.4/</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> logging = <span class="built_in">require</span>(<span class="string">&#x27;logging&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> new_path</span><br><span class="line"><span class="keyword">local</span> path_prefix</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Meta</span><span class="params">(meta)</span></span></span><br><span class="line">    <span class="comment">-- logging.temp(&#x27;Meta&#x27;,meta)</span></span><br><span class="line">    <span class="keyword">local</span> meta_path = meta[<span class="string">&#x27;path&#x27;</span>]</span><br><span class="line">    <span class="keyword">local</span> meta_title = meta[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> (meta_path == <span class="literal">nil</span> <span class="keyword">or</span> meta_title == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        logging.temp(<span class="string">&#x27;Meta&#x27;</span>,<span class="string">&#x27;no meta data found, ignored.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    new_path = pandoc.utils.stringify(meta_path)</span><br><span class="line">    path_prefix = pandoc.utils.stringify(meta_title) .. <span class="string">&#x27;/&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Image</span><span class="params">(image)</span></span></span><br><span class="line">    <span class="keyword">if</span> (new_path == <span class="literal">nil</span> <span class="keyword">or</span> path_prefix == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> length = pandoc.text.<span class="built_in">len</span>(path_prefix)</span><br><span class="line">    <span class="keyword">local</span> prefix = pandoc.text.<span class="built_in">sub</span>(image.src,<span class="number">1</span>,length)</span><br><span class="line">    <span class="keyword">local</span> postfix = pandoc.text.<span class="built_in">sub</span>(image.src,length+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (prefix == path_prefix) <span class="keyword">then</span></span><br><span class="line">        image.src = new_path .. postfix</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">RawBlock</span> <span class="params">(raw)</span></span></span><br><span class="line">    <span class="keyword">if</span> raw.<span class="built_in">format</span>:<span class="built_in">match</span>(<span class="string">&#x27;html&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> res = pandoc.<span class="built_in">read</span>(raw.text,<span class="string">&#x27;html&#x27;</span>)</span><br><span class="line">        <span class="comment">-- https://pandoc.org/lua-filters.html#type-blocks</span></span><br><span class="line">        <span class="keyword">if</span> ( #res.blocks == <span class="number">1</span> ) <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- convert Plain to Para</span></span><br><span class="line">            <span class="keyword">return</span> pandoc.Para(res.blocks[<span class="number">1</span>].content)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- function Pandoc(pandoc)</span></span><br><span class="line"><span class="comment">--     logging.temp(&#x27;Pandoc&#x27;,pandoc)</span></span><br><span class="line"><span class="comment">-- end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- return in global scope (can be loaded via `require`)</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123; RawBlock = RawBlock &#125;,</span><br><span class="line">    &#123; Meta = Meta &#125;,</span><br><span class="line">    &#123; Image = Image &#125;,</span><br><span class="line">    <span class="comment">-- &#123; Pandoc = Pandoc &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及完整的插件代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code modified from https://github.com/wzpan/hexo-renderer-pandoc/blob/master/index.js</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;cross-spawn&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;node:path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CacheStream</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;hexo-util&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;node:assert&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; yellow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;picocolors&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">config</span>.<span class="property">pandoc</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;</span><br><span class="line">    <span class="attr">pandoc_bin</span>: <span class="string">&#x27;pandoc&#x27;</span>,</span><br><span class="line">    <span class="attr">math_engine</span>: <span class="string">&#x27;mathjax&#x27;</span>,</span><br><span class="line">    <span class="attr">markdown_mode</span>: <span class="string">&#x27;gfm&#x27;</span>,</span><br><span class="line">    <span class="attr">filters</span>: [],</span><br><span class="line">    <span class="attr">lua_filters</span>: [],</span><br><span class="line">    <span class="attr">extra</span>: [],</span><br><span class="line">&#125;, hexo.<span class="property">config</span>.<span class="property">pandoc</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// must have the `?.lua` specified!</span></span><br><span class="line"><span class="keyword">const</span> pandoc_env = &#123; ...process.<span class="property">env</span>, <span class="attr">LUA_PATH</span>: path.<span class="title function_">join</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;lua&#x27;</span>, <span class="string">&#x27;?.lua&#x27;</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">argument</span> = (<span class="params">name, value = <span class="literal">undefined</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`--<span class="subst">$&#123;name&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`--<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is_string</span> = obj =&gt; <span class="keyword">typeof</span> (obj) === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is_array</span> = obj =&gt; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is_object</span> = obj =&gt; <span class="keyword">typeof</span> (obj) === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get_cache</span> = (<span class="params">stream, encoding</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> buf = stream.<span class="title function_">getCache</span>();</span><br><span class="line">    stream.<span class="title function_">destroy</span>();</span><br><span class="line">    <span class="keyword">if</span> (!encoding) <span class="keyword">return</span> buf;</span><br><span class="line">    <span class="keyword">return</span> buf.<span class="title function_">toString</span>(encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">renderer</span> = (<span class="params">data, options</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; log &#125; = hexo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = hexo.<span class="property">config</span>.<span class="property">pandoc</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> filters = [];</span><br><span class="line">    <span class="keyword">const</span> lua_filters = [];</span><br><span class="line">    <span class="keyword">const</span> extra = [<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">&#x27;pagetitle:ignored&#x27;</span>)];</span><br><span class="line">    <span class="comment">// To satisfy pandoc&#x27;s requirement that html5 must have a title.</span></span><br><span class="line">    <span class="comment">// Since the markdown file is only rendered as body part,</span></span><br><span class="line">    <span class="comment">// the title is never used and thus does not matter</span></span><br><span class="line">    <span class="keyword">const</span> pandoc_bin = config.<span class="property">pandoc_bin</span>;</span><br><span class="line">    <span class="keyword">const</span> math_engine = <span class="title function_">argument</span>(config.<span class="property">math_engine</span>);</span><br><span class="line">    <span class="keyword">const</span> markdown_mode = config.<span class="property">markdown_mode</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is_array</span>(config.<span class="property">filters</span>)) &#123;</span><br><span class="line">        config.<span class="property">filters</span> = [config.<span class="property">filters</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is_array</span>(config.<span class="property">lua_filters</span>)) &#123;</span><br><span class="line">        config.<span class="property">lua_filters</span> = [config.<span class="property">lua_filters</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is_array</span>(config.<span class="property">extra</span>)) &#123;</span><br><span class="line">        config.<span class="property">extra</span> = [config.<span class="property">extra</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    config.<span class="property">filters</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line">        filters.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;filter&#x27;</span>, filter));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    config.<span class="property">lua_filters</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line">        lua_filters.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;lua-filter&#x27;</span>, filter));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    config.<span class="property">extra</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_string</span>(item)) &#123;</span><br><span class="line">            extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(item));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">is_object</span>(item)) &#123;</span><br><span class="line">            <span class="title function_">assert</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(item).<span class="property">length</span> === <span class="number">1</span>, <span class="string">`item in extra must be a key-value tuple or string`</span>);</span><br><span class="line">            <span class="keyword">const</span> [key, value] = <span class="title class_">Object</span>.<span class="title function_">entries</span>(item)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">is_array</span>(value)) &#123;</span><br><span class="line">                value.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                    extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(key, v));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(key, value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`unknown extra config for pandoc: <span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">POST_MODEL</span> = hexo.<span class="title function_">model</span>(<span class="string">&#x27;Post&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> source = data.<span class="property">path</span>.<span class="title function_">substring</span>(hexo.<span class="property">source_dir</span>.<span class="property">length</span>).<span class="title function_">replace</span>(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> current_post = <span class="variable constant_">POST_MODEL</span>.<span class="title function_">findOne</span>(&#123; source &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_post) &#123;</span><br><span class="line">        <span class="comment">// manually add root path</span></span><br><span class="line">        <span class="keyword">const</span> post_path = <span class="string">`/<span class="subst">$&#123;current_post.path&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">// the filename (xxx.md) may not correspond to title field in Markdown Front Matter</span></span><br><span class="line">        <span class="keyword">const</span> filename = path.<span class="title function_">basename</span>(data.<span class="property">path</span>, <span class="string">&#x27;.md&#x27;</span>);</span><br><span class="line">        log.<span class="title function_">debug</span>(<span class="string">&#x27;Filename: %s&#x27;</span>, <span class="title function_">yellow</span>(filename));</span><br><span class="line">        <span class="comment">// const title = current_post.title;</span></span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">`path:<span class="subst">$&#123;post_path&#125;</span>`</span>));</span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">`title:<span class="subst">$&#123;filename&#125;</span>`</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we are rendering a post,</span></span><br><span class="line">    <span class="comment">// `data` has the key `path`</span></span><br><span class="line">    <span class="comment">// https://github.com/hexojs/hexo/blob/2ed17cd105768df379dad8bbbe4df30964fe8f2d/lib/hexo/post.js#L269</span></span><br><span class="line">    <span class="comment">// otherwise (e.g., rendering a tag),</span></span><br><span class="line">    <span class="comment">// `path` is not present in `data`.</span></span><br><span class="line">    <span class="comment">// https://github.com/hexojs/hexo/blob/2ed17cd105768df379dad8bbbe4df30964fe8f2d/lib/extend/tag.js#L173</span></span><br><span class="line">    <span class="comment">// https://github.com/hexojs/hexo/blob/a6dc0ea28dddad1b5f1bad7c6f86f1e0627b564a/lib/plugins/tag/blockquote.js#L64</span></span><br><span class="line">    <span class="comment">// are we rendering a standalone post?</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">path</span>) &#123;</span><br><span class="line">        <span class="comment">// only apply template when rendering post, not tags</span></span><br><span class="line">        <span class="keyword">if</span> (config.<span class="property">template</span>) &#123;</span><br><span class="line">            extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;template&#x27;</span>, config.<span class="property">template</span>, <span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do not apply `--standalone`,</span></span><br><span class="line">        <span class="comment">// header/footer are to be added by Hexo</span></span><br><span class="line">        <span class="comment">// also set a metavariable to let concerned</span></span><br><span class="line">        <span class="comment">// pandoc filters know</span></span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">&#x27;standalone:true&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// or some thing to be embedded in a post,</span></span><br><span class="line">        <span class="comment">// like tags?</span></span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">&#x27;standalone:false&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> args = [</span><br><span class="line">        <span class="title function_">argument</span>(<span class="string">&#x27;from&#x27;</span>, markdown_mode),</span><br><span class="line">        <span class="title function_">argument</span>(<span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;html5&#x27;</span>),</span><br><span class="line">        math_engine,</span><br><span class="line">        ...extra,</span><br><span class="line">        ...lua_filters,</span><br><span class="line">        ...filters,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    log.<span class="title function_">debug</span>(<span class="string">&#x27;Pandoc command: %s&#x27;</span>, <span class="title function_">yellow</span>(<span class="string">`<span class="subst">$&#123;pandoc_bin&#125;</span> <span class="subst">$&#123;args.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> task = <span class="title function_">spawn</span>(pandoc_bin, args, &#123;</span><br><span class="line">            <span class="attr">env</span>: pandoc_env,</span><br><span class="line">            <span class="attr">cwd</span>: process.<span class="title function_">cwd</span>()</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> encoding = <span class="string">&#x27;utf-8&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> stdout_cache = <span class="keyword">new</span> <span class="title class_">CacheStream</span>();</span><br><span class="line">        <span class="keyword">const</span> stderr_cache = <span class="keyword">new</span> <span class="title class_">CacheStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task.<span class="property">stdout</span>) &#123;</span><br><span class="line">            task.<span class="property">stdout</span>.<span class="title function_">setEncoding</span>(encoding);</span><br><span class="line">            task.<span class="property">stdout</span>.<span class="title function_">pipe</span>(stdout_cache);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task.<span class="property">stderr</span>) &#123;</span><br><span class="line">            task.<span class="property">stderr</span>.<span class="title function_">setEncoding</span>(encoding);</span><br><span class="line">            task.<span class="property">stderr</span>.<span class="title function_">pipe</span>(stderr_cache);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (task.<span class="property">stdin</span>) &#123;</span><br><span class="line">            task.<span class="property">stdin</span>.<span class="title function_">setEncoding</span>(encoding);</span><br><span class="line">            task.<span class="property">stdin</span>.<span class="title function_">write</span>(data.<span class="property">text</span>);</span><br><span class="line">            task.<span class="property">stdin</span>.<span class="title function_">end</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> stderr_msg = <span class="title function_">get_cache</span>(stderr_cache, encoding);</span><br><span class="line">            <span class="keyword">if</span> (code) &#123;</span><br><span class="line">                <span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`pandoc process exited with code <span class="subst">$&#123;code&#125;</span>.<span class="subst">$&#123;stderr_msg.length &gt; <span class="number">0</span> ? <span class="string">`\n<span class="subst">$&#123;stderr_msg&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">                e.<span class="property">code</span> = code;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stderr_msg.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stderr_msg.<span class="title function_">endsWith</span>(<span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">                    stderr_msg = stderr_msg.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                log.<span class="title function_">debug</span>(<span class="string">`Pandoc:\n%s`</span>, <span class="title function_">yellow</span>(stderr_msg));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="title function_">get_cache</span>(stdout_cache, encoding));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;md&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;markdown&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mkd&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mkdn&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mdwn&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mdtxt&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mdtext&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h1 id="总结">总结</h1>
<p>写了很多，大概记录了一下 hexo
自定义插件过程，还有很多没有详细介绍的，有兴趣的话参照下方的参考链接进行自行编写即可，弄清楚逻辑后代码写起来还是很快的。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://hexo.io/zh-cn/docs/plugins">插件 | Hexo</a></li>
<li><a
href="https://github.com/wzpan/hexo-renderer-pandoc">wzpan/hexo-renderer-pandoc:
A pandoc-markdown-flavor renderer for hexo. (github.com)</a></li>
<li><a
href="https://nodejs.org/docs/latest-v18.x/api/child_process.html#child_processspawncommand-args-options">Child
process | Node.js v18.13.0 Documentation (nodejs.org)</a></li>
<li><a
href="https://github.com/moxystudio/node-cross-spawn">moxystudio/node-cross-spawn:
A cross platform solution to node's spawn and spawnSync
(github.com)</a></li>
<li><a href="https://pandoc.org/lua-filters.html">Pandoc - Pandoc Lua
Filters</a></li>
<li><a
href="https://github.com/wlupton/pandoc-lua-logging">wlupton/pandoc-lua-logging:
Pandoc lua filter logging support (github.com)</a></li>
<li><a href="http://www.lua.org/manual/5.4/">Lua 5.4 Reference Manual -
contents</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>pandoc</tag>
        <tag>node.js</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数执行原理理解</title>
    <url>/posts/55c5/</url>
    <content><![CDATA[<h1 id="虚函数执行原理理解">虚函数执行原理理解</h1>
<p>刷牛客时经常能刷到面向对象相关的题目，多态作为面向对象中的一个重要特性（封装，继承和多态），在八股中经常考察其实现原理。为了方便理解，我们给出一个简单的多态样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value + v; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value - v; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value * v; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> v * <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> value&#123;<span class="number">0xfeff</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> value + <span class="number">2</span> * v; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value * <span class="number">2</span> * v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> value&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就是经典调用函数写输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.value = <span class="number">2</span>;</span><br><span class="line">  A *a = &amp;b;</span><br><span class="line">  a-&gt;value = <span class="number">4</span>;</span><br><span class="line">  <span class="type">int</span> v = <span class="number">20</span>;</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;b.A::value=&#123;&#125;\nb.B::value=&#123;&#125;\n&quot;</span>, b.A::value, b.B::value);</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func1(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func1</span>(v));</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func2(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func2</span>(v));</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func3(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func3</span>(v));</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func4(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func4</span>(v));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>执行如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Cpp\learn-git&gt; xmake -brv learn-git &amp;&amp; xmake run learn-git</span><br><span class="line">[100%]: build ok!</span><br><span class="line">b.A::value=4</span><br><span class="line">b.B::value=2</span><br><span class="line">a-&gt;func1(20) = 42</span><br><span class="line">a-&gt;func2(20) = -16</span><br><span class="line">a-&gt;func3(20) = 80</span><br><span class="line">a-&gt;func4(20) = 40</span><br></pre></td></tr></table></figure>

<p>执行结果不难想到，根据虚函数运行时绑定的特性（晚绑定），通过基类调用虚函数时会根据实际类型调用对应的函数。对于非虚函数则是直接调用普通的成员函数（是
A 类时调用 <code>A::func3</code>，是 B 类时调用
<code>B::func3</code>），且需要调用的函数在编译期间就已经确定好了。</p>
<h2 id="成员函数指针">成员函数指针</h2>
<p>例子就介绍到这，下面我们要简单理解 C++
中实现原理，首先从成员函数指针来看，对于任意一个类别的成员函数，我们可以使用类似与函数指针的表达方式，即<code>void(T::*)()</code>，写成模板形式的话如下（当然，使用
<code>auto</code> 是最简单的，就是容易变成 auto
script，然后导致代码理解起来有困难）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">R</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如 <code>A::func1</code> 就可以采用如下的定义方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type ptr_test = &amp;A::test;</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/55c5/image-20230202162248754.png"
style="zoom: 67%;" /></p>
<p>可以看到，其实际上就是
<code>void (A::*)()</code>，但是这样比写函数指针稍微舒服一点，我们可以通过
<code>.*</code> 和 <code>-&gt;*</code> 的方式来调用成员函数指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(a-&gt;*ptr_test)();</span><br><span class="line">((*a).*ptr_test)();</span><br></pre></td></tr></table></figure>

<p>除此之外，我们也可以使用 <code>std::function</code>
的方式来封装封装成员函数，在函数的入参添加 <code>A*</code> 或
<code>A&amp;</code> 参数接口（对于 <code>const</code> 的函数还需要添加
<code>const</code> 修饰符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>(A*)&gt; std_ptr_test = &amp;A::test;</span><br></pre></td></tr></table></figure>

<p>然后在调用这个函数时将对象指针也作为参数传递过去即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std_ptr_test</span>(a);</span><br></pre></td></tr></table></figure>

<p>最后总结一下调用成员函数的几种方式（<em><strong>”茴“字的 4
种写法</strong></em>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常版</span></span><br><span class="line">a-&gt;<span class="built_in">test</span>();</span><br><span class="line"><span class="comment">// 指针版</span></span><br><span class="line">MemberFuncPtr&lt;A,<span class="type">void</span>&gt;::type ptr_test = &amp;A::test;</span><br><span class="line">(a-&gt;*ptr_test)();</span><br><span class="line"><span class="comment">// std::function 版</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(A*)&gt; std_ptr_test = &amp;A::test;</span><br></pre></td></tr></table></figure>

<p>之所以出现后面两种写法，主要就是为了实现
<code>Delegate</code>，当我们需要由代码来决定成员函数的调用时机时（例如事件响应等），我们就可以使用后面两种调用方式，不过在我们这里主要是探究虚函数的调用机制。</p>
<h2 id="成员函数指针的大小">成员函数指针的大小？</h2>
<p>当我们通过 <code>&amp;A::test</code>
拿到成员函数的地址时，我们自然将其联想到和普通函数指针大小一致，但是不然，<strong>其大小与不同的编译器有关（或者更准确的说，与
C++ Compiler ABI 有关）。</strong></p>
<p>我们在 <a href="https://godbolt.org">Compiler Explorer</a>
中进行运行测试（不支持 MSVC Compiler 的运行测试，但是可以测试 Clang 和
GCC）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof &amp;A::func = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(&amp;A::func) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下表所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Compiler</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">x86-64 gcc 9.4</td>
<td>16</td>
</tr>
<tr class="even">
<td style="text-align: left;">x86-64 clang 15.0.0</td>
<td>16</td>
</tr>
<tr class="odd">
<td style="text-align: left;">x86-64 msvc v19.25.28614 (default)</td>
<td>8</td>
</tr>
<tr class="even">
<td style="text-align: left;">x86-64 msvc v19.25.28614
(single_inheritance)</td>
<td>8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">x86-64 msvc v19.25.28614
(multiple_inheritance)</td>
<td>16</td>
</tr>
<tr class="even">
<td style="text-align: left;">x86-64 msvc v19.25.28614
(virtual_inheritance)</td>
<td>24</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：关于 MSVC 的成员函数指针大小的设置，参考<a
href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/pointers-to-members?view=msvc-160">pointers_to_members
pragma | Microsoft Learn</a>，可以手动指定成员函数指针形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pointers_to_members( full_generality, virtual_inheritance )</span><br></pre></td></tr></table></figure>

<ul>
<li>single_inheritance 表示单继承</li>
<li>multiple_inheritance 表示多继承</li>
<li>virtual_inheritance 表示虚继承</li>
</ul>
<p>如果不指定，就是根据函数类型自动选择空间最小的表示方式（也就是混合上面三种表示方式）</p>
</blockquote>
<h2 id="虚表和虚指针">虚表和虚指针</h2>
<p>对于一个包含虚函数的类而言，其会在类的起始处添加一个指向虚表的指针（vtable），称为虚指针（vptr）（在
MSVC C++ 中称为 vftable 和 vfptr）</p>
<p>虚表中存储了各种各样的类别数据信息（RTTI等），也存储了虚函数的实际地址，通过虚指针和虚表，我们就可以在运行过程中动态解析函数地址并进行调用。</p>
<p>MSVC、Clang 以及 GCC 中都提供了类内存布局查看的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gcc 调用命令</span></span><br><span class="line">g++ -fdump-lang-class=- test.cpp</span><br><span class="line"><span class="comment"># clang 查看命令 （-Xclang 表示传递后面的参数给 clang compiler） </span></span><br><span class="line">clang++-15 -Xclang -fdump-record-layouts test.cpp</span><br><span class="line">clang++-15 -Xclang -fdump-vtable-layouts test.cpp</span><br><span class="line"><span class="comment"># msvc 查看命令</span></span><br><span class="line">cl /d1 reportAllClassLayout test.cpp</span><br></pre></td></tr></table></figure>

<p>我们可以使用一个简单的类测试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>x86-64 gcc 9.4 输出结果</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">➜  src g++ -fdump-lang-class=- test.cpp</span><br><span class="line">Vtable for A</span><br><span class="line">A::_ZTV1A: 3 entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">8     (int (*)(...))(&amp; _ZTI1A)</span><br><span class="line">16    (int (*)(...))A::func</span><br><span class="line"></span><br><span class="line">Class A</span><br><span class="line">   size=16 align=8</span><br><span class="line">   base size=12 base align=8</span><br><span class="line">A (0x0x7ff174281420) 0</span><br><span class="line">    vptr=((&amp; A::_ZTV1A) + 16)</span><br></pre></td></tr></table></figure>

<p>x86-64 clang 15.0.7 输出结果</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">➜  src clang++-15 -Xclang -fdump-record-layouts test.cpp</span><br><span class="line"></span><br><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         0 | class A</span><br><span class="line">         0 |   (A vtable pointer)</span><br><span class="line">         8 |   int n</span><br><span class="line">           | [sizeof=16, dsize=12, align=8,</span><br><span class="line">           |  nvsize=12, nvalign=8]</span><br><span class="line">             </span><br><span class="line">*** Dumping IRgen Record Layout    </span><br><span class="line">...</span><br><span class="line">➜  src clang++-15 -Xclang -fdump-vtable-layouts test.cpp</span><br><span class="line">Vtable for &#x27;A&#x27; (3 entries).</span><br><span class="line">   0 | offset_to_top (0)</span><br><span class="line">   1 | A RTTI</span><br><span class="line">       -- (A, 0) vtable address --</span><br><span class="line">   2 | void A::func()</span><br><span class="line"></span><br><span class="line">VTable indices for &#x27;A&#x27; (1 entries).</span><br><span class="line">   0 | void A::func()</span><br></pre></td></tr></table></figure>

<p>x86-64 msvc 19.25.28614 输出结果</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Cpp\learn-git&gt; cl /d1 reportAllClassLayout test.cpp</span><br><span class="line">...</span><br><span class="line">class A size(16):</span><br><span class="line">        +---</span><br><span class="line"> 0      | &#123;vfptr&#125;</span><br><span class="line"> 8      | n</span><br><span class="line">        | &lt;alignment member&gt; (size=4)</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">A::$vftable@:</span><br><span class="line">        | &amp;A_meta</span><br><span class="line">        |  0</span><br><span class="line"> 0      | &amp;A::func</span><br><span class="line"></span><br><span class="line">A::func this adjustor: 0</span><br></pre></td></tr></table></figure>

<p>从图中我们可以看出，三个编译器给出的虚表结构以及内存布局基本一致，且虚指针就位于类的前8字节，可以使用
<code>reinterpret_cast</code>
来读取，而虚表本质上是一个指针数组。我们可以尝试直接从虚表中拿到虚函数的真实地址进行调用。代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> v + <span class="number">20</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="comment">// 读取类的前8字节，拿到虚表指针</span></span><br><span class="line">  <span class="type">uintptr_t</span> *vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span> **&gt;(&amp;a);</span><br><span class="line">  <span class="comment">// 从虚表中拿到虚函数的地址</span></span><br><span class="line">  <span class="type">uintptr_t</span> ptr_func = vptr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">using</span> Func = <span class="built_in">int</span> (*)(A *, <span class="type">int</span>);</span><br><span class="line">  Func f = <span class="built_in">reinterpret_cast</span>&lt;Func&gt;(ptr_func);</span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">f</span>(&amp;a, <span class="number">20</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a.func(20) = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  res = a.<span class="built_in">func</span>(<span class="number">20</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a.func(20) = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>uintptr_t</code> 表示和指针大小一致的整型数，在 64 位平台上就为
<code>uint64_t</code>，使用这个方便跨平台使用</p>
</blockquote>
<p>如果调用调用正确，我们可以看到两行一样的输出</p>
<p><img data-src="/posts/55c5/image-20230202183658979.png" /></p>
<p>输出的确如我们所愿（x86-64 msvc 19.25.28614）</p>
<p>再在 compiler explorer 上跑下 GCC 和 Clang 的结果</p>
<p><img data-src="/posts/55c5/image-20230202190619327.png"
style="zoom:67%;" /></p>
<p>GCC 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202190941102.png"
style="zoom:67%;" /></p>
<p>这个例子比较简单，没有考虑继承情况，以及最关键的 this
指针问题，下面给一个稍微复杂一点的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v = &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> v + n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> n&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> n, <span class="type">int</span> f) : <span class="built_in">A</span>(n), <span class="built_in">f</span>(f) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v = &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f = &quot;</span> &lt;&lt; f &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> v + n + f;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> f&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  A *a = &amp;b;</span><br><span class="line">  <span class="type">uintptr_t</span> *vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span> **&gt;(&amp;b);</span><br><span class="line">  <span class="type">uintptr_t</span> ptr_func = vptr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">using</span> Func = <span class="built_in">int</span> (*)(A *, <span class="type">int</span>);</span><br><span class="line">  Func f = <span class="built_in">reinterpret_cast</span>&lt;Func&gt;(ptr_func);</span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">f</span>(a, <span class="number">30</span>);</span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  res = a-&gt;<span class="built_in">func</span>(<span class="number">30</span>);</span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MSVC 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202192352189.png"
style="zoom:67%;" /></p>
<p>GCC 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202192817764.png"
style="zoom:67%;" /></p>
<p>Clang 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202192847211.png"
style="zoom:67%;" /></p>
<h2 id="虚函数调用过程">虚函数调用过程</h2>
<p>最后，我们可以尝试理解成员函数指针到底是什么？为什么其比寻常的函数指针更大？</p>
<p>我们直接将其转换成字节数组，然后读取其值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">Ret</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> size_a = <span class="built_in">sizeof</span>(&amp;A::func);</span><br><span class="line">  <span class="type">uint8_t</span> bytes[size_a];</span><br><span class="line">  MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type ptr = &amp;A::func;</span><br><span class="line">  std::<span class="built_in">copy</span>(&amp;ptr, &amp;ptr + size_a, bytes);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint8_t</span> v : bytes) &#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; (<span class="type">uint32_t</span>)v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结果会随着编译器不同有所改变，在 MSVC 下，输出结果如下</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[ 4d 40 8c 7a f7 7f  0  0 ]</span><br></pre></td></tr></table></figure>

<p>而在 Clang 和 GCC 下，二者输出都是</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br></pre></td></tr></table></figure>

<p>一个好像看不出什么结果，我们多弄点类和继承，再来看看效果</p>
<p>测试代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">Ret</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_bytes</span><span class="params">(<span class="keyword">typename</span> MemberFuncPtr&lt;T, Ret, Args...&gt;::type func_ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(func_ptr);</span><br><span class="line">  std::array&lt;<span class="type">uint8_t</span>, size&gt; content;</span><br><span class="line">  <span class="type">uint8_t</span> *arr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(&amp;func_ptr);</span><br><span class="line">  std::<span class="built_in">copy</span>(arr, arr + size, content.<span class="built_in">begin</span>());</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint8_t</span> v : content) &#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; (<span class="type">uint32_t</span>)v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;A::func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(&amp;A::func1);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;A::func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(&amp;A::func2);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;B::func3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;B, <span class="type">void</span>&gt;(&amp;B::func3);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;B::func4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;B, <span class="type">void</span>&gt;(&amp;B::func4);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func1);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func2);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func3);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>msvc （添加 <code>/RTC1</code> 标志，将所有未初始化的栈上内存标记为
<code>0xcc</code> ）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&amp;A::func1</span><br><span class="line">[ a2 40 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;A::func2</span><br><span class="line">[ 87 1a 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;B::func3</span><br><span class="line">[ b8 2a 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;B::func4</span><br><span class="line">[ bf 3c 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;C::func1</span><br><span class="line">[ a2 40 4e 34 f6 7f  0  0  0  0  0  0 cc cc cc cc ]</span><br><span class="line">&amp;C::func2</span><br><span class="line">[ 87 1a 4e 34 f6 7f  0  0  0  0  0  0 cc cc cc cc ]</span><br><span class="line">&amp;C::func3</span><br><span class="line">[ b8 2a 4e 34 f6 7f  0  0  8  0  0  0 cc cc cc cc ]</span><br><span class="line">&amp;C::func4</span><br><span class="line">[ bf 3c 4e 34 f6 7f  0  0  8  0  0  0 cc cc cc cc ]</span><br></pre></td></tr></table></figure>

<p>GCC / Clang</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&amp;A::func1</span><br><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;A::func2</span><br><span class="line">[  9  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;B::func3</span><br><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;B::func4</span><br><span class="line">[  9  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func1</span><br><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func2</span><br><span class="line">[  9  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func3</span><br><span class="line">[  1  0  0  0  0  0  0  0  8  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func4</span><br><span class="line">[  9  0  0  0  0  0  0  0  8  0  0  0  0  0  0  0 ]</span><br></pre></td></tr></table></figure>

<p><code>  print_bytes&lt;A, void&gt;(&amp;A::func1);</code>
可以对应到下面的汇编</p>
<p>MSVC</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lea     rcx, OFFSET FLAT:[thunk]:A::`vcall<span class="number">&#x27;</span>&#123;<span class="number">0</span>,&#123;flat&#125;&#125;<span class="string">&#x27; &#125;&#x27;</span>            ; A::`vcall<span class="number">&#x27;</span>&#123;<span class="number">0</span>&#125;&#x27;</span><br><span class="line">call    <span class="type">void</span> <span class="built_in">print_bytes</span>&lt;A,<span class="type">void</span>&gt;(<span class="built_in">void</span> (__cdecl A::*)(<span class="type">void</span>)) ; print_bytes&lt;A,<span class="type">void</span>&gt;</span><br></pre></td></tr></table></figure>

<p>GCC 对应调用的汇编</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mov     r12d, <span class="number">1</span></span><br><span class="line">mov     r13d, <span class="number">0</span></span><br><span class="line">mov     rcx, r12</span><br><span class="line">mov     rbx, r13</span><br><span class="line">mov     rax, r12</span><br><span class="line">mov     rdx, r13</span><br><span class="line">mov     rax, rdx</span><br><span class="line"># 最终 rdi = <span class="number">1</span>, rsi = <span class="number">0</span></span><br><span class="line">mov     rdi, rcx</span><br><span class="line">mov     rsi, rax</span><br><span class="line">call    <span class="type">void</span> <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type)</span><br></pre></td></tr></table></figure>

<p>Clang 对应汇编</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mov     qword ptr [rbp - <span class="number">24</span>], <span class="number">0</span></span><br><span class="line">mov     qword ptr [rbp - <span class="number">32</span>], <span class="number">1</span></span><br><span class="line"># 最终 rdi = <span class="number">1</span>, rsi = <span class="number">0</span>    </span><br><span class="line">mov     rdi, qword ptr [rbp - <span class="number">32</span>]</span><br><span class="line">mov     rsi, qword ptr [rbp - <span class="number">24</span>]</span><br><span class="line">call    <span class="type">void</span> <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type)</span><br><span class="line">mov     rdi, qword ptr [rbp - <span class="number">160</span>]      # <span class="number">8</span>-byte Reload</span><br></pre></td></tr></table></figure>

<p>从结果中可以很清楚的看到，MSVC 和 GCC、Clang
的输出结果完全不一样，但从 MSVC
的结果上来看，存储的确实应该是一个指针，对于多继承情况下还包含一个4字节（<code>uint32_t</code>）的偏移量，而
GCC 和 Clang 是两个64位的值。</p>
<p>根据网上搜集的资料，我们可以得到这两个结构体的含义</p>
<ul>
<li><p><a href="https://rants.vastheman.com/2021/09/21/msvc/">MSVC C++
ABI Member Function Pointers « Rants from Vas
(vastheman.com)</a></p></li>
<li><p><a
href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#member-pointers">Itanium
C++ ABI (itanium-cxx-abi.github.io)</a></p></li>
</ul>
<p>MSVC C++ ABI member function pointer 结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// single inheritance</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">  <span class="comment">// thunk function pointer</span></span><br><span class="line">  <span class="type">uintptr_t</span> ptr;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// muiltiple inheritance</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">    <span class="comment">// thunk function pointer</span></span><br><span class="line">    <span class="type">uintptr_t</span> ptr;</span><br><span class="line">    <span class="comment">// adjustor</span></span><br><span class="line">    <span class="type">uint32_t</span> adj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GCC / Clang Itanium C++ ABI member function pointer 结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc / clang</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">    <span class="comment">// function pointer / vtable offset in bytes</span></span><br><span class="line">    <span class="type">uintptr_t</span> ptr;</span><br><span class="line">    <span class="comment">// adjustor</span></span><br><span class="line">    <span class="type">ptrdiff_t</span> adj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在 x86-64 上，通过 ptr
的最后一位判断是否是虚函数，因为虚函数指针大小为 8 字节，也就是说 ptr
的值一定是偶数，即 ptr 的最后一位永远都是
0，这样对于普通函数而言，这个值就为偶数，而虚函数则是奇数。</strong></p>
<p><strong>在 arm 上，对于虚函数的判断方式转换成了 adj，通过 adj
的最后一位标识是否是虚函数</strong></p>
<p>这样，我们可以尝试解析成员函数指针并进行调用（仅限于 Itanium C++
ABI，也就是 GCC 和 Clang，对于 MSVC
实在是没办法，居然是又新增了一段跳转函数，属实是恶心人了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> n + v; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> n - v; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">Ret</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr;</span><br><span class="line">  <span class="type">ptrdiff_t</span> adj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">member_func_info</span></span><br><span class="line"><span class="function"><span class="title">from_raw</span><span class="params">(<span class="keyword">typename</span> MemberFuncPtr&lt;T, Ret, Args...&gt;::type func_ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;member_func_info *&gt;(&amp;func_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">Ret <span class="title">invoke</span><span class="params">(T *obj, <span class="keyword">typename</span> MemberFuncPtr&lt;T, Ret, Args...&gt;::type func_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">           Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr_this = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(obj);</span><br><span class="line">  member_func_info func_info = <span class="built_in">from_raw</span>&lt;T, Ret, Args...&gt;(func_ptr);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&lt;ptr=&quot;</span> &lt;&lt; func_info.ptr &lt;&lt; <span class="string">&quot;,adj=&quot;</span> &lt;&lt; func_info.adj &lt;&lt; <span class="string">&quot;&gt;&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">uintptr_t</span> adj_this = ptr_this + func_info.adj;</span><br><span class="line">  <span class="type">uintptr_t</span> vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span> *&gt;(adj_this);</span><br><span class="line">  <span class="type">uintptr_t</span> func_address = vptr + func_info.ptr &amp; (~<span class="number">0x1</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  // arm case</span></span><br><span class="line"><span class="comment">  uintptr_t adj_this = ptr_this + func_info.adj &gt;&gt; 1;</span></span><br><span class="line"><span class="comment">  uintptr_t vptr = *reinterpret_cast&lt;uintptr_t *&gt;(adj_this);</span></span><br><span class="line"><span class="comment">  uintptr_t func_address = vptr + func_info.ptr;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// call function</span></span><br><span class="line">  <span class="keyword">using</span> Func = <span class="built_in">Ret</span> (*)(T *, Args...);</span><br><span class="line">  Func f = *<span class="built_in">reinterpret_cast</span>&lt;Func *&gt;(func_address);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>(obj, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">  <span class="comment">// 主打的就是一个脱裤子放屁</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">invoke</span>&lt;A, <span class="type">int</span>&gt;(&amp;a, &amp;A::func2, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">  a.<span class="built_in">func2</span>(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img data-src="/posts/55c5/image-20230202221518873.png" /></p>
<p>对于 clang 也是一样</p>
<p><img data-src="/posts/55c5/image-20230202223902378.png" /></p>
<h2 id="总结">总结</h2>
<p><strong>虚函数的出现是因为我们无法在静态编译过程中确定要执行的函数，需要动态查找待执行的函数</strong>。具体而言就是通过对象示例中存储的一个指向虚函数表（vtable）的虚指针（vptr），结合待调用的虚函数信息（在
vtable 上的偏移量）获取到实际的函数地址，最后调用函数。</p>
<p>对于普通的函数而言，在静态编译过程中能够获取到函数地址，而虚函数则多了一个查找的过程（虚继承情况可能还要再多一次虚基的寻址过程）。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串编码</title>
    <url>/posts/c4ef/</url>
    <content><![CDATA[<h1 id="字符串编码">字符串编码</h1>
<p><em><strong>Encodings should be known, not divined.</strong></em></p>
<h2 id="问题描述">问题描述</h2>
<p>在前一篇我们使用 pandoc 的 lua filter 解决了 markdown 转 html
中链接问题，但是在调试代码的过程中发现了一个问题，在不同的 shell 中执行
lua
脚本时，输出中文有时会乱码，有时又不会乱码，搞得有点烦，本篇就针对字符串问题做一个探究，搞清楚乱码的源头以及解决方案。</p>
<p>首先看一个简单的示例，下面是一段简单的 c 语言 hello world</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你好，世界！😉&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件保存格式为：<code>UTF-8</code>（注意看 vscode 的右下角，写着
UTF-8）</p>
<p><img data-src="/posts/c4ef/image-20230117150536045.png"
style="zoom:50%;" /></p>
<span id="more"></span>

<p>使用 msvc 编译后，分别在 git
bash、msys2、powershell上运行后输出结果如下</p>
<p><img data-src="/posts/c4ef/image-20230117150241891.png"
style="zoom: 67%;" /></p>
<blockquote>
<p>注：使用 msvc 编译 UTF-8 文件时，需要添加 <code>/utf-8</code>
参数，否则会使用本机默认编码进行编译，有可能导致编译失败。</p>
<p><img data-src="/posts/c4ef/image-20230119233748271.png" /></p>
</blockquote>
<p>可以看到，仅在 git bash 中能正确输出中文，如果我们将编码保存为
GBK，再编译运行</p>
<p><img data-src="/posts/c4ef/image-20230117151454957.png"
style="zoom:50%;" /></p>
<p>输出结果如下：</p>
<p><img data-src="/posts/c4ef/image-20230117152301608.png"
style="zoom: 67%;" /></p>
<p>可以看到此时在 Git Bash 中输出乱码了，而在 msys2 和 powershell
中可以正确输出中文了，但是 emoji 的输出还是有问题（变成了问号）</p>
<p>再使用 python 输出上面那句话看看效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你好，世界！😉&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>分别在三个终端中进行测试，输出结果如下</p>
<p><img data-src="/posts/c4ef/image-20230117154659021.png"
style="zoom: 67%;" /></p>
<p>此时 git bash 中直接报错，说 GBK 无法解析 <code>U+1F609</code>
也就是笑脸 😉 ，而在 msys2 和 powershell 中均可以正确输出中文，但是
powershell 中无法输出 emoji 表情，而 msys2 可以正确输出。</p>
<p>这个结果更令人费解了，C 语言和 Python
输出结果不一致，在不同终端下输出也不一样。</p>
<h2 id="编码简史">编码简史</h2>
<p>关于编码的发展过程，下面这篇文章做了很好的介绍</p>
<blockquote>
<p><a
href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">The
Absolute Minimum Every Software Developer Absolutely, Positively Must
Know About Unicode and Character Sets (No Excuses!) – Joel on
Software</a></p>
</blockquote>
<p>参考这篇文章，我们做一个简单的总结。</p>
<h3 id="ascii">ASCII</h3>
<p>在计算机中，所有数据都是以二进制形式存储的，我们在屏幕上阅读的文字如
“A”，“你好”
等也需要以二进制形式存储。<strong>编码描述的就是我们如何将可阅读的字符存储在计算机中</strong>。
ASCII ( /ˈæski/ )
编码是早期常用的一种编码（现在也很常用，只不过是其他编码兼容该编码罢了）。其包含128个字符，使用
8 位存储（剩下的 128 - 255 部分称为扩展 ASCII
编码，不过并不常用），下图展示了所有的ASCII字符及其对应的编码值（图片来自：<a
href="http://www.asciicharstable.com/"><span>http://www.asciicharstable.com/</span></a>）</p>
<p><img data-src="/posts/c4ef/ascii-chars-table-landscape.jpg"
style="zoom: 25%;" /></p>
<p>例如大写字母 <code>A</code> 对应的 ASCII 十进制编码就是
<code>65</code>，也即二进制的 <code>0b01000001</code> 和十六进制的
<code>0x41</code>。</p>
<p>从表中可以看到，仅包含大小写字母，而中文、俄语等文字并不包括在内。为了解决这个问题，一些厂家就自定义了一套编码格式，从而支持其他语言的字符显示。但是厂家自定义的编码并不能跨平台，例如在
IBM 上编写的文档就有可能无法在 Mach 上打开，因为他们使用的编码不同。</p>
<h3 id="ansi">ANSI</h3>
<p>厂家自定义编码太杂乱，为了实现跨平台，后来就统一了编码（车同轨，书同文？），称为
ANSI 编码。ANSI 编码并不将所有的字符都编码到一张表上，其仅确保前 128
个字符（也就是 ASCII 编码部分）是一致的，后面部分的编码由代码页（code
page）决定，不同地区使用不同的代码页，从而在不同地区显示不同的文字。目前
Windows
仍然支持的这种编码方式，可以在控制面板的时钟和区域中进行设置。</p>
<p><img data-src="/posts/c4ef/image-20230118163241733.png"
style="zoom:50%;" /></p>
<p>对于中日韩文而言，其使用的是表意文字（ideograph），可能包含数万个字符，仅使用
8 位显然是无法表示这些字符的。后面就将 ANSI 编码扩展到了两个字节，其中
<code>0x80</code> 至 <code>0xFFFF</code>
部分由代码页来决定编码。中文对应的编码方式有 GB 2312 及其扩展
GBK（<strong>G</strong>uo jia <strong>B</strong>iao zhun
<strong>K</strong>uo zhan，国家标准扩展）。</p>
<blockquote>
<p>注：GBK 和 ANSI 的关系：GBK 属于 ANSI
的一部分，其专门负责对中文进行编码，而其他字母等仍使用 ASCII
编码，例如一段话</p>
<p><code>Hi, 你好</code>，对应的 GBK ANSI 编码为，其中 <code>Hi,</code>
仍是单字节编码，而后面的 <code>你好</code> 则是双字节编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0x48,0x69,0x20,0xC4,0xE3,0xBA,0xC3]</span><br></pre></td></tr></table></figure>

<p>GBK 实际上是一个定长编码，其描述的所有字符都是双字节，但是此时 ANSI
就是一个变长编码，其既包含单字节字符，也包含双字节字符。</p>
</blockquote>
<p>在 Windows 下，可以使用 <code>chcp</code> 命令查看当前控制台使用的
ANSI 代码页（同时也可以使用该命令切换控制台使用的代码页）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Users\xiao&gt; chcp</span><br><span class="line">活动代码页: 936</span><br></pre></td></tr></table></figure>

<p>在程序中可以使用 <code>GetACP()</code>
函数来查询程序中使用的代码页（需要调用 Windows API）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winnls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current Windows ANSI code page identifier is: %u&quot;</span>,<span class="built_in">GetACP</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Cpp\encoding-demo\bin&gt; .\test.exe    </span><br><span class="line">current Windows ANSI code page identifier is: 936</span><br></pre></td></tr></table></figure>

<p>在微软 win32 文档中给出了代码页标识符的相关描述：<a
href="https://learn.microsoft.com/en-us/windows/win32/intl/code-page-identifiers">Code
Page Identifiers - Win32 apps | Microsoft Learn</a></p>
<p><img data-src="/posts/c4ef/image-20230118172323075.png"
style="zoom:50%;" /></p>
<p>可以看到，本机 Windows 的ANSI代码页编号为 936，对应 GB2312
编码，而后续 GBK 发布后更新了 GBK 部分的字符，因此也常称为 GBK
编码。</p>
<p>采用代码页的方式在单语言场景下足够使用了，但是有时我们可能会浏览其他语言的网站，或接收到其他语言的邮件，我们的系统上就无法显示这些字符了（代码页并不能随便切换）。</p>
<p><strong>彩蛋：”烫烫烫烫烫烫烫烫...“？</strong></p>
<p>在 GBK 编码中，烫的编码为 <code>[0xCC,0xCC]</code>，在 MSVC
的调试模式下，会自动将未初始化的内存设置为
<code>0xCC</code>（字节），用来进行 <a
href="https://learn.microsoft.com/zh-cn/cpp/build/reference/rtc-run-time-error-checks?view=msvc-170">运行时错误检查</a>。</p>
<p>添加 <code>/RTC1</code>
编译标志即可开启检查功能，我们进行调试时，就会看到如下字样</p>
<p><img data-src="/posts/c4ef/image-20230120002426547.png"
style="zoom: 50%;" /></p>
<p>下面是测试代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处故意不初始化</span></span><br><span class="line"><span class="type">uint32_t</span> v;</span><br><span class="line"><span class="type">uint8_t</span> *arr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(&amp;v);</span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出结果就为 <code>烫烫</code></p>
<p>除了 <code>烫</code>，还有可能出现 <code>屯屯屯屯</code>，因为 MSVC
在调试时会将动态分配的内存值初始化为 <code>0xCD</code>，而
<code>屯</code> 的 GBK 编码刚好是 <code>[0xCD,0xCD]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;烫&quot;</span>.encode(<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;\xcc\xcc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;屯&#x27;</span>.encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;\xcd\xcd&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="unicode">Unicode</h3>
<p>为了解决在同一系统上的跨语言显示问题，就只能将全部字符编码到一张表上，这种表示方式称为
Unicode，中文称为 <strong>统一码</strong>，不过一般直接说 Unicode
即可。注意这里我们用的表述是
字符的<strong>表示方式</strong>，而不是编码方式。Unicode
为每一个字符分配一个 code point（码点），就唯一表示一个字符，例如
<code>你</code> 的 Unicode 码点为 <code>U+4F60</code>，<code>U+</code>
前缀就表示这是一个 Unicode 码点，后面的十六进制就表示具体的代码值。</p>
<p><strong>码点和编码之间并不是一一对应关系，码点只是一个形式化的表示方式（可以理解为字符在字符空间中的一个坐标），其并不关心具体如何在计算机中存储的</strong>。UTF
(<strong>U</strong>nicode <strong>T</strong>ransformation
<strong>F</strong>ormat，Unicode 传输格式)
才是决定具体如何在计算机中存储和传输的，根据使用场景不同，包含以下六类：</p>
<ul>
<li>UTF-8</li>
<li>UTF-8 with BOM</li>
<li>UTF-16 LE</li>
<li>UTF-16 BE</li>
<li>UTF-32 BE</li>
<li>UTF-32 LE</li>
</ul>
<p>注：BOM 表示 <strong>B</strong>yte <strong>O</strong>rder
<strong>M</strong>ark，字节顺序标志，LE 和 BE 分别代表 Little Endian
（小端）以及 Big Endian （大端）</p>
<h4 id="大小端与字节顺序">大小端与字节顺序</h4>
<p>大小端描述的是字节在多字节数据中的存储顺序，例如一个
<code>uint32_t</code> 是 4 个字节，例如
<code>0x1f2f3f4f</code>，其各字节信息如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Value(uint32_t): 0x1f2f3f4f</span><br><span class="line">Byte View:</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">| bits |   0..7   |   8..15  |  16..23  |  24..31  |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">| byte |  byte[0] |  byte[1] |  byte[2] |  byte[3] |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">|  hex |    4f    |    3f    |    2f    |    1f    |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">|  bin | 01001111 | 00111111 | 00101111 | 00011111 |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>而其实际在内存中存储按字节顺序可以分为两种存储顺序</p>
<ul>
<li><p><strong>按内存地址从低到高，字节顺序从低字节到高字节存储</strong></p>
<p>这种字节排列顺序称为小端，因为低位字节（小值）优先存储</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Little Endian Memory View:</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">| addr | 0x1fdd3356050 | 0x1fdd3356051 | 0x1fdd3356052 | 0x1fdd3356053 |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  hex |       4f      |       3f      |       2f      |       1f      |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  bin |    01001111   |    00111111   |    00101111   |    00011111   |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>按内存地址从低到高，字节顺序从高字节到低字节存储</strong></p>
<p>这种字节排列顺序称为大端，因为高位字节（大值）优先存储</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Big Endian Memory View:</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">| addr | 0x1fdd3356550 | 0x1fdd3356551 | 0x1fdd3356552 | 0x1fdd3356553 |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  hex |       1f      |       2f      |       3f      |       4f      |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  bin |    00011111   |    00101111   |    00111111   |    01001111   |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注：<strong>无论是大端还是小端，一个字节中的 bit
的排列顺序永远都是从低位到高位</strong></p>
<blockquote>
<p>大端和小端出自 Jonathan Swift 的《格列佛游记》（Gulliver's
Trabels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。</p>
<p>一下是 Jonathan Swift 在1726年关于大小端之争的历史描述：</p>
<p><em>“......下面要告诉你的是，Lilliput 和 Blefuscu
这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋是碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由
Blefuscu
的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。”</em></p>
<p><em>（此段译文摘自网上蒋剑锋译的
《格列佛游记》第一卷第4章。）</em></p>
<p><img data-src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHCBIUEhcVEhUYFxcZGRoXGRoZGhocIB0aGBciHRgaIBoaICwkICEpIhoZJDYkKS0vNDMzGSI4PjgzPSwyMzUBCwsLDw4PHhISHTMjIiM6Ly8vMzM6Mi8yOjIvMjI0LzQ0LzIyMi8yMjIzLzIyMjo7MjQyLzQ0MjIzMjIyMjIvL//AABEIAJ8BPgMBIgACEQEDEQH/xAAbAAEBAAMBAQEAAAAAAAAAAAAABgEEBQMHAv/EAEcQAAEDAgQDBQMICAMHBQAAAAEAAgMEEQUSITEGQVETIjJhcRSBkQcjM0JSYqGxFSQ0Q1NyksGisvEWF0Rjg8LRNoKT0vD/xAAaAQEAAwEBAQAAAAAAAAAAAAAAAQIDBAUG/8QALhEBAAICAQMCBAMJAAAAAAAAAAECAxEEEiExQVEiYYGRE6HwFCMyQmJxscHx/9oADAMBAAIRAxEAPwD7MiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiIMIpziDjKiozkkkzynwwxjPITyGUbX+8QuGcVxqr/Z4Y6CI7ST9+W1tCIho0+Th71S161jdp0a2vS4AXOgXEr+LsOhJEtXC0jdoe1zv6W3Km/wDYNkuuIVVTVnS7XyFkd/KNm3xXYoeFsPht2VJC0jmY2ud/U+5/FctubjjxuV4pLSf8qOE7MlfIfuQyn82hef8AvQouUNWR17A/+VTsaG+EBvoLfkv3nPUrOef7V/M6EzH8qGFbPlkjP34ZB/laV38N4loanSCpikP2Q8Zv6Tr+C9HsDtHAOHmAfzXDxLg/DqgHtKWK5+sxuR39Udj8VavPr6wdCvRfOxw/iFH3sOrHSRjU09Wc7bdGybs05aDqVv8ACPyhUta7sX2hqAS3s3ODmvI37N40d6b9LjVddMtckbrKsxpbIiLRAiIgIiICIiAiIgIi5eMY7S0jc1VMyIcg494/ytHed7gg6aKDPHss+mG0E9QOUkloYzfmHP39NF+XRY/P46ilpAdhFGZXgdCZO78Cs75aV8ymImV8sr587g+pf9Pitc4/8pzYh8G3WBwBTfWqa5x6mod/9VjPMxR6p6ZfQUXz48AQj6Orr4z1bUH+7Vn/AGbxKK3suKzG31ahjZQfIuOvvsleXin10dMvoCKBbxFi9L+20bamMby0Zu4AczE7U+6wVJgHE9JWtvTShzh4mHuvb/Mw6j12810VtW0bidqu2iIrAiIgIiICwsqR4o4uFO8U1LH7RWP8MTTowH68jvqtG9ufkNVEzodnHMcpqOIy1MgY3YX1c49GtGpPoo51TimJ+HNh9IeZ/aJGnoPqA9d/ULawXhQ9r7ViL/aao6i+scXPLGw6afat/dVS4M3M9KfdpWvu4+A8NUlGPmIwHnxSu70jidyXnXXoLDyXXRF51rTadzO1ojQiIqJEREBfmWRrGlzyGtaCXOJsABqSSdgv0of5RMPqpBG9rXTUcZDqinjJbI8A3vmF87RvlFtve3XFSL21M6RM6edRUTYy90VO50WHtOWWYaPqCN42X2byJ58+i79fwlRS0raYxBjGD5tzNHsd9tr9819Te9+d1tcPYjS1FO11G5vZABoa0BuSw8BZ9UjoumtL5bVnVfh1+u6NJThvHaimqG4diTsznD9VqdhM0fUd0kGnrsdbF16pfibA462ndE/uu8UTxuyQeB4I19fK68+A8dfUwvhqNKqmd2U4+0R4ZB5OAOvUG2ll6XGz/i17+YUtGlaiIulUREQEREGFyce4gpaKPtKmRrB9UbucejWjUqexvjGR8xpMKjFRUDR8h+ih5Xe4bnfujpzOi4OKYdHh8Zq6h5rcRlIjhdIL/Ou0aI49mtbe/wCAteyyvlrWdeZn0TEMxcW4jidU+mo2miiYA6WV7c0oafCMp7rXO5DewJvou9hPBVFA7tHNNRMdTLUHtHk9e9oPcL+a2OEcC9jpgxxzzSEyzv3LpH6uN+YGw+PMruLzeRybWtqs9l61ZWERca4iIoBERBlTuPcJQVLhKwugqW6sni7rwfvW8Y9dbc1QotKXtSd1lExtM4BxRNFO2ixUNbOfoZm6MnA/Br+o015C4vcKa4gwOGsgdDMNN2OHiY8eF7TyI/EaLR4IxyYukoK4/rVPazv40P1ZRfc6gH1HO4Hr8fkRljXrDOY0tERF0qiIo/5QMaliiipqQ/rVW/soz9hv7yTyyg78r35KJnQ1OIOJ5ppnUOF2dONJpzqynGx12c/ew69SDbf4b4chomEMu+R/elmfq+R25JJ1tfl+ZuV7cPYJDRU7YYRoNXuPie8+J7jzJ/AWHJdNeRyOTN51Xw0rXQiIuNcREQEREBERAWVhEEljXC8rJTV4Y9sNT+8jP0c43s9uwd978jqt3hviiOqLoXtMFVHpLA/RwI3LftN53HIjqCtjiXiGGiiD33fI85YomavkfsGtHS5Fz58zYHlcOcPSun9vxCzqpwtGweGnZrZjertTc8rnzK6/4se8n0n1/wCKevZWqNx39SxOlrW6RzkUdT0u76GQ+YIsSeTLc1ZLgcd4f7RhtTHa5EZkb1zR99tvXLb3qvGydGSJ+ibRuFki5HC2Impoaec7yRMc7+a1n/4gV117bIREQeUkjWtLnEAAEkk2AA3JJ2C+eV2L1OLSOgoHGGjack1UNHSW8UcXl97z6aO866WTGal8THubhsDsshYbGplbqWh32B1G+/MFtpTU7I2NjjYGMYA1rWiwAHIBcXJ5P4favn/C9a7a2D4RBSRCKnjDGD4uP2nO3cfMqV4l+Yxajq6jv05a6BhO0Ez9nn+ba52segVwuBxpLReySR10rIo5GkC+rsw1a5jBcuINjoOS4MN5m/fvvtPv3WmOygWFMfJ5ic89Cz2hjw9ncD3tLe1YPA8ZtTcWBPUX5qnWeSnRaa+yYERFmkREQEREBERAUhx7SPjbFiNOPnqN2Zw2zwHSRhPSxJ8hmVevzJG17S1wu1wLXA82kWI94WuHJOO8TCJjcNvD6xk0TJYzdkjGvafuuFx+a2lC/JhK6OKooXm7qOd8bb7mJ5Lo3H179vIK5XvRO42xF89wv9axqsqHaspWMpIugeQXSkeYOZvo5fQl8++TkXjrXnxPr6ku/wAP/wC965+VbpxStXyr0RF4jUREQEREBERAREQFxOJuI46Nje6ZJnnLDCzV73nbQahvV3wudF21xeJOG4K2MB+ZkjDmjmZpIx3Ihw3F92/kbEa4ujq+Pwid+jm8M8NSCU1uIuElY8aDdkDT+7YNr2Ni71sTcudWKMwviOelmbSYtZrzpDVDSOYcg47Mf1/G2hdaK2eL9W5+ntr5FdMI5gcC07HQ+h0KJmA1Ow1PuWMeUpv5I3H9FRsP7uSaP4SuP/crdQ/yRAnC2PP7yWZ498pH/aVcL6NgwpP5R8WfT0LhD9NO9tNFbfPLoSDyIaHWPWyrFCcXfO4vhkJ8LO3qHD7zGDIfcR+Kra2qzPsO1gWFMpKaOnj8MbQ0n7Tt3u9S4k+9b5Om1/Ic/LVEXgWmZnctnzXiDjarFQKbJ+jWO09oqWOeTt4AwOj573I+8FQcPcKULSKnP7bK7X2iR4lufu6lrbctyOqpqiBkjCyRjXsdoWvaHNPq06FStVwHA15koJZaKQ7mFxLHdM0bjYjyBA12XTGWk16Y+H9fdXUq5FCYHxBiArzQythq8gBkniLmdm374y5c/wBxoGp33tdrDLjmk6laJ2IiLJIiIgIiICIiAiIglMI+a4hqWDaoo45j/NE4RjT0zFXqgXf+o4bbigfm9O2db8VfFe/gneOv9mM+RfPeEfmK/EqN2h7f2tn3mTgE28mnI2/Ur6EojjrC5mSRYlRszT04LZIx+9gOr2abltyR6ncgBM2PrpNSJ1KlRaGC4xDVwNmp35mu+LXc2OHJw6e/Zb68K1ZrOpbbERFUEREBERAREQERCeqDUxPDYamJ0VQwSRu3B68iDuCORGqh48VlwaaOlqZDUUshtA+4dPHrYMdGO89mtgQPTk1dGv4rlqZHU2ENEsg0kqXfQx+h+u7oBcfzarocPcJxUzzNI91RVO1fPJq6/MMB8LeWmttL20XZX93XWTxPp/v5KeZ7KIFcHjnEvZsOqJL2d2ZjZ1zydxtvTNf3LvKNxke3YrT0bdYqUirqTyzj6GM+etyDuHHoqcbH15I+6bdoVnCmGmloaeAixZEwO/nIu/8AxErsoi9tkwoTic5Maw158MjKiG/R2S7R7yQrtSnyhYRJUUmen/aKd7aiG25fHqW+dxfTmQFW9eqsx7ph2lhczh3Go6ymZURbPHebza8eNh9D8RY81018/es1nUtYkUlxLjsz5vYMP1qXC8sm7aeM7vcftkEWHmOZCrVIcZ4bLHIzEqQXngFpGD99B9dp6lo1H/kBaYOnr7/T236Is7XDuBQ0UAiiBJJzPe7xPed3uPXy5LqrTwnEYqmCOeF2Zj25genItPQg3BHULcVLzabT1eUwIiKiRERAREQEREBEWrileynhkmk8ETHPd55RoB5k2A8yrREzOoE/w+O2x2slA7tPBFSg8i557R3vBaR/qrxR3yZYe9lD2030tXI+qk/6h7g9MoBt94qxXv0r01iPZgyiIriFxng+WOZ1XhLxDM7WSF30M3q0eFx6jz2JJX5wfjGN8ns9ZG6jqtuzk0a/zZJ4XA8vwvurtczGsDpquPs6qJsjeVxq09WuGrT5grDLgpk8+fdMWmH6WFHuwHFMP1oZPbKcf8PO60jR0jl/sdPIrawzjeklf2U+ekn2MVQMhuTbuvPddflsT0Xm5OJenzhpF4lTIiLlWERFAIiIChPlKZKDA6V7xh+cMqmx91/eNmuc7csvYED8SRa7XlU07JGOjkaHMe0tc07FpFiFthv0XiyJ7vLDKSGKJjKdjWRgAsDPDY65vO+9zqbraUXwdPJTVM2FvcZGRN7WB+5bE46Rv6OGYW8vKy7XEnEkFEwdpd8j9I4Wd573HYBo2F+f5nRWyYrTfUd9oiezHFWPso4M9s8ryI4YxqZJHaNAA5AkE/Dche3BHD7qSnLpzmqZnGWof1e7XLfo29ul7nmtDhjhyd8/6QxKxqCLRRDVtOw8h1eb6nzKtl6nHwRir858qWnbKIi6FRERBAY1gNVRzvrMMb2jZDmqaTYPPOSPo/fTnrvey6nD/ElNWtPYvs9uj4njK9hGhDmHodLi4VUpniPg2lrHCXvQ1DdWTxHK8EdbeIctdbbELmzcauXv4laLadRfmWRrGlz3BrRqXOIAA6knRR0mM4jh3dxGI1EA2q4BqB1kj5eZFh6rgcTshqJWYg2R1fQtt21O2RwMP/MEYI0G5a4A9dDdvDHEtFtT2hbqbnDGKRRYpJT0BdPRzHO7s2OLaeY+KzrZezdYbaC46a/Rlo4NJTOgjdSdn2LhdvZgNbb0Gx5EHUHdbyxz3i1vGk1ERFgsIiICIiAiIgKK4hccRrmYZHcwxFs1a4bZWm8cN+pNiR6fZK3+J+IXxvbSUTe0rZBZjRqImneR52AA1AP+vY4S4dZQ0/ZhxfK9xkmlO75Haucb625Af3JK9Licfv12+il7ejvMaAAALAaADkv2iL0mYiIgIiIC52KYPT1TMlTCyRvLO0Ej0O4PmCuiiCCdwJLT64XWywD+DJ87F6AO1b66lef6Wxim0qqBtQ0by0j7n/4394n4L6AiyvhpfzCYmYQMHyhYeSGzOkpn/Yniewj3gEfiu3SY9Ry/RVML/wCWVl/he67tRTskGV7GuHRzQ4fArhVfA2FSXzUcNz9luT/JZc1uDjnxMwt1y6LXA7G/pqv1lPQqZPyX4UPBHJH/ACTSj83FY/3Z0P8AEqrdO3es/wBg/q/JPWo5JGtF3uDR1cQB+Knca43oKZjvn45JADljjdnc59u63uXAubbr9R/JjhQIL4XyEfxJZHfhmAVBhuAUdN+z08UZ6tY0H+q1/wAVenBrE952ibvl/CFPjEjJHwwCCSokMs1XUDXc5WxxEXytB0zXGp2FlecO8GwUrzM9zqiqd455Tmd5hoOjR6a20uqhF2xWIncQoyiIrAiIgIiICIiDBCkMX4BpJZO2gz0s/wDFgOS998zPC4HntdWCIPkWFYBi+ESvdE0VtNIS6SOOzHB322sPhd5NuCNOQIoqHjygkdkle6mk5x1DDGR7z3fxV0tLEMMp6huWeKOVvSRjXfC40XPl41Mk7nytFphrwyNe3MxzXtPNpDh8Qv2puo+TWguXUzp6R5+tBK5v4OuPhZeR4WxaP9nxUuA2bPCx/wAXjX8FyX4E/wAsrRdUrKlDBxEw/wDASj/qsJ/sgqsfG9FSn0nI/NZTwcnyT1wqkUsZuIHaNpKOPzfK93+VY/QWOzW7augpxzFPEXH0DpLEeqmvByT51B1woq+uhgaXzyMjYPrPcGj3X3PkFJu4gq8QJjwmMsjJs+slaWsA59mwi73eo9w3XVw/5PaJjxJUmSsl+3UvMnwZ4beoKrmMDQA0AAaADQAei68fDpWdz3lWbzLhcL8LwULHZC6SV5vLNIbvkPmTsPL8zqqFEXYoIiICIiAiIgIiIOXX47SwPyTTMY4NDyHG1mkkBxOwF2nU9CtptZGXOYHtLmsbI4X2Y8nK4+Ryu18ionia4raoGofTiSjhYCyLtM5zz3aBkcbjMNG698eS8J6KeVk7Wwlj3YfQgxC/1JJXSwAu3JZdmp+sLoK+i4io5niOKdj3OuWgHxBuriwnR4H3br3xDF6eBzWzSNY5wLmg3JIaQHGwGwzD4rhP4lD5qVlLZzXSZJWOglDo2lhIJdcNiILcuVwJObTYr88STOZiFO8S9iPZqhucx5xcywkMtyJyk/8AtKChgxSB72xtkaXujEzW37xiJsH2Otr6LynxylY3M+VoHaOhvqfnGXzM0G4yu+BUziVC+pre1p3DtY6SKWnlIIaXiWW7HaeB7TlcN7OB3AWlRVVm0s0rHxD9JVUj2vabx54pxZ2W/wBZwF9jcdUFpHjVK6J0zZmGJhIc8OuGkGxDrbG5Gh6rYlrY2SMic9ofIHFjCdXBgu+w52BCh8YvM2vnhjeInwwxgmNzO1lZI8ue1rgHOAa5jc9tbaXAWcabWPnqKuGFrm074xGS94kLaYl84jiEZDu07SSPxi+UeSC3irY3SPia9pfHlL2g6tDxdhI6EA/BelLUslY2SNwcxwu1w2IUY+nkNXU1lM0uljdC4NAt20LoGl8Vzz0zN6PaORK7fBQP6Pp7hzfm9nCxGp0I5FB30REBERAREQEREBa8VUxz3sa4FzMudvNuYXbf1Gq2FKU2IxQ19YJXZM5gy3a6zrRWNiBbdB1KriGkjBMkzGgF7STewMZs8E20sd15v4oomtzunaG66kOA0AJ1I8wuBVxOOF4o0Nddz66wsbm5daw53Xb4zaXYZVhoJJp5QANSSYzoAEG7S4zTSFojka4uJa0ai5a3M4C45NN0rsapoXiOWVrHlucNNyct7XsBtfRcvH6hsdVRSPJDGmbM6xIGaKwvYG1yubiOIg17ZY6jsmOpbB5iLw4iZ3d1GhFigrKrEYYo+1keGx93vG9u+QG/EkD3rXbjlKWB4laGukbECbtBkd4WagalcvjSTPQtex1h21I8PDS6zRUxuz5dyAO9byWliwjq4II3vFS01bGyEMLBlcx/1eVrjXrYoKmpxGGMuD5GtLIzK+5tljF7vPlofgvCgxymmdkimY91s2W9nZftBp1I81EV0dTavima9748NlibJl0maTIY3i277ENcPtNJGhC7E9UyqkomU4c58UrZXyZHBsbGxua8F7gBd+bJkBJ1vawugopcWp2wGofKxsQuDITZos/Jufvaeq9Zq6Jj42Pe1r5cwjaTq4tGZwb1sNVCQQzywUtMyFsgDqieVkrnRsLGzPZGxzhG83Ln5wMv7rdI6KSpbRQVAcyWEVMLpBqWSwtYIpWuIFyQGPBsL3ItqQgvo6ljnvY1wLmWDwN2lwzC/qNVsKT4QkndPWGojLJc8TX6Wa5zIQ0vYebXWzDmAbHUKsQEREBERAREQEREGLJZZRBiyyiIMWSyyiDFllEQYssoiAiIgIiICIiAiIgIiICIiDFkssogxZZREGLJZZRBiyWWUQEREBERB//Z" /></p>
</blockquote>
<p>大小端在日常使用中两者都有可能遇到，但在网络传输中 TCP/IP
规定数据包字节序为大端，如果是小端机器，那么在传输过程中就需要先将小端数据转换成大端数据再进行发送，同时在接受数据时也需要先将数据转换成小端再进行读取（仅针对多字节数据，例如
<code>short</code>，<code>int</code>，<code>double</code>等
），字节序和字符串编码一样，<strong>我们在使用前必须提前知道处理的数据字节序情况</strong>，否则就会出问题。</p>
<h4 id="utf-8--utf-8-with-bom">UTF-8 &amp; UTF-8 with BOM</h4>
<p>前面提到，UTF-8 后面的 8 表示其编码单位是 8 位，即我们可以使用
<code>char</code> 来存储 UTF-8 字符串，但是很明显 8 位存不下所有的
Unicode 字符，那么就使用多个编码单位来表示一个字符。</p>
<p>为了确保我们可以从字节流中准确还原出 Unicode 字符，UTF-8
编码规则如下（RFC3629）</p>
<ol type="1">
<li>确定 Unicode 字符所需要的字节数</li>
<li>在首字节中添加长度标识前缀（<code>110</code>，<code>1110</code>，<code>11110</code>)，在剩下字节中添加标识前缀（<code>10</code>）</li>
<li>对于单字节字符，直接使用 ASCII
编码，对于多字节字符，从低位到高位开始，每次选取 6
位填入编码中（从后向前）</li>
</ol>
<p>下表展示了 Code 和 UTF-8 编码之间的转换关系</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">UTF-8 &lt;-&gt; Unicode Conversion</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|    Unicode Range    |  Byte[0] |  Byte[1] |  Byte[2] |  Byte[3] |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+000000 ~ U+00007F | 0xxxxxxx |          |          |          |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+000080 ~ U+0007FF | 110xxxxx | 10xxxxxx |          |          |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |          |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+010000 ~ U+10FFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：实际上使用 4 个字节的 UTF-8 编码最大可以表示到 U+1FFFFF（21位的
Unicode 字符），且 UTF-8 最多可以使用 6 个字节来表示一个 Unicode
字符，但是为了和 UTF-16 的表示范围一致，其将最大可表示范围限制到了
<code>U+10FFFF</code>（也就是 20 位的 Unicode 字符）</p>
</blockquote>
<p>下面来几个转换样例（编码）：</p>
<p><code>A</code>：U+0041</p>
<p>对于在 <code>U+0000</code> 到 <code>U+007F</code>
之间的字符，直接使用 ASCII 码即可</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">| U+000000 ~ U+00007F | 0xxxxxxx |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">|       U+000041      |  1000001 |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">|       U+000041      | 01000001 |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">|       U+000041      |   \x41   |</span><br><span class="line">+---------------------+----------+</span><br></pre></td></tr></table></figure>

<p><code>α</code>：U+03B1</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">| U+000080 ~ U+0007FF | 110xxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       U+0003B1      |    01110 |   110001 |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       U+0003B1      | 11001110 | 10110001 |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       U+0003B1      |   \xce   |   \xb1   |</span><br><span class="line">+---------------------+----------+----------+</span><br></pre></td></tr></table></figure>

<p><code>你</code>：U+4F60</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+004F60      |     0100 |   111101 |   100000 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+004F60      | 11100100 | 10111101 | 10100000 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+004F60      |   \xe4   |   \xbd   |   \xa0   |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p><code>🧐</code>：U+1F9D0</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |  Byte[3] |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+010000 ~ U+1FFFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       U+01F9D0      |      000 |   011111 |   100111 |   010000 |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       U+01F9D0      | 11110000 | 10011111 | 10100111 | 10010000 |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       U+01F9D0      |   \xf0   |   \x9f   |   \xa7   |   \x90   |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>Unicode 转 UTF-8 代码实现（C++），通过简单的位运算就可以实现了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">encode_utf8</span><span class="params">(<span class="type">uint32_t</span> u)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint8_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span> (u &lt; <span class="number">0x80</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(u);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &lt; <span class="number">0x800</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xc0</span> | (u &gt;&gt; <span class="number">6</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | (u &amp; <span class="number">0x3f</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &lt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xe0</span> | (u &gt;&gt; <span class="number">12</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | (u &amp; <span class="number">0x3f</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &lt; <span class="number">0x10ffff</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xf0</span> | (u &gt;&gt; <span class="number">18</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | ((u &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3f</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | (u &amp; <span class="number">0x3f</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; fmt::format(<span class="string">&quot;Failed to encode &#123;&#125; to UTF-8, replaced with U+FFFD&quot;</span>,</span><br><span class="line">                             <span class="built_in">unicode</span>(u))</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xef</span>);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xbf</span>);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xbd</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 UTF-8
字符串的解码，也是类似，我们首先判断当前字节流前缀信息，得出当前字符的字节位数，然后根据这个信息读取后续的字节数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> one_byte = (curr_byte &gt;&gt; <span class="number">7</span>) == <span class="number">0x0</span>; </span><br><span class="line"><span class="type">bool</span> two_bytes = (curr_byte &gt;&gt; <span class="number">5</span>) == <span class="number">0x6</span>;</span><br><span class="line"><span class="type">bool</span> three_bytes = (curr_byte &gt;&gt; <span class="number">4</span>) == <span class="number">0xE</span>;</span><br><span class="line"><span class="type">bool</span> four_bytes = (curr_byte &gt;&gt; <span class="number">3</span>) == <span class="number">0x1E</span>;</span><br></pre></td></tr></table></figure>

<p>完整 UTF-8 转 Unicode 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">decode_utf8</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint32_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> curr = *it;</span><br><span class="line">    <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">7</span>) == <span class="number">0x0</span>) &#123;</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">5</span>) == <span class="number">0x6</span>) &#123;</span><br><span class="line">      c |= (curr &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">6</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>);</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">4</span>) == <span class="number">0xE</span>) &#123;</span><br><span class="line">      c |= (curr &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">12</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">6</span>;  <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>);</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">3</span>) == <span class="number">0x1E</span>) &#123;</span><br><span class="line">      <span class="comment">// get 3 bit from value</span></span><br><span class="line">      c |= (curr &amp; <span class="number">0x7</span>) &lt;&lt; <span class="number">18</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">12</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">6</span>;  <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>);</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cerr &lt;&lt; fmt::format(<span class="string">&quot;Failed to decode byte &#123;&#125; at index: &#123;&#125;&quot;</span>,</span><br><span class="line">                               <span class="built_in">hex</span>(*it), it - s.<span class="built_in">begin</span>())</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">      <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：对于 UTF-8
的解码，还有很多加速算法，这里就不做过多的介绍了，详细可以参考这篇博客：<a
href="https://nullprogram.com/blog/2017/10/06/">A Branchless UTF-8
Decoder (nullprogram.com)</a></p>
</blockquote>
<p>最后我们再简单介绍一下 UTF-8 with BOM，从名字上就可以知道，UTF-8 with
BOM 就是在 UTF-8 的基础之上添加了一个 BOM（字节序标志），这个标志的
Unicode code point为 <code>U+FEFF</code> ，表示
”零宽无间断间隔“，仅在传输过程中用来确认字节顺序，打印时不占字宽，（但在控制台打印等宽表格中会计算其长度，导致输出有问题，这一点需要注意）。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">UTF-8 encoding of U+00FEFF</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FEFF      |     1111 |   111011 |   111111 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FEFF      | 11101111 | 10111011 | 10111111 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FEFF      |   \xef   |   \xbb   |   \xbf   |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>将文件手动保存为 UTF-8 with BOM</p>
<p><img data-src="/posts/c4ef/image-20230127221806025.png"
style="zoom:50%;" /></p>
<p>以二进制形式读取文件（<code>rb</code>），我们可以看到文件的前三个字节为固定的
<code>[0xEF,0xBB,0xBF]</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+----------------+--------------+-----------------+</span><br><span class="line">|      file      | size (bytes) |  first 3 bytes  |</span><br><span class="line">+----------------+--------------+-----------------+</span><br><span class="line">| UTF-8 with BOM |     207      | b&#x27;\xef\xbb\xbf&#x27; |</span><br><span class="line">|     UTF-8      |     204      | b&#x27;\xe3\x80\x8e&#x27; |</span><br><span class="line">+----------------+--------------+-----------------+</span><br></pre></td></tr></table></figure>

<p>由于 UTF-8
的编码单位为字节，实际上完全没必要考虑字节顺序的问题，因此并不推荐使用
UTF-8 with BOM ，甚至在某些情况下 UTF-8 with BOM
还会导致代码无法运行（例如 PHP）。</p>
<p><strong>彩蛋：”锟斤拷“ 是怎么来的？</strong></p>
<p>对于编码失败的情况，UTF-8 编码器会直接将其转换成 <code>U+FFFD</code>
，显示为 <code>�</code>，其对应的 UTF-8 编码如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">UTF-8 encoding of U+00FFFD</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FFFD      |     1111 |   111111 |   111101 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FFFD      | 11101111 | 10111111 | 10111101 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FFFD      |   \xef   |   \xbf   |   \xbd   |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>即
<code>[0xEF,0xBF,0xBD]</code>，在编码错误的情况下，就可能会连着出现，也就是</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[...,0xEF,0xBF,0xBD,0xEF,0xBF,0xBD,...]</span><br></pre></td></tr></table></figure>

<p>由于 <strong>GBK
编码是双字节编码</strong>，其会将其解析为三个汉字，而这三个字就是
<code>锟斤拷</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;\xef\xbf\xbd\xef\xbf\xbd&#x27;</span>.decode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;锟斤拷&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在中文环境下，出现 <code>锟斤拷</code>
就基本上就表示我们将一个原本是正常编码的文件<strong>采用 UTF-8
编码打开并以 UTF-8 保存</strong>，由于 UTF-8
编码无法对文件中字符进行编码，就全部替换成了
<code>�</code>，此时我们再通过 GBK 打开时就会出现满屏的
<code>锟斤拷</code>
了，而且这种错误是不可逆的，因为无法编码的字符已经被替换成了
<code>�</code>，我们再也无法找回之前的编码了。</p>
<p>下面给出了一个具体示例：</p>
<p>文件初始内容：</p>
<p><img data-src="/posts/c4ef/image-20230120000459771.png"
style="zoom:50%;" /></p>
<p>我们原本的文件是 GBK 编码的，我们将窗口关闭，再打开。由于 VS Code
并不知道文件的编码，便默认使用 UTF-8 编码打开，内容如下：</p>
<p><img data-src="/posts/c4ef/image-20230120000558448.png" /></p>
<p>如果此时我们手贱，将文件保存的话（<kbd>Ctrl</kbd> +
<kbd>S</kbd>），文件就会以 UTF-8 编码保存，而其中 <code>�</code>
就会直接写入到文件中。</p>
<p>假如我们又看到了文件名中的
<code>文本-gbk</code>，知道文件的正确编码为 GBK，再次使用 GBK
编码打开时，文件内容如下：<img data-src="/posts/c4ef/image-20230120000912272.png" /></p>
<p>我们永远也不知道文件里写了什么了！😭</p>
<blockquote>
<p><em>“白色相簿”什么的，已经无所谓了。</em></p>
<p><em>因为已经不再有歌，值得去唱了。</em></p>
<p><em>传达不了的恋情，已经不需要了。</em></p>
<p><em>因为已经不再有人，值得去爱了。</em></p>
</blockquote>
<p>血的教训告诉我们：<strong>当打开不知道编码的文件时，千万不要手贱按下保存，保存后很有可能无法还原了！</strong></p>
<h4 id="utf-16--utf-32">UTF-16 &amp; UTF-32</h4>
<p>UTF-16 的编码单位为 16 位，即 2 字节，而 UTF-32 的编码单位为 32
位，4字节。</p>
<blockquote>
<p>注：编码单位（code
uint）是编码中每个字符编码的基本元素，对于定长编码中，编码单位大小就等于字符大小，例如
GBK 中编码单位为 2 字节，其可表示的所有字符都是 2
字节；对于变长编码，一个字符的编码可以由多个编码单位进行表示。</p>
</blockquote>
<p>由于 UTF-16 和 UTF-32
的编码单位为多字节，必定要考虑字节顺序问题。我们可以手动指定字节顺序（和
UTF-8 with BOM 类似，在文件开头添加 <code>U+FEFF</code>
来自动判断编码），也可以直接使用 <code>LE</code>
后缀或<code>BE</code>后缀的编码来表示，例如 UTF-16LE 和 UTF-16BE。</p>
<p>在 UTF-16 编码中，一个字符由1个或2个16位整数表示，最大可表示字符为
<code>U+10FFFF</code>，<strong>参考 UTF-16
规范（RFC2781）</strong>，其编码和解码规则如下：</p>
<ol type="1">
<li>对于 <code>U+0000 ~ U+FFFF</code>
的字符，其直接使用1个16位整数表示即可，且值等于 Unicode Code Point
值。</li>
<li>对于 <code>U+010000 ~ U+10FFFF</code>
的字符，使用2个16位整数表示（称为 surrogate
pair，代理对，意为16位整数对表示一个字符），每个部分存储 Unicode Code
Point 的10 位（需要进行特殊处理），再在前面添加前缀（6
位），第一个前缀为 <code>110110</code>，第二个前缀为
<code>110111</code></li>
<li>对于 <code>&gt; U+10FFFF</code> 的字符无法使用 UTF-16
编码表示（目前并不存在）</li>
</ol>
<blockquote>
<p>为了保证 UTF-16 解码的唯一性，对于 <code>U+D800 ~ U+DFFF</code> 的
Unicode 字符不做编码。</p>
</blockquote>
<p>同样，下面给出了一个转换示例</p>
<p><code>🧐</code>：U+1F9D0</p>
<ol type="1">
<li><p>首先减去 <code>0x10000</code>，确保 <code>U'</code> 的范围在
<code>0xFFFFF</code> 之间（最多支持 20 位）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">U&#x27; = U - 0x10000</span><br><span class="line">   = 0xf9d0</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别取出 <code>U'</code> 的
前10位和后10位，填充到两个16位整数中</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">w0 = (U&#x27; &gt;&gt; 10) &amp; 0x3ff</span><br><span class="line">   = 0b0000111110</span><br><span class="line">w1 = U&#x27; &amp; 0x3ff</span><br><span class="line">   = 0b0111010000</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后添加6位的前缀</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">w0 = w0 | 0xd800</span><br><span class="line">   = 0b1101100000111110</span><br><span class="line">   = 0xd83e</span><br><span class="line">w1 = w1 | 0xdc00</span><br><span class="line">   = 0b1101110111010000 </span><br><span class="line">   = 0xddd0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终得到 <code>🧐</code> 的 UTF-16 编码为
<code>[0xd83e,0xddd0]</code></p>
<ul>
<li>UTF-16LE： <code>b'\x3e\xd8\xd0\xdd'</code></li>
<li>UTF-16BE： <code>b'\xd8\x3e\xdd\xd0'</code></li>
</ul>
<p>代码写起来就十分简单了，将上面的过程翻译成 C++ 位运算即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint16_t</span>&gt; <span class="title">encode_utf16</span><span class="params">(<span class="type">uint32_t</span> u)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint16_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span> (u &lt; <span class="number">0xd800</span> || (u &gt; <span class="number">0xdfff</span> &amp;&amp; u &lt;= <span class="number">0xffff</span>)) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(u);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &gt; <span class="number">0xffff</span> &amp;&amp; u &lt;= <span class="number">0x10ffff</span>) &#123;</span><br><span class="line">    u -= <span class="number">0x10000</span>;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(((u &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x3ff</span>) | <span class="number">0xd800</span>);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>((u &amp; <span class="number">0x3ff</span>) | <span class="number">0xdc00</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; fmt::format(</span><br><span class="line">                     <span class="string">&quot;Failed to encode &#123;&#125; to UTF-16, replaced with U+FFFD&quot;</span>,</span><br><span class="line">                     <span class="built_in">unicode</span>(u))</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xfffd</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于解码也是一样，不过我们需要验证一下 surrogate
的有效性（必须成对存在）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">decode_utf16</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint16_t</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint32_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="type">uint16_t</span> w0 = *it;</span><br><span class="line">    <span class="keyword">if</span> (w0 &lt; <span class="number">0xd800</span> || w0 &gt; <span class="number">0xdfff</span>) &#123;</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(w0);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">uint16_t</span> w1 = *it;</span><br><span class="line">    <span class="keyword">if</span> (w1 &lt; <span class="number">0xdc00</span> || w1 &gt; <span class="number">0xdfff</span>) &#123;</span><br><span class="line">      std::cerr &lt;&lt; fmt::format(<span class="string">&quot;Failed to decode word &#123;:#04x&#125; at index &#123;&#125;&quot;</span>, w1,</span><br><span class="line">                               it - s.<span class="built_in">begin</span>())</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">      <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x10000</span> + ((w0 &amp; <span class="number">0x3ff</span>) &lt;&lt; <span class="number">10</span>) | (w1 &amp; <span class="number">0x3ff</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：UTF-16、UTF-16LE、UTF-16BE 的区别：</p>
<ul>
<li>UTF-16 类似于 UTF-8 with BOM，在文件开头添加 <code>U+FEFF</code>
标记，用来标识存储内容的字节顺序</li>
<li>而 UTF-16LE 和 UTF-16BE则是在编码时就约定好字节顺序，不需要通过 BOM
来确定。</li>
</ul>
<p>对于 UTF-32、UTF-32LE、UTF-32BE 也是类似，和 UTF-8 with BOM
类似，一般直接使用 LE 或 BE 版本即可，最好不要在文件开头添加
BOM（有可能影响文件解析）</p>
</blockquote>
<p>而对于 UTF-32 编码，就简单很多了，目前最大的 Unicode 字符也就到
<code>U+10FFFF</code>，使用 32 位来表示完全足够了（即 Unicode code point
就是 UTF-32 编码值）。但是代价也很明显，存储代价太大了，对于纯 ASCII
的代码，需要 4 倍的存储空间。而在 Python 中就采用了
Latin-1（ASCII）、UTF-16 和 UTF-32
的混合表示方式（代价是性能，但是其字符串操作上十分便捷）。</p>
<h2 id="unicode-in-c">Unicode in C++</h2>
<p>目前 Windows 并不支持 UTF-8（使用的 UTF-16），如果我们编写了一段 c++
程序输出 UTF-8
字符串，我们会看到乱码的结果。<strong>除此之外，对于文件的读写、命令行参数的传递也会出现同样的问题</strong>。如果我们想编写跨平台应用程序，最好保证使用的所有字符串都是
UTF-8。通过 <code>Boost.Nowide</code>
库可以实现这个转换。（单纯输出乱码的话可以使用 <code>fmt::print</code>
来解决乱码问题）</p>
<p>使用时我们需要<strong>确保在程序中使用的 <code>char*</code> 和
<code>std::string</code> 都是 UTF-8
编码的</strong>，进行文件I/O、解析命令行命令以及 stdout、stdin、stderr
时统一使用nowide库进行操作，就基本可以屏蔽掉大部分的坑。</p>
<p>对于命令行命令的解析，有一点小坑，我们需要手动链接
<code>shell32.dll</code> ，这个在 Windows SDK
中自带，只需要链接上即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/nowide/args.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/nowide/iostream.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/ranges.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> nw = boost::nowide;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  nw::args _(argc, argv);</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">args</span><span class="params">(argv, argv + argc)</span></span>;</span><br><span class="line">  nw::cout &lt;&lt; fmt::format(<span class="string">&quot;arguments: &#123;&#125;&quot;</span>, args) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 xmake</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">target(<span class="string">&quot;nw&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    set_languages(<span class="string">&quot;cxx17&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/nw.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;fmt&quot;</span>,<span class="string">&quot;tabulate&quot;</span>,<span class="string">&quot;boost&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">        add_cxxflags(<span class="string">&quot;/utf-8&quot;</span>,&#123;tools=<span class="string">&quot;cl&quot;</span>&#125;)</span><br><span class="line">        add_cxxflags(<span class="string">&quot;/RTC1&quot;</span>,&#123;tools=<span class="string">&quot;cl&quot;</span>&#125;)</span><br><span class="line">        add_defines(<span class="string">&quot;BOOST_USE_WINDOWS_H&quot;</span>,<span class="string">&quot;NOMINMAX&quot;</span>)</span><br><span class="line">        add_links(<span class="string">&quot;shell32&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set_installdir(<span class="built_in">path</span>.join(<span class="built_in">os</span>.scriptdir()))</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img data-src="/posts/c4ef/image-20230129173623164.png"
style="zoom:50%;" /></p>
<p>此处链接 <code>shell32.dll</code> 十分关键，如果没有就会报错
LNK2019：无法解析的外部符号 <code>__imp_CommandLineToArgvW</code></p>
<p><img data-src="/posts/c4ef/image-20230129173845768.png"
style="zoom:50%;" /></p>
<p>这个函数实际上就是 Windows
提供的命令行参数编码转换函数，具体可以参考：<a
href="https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw">CommandLineToArgvW
function (shellapi.h) - Win32 apps | Microsoft Learn</a></p>
<p>还有另外一种解决方案，就是开启 UTF-8 实验性功能，这样 Windows
强制所有编码都是
UTF-8，就是对一些老应用不友好，特别是之前编译的中文应用，因为其使用的可能是
GBK 编码。</p>
<p><img data-src="/posts/c4ef/image-20230118163241733.png"
style="zoom:50%;" /></p>
<p>将其勾上然后重启电脑就可以了，这样我们直接通过 <code>std::cout</code>
以及 <code>std::fstream</code>
打开文件时就不会乱码了，但是无法确保其他人也这么做，所以还是老老实实使用
Nowide 库比较靠谱。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">The
Absolute Minimum Every Software Developer Absolutely, Positively Must
Know About Unicode and Character Sets (No Excuses!) – Joel on
Software</a></li>
<li><a href="https://utf8everywhere.org/zh-cn">UTF-8 遍地开花
(utf8everywhere.org)</a></li>
<li><a
href="https://www.boost.org/doc/libs/1_81_0/libs/nowide/doc/html/index.html">Boost.Nowide:
Boost.Nowide - 1.81.0</a></li>
<li><a
href="https://learn.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getacp">GetACP
function (winnls.h) - Win32 apps | Microsoft Learn</a></li>
<li><a
href="https://learn.microsoft.com/en-us/windows/win32/intl/code-pages?source=recommendations">Code
Pages - Win32 apps | Microsoft Learn</a></li>
<li><a
href="https://learn.microsoft.com/en-us/windows/win32/intl/code-page-identifiers">Code
Page Identifiers - Win32 apps | Microsoft Learn</a></li>
<li><a
href="https://stackoverflow.com/questions/61449854/getting-error-lnk2019-unresolved-external-symbol-when-compiling-sdl2-code-in-wi">visual
c++ - Getting error LNK2019: unresolved external symbol when compiling
SDL2 code in Windows using MSVC - Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/56419639/what-does-beta-use-unicode-utf-8-for-worldwide-language-support-actually-do">c#
- What does "Beta: Use Unicode UTF-8 for worldwide language support"
actually do? - Stack Overflow</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Unicode</tag>
        <tag>UTF-8</tag>
      </tags>
  </entry>
</search>
