<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人博客搭建记录</title>
    <url>/posts/96e0/</url>
    <content><![CDATA[<p>之前都是在知乎上写博客，这样看的人也多，方便讨论，但是知乎的 markdown
编辑器不是很好用，本地写完后还需要一张一张上传图片，太麻烦了，就自己搭一个博客，又不想进行域名备案啥的，服务器也要出钱
:( 。最后搜到 Github 有提供免费的静态页面部署功能，这样写完 markdown
笔记可以直接上传到
Github，还可以通过网页访问，nice！(白嫖的感觉真好)</p>
<h1 id="github-pages">Github Pages</h1>
<h2 id="创建主页仓库">创建主页仓库</h2>
<p>通过 <a href="https://pages.github.com/">Github Pages</a>，我们可以将
markdown
撰写的笔记转换成静态网页，并进行部署。其创建流程也十分简单，只需要创建一个名为
<code>&lt;username&gt;.github.io</code> 的仓库，如下图所示</p>
<p><img data-src="/posts/96e0/image-20230102151015131.png"
style="zoom:50%;" /></p>
<p>此处我们选择的是 Private
仓库，只有我们能进行修改，但是主页是公开访问的，这样可以保证笔记源文件安全
:) 。</p>
<span id="more"></span>

<p>创建完成后仓库中什么都没有</p>
<p><img data-src="/posts/96e0/image-20230102151942075.png"
style="zoom:33%;" /></p>
<p>此时我们在浏览器中输入 <a
href="https://purewhitevk.github.io"><span>https://purewhitevk.github.io</span></a>
（URL不区分大小写，直接用小写即可），显示404，页面不存在。</p>
<p><img data-src="/posts/96e0/image-20230102152125799.png"
style="zoom: 50%;" /></p>
<p>别心急，很快就可以看到博客页面了。</p>
<h2 id="静态博客框架">静态博客框架</h2>
<p>在网上搜了一下，有很多博客框架，例如 wordpress 等，但是 wordpress
需要数据库，还需要单独配服务器进行部署，太麻烦了，满足我们需求的有三个</p>
<ul>
<li><p>Jekyll（Github 原生支持）</p>
<p>使用 Ruby 实现</p></li>
<li><p>Hexo</p>
<p>使用 Node.js 实现</p></li>
<li><p>Hugo</p>
<p>使用 Go 实现</p></li>
</ul>
<p>三者在功能上大同小异，都可以直接将 <code>.md</code>
文件转换成<code>html</code> 文件，且支持部署在 Github Pages
上。个人比较推荐 <a
href="https://hexo.io/">Hexo</a>，其环境搭建起来比较方便，且插件较多，操作起来比较简单。</p>
<p><img data-src="/posts/96e0/image-20230102153212301.png"
style="zoom:50%;" /></p>
<h1 id="hexo环境配置">hexo环境配置</h1>
<h2 id="安装">安装</h2>
<ol type="1">
<li><p>全局安装 hexo-cli，这样我们可以直接调用 hexo 的命令行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>将我们的主页仓库 clone 到本地，此处我们将其放到文件夹
<code>Note</code> 下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/PureWhiteVK/PureWhiteVK.github.io.git Note</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载 <a
href="https://github.com/hexojs/hexo-starter">hexo-starter</a>
并解压到本地仓库中</p>
<p>点击右侧 <code>Code</code> 按钮，直接下载 ZIP
压缩包即可（其实我们也可以直接 fork 这个仓库，但是这样我们的仓库就不能是
private 了）</p>
<p><img data-src="/posts/96e0/image-20230102154426653.png"
style="zoom:50%;" /></p></li>
<li><p>使用 <code>npm install</code> 安装依赖</p></li>
<li><p>输入 <code>hexo server</code> 进行运行本地服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Note&gt; hexo server</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  hexois running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>

<p>在浏览器中打开
<code>localhost:4000</code>，就可以预览生成后的静态页面效果了</p>
<p><img data-src="/posts/96e0/image-20230102161237387.png"
style="zoom:50%;" /></p></li>
</ol>
<h2 id="主题">主题</h2>
<p>hexo 上有很多精美的主题，这里我们选择 <a
href="https://github.com/theme-next/hexo-theme-next">next</a>
作为博客主题，其比较稳定，功能也很全。</p>
<p>直接使用 npm 进行安装即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>安装之后，我们需要将主题配置文件
<code>node_modules/hexo-theme-next/_config.yml</code>
拷贝至根目录下，并重命名为 <code>_config.next.yml</code></p>
<p>最终修改根目录下的 <code>_config.yml</code>
即可，将其更换为我们需要的主题</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>最后清理之前生成的文件，并重建部署一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo server</span><br></pre></td></tr></table></figure>

<p>主题效果如下</p>
<p><img data-src="/posts/96e0/image-20230102163251257.png"
style="zoom:50%;" /></p>
<h2 id="插件">插件</h2>
<p>hexo 提供了很多插件来简化我们的操作，并提供一些其他的功能。由于 hexo
是基于 node.js 实现的，我们可以通过 npm 来安装和卸载 hexo 插件。</p>
<p>安装插件命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --save &lt;plugin-name&gt;</span><br></pre></td></tr></table></figure>

<p>删除插件命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall --save &lt;plugin-name&gt;</span><br></pre></td></tr></table></figure>

<p>我们使用了以下几个插件（具体配置可以直接参考 hexo-next-theme
的插件使用文档：<a
href="https://theme-next.js.org/docs/third-party-services/">Third-party
Plugins | NexT</a> 即可）</p>
<ul>
<li>hexo-generator-searchdb：实现搜索功能，支持html文件检索</li>
<li>hexo-abbrlink：自动生成文章的永久链接</li>
<li>hexo-word-counter：统计文章字数</li>
</ul>
<h2 id="配置">配置</h2>
<p>hexo的配置文件位于根目录下的
<code>_config.yml</code>，下面列举了我们需要修改的一些关键配置项</p>
<h3 id="网站基本设置">网站基本设置</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">&quot;PureWhite&#x27;s Blog&quot;</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">PureWhiteVK</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h3 id="url设置">URL设置</h3>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://purewhitevk.github.io</span></span><br><span class="line"><span class="comment"># 这样我们笔记永久链接为 https://purewhitevk.github.io/posts/43fc/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span> </span><br><span class="line"><span class="comment"># 我们使用了 hexo-abbrlink 插件，其通过对名称以及时间戳使用 crc16 算法，生成四位的一个唯一编码</span></span><br><span class="line"><span class="comment"># 四位十六进制可以表示 65536 篇文章，这对于我们博客而言已经绰绰有余了</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc16</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="comment"># 末尾的index后缀</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 末尾的.html后缀</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="写作相关配置">写作相关配置</h3>
<p>这里我们主要调整生成 hexo 生成的 markdown 文件名称</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:year/:month/:day/:title.md</span></span><br></pre></td></tr></table></figure>

<p>hexo 添加 post 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Note&gt; hexo new post <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: D:\Code\Note\<span class="built_in">source</span>\_posts\2023\01\02\Hello-World.md</span><br></pre></td></tr></table></figure>

<p>markdown 文件内容如下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2023-01-02 17:03:17</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>其会默认包含一些内容，其中用三横线包裹起来的是 Front
Matter，其用来标识 markdown
文档的一些属性，例如标题、创建日期、标签（tags）、类别（categories）、永久链接等，hexo
通过读取 Front Matter 来控制生成的 html 文件。</p>
<h3 id="next-主题配置">next 主题配置</h3>
<p>前面提到，我们从 <code>node_modules</code> 中将 next
的配置拷贝至了根目录，并重命名为
<code>_config.next.yml</code>，主题相关的配置直接在这个文件中进行修改即可，next
中提供了非常多的配置项，就不一一介绍了，详细可以直接参考Next主题文档：<a
href="https://theme-next.js.org/">NexT - Theme for Hexo</a></p>
<h2 id="图片">图片</h2>
<p>由于 markdown 和 html 在使用上的区别（markdown 本地，html
网络），我们在 markdown 中插入图片</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">image-description</span>](<span class="link">/local/path/to/image</span>)</span><br></pre></td></tr></table></figure>

<p>会被直接转换成 html 的 <code>img</code> 标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/local/path/to/image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image-description&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是一个是本地路径，一个是网络 URI，直接这么转换肯定会问题。</p>
<p>参考 hexo 的[资源管理文档](<a
href="https://hexo.io/docs/asset-folders">Asset Folders | Hexo</a>)，在
hexo 中，最简单的图片管理方式就是将图片文件放置在
<code>source/images</code> 文件夹下，这样在网页中我们可以直接通过
<code>/images/&lt;image-name&gt;</code> 进行访问。</p>
<blockquote>
<p>Assets are non-post files in the <code>source</code> folder, such as
images, CSS or JavaScript files. For instance, If you are only going to
have a few images in the hexoproject, then <strong>the easiest way is to
keep them in a <code>source/images</code> directory.</strong> Then, you
can access them using something like</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">/images/image.jpg</span>)</span><br></pre></td></tr></table></figure>

</blockquote>
<p>markdown 写法</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">/images/image.jpg</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意images前面的 <code>/</code>
，必须包含这个斜杠，否则图片路径就变成了相对当前URL的路径，会导致图片访问出错。加上<code>/</code>
就表示是相对域名的URL，即
<code>https://purewhitevk.github.io/images/image.jpg</code>；而不加<code>/</code>时就是相对当前网址的URL，假设我们当前网址为
<code>https://purewhitevk.github.io/posts/abcd</code>
，那么对应的图片URL为
<code>https://purewhitevk.github.io/posts/abcd/images/image.jpg</code>，这样就会导致找不到图片。（通过相对路径读取图片文件也是一种可行的方式）</p>
</blockquote>
<p>对应生成的 html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/image.jpg&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是这样我们在本地使用 typora 编写 markdown 时就会有问题，好在 typora
也给出了解决方案：<a
href="https://support.typora.io/Images/#relative-path-to-certain-folder">Images
in Typora - Typora Support</a>。只需要在 markdown 的 Front Matter
中添加两个属性，将 markdown
中所有的图片路径都修改成相对某个路径的绝对路径即可（也就是<code>/relative/to/some-image.png</code>的形式）。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置相对的路径，设置根目录为 source</span></span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../../../../</span></span><br><span class="line"><span class="comment"># 插入图片时自动拷贝图片到 source/images/ 下</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> <span class="string">../../../../images</span></span><br></pre></td></tr></table></figure>

<p>我们的文章都位于
<code>source/_posts/&lt;year&gt;/&lt;month&gt;/&lt;day&gt;</code>
路径下，图片存储路径为<code>source/images</code>下，通过设置<code>typora-root-url</code>，当我们在markdown中插入一张路径为
<code>/images/image.jpg</code> 时，其会自动将
<code>typora-root-url</code>和该路径进行拼接，最终结果就是
<code>../../../../images/image.jpg</code>，正确读取到图片。另外一个便捷的功能就是插入图片时自动拷贝到指定文件夹，这样我们可以丝滑的添加图片了，不需要手动上传并设置链接。</p>
<p>我们可以将这两个配置项添加到 markdown 模板中（hexo 中称为
scaffold，脚手架），就不用每次都手动添加，修改
<code>scaffolds/post.md</code> 如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> &#123;&#123; <span class="string">title</span> &#125;&#125;</span><br><span class="line"><span class="attr">date:</span> &#123;&#123; <span class="string">date</span> &#125;&#125;</span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="attr">category:</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">../../../../</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> <span class="string">../../../../images</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="comment"># 此处 more 标签用于 next 主题显示摘要</span></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">more</span> <span class="string">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们通过 <code>hexo new post &lt;title&gt;</code>
时就会默认配置好 typora。</p>
<p>附：typora的图像存储相关设置</p>
<p><img data-src="/posts/96e0/image-20230105230235058.png"
style="zoom:50%;" /></p>
<p>由于我们使用 Front Matter 进行配置，在图像处就不需要任何配置了。</p>
<h2 id="公式">公式</h2>
<p>另外一个比较令人头疼的就是公式渲染问题，latex 公式在语法上和 markdown
存在一些冲突，如果使用默认的 <code>hexo-renderer-marked </code>
渲染引擎进行生成会导致最终渲染出来的 latex 公式是错误的，我们需要将
markdown 渲染引擎替换为 <code>hexo-renderer-pandoc</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先删除原来的渲染器</span></span><br><span class="line">npm uninstall --save hexo-renderer-marked</span><br><span class="line"><span class="comment"># 安装新的渲染器</span></span><br><span class="line">npm install --save hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>

<p>然后在 next 主题的配置文件 <code>_config.next.yml</code> 中开启
mathjax 的支持</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (false) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to true, it will load mathjax / katex script EVERY PAGE.</span></span><br><span class="line">  <span class="attr">every_page:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># &lt;--- 将此处 false 修改为 true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>写一个简单的公式测试一下效果</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\int</span> <span class="built_in">_</span>0 <span class="built_in">^</span><span class="keyword">\pi</span> <span class="keyword">\sin</span> x <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125; x = 2</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>对应渲染结果 <span class="math display">\[
\int _0 ^\pi \sin x \,\mathrm{d} x = 2
\]</span> 如果可以正确看到公式就说明公式配置成功。</p>
<h2 id="部署">部署</h2>
<p>在 hexo 官网中给出了 Github Pages 的部署方式：<a
href="https://hexo.io/docs/github-pages">GitHub Pages |
Hexo</a>，由于我们会将源代码也上传至 Github 仓库，我们使用 Github
Workflow 的方式来自动执行部署过程。</p>
<p>其部署过程很简单</p>
<ol type="1">
<li>提交代码 （push）</li>
<li>执行 workflow 中指定的操作，安装
node.js，执行相关命令生成静态页面</li>
<li>通过 Github Pages 展示静态页面</li>
</ol>
<p>由于我们将hexo的markdown渲染器修改为<code>hexo-renderer-pandoc</code>，其需要提前安装好
pandoc
并添加到环境变量，我们需要在官方提供的workflow中修改一下，在容器中安装好
pandoc，网上一搜发现也有大佬已经分享了 pandoc 的配置命令：<a
href="https://github.com/nikeee/setup-pandoc">nikeee/setup-pandoc</a>，直接拿过来用即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">nikeee/setup-pandoc@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">pandoc-version:</span> <span class="string">&#x27;2.7.3&#x27;</span> <span class="comment"># The pandoc version to download (if necessary) and use.</span></span><br></pre></td></tr></table></figure>

<p>最后根据本地使用的 node.js 和 pandoc
版本，将其修改成对应的版本即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Note&gt; node --version</span><br><span class="line">v18.12.1</span><br><span class="line">(base) PS D:\Code\Note&gt; pandoc --version</span><br><span class="line">pandoc.exe 2.19.2</span><br><span class="line">Compiled with pandoc-types 1.22.2.1, texmath 0.12.5.2, skylighting 0.13,</span><br><span class="line">citeproc 0.8.0.1, ipynb 0.2, hslua 2.2.1</span><br><span class="line">Scripting engine: Lua 5.4</span><br><span class="line">User data directory: C:\Users\xiao\AppData\Roaming\pandoc</span><br><span class="line">Copyright (C) 2006-2022 John MacFarlane. Web:  https://pandoc.org</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions. There is no</span><br><span class="line">warranty, not even <span class="keyword">for</span> merchantability or fitness <span class="keyword">for</span> a particular purpose.</span><br></pre></td></tr></table></figure>

<p>完整的 workflow 配置代码如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span>  <span class="comment"># default branch</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">submodules:</span> <span class="string">recursive</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Pandoc</span> <span class="number">2.19</span><span class="number">.2</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">nikeee/setup-pandoc@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">pandoc-version:</span> <span class="string">&quot;2.19.2&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="number">18.12</span><span class="number">.1</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18.12.1&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Cache</span> <span class="string">NPM</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.OS</span> <span class="string">&#125;&#125;-npm-cache</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">github_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./public</span></span><br></pre></td></tr></table></figure>

<p>由于我们仓库实际上还没有初始化，需要使用 git
初始化一下仓库再进行提交，初始化命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;Initial commit&quot;</span></span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https://github.com/PureWhiteVK/PureWhiteVK.github.io.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p>提交之后代码后，我们可以在 Actions 面板中看到正在执行的 Workflows</p>
<p><img data-src="/posts/96e0/image-20230102185759306.png"
style="zoom:50%;" /></p>
<p>第一次 pages build and deployment 一定会执行失败，因为我们还没设置
Github Page 部署时使用的分支，hexo 的 workflow
在执行后会单独创建一个分支（gh-pages）来存放静态网页，我们在设置中切换一下即可。</p>
<p><img data-src="/posts/96e0/image-20230102190220044.png"
style="zoom:50%;" /></p>
<p>调整完成后，可以看到提示我们网站已经上线了（Your site is live at <a
href="https://purewhitevk.github.io"><span>https://purewhitevk.github.io</span></a>），进入
<a
href="https://purewhitevk.github.io"><span>https://purewhitevk.github.io</span></a>
就可以访问到部署好的博客页面了。（github.io访问速度可能较慢，最好挂梯子）</p>
<p><img data-src="/posts/96e0/image-20230102190311710.png"
style="zoom: 25%;" /></p>
]]></content>
      <categories>
        <category>Hexo使用记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github pages</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTex公式学习笔记</title>
    <url>/posts/caff/</url>
    <content><![CDATA[<p>之前我们已经配置好了 hexo 对 LaTex 公式的支持（在 markdown 的 Front
Matter 中添加 <code>mathjax: true</code> 开启 LaTex
公式渲染支持），支持两种形式的公式输入</p>
<ul>
<li><p>内联公式（inline），通过 <code>$...$</code>
进行包裹（必须在同一行）</p>
<p>例：markdown 代码 <code>$\phi = 30$</code> 对应内联公式渲染结果 <span
class="math inline">\(\phi = 30\)</span></p>
<p>在 <code>$</code>
和公式之间不能存在空格，也就是说，对于<code>$ \phi = 30 $</code>
并不能得到正确的渲染结果</p></li>
<li><p>块公式（block），通过 <code>$$...$$</code>
进行包裹（两个<code>$$</code>必须在不同行）</p>
<p>例：markdown 代码</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\int</span> <span class="built_in">_</span>0 <span class="built_in">^</span><span class="keyword">\pi</span> <span class="keyword">\sin</span>(x) = 2</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>对应块渲染结果 <span class="math display">\[
\int _0 ^ \pi \sin x = 2
\]</span></p></li>
</ul>
<p>现在我们可以在 markdown
文档中添加并渲染公式了，那么下一步就是如何正确书写公式，以及一些常用公式符号。</p>
<span id="more"></span>

<h1 id="常用符号">常用符号</h1>
<p>可以使用在线的<a
href="https://www.latexlive.com/">LaTex公式编辑器</a>来手动选取，下面列举了一些常用的符号</p>
<h2 id="关系和运算符号">关系和运算符号</h2>
<p><span class="math display">\[
\begin{align}
&amp; &lt; &amp; &amp; \mathtt{&lt;} &amp;
&amp; \leq &amp; &amp; \mathtt{\backslash leq} &amp;
&amp; \ll &amp; &amp; \mathtt{\backslash ll} &amp;
\\
&amp; &gt; &amp; &amp; \mathtt{&gt;} &amp;
&amp; \geq &amp; &amp; \mathtt{\backslash geq} &amp;
&amp; \gg &amp; &amp; \mathtt{\backslash gg} &amp;
\\
\\
&amp; \in &amp; &amp; \mathtt{\backslash in} &amp;
&amp; \subset &amp; &amp; \mathtt{\backslash subset} &amp;
&amp; \subseteq &amp; &amp; \mathtt{\backslash subseteq} &amp;
\\
&amp; \ni &amp; &amp; \mathtt{\backslash ni} &amp;
&amp; \supset &amp; &amp; \mathtt{\backslash supset} &amp;
&amp; \supseteq &amp; &amp; \mathtt{\backslash supseteq} &amp;
\\
&amp; \notin &amp; &amp; \mathtt{\backslash notin} &amp;
\\
\\
&amp; = &amp; &amp; \mathtt{=} &amp;
&amp; \neq &amp; &amp; \mathtt{\backslash neq} &amp;
&amp; \equiv &amp; &amp; \mathtt{\backslash equiv} &amp;
\\
&amp; \approx &amp; &amp; \mathtt{\backslash approx} &amp;
&amp; \propto &amp; &amp; \mathtt{\backslash propto} &amp;
\\
\\
&amp; \parallel &amp; &amp; \mathtt{\backslash parallel} &amp;
&amp; \nparallel &amp; &amp; \mathtt{\backslash nparallel} &amp;
&amp; \sim &amp; &amp; \mathtt{\backslash sim} &amp;
\\
&amp; \perp &amp; &amp; \mathtt{\backslash perp} &amp;
\\
\\
&amp; + &amp; &amp; \text{+} &amp;
&amp; - &amp; &amp; \text{-} &amp;
&amp; \star &amp; &amp; \mathtt{\backslash star} &amp;
\\
&amp; \times &amp; &amp; \mathtt{\backslash times} &amp;
&amp; \div &amp; &amp; \mathtt{\backslash div} &amp;
&amp; \cdot &amp; &amp; \mathtt{\backslash cdot} &amp;
\\
&amp; \cup &amp; &amp; \mathtt{\backslash cup} &amp;
&amp; \cap &amp; &amp; \mathtt{\backslash cap} &amp;
&amp; \ast &amp; &amp; \mathtt{\backslash ast} &amp;
\\
&amp; \vee &amp; &amp; \mathtt{\backslash vee} &amp;
&amp; \wedge &amp; &amp; \mathtt{\backslash wedge} &amp;
&amp; \oplus &amp; &amp; \mathtt{\backslash oplus} &amp;
\\
&amp; \otimes &amp; &amp; \mathtt{\backslash otimes} &amp;
&amp; \ominus &amp; &amp; \mathtt{\backslash ominus} &amp;
&amp; \odot &amp; &amp; \mathtt{\backslash odot} &amp;
\end{align}
\]</span></p>
<h2 id="箭头符号">箭头符号</h2>
<p><span class="math display">\[
\begin{align}
&amp; \leftarrow &amp; &amp; \mathtt{\backslash leftarrow} &amp;
&amp; \rightarrow &amp; &amp; \mathtt{\backslash rightarrow} &amp;
\\
&amp; \uparrow &amp; &amp; \mathtt{\backslash uparrow} &amp;
&amp; \downarrow &amp; &amp; \mathtt{\backslash downarrow} &amp;
\\
&amp; \updownarrow &amp; &amp; \mathtt{\backslash updownarrow} &amp;
&amp; \leftrightarrow &amp; &amp; \mathtt{\backslash leftrightarrow}
&amp;
\\
\\
&amp; \nwarrow &amp; &amp; \mathtt{\backslash nwarrow} &amp;
&amp; \nearrow &amp; &amp; \mathtt{\backslash nearrow} &amp;
\\
&amp; \swarrow &amp; &amp; \mathtt{\backslash swarrow} &amp;
&amp; \searrow &amp; &amp; \mathtt{\backslash searrow} &amp;
\\
\\
&amp; \mapsto &amp; &amp; \mathtt{\backslash mapsto} &amp;
&amp; \rightleftharpoons &amp; &amp; \mathtt{\backslash
rightleftharpoons} &amp;
\\
&amp; \leftharpoonup &amp; &amp; \mathtt{\backslash leftharpoonup} &amp;
&amp; \rightharpoonup &amp; &amp; \mathtt{\backslash rightharpoonup}
&amp;
\\
&amp; \leftharpoondown &amp; &amp; \mathtt{\backslash leftharpoondown}
&amp;
&amp; \rightharpoondown &amp; &amp; \mathtt{\backslash rightharpoondown}
&amp;
\\
\\
&amp; \longleftarrow &amp; &amp; \mathtt{\backslash longleftarrow} &amp;
&amp; \longrightarrow &amp; &amp; \mathtt{\backslash longrightarrow}
&amp;
\\
&amp; \longleftrightarrow &amp; &amp; \mathtt{\backslash
longleftrightarrow} &amp;
&amp; \longmapsto &amp; &amp; \mathtt{\backslash longmapsto} &amp;
\\
\\
&amp; \Leftarrow &amp; &amp; \mathtt{\backslash Leftarrow} &amp;
&amp; \Rightarrow &amp; &amp; \mathtt{\backslash Rightarrow} &amp;
\\
&amp; \Uparrow &amp; &amp; \mathtt{\backslash Uparrow} &amp;
&amp; \Downarrow &amp; &amp; \mathtt{\backslash Downarrow} &amp;
\\
&amp; \Updownarrow &amp; &amp; \mathtt{\backslash Updownarrow} &amp;
&amp; \Leftrightarrow &amp; &amp; \mathtt{\backslash Leftrightarrow}
&amp;
\\
&amp; \Longleftarrow &amp; &amp; \mathtt{\backslash Longleftarrow} &amp;
&amp; \Longrightarrow &amp; &amp; \mathtt{\backslash Longrightarrow}
&amp;
\\
&amp; \Longleftrightarrow &amp; &amp; \mathtt{\backslash
Longleftrightarrow} &amp;
\end{align}
\]</span></p>
<p>注：当我们需要表示当且仅当关系是常用 <code>\Longleftrightarrow</code>
，为了简写，也可以使用 <code>\iff</code> （if and only if, 当且仅当)
来简化</p>
<h2 id="希腊字母">希腊字母</h2>
<p><span class="math display">\[
\begin{align}
&amp;\alpha &amp; &amp; \mathtt{\backslash alpha}&amp;  
&amp;\beta &amp; &amp; \mathtt{\backslash beta}&amp;
&amp;\gamma &amp; &amp; \mathtt{\backslash gamma}&amp;
\\
&amp;\delta &amp; &amp; \mathtt{\backslash delta}&amp;
&amp;\epsilon &amp; &amp; \mathtt{\backslash epsilon}&amp;
&amp;\zeta &amp; &amp; \mathtt{\backslash zeta}&amp;
\\
&amp;\eta &amp; &amp; \mathtt{\backslash eta}&amp;
&amp;\theta &amp; &amp; \mathtt{\backslash theta}&amp;
&amp;\iota &amp; &amp; \mathtt{\backslash iota}&amp;
\\
&amp;\kappa &amp; &amp; \mathtt{\backslash kappa}&amp;
&amp;\lambda &amp; &amp; \mathtt{\backslash lambda}&amp;
&amp;\mu &amp; &amp; \mathtt{\backslash mu}&amp;
\\
&amp;\nu &amp; &amp; \mathtt{\backslash nu}&amp;
&amp;\xi &amp; &amp; \mathtt{\backslash xi}&amp;
&amp;\omicron &amp; &amp; \mathtt{\backslash omicron}&amp;
\\
&amp;\pi &amp; &amp; \mathtt{\backslash pi}&amp;
&amp;\rho &amp; &amp; \mathtt{\backslash rho}&amp;
&amp;\sigma &amp; &amp; \mathtt{\backslash sigma}&amp;
\\
&amp;\tau &amp; &amp; \mathtt{\backslash tau}&amp;
&amp;\upsilon &amp; &amp; \mathtt{\backslash upsilon}&amp;
&amp;\phi &amp; &amp; \mathtt{\backslash phi}&amp;
\\
&amp;\chi &amp; &amp; \mathtt{\backslash chi}&amp;
&amp;\psi &amp; &amp; \mathtt{\backslash psi}&amp;
&amp;\omega &amp; &amp; \mathtt{\backslash omega}&amp;
\\
\\
&amp; \varepsilon &amp; &amp; \mathtt{\backslash varepsilon} &amp;
&amp; \vartheta &amp; &amp; \mathtt{\backslash vartheta} &amp;
&amp; \varpi &amp; &amp; \mathtt{\backslash varpi} &amp;
\\
&amp; \varrho &amp; &amp; \mathtt{\backslash varrho} &amp;
&amp; \varsigma &amp; &amp; \mathtt{\backslash varsigma} &amp;
&amp; \varphi &amp; &amp; \mathtt{\backslash varphi} &amp;
\\
&amp; \varkappa &amp; &amp; \mathtt{\backslash varkappa} &amp;
\\
\\
&amp;\Gamma &amp; &amp; \mathtt{\backslash Gamma}&amp;  
&amp; \Lambda &amp; &amp; \mathtt{\backslash Lambda} &amp;
&amp;\Sigma &amp; &amp; \mathtt{\backslash Sigma}&amp;  
\\
&amp; \Psi &amp; &amp; \mathtt{\backslash Psi} &amp;
&amp;\Delta &amp; &amp; \mathtt{\backslash Delta}&amp;  
&amp; \Xi &amp; &amp; \mathtt{\backslash Xi} &amp;
\\
&amp;\Upsilon &amp; &amp; \mathtt{\backslash Upsilon}&amp;  
&amp; \Omega &amp; &amp; \mathtt{\backslash Omega} &amp;
&amp;\Theta &amp; &amp; \mathtt{\backslash Theta}&amp;  
\\
&amp; \Pi &amp; &amp; \mathtt{\backslash Pi} &amp;
&amp;\Phi &amp; &amp; \mathtt{\backslash Phi}&amp;  
\end{align}
\]</span></p>
<h2 id="三角函数">三角函数</h2>
<p><span class="math display">\[
\begin{align}
&amp;\sin&amp; &amp;\mathtt{\backslash sin}&amp;
&amp;\cos&amp; &amp;\mathtt{\backslash cos}&amp;
\\
&amp;\tan&amp; &amp;\mathtt{\backslash tan}&amp;
&amp;\cot&amp; &amp;\mathtt{\backslash cot}&amp;
\\
&amp;\sec&amp; &amp;\mathtt{\backslash sec}&amp;
&amp;\csc&amp; &amp;\mathtt{\backslash csc}&amp;
\\
\\
&amp;\arcsin&amp; &amp;\mathtt{\backslash arcsin}&amp;
&amp;\arccos&amp; &amp;\mathtt{\backslash arccos}&amp;
\\
&amp;\arctan&amp; &amp;\mathtt{\backslash arctan}&amp;
\\
\\
&amp;\sinh&amp; &amp;\mathtt{\backslash sinh}&amp;
&amp;\cosh&amp; &amp;\mathtt{\backslash cosh}&amp;
\\
&amp;\tanh&amp; &amp;\mathtt{\backslash tanh}&amp;
&amp;\coth&amp; &amp;\mathtt{\backslash coth}&amp;
\\
\end{align}
\]</span></p>
<h2 id="其他符号">其他符号</h2>
<p><span class="math display">\[
\begin{align}
&amp; \infty &amp; &amp; \mathtt{\backslash infty} &amp;
&amp; \Re &amp; &amp; \mathtt{\backslash Re} &amp;
\\
&amp; \forall &amp; &amp; \mathtt{\backslash forall} &amp;
&amp; \exists &amp; &amp; \mathtt{\backslash exists} &amp;
\\
&amp; \nexists &amp; &amp; \mathtt{\backslash nexists} &amp;
&amp; \emptyset &amp; &amp; \mathtt{\backslash emptyset} &amp;
\\
&amp; \varnothing &amp; &amp; \mathtt{\backslash varnothing} &amp;
&amp; \top &amp; &amp; \mathtt{\backslash top} &amp;
\\
&amp; \partial &amp; &amp; \mathtt{\backslash partial} &amp;
&amp; \nabla &amp; &amp; \mathtt{\backslash nabla} &amp;
\end{align}
\]</span></p>
<h2 id="标识符号">标识符号</h2>
<p>有时我们可能需要在字母上添加上标（例如平均数 <span
class="math inline">\(\bar{x}\)</span>，估计值 <span
class="math inline">\(\hat{x}\)</span> 等），下标（下划线 <span
class="math inline">\(\underline{x}\)</span> ）等</p>
<table>
<thead>
<tr class="header">
<th>Code</th>
<th>Result</th>
<th>Code</th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a'</code> or <code>a^&#123;\prime&#125;</code></td>
<td><span class="math inline">\(a&#39;\)</span></td>
<td><code>a''</code></td>
<td><span class="math inline">\(a&#39;&#39;\)</span></td>
</tr>
<tr class="even">
<td><code>\hat&#123;a&#125;</code></td>
<td><span class="math inline">\(\hat{a}\)</span></td>
<td><code>\bar&#123;a&#125;</code></td>
<td><span class="math inline">\(\bar{a}\)</span></td>
</tr>
<tr class="odd">
<td><code>\acute&#123;a&#125;</code></td>
<td><span class="math inline">\(\acute{a}\)</span></td>
<td><code>\check&#123;a&#125;</code></td>
<td><span class="math inline">\(\check{a}\)</span></td>
</tr>
<tr class="even">
<td><code>\grave&#123;a&#125;</code></td>
<td><span class="math inline">\(\grave{a}\)</span></td>
<td><code>\dot&#123;a&#125;</code></td>
<td><span class="math inline">\(\dot{a}\)</span></td>
</tr>
<tr class="odd">
<td><code>\mathring&#123;a&#125;</code></td>
<td><span class="math inline">\(\mathring{a}\)</span></td>
<td><code>\breve&#123;a&#125;</code></td>
<td><span class="math inline">\(\breve{a}\)</span></td>
</tr>
<tr class="even">
<td><code>\tilde&#123;a&#125;</code></td>
<td><span class="math inline">\(\tilde{a}\)</span></td>
<td><code>\vec&#123;a&#125;</code></td>
<td><span class="math inline">\(\vec{a}\)</span></td>
</tr>
<tr class="odd">
<td><code>\underline&#123;a&#125;</code></td>
<td><span class="math inline">\(\underline{a}\)</span></td>
<td><code>\overline&#123;a&#125;</code></td>
<td><span class="math inline">\(\overline{a}\)</span></td>
</tr>
<tr class="even">
<td><code>\overrightarrow&#123;AB&#125;</code></td>
<td><span class="math inline">\(\overrightarrow{AB}\)</span></td>
<td><code>\overleftarrow&#123;AB&#125;</code></td>
<td><span class="math inline">\(\overleftarrow{AB}\)</span></td>
</tr>
<tr class="odd">
<td><code>\widehat&#123;AB&#125;</code></td>
<td><span class="math inline">\(\widehat{AB}\)</span></td>
<td><code>\widetilde&#123;AB&#125;</code></td>
<td><span class="math inline">\(\widetilde{AB}\)</span></td>
</tr>
</tbody>
</table>
<h2 id="括号">括号</h2>
<p>常见的括号 <code>()</code>、中括号 <code>[]</code>、以及大括号
<code>&#123;&#125;</code> 都可以直接在键盘中输入，由于大括号在 LaTex
中的特殊含义（用来包裹一段公式），我们使用时需要添加 <code>\</code>
进行转义，即 <code>\&#123;</code> 和 <code>\&#125;</code></p>
<p>对于竖线 <code>|</code> ，我们可以直接从键盘中输入，也可以使用
<code>\mid</code> 来表示，双竖线（范数的表示）可以使用 <code>\|</code>
来表示（不能使用两个竖线，因为双竖线应该表示为一个字符），示例如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\|</span>x<span class="keyword">\|</span><span class="built_in">_</span>2</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\|x\|_2
\]</span></p>
<p>其他分隔符表示如下 <span class="math display">\[
\begin{align}
&amp; / &amp; &amp; \mathtt{/} &amp;
&amp; \backslash &amp; &amp; \mathtt{\backslash backslash} &amp;
\\
&amp; \langle &amp; &amp; \mathtt{\backslash langle} &amp;
&amp; \rangle &amp; &amp; \mathtt{\backslash rangle} &amp;
\\
&amp; \lceil &amp; &amp; \mathtt{\backslash lceil} &amp;
&amp; \rceil &amp; &amp; \mathtt{\backslash rceil} &amp;
\\
&amp; \lfloor &amp; &amp; \mathtt{\backslash lfloor} &amp;
&amp; \rfloor &amp; &amp; \mathtt{\backslash rfloor} &amp;
\end{align}
\]</span></p>
<p>当我们使用这些括号包裹一个大的公式时，如下所示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2&#125;&#123;y<span class="built_in">^</span>3&#125;)</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
(\frac{x^2}{y^3})
\]</span></p>
<p>我们可以发现这个括号（parentheses）不能完全的包裹住公式，此时我们需要使用
<code>\left(...\right)</code> 来自动调整括号的大小</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>(<span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2&#125;&#123;y<span class="built_in">^</span>3&#125;<span class="keyword">\right</span>)</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left(\frac{x^2}{y^3}\right)
\]</span></p>
<p>除此之外，在中间表示时还可以使用 <code>\middle</code>
来进行控制（条件概率时）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">P<span class="keyword">\left</span>(A=2<span class="keyword">\middle</span>|<span class="keyword">\frac</span>&#123;A<span class="built_in">^</span>2&#125;&#123;B&#125;&gt;4<span class="keyword">\right</span>)</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
P\left(A=2\middle| \frac{A^2}{B}&gt;4\right)
\]</span></p>
<p>而对于花括号（curly
braces）和方括号（brackets）时，需要使用转义符进行转义
<code>\&#123;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span><span class="keyword">\&#123;</span><span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>2&#125;&#123;y<span class="built_in">^</span>3&#125;<span class="keyword">\right</span><span class="keyword">\&#125;</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left\{\frac{x^2}{y^3}\right\}
\]</span></p>
<p>我们还可以使用 <code>.</code> 来忽略左侧或右侧符号</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>. <span class="keyword">\frac</span>&#123;x<span class="built_in">^</span>3&#125;&#123;3&#125; <span class="keyword">\right</span>| <span class="built_in">_</span>0 <span class="built_in">^</span>1</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left.\frac{x^3}{3}\right|_0^1
\]</span></p>
<p>最终，如果我们还是不满意，可以手动调整符号的大小</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">( <span class="keyword">\big</span>( <span class="keyword">\Big</span>( <span class="keyword">\bigg</span>( <span class="keyword">\Bigg</span>(</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
( \big( \Big( \bigg( \Bigg(
\]</span></p>
<h2 id="空格">空格</h2>
<p>如果我们直接在公式中输入空格，如果直接在字母中间插入空格，会被直接忽略掉，如果我们明确需要插入空格，需要通过指令形式显式给出，在
LaTex 中空格相关的指令总结如下</p>
<table>
<thead>
<tr class="header">
<th>指令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>（space）</td>
<td>默认空格</td>
<td><span class="math inline">\(abc \rightarrow \leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>\,</code></td>
<td>短空格(3/18 em)</td>
<td><span class="math inline">\(abc \rightarrow\,\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>\!</code></td>
<td>短负空格(-3/18 em)</td>
<td><span class="math inline">\(abc \rightarrow \! \leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>!:</code></td>
<td>中空格(4/18 em)</td>
<td><span class="math inline">\(abc \rightarrow\:\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>!;</code></td>
<td>大空格(5/18 em)</td>
<td><span class="math inline">\(abc \rightarrow\;\leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>\enspace</code></td>
<td>0.5字宽空格 (0.5 em)</td>
<td><span class="math inline">\(abc \rightarrow\enspace\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>\quad</code></td>
<td>1字宽空格(1 em)</td>
<td><span class="math inline">\(abc \rightarrow\quad\leftarrow
abc\)</span></td>
</tr>
<tr class="even">
<td><code>\qquad</code></td>
<td>2字宽空格(2 em)</td>
<td><span class="math inline">\(abc \rightarrow\qquad\leftarrow
abc\)</span></td>
</tr>
<tr class="odd">
<td><code>\hspace&#123;3em&#125;</code></td>
<td>自定义宽度空格</td>
<td><span class="math inline">\(abc \rightarrow\hspace{3em}\leftarrow
abc\)</span></td>
</tr>
</tbody>
</table>
<p>注：em 是一种长度单位，和 px 意义，但是其是相对字宽来度量的，1 em
就表示一个字宽</p>
<p>空格在积分公式的书写上十分有用，如果我们直接写的话，如下所示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\int</span> y <span class="keyword">\mathrm</span>&#123;d&#125; x</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\int y \mathrm{d} x
\]</span></p>
<p>我们可以看到被积函数 <span class="math inline">\(y\)</span> 和微元
<span class="math inline">\(\mathrm{d}x\)</span>
之间距离太短，看起来不是很自然，此时我们就可以在二者之间插入一个小的空白，如下所示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\int</span> y <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125; x</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\int y \,\mathrm{d} x
\]</span></p>
<p>这样看起来就十分自然了。</p>
<p>另外一个示例就是分段函数的表示</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">f(n) = </span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">n / 2 <span class="built_in">&amp;</span> <span class="keyword">\quad</span> <span class="keyword">\text</span>&#123;if &#125; n <span class="keyword">\text</span>&#123; is even&#125; <span class="keyword">\\</span></span><br><span class="line">-(n+1)/2 <span class="built_in">&amp;</span> <span class="keyword">\quad</span> <span class="keyword">\text</span>&#123;if &#125; n <span class="keyword">\text</span>&#123; is odd&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
f(n) =
\begin{cases}
n / 2 &amp; \quad \text{if } n \text{ is even} \\
-(n+1)/2 &amp; \quad \text{if } n \text{ is odd}
\end{cases}
\]</span></p>
<h1 id="字体">字体</h1>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Command</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Upright Roman Font</td>
<td><code>\mathrm&#123;&#125;</code></td>
<td><span class="math inline">\(\mathrm{x}\)</span></td>
</tr>
<tr class="even">
<td>Normal Italic Font</td>
<td><code>\mathnormal&#123;&#125;</code></td>
<td><span class="math inline">\(\mathnormal{x}\)</span></td>
</tr>
<tr class="odd">
<td>Calligraphic Font</td>
<td><code>\mathcal&#123;&#125;</code></td>
<td><span class="math inline">\(\mathcal{X}\)</span></td>
</tr>
<tr class="even">
<td>Upright Roman Boldface</td>
<td><code>\mathbf&#123;&#125;</code></td>
<td><span class="math inline">\(\mathbf{x}\)</span></td>
</tr>
<tr class="odd">
<td>Upright Sans Serif</td>
<td><code>\mathsf&#123;&#125;</code></td>
<td><span class="math inline">\(\mathsf{x}\)</span></td>
</tr>
<tr class="even">
<td>Italic Font</td>
<td><code>\mathit&#123;&#125;</code></td>
<td><span class="math inline">\(\mathit{x}\)</span></td>
</tr>
<tr class="odd">
<td>Typewritter Font</td>
<td><code>\mathtt&#123;&#125;</code></td>
<td><span class="math inline">\(\mathtt{x}\)</span></td>
</tr>
<tr class="even">
<td>Blackboard Bold Font</td>
<td><code>\mathbb&#123;&#125;</code></td>
<td><span class="math inline">\(\mathbb{X}\)</span></td>
</tr>
<tr class="odd">
<td>Eular Calligraphic Font</td>
<td><code>\mathscr&#123;&#125;</code></td>
<td><span class="math inline">\(\mathscr{X}\)</span></td>
</tr>
<tr class="even">
<td>Fraktur(Gothic) Font</td>
<td><code>\mathfrak&#123;&#125;</code></td>
<td><span class="math inline">\(\mathfrak{X}\)</span></td>
</tr>
</tbody>
</table>
<p>注：</p>
<ol type="1">
<li>Calligraphic 表示书法体（花体），Euler Calligraphic
为欧拉手稿字体</li>
<li>Sans Serif 表示非衬线字体（不包含其他多余的笔画）</li>
<li>Boldface 表示粗体</li>
<li>Typewriter Font 是等宽字体</li>
<li>如果不加任何标注，默认的字体就是 Normal Italic Font，也就是 Roman
字体的斜体形式，如 <span class="math inline">\(hello\)</span></li>
</ol>
<h1 id="常用公式写法">常用公式写法</h1>
<h2 id="三角函数-1">三角函数</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\cos</span> (2<span class="keyword">\theta</span>) = <span class="keyword">\cos</span><span class="built_in">^</span>2 <span class="keyword">\theta</span> - <span class="keyword">\sin</span><span class="built_in">^</span>2 <span class="keyword">\theta</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\cos (2\theta) = \cos^2 \theta - \sin^2 \theta
\]</span></p>
<h2 id="极限">极限</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\lim</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;x <span class="keyword">\to</span> <span class="keyword">\infty</span>&#125; <span class="keyword">\exp</span>(-x) = 0</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\lim\limits_{x \to \infty} \exp(-x) = 0
\]</span></p>
<p><code>\limits</code> 指令将后续紧跟的上标 <code>^</code> 和下标
<code>_</code>
放置在当前符号的上方（不写的其实也可以正常渲染，但是加上比较符合我们的观察）</p>
<h2 id="取模">取模</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">&amp;</span> a <span class="keyword">\bmod</span> b <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> x <span class="keyword">\equiv</span> a <span class="keyword">\pmod</span>&#123;b&#125; </span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
&amp; a \bmod b \\
&amp; x \equiv a \pmod{b}
\end{align}
\]</span></p>
<h2 id="上下标">上下标</h2>
<p>通过 <code>_</code> 表示下标，<code>^</code>
表示上标，如果需要将一块一整体进行上标，需要使用 <code>&#123;&#125;</code>
进行包裹</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">n<span class="built_in">^</span>&#123;22&#125; <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line">k<span class="built_in">_</span>&#123;n+1&#125; <span class="built_in">&amp;</span> = n<span class="built_in">^</span>2 + k<span class="built_in">_</span>n<span class="built_in">^</span>2 - k<span class="built_in">_</span>&#123;n-1&#125; <span class="keyword">\\</span></span><br><span class="line">f(n) <span class="built_in">&amp;</span> = <span class="keyword">\left</span>. n<span class="built_in">^</span>5 + 4n<span class="built_in">^</span>2 + 2 <span class="keyword">\right</span>|<span class="built_in">_</span>&#123;n=17&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
n^{22} &amp; \\
k_{n+1} &amp; = n^2 + k_n^2 - k_{n-1} \\
f(n) &amp; = \left. n^5 + 4n^2 + 2 \right|_{n=17}
\end{align}
\]</span></p>
<h2 id="分数和二项式系数">分数和二项式系数</h2>
<p>使用 <code>\frac&#123;numerator&#125;&#123;denominator&#125;</code>
来表示分数（numerator表示分子，denominator表示分母）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;n!&#125;&#123;k!(n-k)!&#125; = <span class="keyword">\binom</span>&#123;n&#125;&#123;k&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\frac{n!}{k!(n-k)!} = \binom{n}{k}
\]</span></p>
<p>分数也可以进行嵌套</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\frac</span>&#123;1&#125;&#123;x&#125;+<span class="keyword">\frac</span>&#123;1&#125;&#123;y&#125;&#125;&#123;y-z&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\frac{\frac{1}{x}+\frac{1}{y}}{y-z}
\]</span></p>
<p>为了在一行表示分数，我们也可以将分数表示为斜线形式</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">^</span>3/<span class="built_in">_</span>7 <span class="keyword">\quad</span> 3 / 7</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
^3/_7 \quad 3 / 7
\]</span> 使用 <code>\frac&#123;...&#125;&#123;...&#125;</code>
我们也可以表示其他内容，例如乘法和加法公式</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;</span><br><span class="line">	<span class="keyword">\begin</span>&#123;array&#125;[b]&#123;r&#125;</span><br><span class="line">		<span class="keyword">\left</span>( x<span class="built_in">_</span>1 x<span class="built_in">_</span>2 <span class="keyword">\right</span>) <span class="keyword">\\</span></span><br><span class="line">		<span class="keyword">\times</span> <span class="keyword">\left</span>( x&#x27;<span class="built_in">_</span>1 x&#x27;<span class="built_in">_</span>2 <span class="keyword">\right</span>)</span><br><span class="line">	<span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line">&#125;&#123;</span><br><span class="line">	<span class="keyword">\left</span>( y<span class="built_in">_</span>1 y<span class="built_in">_</span>2 y<span class="built_in">_</span>3 y<span class="built_in">_</span>4 <span class="keyword">\right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\frac{
\begin{array}[b]{r}
\left( x_1 x_2 \right)\\
\times \left(x&#39;_1 x&#39;_2\right)
\end{array}
}{
\left( y_1y_2y_3y_4 \right)
}
\]</span></p>
<p>其中对齐公式使用的 <code>\align</code> 以及
<code>\begin&#123;&#125;...\end&#123;&#125;</code> 会单独进行详细地介绍。</p>
<h2 id="根式">根式</h2>
<p>使用 <code>\sqrt&#123;...&#125;</code>
来表示根号，默认为2，也可以指定为其他幂次，通过<code>\sqrt[n]&#123;&#125;</code>
来指定</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span>[n]&#123;1 + x + x<span class="built_in">^</span>2 + x<span class="built_in">^</span>3 +<span class="keyword">\cdots</span> + x<span class="built_in">^</span>n&#125;</span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\sqrt[n]{1+x+x^2+x^3+\cdots+x^n}
\]</span></p>
<h2 id="求和乘积与积分">求和、乘积与积分</h2>
<p>通过 <code>\sum _&#123;&#125; ^&#123;&#125; &#123;&#125;</code> 来表示大型加法表达式，如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\sum</span> <span class="built_in">_</span>&#123;i=1&#125; <span class="built_in">^</span>&#123;<span class="keyword">\infty</span>&#125; x<span class="built_in">^</span>i</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\sum _{i=1} ^{\infty} x^i
\]</span></p>
<p>对于连乘也是类似 <code>\prod _&#123;&#125; ^&#123;&#125; &#123;&#125;</code>
来表示大型乘法表达式，如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\prod</span> <span class="built_in">_</span>&#123;i=1&#125; <span class="built_in">^</span>&#123;n&#125; x<span class="built_in">^</span>i</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\prod _{i=1} ^{n} x^i
\]</span></p>
<p>积分（integral），通过 <code>\int _&#123;&#125; ^&#123;&#125; &#123;&#125;</code>
来表示积分符号</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\int</span> <span class="built_in">_</span>&#123;0&#125; <span class="built_in">^</span>&#123;<span class="keyword">\pi</span>&#125; <span class="keyword">\sin</span> x <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;x</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\int _{0} ^{\pi} \sin x \,\mathrm{d}x
\]</span></p>
<p>除了一重积分外，我们还有各种各样的积分符号，如二重积分、三重积分、曲面积分等等，其使用的积分符号也有相应的变化</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\iint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(u,v) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;v</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\iiint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(u,v,w) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;v<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;w</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\iiiint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(t,u,v,w) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;t<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;v<span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;w</span><br><span class="line"><span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> <span class="keyword">\idotsint</span> <span class="keyword">\limits</span> <span class="built_in">_</span>V <span class="keyword">\mu</span>(u<span class="built_in">_</span>1,<span class="keyword">\dots</span>,u<span class="built_in">_</span>k) <span class="keyword">\,</span><span class="keyword">\mathrm</span>&#123;d&#125;u<span class="built_in">_</span>1 <span class="keyword">\dots</span> <span class="keyword">\mathrm</span>&#123;d&#125;u<span class="built_in">_</span>k</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
&amp; \iint \limits _V \mu(u,v) \,\mathrm{d}u\,\mathrm{d}v
\\
&amp; \iiint \limits _V \mu(u,v,w)
\,\mathrm{d}u\,\mathrm{d}v\,\mathrm{d}w
\\
&amp; \iiiint \limits _V \mu(t,u,v,w)
\,\mathrm{d}t\,\mathrm{d}u\,\mathrm{d}v\,\mathrm{d}w
\\
&amp; \idotsint \limits _V \mu(u_1,\dots,u_k) \,\mathrm{d}u_1 \dots
\mathrm{d}u_k
\end{align}
\]</span></p>
<h2 id="矩阵">矩阵</h2>
<p>对于矩阵而言，需要使用 <code>\begin&#123;&#125;...\end&#123;&#125;</code>
来包裹（对齐）</p>
<p>普通矩阵</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{matrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{matrix}
\]</span></p>
<p>括号矩阵（<code>pmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{pmatrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{pmatrix}
\]</span></p>
<p>方括号矩阵（<code>bmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{bmatrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{bmatrix}
\]</span></p>
<p>花括号矩阵（<code>Bmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Bmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{Bmatrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{Bmatrix}
\]</span></p>
<p>竖线矩阵（<code>vmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6<span class="keyword">\\</span></span><br><span class="line">7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{vmatrix}
1 &amp; 2 &amp; 3\\
4 &amp; 5 &amp; 6\\
7 &amp; 8 &amp; 9
\end{vmatrix}
\]</span></p>
<p>双数竖线矩阵（<code>Vmatrix</code>）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Vmatrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">4 <span class="built_in">&amp;</span> 5 <span class="built_in">&amp;</span> 6<span class="keyword">\\</span></span><br><span class="line">7 <span class="built_in">&amp;</span> 8 <span class="built_in">&amp;</span> 9</span><br><span class="line"><span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{Vmatrix}
1 &amp; 2 &amp; 3\\
4 &amp; 5 &amp; 6\\
7 &amp; 8 &amp; 9
\end{Vmatrix}
\]</span></p>
<p>我们也可以使用其他分界符搭配 <code>\left ... \right</code>
来构造其他形式，例如</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\left</span><span class="keyword">\langle</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">1 <span class="built_in">&amp;</span> 2 <span class="built_in">&amp;</span> 3<span class="keyword">\\</span></span><br><span class="line">a <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> c</span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\right</span><span class="keyword">\rangle</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\left\langle
\begin{matrix}
1 &amp; 2 &amp; 3\\
a &amp; b &amp; c
\end{matrix}
\right\rangle
\]</span></p>
<p>如果想在一行显示矩阵，我们可以使用 <code>smallmatrix</code> 布局</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span> <span class="keyword">\big</span>(<span class="keyword">\begin</span>&#123;smallmatrix&#125;</span><br><span class="line">  a <span class="built_in">&amp;</span> b<span class="keyword">\\</span></span><br><span class="line">  c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;smallmatrix&#125;<span class="keyword">\big</span>)<span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>这一行包含矩阵公式：<span
class="math inline">\(\big(\begin{smallmatrix}a&amp;b\\c&amp;d\end{smallmatrix}\big)\)</span></p>
<p>注：在 markdown 中，内联公式必须在同一行</p>
<p>(但是这一行不是很好写捏:(</p>
<h1 id="公式的对齐">公式的对齐</h1>
<h2 id="对齐显示">对齐显示</h2>
<p>使用 <code>align</code> 来表示多行对齐公式（还有一个
<code>align</code> ，其效果和 <code>align</code>
类似，只不过二者使用场景不一样，在 markdown 需要对齐的话使用
<code>align</code> 基本就可以了），使用 <code>\\</code>
来换行，<code>&amp;</code> 来指示需要对齐的位置</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">A <span class="built_in">&amp;</span> = <span class="keyword">\frac</span>&#123;<span class="keyword">\pi</span> r<span class="built_in">^</span>2&#125;&#123;2&#125; <span class="keyword">\\</span></span><br><span class="line">  <span class="built_in">&amp;</span> = <span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125; <span class="keyword">\pi</span> r<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
A &amp; = \frac{\pi r^2}{2} \\
&amp; = \frac{1}{2} \pi r^2
\end{align}
\]</span></p>
<p>这样就可以在等号处对齐了。</p>
<p>我们也可以使用 <code>align</code> 实现表格式的对齐，示例如下：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) = a x<span class="built_in">^</span>2 + b x + c <span class="keyword">\quad</span>  g(x) = d x<span class="built_in">^</span>3 <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) = 2 a x + b  <span class="keyword">\quad</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2 </span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) = a x^2 + b x + c \quad  g(x) = d x^3 \\
f&#39;(x) = 2 a x + b  \quad g&#39;(x) = 3 d x ^2
\end{align}
\]</span></p>
<p>我们的目标是将两个公式分别在等号处对齐。</p>
<p>首先观察一下其对齐情况，可以看到两行公式目前在末尾处是对齐的，这就相当于我们在末尾加上了一个
<code>&amp;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) = a x<span class="built_in">^</span>2 + b x + c <span class="keyword">\quad</span>  g(x) = d x<span class="built_in">^</span>3 <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) = 2 a x + b  <span class="keyword">\quad</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2 <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) = a x^2 + b x + c \quad  g(x) = d x^3 &amp; \\
f&#39;(x) = 2 a x + b  \quad g&#39;(x) = 3 d x ^2 &amp;
\end{align}
\]</span></p>
<p>如果用表格来描述这个公式，如下所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;"><span class="math inline">\(f(x) = a x^2
+ b x + c \quad  g(x) = d x^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span class="math inline">\(f&#39;(x) = 2
a x + b  \quad g&#39;(x) = 3 d x ^2\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>如果我们想要公式在第一个等于号时对齐，那么在等号前加上
<code>&amp;</code>，如下</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= a x<span class="built_in">^</span>2 + b x + c <span class="keyword">\quad</span>  g(x) = d x<span class="built_in">^</span>3 <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) <span class="built_in">&amp;</span>= 2 a x + b  <span class="keyword">\quad</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2 <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) &amp;= a x^2 + b x + c \quad  g(x) = d x^3 &amp; \\
f&#39;(x) &amp;= 2 a x + b  \quad g&#39;(x) = 3 d x ^2 &amp;
\end{align}
\]</span></p>
<p>可以观察到，此时在 <span class="math inline">\(f(x)\)</span> 和 <span
class="math inline">\(f&#39;(x)\)</span>
后的等号对齐了，但是其末尾处并不对齐了</p>
<p>此时我们将其表格化，如下所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th style="text-align: left;"><span
class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">$f(x) $</td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><span class="math inline">\(=a x^2 + b x +
c \quad  g(x) = d x^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span
class="math inline">\(f&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: left;"><span class="math inline">\(= 2 a x +
b  \quad g&#39;(x) = 3 d x ^2\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>可以看到，我们插入的 <code>&amp;</code> 将公式划分成了两列，而在
<code>&amp;</code> 左侧的列为右对齐，右侧的列为左对齐，这样就形成了在
<code>&amp;</code>
处对齐的效果，由于后半部所在的列已经左对齐了，自然也就不能在末尾处对齐了。</p>
<p>我们继续对公式进行修改，将 <code>\quad</code> 替换为
<code>&amp;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= a x<span class="built_in">^</span>2 + b x + c <span class="built_in">&amp;</span>  g(x) = d x<span class="built_in">^</span>3 <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) <span class="built_in">&amp;</span>= 2 a x + b  <span class="built_in">&amp;</span> g&#x27;(x) = 3 d x <span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) &amp;= a x^2 + b x + c &amp;  g(x) = d x^3 \\
f&#39;(x) &amp;= 2 a x + b  &amp; g&#39;(x) = 3 d x ^2
\end{align}
\]</span></p>
<p>此时可以发现公式又在末尾处对齐了，将其转化成表格</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th><span class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">$f(x) $</td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=a x^2 + b x + c\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span class="math inline">\(g(x) = d
x^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span
class="math inline">\(f&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(= 2 a x + b\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span class="math inline">\(g&#39;(x) = 3
d x ^2\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>最后我们在 <span class="math inline">\(g(x)\)</span> 和 <span
class="math inline">\(g&#39;(x)\)</span> 后添加 <code>&amp;</code></p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">f(x) <span class="built_in">&amp;</span>= a x<span class="built_in">^</span>2 + b x + c <span class="built_in">&amp;</span>  g(x) <span class="built_in">&amp;</span> = d x<span class="built_in">^</span>3 <span class="keyword">\\</span></span><br><span class="line">f&#x27;(x) <span class="built_in">&amp;</span>= 2 a x + b  <span class="built_in">&amp;</span> g&#x27;(x)  <span class="built_in">&amp;</span> = 3 d x <span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
f(x) &amp;= a x^2 + b x + c &amp;  g(x) &amp; = d x^3 \\
f&#39;(x) &amp;= 2 a x + b  &amp; g&#39;(x)  &amp; = 3 d x ^2
\end{align}
\]</span></p>
<p>最终的表格如下所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th><span class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th style="text-align: right;"><span
class="math inline">\(\Rightarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
<th><span class="math inline">\(\Leftarrow\)</span></th>
<th style="text-align: center;"><code>&amp;</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;"><span
class="math inline">\(f(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=ax^2+bx+c\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span
class="math inline">\(g(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=dx^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;"><span
class="math inline">\(f&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(= 2 a x + b\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: right;"><span
class="math inline">\(g&#39;(x)\)</span></td>
<td style="text-align: center;"></td>
<td><span class="math inline">\(=3dx^3\)</span></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>从上面的解析中可以看出，<code>&amp;</code> 有两个作用</p>
<ol type="1">
<li>分块，以 <code>&amp;</code> 为中心划分成左右两部分</li>
<li>如果左侧列没有对齐的话，优先右对齐，对于右侧列同理，优先左对齐</li>
</ol>
<p>这样我们参照上面的表格，第一个和第三个 <code>&amp;</code>
左右两侧都是如此，但是第二个 <code>&amp;</code>
由于其左侧块已经有对齐方式了（左对齐），无法再进行布局安排，因此这个
<code>&amp;</code> 只起到了第一个作用，第二个已经自动忽略了。</p>
<p>Tips：如果想实现列表形式的公式展示，可以将 <code>&amp;</code>
作为列的分割符，对于一列，我们直接使用 <code>&amp; a &amp;</code>
包裹即可（左对齐）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">&amp;</span> a <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> b <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> c <span class="built_in">&amp;</span> d <span class="built_in">&amp;</span> <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> e <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> f <span class="built_in">&amp;</span> <span class="built_in">&amp;</span> g <span class="built_in">&amp;</span> h <span class="built_in">&amp;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{align}
&amp; a &amp; &amp; b &amp; &amp; c &amp; d &amp; \\
&amp; e &amp; &amp; f &amp; &amp; g &amp; h &amp;
\end{align}
\]</span></p>
<p>这样虽然有些冗余，但是使用起来比较简单，无需思考 <code>&amp;</code>
放置的位置</p>
<h2 id="居中显示">居中显示</h2>
<p>相比于自定义对齐，居中显示就显得简单很多，使用 <code>gather</code>
即可</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;gather&#125;</span><br><span class="line">2x - 5y =  8 <span class="keyword">\\</span> </span><br><span class="line">3x<span class="built_in">^</span>2 + 9y =  3a + c</span><br><span class="line"><span class="keyword">\end</span>&#123;gather&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p><span class="math display">\[
\begin{gather}
2x - 5y =  8 \\
3x^2 + 9y =  3a + c
\end{gather}
\]</span></p>
<h1 id="导入其他包">导入其他包</h1>
<p>有时候我们想要在 MathJax 中使用其他宏包，例如 Physics
宏，我们可以直接在 LaTex 代码中使用 <code>require&#123;...&#125;</code>
来添加扩展。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\require</span>&#123;physics&#125;</span><br><span class="line"><span class="keyword">\abs</span>&#123;a&#125; <span class="keyword">\quad</span> <span class="keyword">\grad</span>&#123;x&#125; <span class="keyword">\quad</span> <span class="keyword">\order</span>&#123;1&#125; <span class="keyword">\quad</span> <span class="keyword">\cross</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>开启 Physics 宏之后渲染结果 <span class="math display">\[
\require{physics}
\abs{a} \quad \grad{x} \quad \order{1} \quad \cross
\]</span> 如果加载失败，将会显示如下结果</p>
<p><img data-src="/posts/caff/no-physics-error.svg" /></p>
<p>不过感觉 <code>require&#123;&#125;</code> 功能在 mathjax
中还有点问题，最好还是在设置中手动开启。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://en.wikibooks.org/wiki/LaTeX/Mathematics">LaTeX/Mathematics
- Wikibooks, open books for an open world</a></li>
<li><a
href="https://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics">LaTeX/Advanced
Mathematics - Wikibooks, open books for an open world</a></li>
<li><a
href="https://kapeli.com/cheat_sheets/LaTeX_Math_Symbols.docset/Contents/Resources/Documents/index">LaTeX
Math Symbols Cheat Sheet - Kapeli</a></li>
<li><a
href="https://www.overleaf.com/learn/latex/Mathematical_expressions">Mathematical
expressions - Overleaf, Online LaTeX Editor</a></li>
</ol>
]]></content>
      <categories>
        <category>Hexo使用记录</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
        <tag>LaTex</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo自定义插件</title>
    <url>/posts/9a20/</url>
    <content><![CDATA[<h1 id="hexo-plugin">Hexo Plugin</h1>
<p>参考官方<a
href="https://hexo.io/zh-cn/docs/plugins">文档</a>，我们有两种创建插件方式</p>
<ol type="1">
<li>以脚本（Scripts）形式（单个文件）</li>
<li>以 npm package 形式创建（支持多文件）</li>
</ol>
<p>对于一般的插件而言，如果代码并不复杂且依赖较少，可以直接写成脚本形式，放在
hexo 根目录下的 <code>scripts</code>
文件夹即可（不存在直接创建一个即可），在介绍插件具体写法之前，先看一个简单的例子：</p>
<p>文件：<code>scripts/test.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line">  log.<span class="title function_">debug</span>(<span class="string">&quot;hello from test.js!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>然后执行下列命令查看效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate --debug</span><br></pre></td></tr></table></figure>

<p>这一条命令包含两个子命令，<code>hexo clean</code>
清除之前的生成文件，之后的 <code>hexo generate</code>
用来生成静态页面文件。</p>
<p>（<code>--debug</code> 标志会使 hexo 在终端显示调试信息，在所有的
hexo-cli 命令中都可以使用）</p>
<span id="more"></span>

<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; hexo clean &amp;&amp; hexo generate --debug</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deleted database.</span><br><span class="line">INFO  Deleted public folder.</span><br><span class="line">03:05:12.393 DEBUG Writing database to D:\hexo-temp\db.json</span><br><span class="line">03:05:12.401 DEBUG Hexo version: 6.3.0</span><br><span class="line">...</span><br><span class="line">03:05:12.483 INFO  Validating config</span><br><span class="line">...</span><br><span class="line">03:05:12.651 DEBUG Script loaded: scripts\test.js</span><br><span class="line">03:05:12.652 INFO  Start processing</span><br><span class="line">...</span><br><span class="line">03:05:12.717 DEBUG hello from test.js!!!</span><br><span class="line">...</span><br><span class="line">03:05:12.742 INFO  Files loaded <span class="keyword">in</span> 90 ms</span><br><span class="line">...</span><br><span class="line">03:05:12.915 INFO  Generated: archives/2023/index.html</span><br><span class="line">...</span><br><span class="line">03:05:12.922 INFO  17 files generated <span class="keyword">in</span> 180 ms</span><br><span class="line">03:05:12.924 DEBUG Database saved</span><br></pre></td></tr></table></figure>

<p>从输出中我们可以看到，在 <code>Validating config</code>
过程中加载了我们创建的脚本，而在 <code>Start processing</code>
后执行了我们的脚本，并通过 debug 输出了对应的语句。</p>
<p>这样我们就实现了一个简单的 hexo
插件（十分简单，没有对输入的数据做任何处理，打印一条语句后就退出了）。</p>
<h2 id="plugin-写法">plugin 写法</h2>
<p>参考官方<a
href="https://hexo.io/zh-cn/api">文档</a>的扩展部分，其给出了所有插件的种类</p>
<p><img data-src="/posts/9a20/image-20230116112529108.png"
style="zoom: 50%;" /></p>
<p>例如我们之前写的 filter 插件，其<a
href="https://hexo.io/zh-cn/api/filter">文档</a>如下</p>
<p><img data-src="/posts/9a20/image-20230116113313750.png"
style="zoom:50%;" /></p>
<p>所有的插件都可以采用类似的方式实现，通过
<code>hexo.extend.xxx.register</code>
来注册插件，指定好对应的处理函数即可。</p>
<h2 id="基本模板">基本模板</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hexo.<span class="property">extend</span>.&lt;extend-type&gt;.<span class="title function_">register</span>(name,&lt;args&gt;,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;,&lt;extend-args&gt;)</span><br></pre></td></tr></table></figure>

<p>考虑到箭头函数和普通函数的区别，在函数内部我们获取 hexo
变量的方式不一样，在箭头函数中没有 this 指针，我们需要通过一个全局 hexo
变量进行访问即可，而普通函数会包含 this 指针，而 hexo
在调用函数时会将自身绑定到 this 指针上，这样我们可以直接通过 this 访问
hexo 相关变量。</p>
<p>对应代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrow_function1</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = <span class="variable language_">this</span>;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from arrow_function1!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrow_function2</span> = (<span class="params">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from arrow_function2!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> normal_function1 = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = <span class="variable language_">this</span>;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from normal_function1!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> normal_function2 = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line">  log &amp;&amp; log.<span class="title function_">debug</span>(<span class="string">&quot;hello from normal_function2!!!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, arrow_function1);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, arrow_function2);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, normal_function1);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, normal_function2);</span><br></pre></td></tr></table></figure>

<p>对应执行结果（<code>hexo clean &amp;&amp; hexo generate --debug</code>
)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="number">03</span>:<span class="number">55</span>:<span class="number">44.819</span> <span class="variable constant_">DEBUG</span> hello <span class="keyword">from</span> arrow_function2!!!</span><br><span class="line"><span class="number">03</span>:<span class="number">55</span>:<span class="number">44.819</span> <span class="variable constant_">DEBUG</span> hello <span class="keyword">from</span> vanilla_function1!!!</span><br><span class="line"><span class="number">03</span>:<span class="number">55</span>:<span class="number">44.820</span> <span class="variable constant_">DEBUG</span> hello <span class="keyword">from</span> vanilla_function2!!!</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>从执行结果中可以看到，在箭头函数（arrow function）中不包含 this
指针，我们无法通过 this 来访问 hexo 的变量，但是可以直接通过 hexo
全局变量来访问，对于普通函数（normal function）而言，可以通过 this
来访问 hexo，也可以直接通过全局变量 hexo 来访问。</p>
<p>由于脚本模式实际上实在 js 中通过字符串形式执行的，最好在开头处添加
<code>use strict</code> 来标识，确保插件能正常执行。</p>
<p>注：导入包的时候我们只能使用 common js 的包，并不支持 es6
模式的包，即我们不能通过一下模式导入包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unified &#125; <span class="keyword">from</span> <span class="string">&#x27;unified&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>(unified 是一个<a
href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">纯
es6 模块</a>，不支持 comman js 导入)</p>
<p>而必须使用 common js 的导包方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; red &#125; = <span class="built_in">require</span>(<span class="string">&#x27;picocolors&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="日志输出">日志输出</h2>
<p>通过 <code>hexo.log</code> 我们可以拿到 hexo
的日志输出对象，其具体实现在 <a
href="https://github.com/hexojs/hexo-log">hexo-log</a>
中，和普通的日志输出模块类似，其也支持不同级别的日志输出和颜色输出，具体通过
<code>picocolors</code> 库来控制输出的颜色，示例如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;log&#125; = hexo;</span><br><span class="line"><span class="keyword">const</span> &#123;red,green,blue,magenta,cyan&#125; = <span class="built_in">require</span>(<span class="string">&#x27;picocolors&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;before_post_render&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  log.<span class="title function_">trace</span>(<span class="string">&quot;this is a trace message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">debug</span>(<span class="string">&quot;this is a debug message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a info message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">warn</span>(<span class="string">&quot;this is a warn message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">error</span>(<span class="string">&quot;this is a error message&quot;</span>);</span><br><span class="line">  log.<span class="title function_">fatal</span>(<span class="string">&quot;this is a fatal message&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a red&quot;</span>,<span class="title function_">red</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a green&quot;</span>,<span class="title function_">green</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a blue&quot;</span>,<span class="title function_">blue</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a magenta&quot;</span>,<span class="title function_">magenta</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  log.<span class="title function_">info</span>(<span class="string">&quot;this is a cyan&quot;</span>,<span class="title function_">cyan</span>(<span class="string">&quot;message&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对应输出结果</p>
<p><img data-src="/posts/9a20/image-20230116121200965.png"
style="zoom:67%;" /></p>
<h1 id="pandoc-renderer">Pandoc Renderer</h1>
<h2 id="目的">目的</h2>
<p>在前一篇文章中，我们配置好了 hexo
的静态文件处理方式，将所有的图片都放置在了 <code>source/images</code>
路径下，并通过设置 markdown 的 front matter 使得 typora
可以正确显示图片。</p>
<p>但是这种方法<strong>耦合性太强</strong>，所有图片都放在 images
文件夹不说，如果我们换一个 markdown 编辑器，就无法实现正确的预览了。</p>
<p>为此，我们需要调整 hexo 中图片资源管理方式，将 markdown
文件中图片链接全部替换为相对路径。</p>
<h2 id="问题">问题</h2>
<p>首先我们需要对之前的配置进行一些调整，修改
<code>_config.yaml</code>，开启资源文件后处理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>参考官方文档，其会在创建 post文件 的同时创建和 post文件
同名的文件夹，用来存储资源文件，而后在生成站点时将图片拷贝到默认文件夹下。</p>
<p>修改配置后，我们创建一个 post 来查看一下效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;c++学习笔记&quot;</span></span><br></pre></td></tr></table></figure>

<p>（取这个名字还有一个就是文件名实际上和文章的标题不一定会对应，如果包含特殊的字符会进行调整）</p>
<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; hexo new post <span class="string">&quot;c++学习笔记&quot;</span></span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Created: D:\hexo-temp\<span class="built_in">source</span>\_posts\c-学习笔记.md</span><br></pre></td></tr></table></figure>

<p>可以看到 markdown 文件名变成了 <code>c-学习笔记</code>，将
<code>++</code> 替换成了 <code>-</code>，同时在当前目录下也创建了
<code>c-学习笔记</code> 文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp\<span class="built_in">source</span>\_posts&gt; tree /F</span><br><span class="line">卷 Data 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 4000-728D</span><br><span class="line">D:.</span><br><span class="line">│  c-学习笔记.md</span><br><span class="line">│  hello-world.md</span><br><span class="line">│</span><br><span class="line">└─c-学习笔记</span><br><span class="line">        hexo.png</span><br></pre></td></tr></table></figure>

<p>（在 powershell 中也提供了 <code>tree</code> 命令，使用方式和 linux
下的差别较大，传参居然是用 <code>/&lt;argument&gt;</code>
的形式，怪怪的，查看帮助使用 <code>/?</code> 而不是 linux 中的
<code>--help</code> 或 <code>-h</code>）</p>
<p>此时我们在 markdown 文档中插入一张图片测试一下</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: c++学习笔记</span><br><span class="line">date: 2023-01-16 13:30:31</span><br><span class="line"><span class="section">tags:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">测试图片：</span><br><span class="line"></span><br><span class="line">![<span class="string">测试图片</span>](<span class="link">c-学习笔记/hexo.png</span>)</span><br></pre></td></tr></table></figure>

<p>本地预览结果</p>
<p><img data-src="/posts/9a20/image-20230116134147690.png"
style="zoom:50%;" /></p>
<p>生成静态页面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate</span><br></pre></td></tr></table></figure>

<p>生成的文件位于根目录的 <code>public</code> 下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; tree /F public</span><br><span class="line">卷 Data 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 00000048 4000:728D</span><br><span class="line">D:\HEXO-TEMP\PUBLIC</span><br><span class="line">│  index.html</span><br><span class="line">│</span><br><span class="line">├─2023</span><br><span class="line">│  └─01</span><br><span class="line">│      ├─15</span><br><span class="line">│      │  └─hello-world</span><br><span class="line">│      │          index.html</span><br><span class="line">│      │</span><br><span class="line">│      └─16</span><br><span class="line">│          └─c-学习笔记</span><br><span class="line">│                  hexo.png</span><br><span class="line">│                  index.html</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，我们插入的图片也被拷贝到了 public
下的同名文件中，但是在生成的 <code>index.html</code>
中我们可以看到，图片链接不对，在网页中自然无法正确显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;e-content article-entry&quot;</span> <span class="attr">itemprop</span>=<span class="string">&quot;articleBody&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>测试图片：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/hexo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;测试图片&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</code> 是中文
<code>学习笔记</code> 进行 UTF-8 编码后的 URL 表示形式 (urlencode)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\hexo-temp&gt; python</span><br><span class="line">Python 3.9.12 (main, Apr  4 2022, 05:22:27) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; s = <span class="string">&quot;学习笔记&quot;</span></span><br><span class="line">&gt;&gt;&gt; s.encode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;\xe5\xad\xa6\xe4\xb9\xa0\xe7\xac\x94\xe8\xae\xb0&#x27;</span></span><br><span class="line">&gt;&gt;&gt; from urllib.parse import quote    </span><br><span class="line">&gt;&gt;&gt; quote(s)</span><br><span class="line"><span class="string">&#x27;%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果我们对文章采用了永久编码，例如 <code>hexo-abbrlink</code> 等，在
public 下文章名就会对应变成永久链接名称。</p>
<p>此时我们已经发现问题了，<strong>图片对应的URI应该是
<code>&lt;post-perm-link&gt;/&lt;pic-name&gt;</code>，但是我们在
markdown
中填写的路径是<code>&lt;post-md-name&gt;/&lt;pic-name&gt;</code></strong>，如果直接转
html 就会出现问题。</p>
<p>特别的，在 typora 中，当我们调整过图片大小后，其会将原始的 markdown
图片语法切换为 html 的 img 标签形式。</p>
<p>hexo-renderer-marked 可以对 markdown 中图片链接进行转换，但是对于
HTML 文档而言就无能为力了，毕竟 html 此时就相当于是纯文本了。</p>
<p>要想完美实现图片链接的处理，就需要我们通过插件方式进行自行实现</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: c++学习笔记</span><br><span class="line">date: 2023-01-16 13:30:31</span><br><span class="line"><span class="section">tag:</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">markdown 图片：</span><br><span class="line"></span><br><span class="line">![<span class="string">测试图片</span>](<span class="link">c-学习笔记/hexo.png</span>)</span><br><span class="line"></span><br><span class="line">html 图片</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;c-学习笔记/hexo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;测试图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>预览效果</p>
<p><img data-src="/posts/9a20/image-20230116144123563.png"
style="zoom: 50%;" /></p>
<h2 id="解决思路">解决思路</h2>
<p>搞清楚问题后，我们就可以考虑如何解决问题了，主要问题有两个</p>
<ol type="1">
<li>无法实现自动图片链接转换</li>
<li>对于 img 标签形式的图片链接也需要进行转换</li>
</ol>
<p>此时通过正则表达式进行替换的方式实现起来太复杂，不够稳定。例如，对于
markdown
文本中的代码段，如果在代码段中也包含一段图片链接，采用文本替换的方式也会对这个链接进行替换，虽然95%情况下能用，但是还是有5%的不适用场景，个人不推荐这样实现。</p>
<p>另一个比较好的解决思路就是通过<strong>语法分析</strong>获取到
markdown 文档的抽象语法树，对于 html
部分的图片链接也同样进行处理（毕竟我们最终目标是将 markdown 转换成
html，对 html 文档进行解析生成抽象语法树也是一样的）。</p>
<p>拿到抽象语法树之后，我们只需要调整 img 标签对应的 src
属性即可，此时进行替换可以确保我们一定是替换的图片链接，而不会错误地替换代码段中的链接。</p>
<p>这样我们的思路就很清楚了：</p>
<ol type="1">
<li>通过 markdown 语法分析器进行语法分析，生成抽象语法树</li>
<li>遍历抽象语法树，调整 img 节点对应链接属性，修改为永久链接</li>
<li>将抽象语法树转换成 html 文档</li>
</ol>
<p>目前有很多 js 实现的 markdown 分析器，但是根据我们的需求</p>
<ol type="1">
<li>能同时进行 markdown 和 html 文档的语法分析</li>
<li>markdown 和 html 文件能具有统一的中间表示形式</li>
</ol>
<p>纯 js 的解决方案目前只找到 <a
href="https://github.com/remarkjs/remark">remark.js</a>
一个，但是其仅支持 es6，在 hexo 中仅支持 common js 导入。</p>
<p>最后查到 pandoc 支持通过 lua 脚本的形式进行后处理（也就是 pandoc
filter），似乎完美契合我们需求，那么接下来只需要学习如何编写 pandoc
filter 即可。</p>
<blockquote>
<p><a href="https://pandoc.org/filters.html">Pandoc - Pandoc
filters</a></p>
<p>转换流程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INPUT -&gt; reader -&gt; AST -&gt; filter -&gt; AST -&gt; writer -&gt; OUTPUT</span><br></pre></td></tr></table></figure>

</blockquote>
<h2 id="plugin">plugin</h2>
<p>在调用 filter 之前，我们首先将 pandoc 集成到 hexo
中。幸运的是已经有大佬写了相关调用插件了（<a
href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a>），其代码也很简单，不到200行，可以直接通过脚本集成到
hexo 中。</p>
<p>由于 pandoc 是一个单独的可执行文件，在 js 中实际上就是调用 pandoc
可执行文件，并获取其输出。在 node.js 调用其他命令需要
<code>child_process</code> 库的 <code>spawn</code>，<code>exec</code> 或
<code>fork</code></p>
<p>这三类都可以实现外部命令的执行，由于我们需要对 pandoc 提供 markdown
文本输入并获取 html 输出，数据量较大，<code>spawn</code>
是最符合我们需求的，为了满足跨平台要求，我们可以使用
<code>cross-spawn</code>来执行命令。</p>
<p><code>spawn</code> 是一个异步函数，其输入和输出是通过
<code>stdin</code>、<code>stdout</code> 以及 <code>stderr</code>
三个<code>Stream</code> 实现的，我们需要注册相应回调才能拿到结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;node:child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">main</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> task = <span class="title function_">spawn</span>(<span class="string">&#x27;pandoc&#x27;</span>, [<span class="string">&#x27;--version&#x27;</span>], &#123;</span><br><span class="line">      <span class="attr">env</span>: process.<span class="property">env</span>,</span><br><span class="line">      <span class="attr">cwd</span>: process.<span class="title function_">cwd</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> encoding = <span class="string">&#x27;utf-8&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> stdout_chunks = [];</span><br><span class="line">    <span class="keyword">const</span> stderr_chunks = [];</span><br><span class="line">    task.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> stdout_chunks.<span class="title function_">push</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(chunk)));</span><br><span class="line">    task.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> log.<span class="title function_">error</span>(err));</span><br><span class="line">    task.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> stderr_chunks.<span class="title function_">push</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(chunk)));</span><br><span class="line">    task.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> log.<span class="title function_">error</span>(err));</span><br><span class="line">    <span class="comment">// task.stdin.end(data.text, encoding);</span></span><br><span class="line">    task.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> stderr_msg = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(stderr_chunks).<span class="title function_">toString</span>(encoding);</span><br><span class="line">      <span class="keyword">if</span> (code) &#123;</span><br><span class="line">        <span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`pandoc process exited with code <span class="subst">$&#123;code&#125;</span>.<span class="subst">$&#123;stderr_msg.length &gt; <span class="number">0</span> ? <span class="string">`\n<span class="subst">$&#123;stderr_msg&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">        e.<span class="property">code</span> = code;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (stderr_msg.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        log.<span class="title function_">debug</span>(<span class="string">`Pandoc:\n%s`</span>, stderr_msg.<span class="title function_">trim</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> stdout_msg = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(stdout_chunks).<span class="title function_">toString</span>(encoding);</span><br><span class="line">      <span class="title function_">resolve</span>(stdout_msg);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>().<span class="title function_">then</span>(<span class="function"><span class="params">output</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`output from spawn:\n<span class="subst">$&#123;output.trim()&#125;</span>`</span>)).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(e));</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Node node test.js</span><br><span class="line">output from spawn:</span><br><span class="line">pandoc 3.0.1</span><br><span class="line">Features: +server +lua</span><br><span class="line">Scripting engine: Lua 5.4</span><br><span class="line">User data directory: /home/xiao/.local/share/pandoc</span><br><span class="line">Copyright (C) 2006-2023 John MacFarlane. Web:  https://pandoc.org</span><br><span class="line">This is free software; see the <span class="built_in">source</span> <span class="keyword">for</span> copying conditions. There is no</span><br><span class="line">warranty, not even <span class="keyword">for</span> merchantability or fitness <span class="keyword">for</span> a particular purpose.</span><br></pre></td></tr></table></figure>

<p>上面的代码实际上就是调用了 <code>pandoc --version</code> 命令，并通过
CacheStream 获取到了调用命令后的输出结果，以便进行下一步的调用。</p>
<p>如果我们需要向 pandoc 传输数据（例如待处理的 markdown
文本流），我们可以直接在 <code>stdin</code>
中直接写入，同时注意写入完成后<strong>记得关闭输入流</strong>，否则
pandoc 进程会一直等待输入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">task.<span class="property">stdin</span>.<span class="title function_">end</span>(data.<span class="property">text</span>, encoding);</span><br></pre></td></tr></table></figure>

<p>在 pandoc 进行 markdown 转换的命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --from=gfm --to=html5 --mathjax</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ol type="1">
<li><code>--from</code> 表示输入格式</li>
<li><code>--to</code> 表示输出格式</li>
<li><code>--mathjax</code> 表示开启 mathjax 公式支持</li>
</ol>
<p>输入后 pandoc 就会等待 stdin 输入，输出到 stdout
中，同时将错误信息输出到 stderr 中。</p>
<p>例如我们写一个简单的 <code>h1</code> 标题，其 markdown 代码为
<code># This is h1</code> ，对应 html 代码为
<code>&lt;h1&gt;This is h1&lt;/h1&gt;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> task = <span class="title function_">spawn</span>(<span class="string">&#x27;pandoc&#x27;</span>, [<span class="string">&#x27;--from=gfm&#x27;</span>,<span class="string">&#x27;--to=html5&#x27;</span>,<span class="string">&#x27;--mathjax&#x27;</span>], &#123;</span><br><span class="line">    <span class="attr">env</span>: process.<span class="property">env</span>,</span><br><span class="line">    <span class="attr">cwd</span>: process.<span class="title function_">cwd</span>()</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">task.<span class="property">stdin</span>.<span class="title function_">end</span>(<span class="string">&#x27;# This is h1&#x27;</span>, encoding);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  Node node test.js</span><br><span class="line">output from spawn:</span><br><span class="line">&lt;h1 <span class="built_in">id</span>=<span class="string">&quot;this-is-h1&quot;</span>&gt;This is h1&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，通过 spawn 我们可以正确调用 pandoc 并实现从 markdown 到
html 的转换。最后只需要编写 pandoc filter 就可以完成插件了。</p>
<h2 id="pandoc-filter">pandoc filter</h2>
<h3 id="hellolua-filter">hello，lua filter</h3>
<p>在 <a href="https://pandoc.org/lua-filters.html">Pandoc 官网</a>
中给出了一个简单的示例</p>
<p>文件：<code>smallcaps.lua</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    Strong = <span class="function"><span class="keyword">function</span> <span class="params">(elem)</span></span></span><br><span class="line">      <span class="keyword">return</span> pandoc.SmallCaps(elem.c)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其将所有的 Strong 标签（粗体，在 markdown 就是
<code>**A**</code>，<strong>A</strong>）转换 Small Caps 形式，测试
markdown 如下</p>
<p>将其保存为 <code>test.md</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**hello world!**</span></span><br></pre></td></tr></table></figure>

<p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --lua-filter=smallcaps.lua -o test.html test.md</span><br></pre></td></tr></table></figure>

<p>如果不指定输出格式，其默认使用 html 格式输出，对应输出结果如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;smallcaps&quot;</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在 html 中并不能原生支持 smallcaps 样式，但是 pandoc
为其指定了一个 css 类名，通过类名这个我们可以手动实现 smallcaps
效果。</p>
<h3 id="filter-写法">filter 写法</h3>
<p>上面的代码第一眼看上有点奇怪，怎么以来就是一个 <code>return</code>
语句，返回的 <code>&#123;&#125;</code> 怎么直接套了一个
<code>&#123;xxx = xxx&#125;</code></p>
<p>首先解释后面一点，在 lua 中，列表和字典都使用 <code>&#123;&#125;</code>
表示，那么最外层的就是一个列表，然后内层的是一个字典，我们可以看到其指定了一个键为
<code>Strong</code> 的函数，表示对 <code>Strong</code>
这个节点的处理函数。</p>
<p>那么最开始的 <code>return</code>
就表示这个脚本可以作为包被外部使用，就有点类似于 common js
中模块写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> =&#123;</span><br><span class="line">	<span class="title class_">Strong</span> = <span class="keyword">function</span>(<span class="params">elem</span>)&#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后在 pandoc 内部调用时，直接使用下面语句</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">require</span>(<span class="string">&quot;smallcaps&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>即可导入使用</p>
<p>在 Pandoc 中定义了很多种抽象语法树的节点类型，例如
Block、String、Inline等，对于每一个节点类型我们都可以编写对应的处理函数对其进行处理，同时根据列表的顺序还可以控制抽象语法树的遍历方式。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Meta</span><span class="params">(meta)</span></span> </span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&quot;process meta&quot;</span>) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Para</span><span class="params">(para)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;process para&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Image</span><span class="params">(image)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;process image&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123;Meta = Meta&#125;,</span><br><span class="line">    &#123;Para = Para&#125;,</span><br><span class="line">    &#123;Image = Image&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 markdown</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">title: 测试 markdown</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">![<span class="string">test-image</span>](<span class="link">url-to-image</span>)</span><br></pre></td></tr></table></figure>

<p>测试命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --lua-filter test.lua -o test.html test.md</span><br></pre></td></tr></table></figure>

<p>在控制台的输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Lua\pandoc-filter&gt; pandoc --lua-filter test.lua -o test.html test.md</span><br><span class="line">process meta</span><br><span class="line">process para</span><br><span class="line">process para</span><br><span class="line">process image</span><br></pre></td></tr></table></figure>

<p>从输出结果上我们可以看到，首先处理的是 meta，之后是两个 para，最后是
image，其对应的文档结构如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span>&gt;</span>...<span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;url-to-image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;test-image&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：<strong>如果函数中没有返回任何值（或者返回
nil），表示该函数不会对抽象语法树进行修改</strong>。</p>
<h2 id="final-filter">final filter</h2>
<p>参考 pandoc 对于 <a
href="https://pandoc.org/lua-filters.html#type-image">image</a>
标签的描述，通过 <code>src</code>
字段可以读取到图片的链接信息，我们只需要修改 url
值即可，根据之前的描述，我们可以编写一个简单的 filter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local url_prefix</span><br><span class="line"></span><br><span class="line">local function Meta(meta) </span><br><span class="line">  url_prefix = meta.url_prefix </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local function Image(image)</span><br><span class="line">   image.src = url_prefix ..&#x27;/&#x27;.. image.src</span><br><span class="line">   print(&quot;image.src: &quot;,image.src)</span><br><span class="line">   return image</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">   &#123;Meta = Meta&#125;,</span><br><span class="line">   &#123;Image = Image&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时在命令行中通过 <code>--metadata=key:value</code>
来指定元数据信息</p>
<p>转换命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc --metadata=url_prefix:<span class="built_in">test</span> --lua-filter test.lua -o test.html test.md</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">image.src:      <span class="built_in">test</span>/test.jpg</span><br></pre></td></tr></table></figure>

<p>转换后的 html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;test/url-to-image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;test-image&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span>test-image<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到 <code>src</code>
部分已经替换成了我们需要的链接，并且还对图片添加了 figcaption</p>
<p>之前我们提到，在 markdown 文档中可能存在 html
代码，对于这一部分我们也想要进行处理，默认 pandoc 会将其解析为
RawBlock，即不做任何处理，但也可以使用 <code>pandoc.read</code>
进行解析，生成抽象语法树，这样我们就可以对 html
形式的图片进行解析了。</p>
<p>完整代码如下</p>
<p>文件：<code>image-asset.lua</code></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    Reference: </span></span><br><span class="line"><span class="comment">    [1] https://pandoc.org/lua-filters.html</span></span><br><span class="line"><span class="comment">    [2] http://www.lua.org/manual/5.4/</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> logging = <span class="built_in">require</span>(<span class="string">&#x27;logging&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> new_path</span><br><span class="line"><span class="keyword">local</span> path_prefix</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Meta</span><span class="params">(meta)</span></span></span><br><span class="line">    <span class="comment">-- logging.temp(&#x27;Meta&#x27;,meta)</span></span><br><span class="line">    <span class="keyword">local</span> meta_path = meta[<span class="string">&#x27;path&#x27;</span>]</span><br><span class="line">    <span class="keyword">local</span> meta_title = meta[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> (meta_path == <span class="literal">nil</span> <span class="keyword">or</span> meta_title == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        logging.temp(<span class="string">&#x27;Meta&#x27;</span>,<span class="string">&#x27;no meta data found, ignored.&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line">    new_path = pandoc.utils.stringify(meta_path)</span><br><span class="line">    path_prefix = pandoc.utils.stringify(meta_title) .. <span class="string">&#x27;/&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">Image</span><span class="params">(image)</span></span></span><br><span class="line">    <span class="keyword">if</span> (new_path == <span class="literal">nil</span> <span class="keyword">or</span> path_prefix == <span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> length = pandoc.text.<span class="built_in">len</span>(path_prefix)</span><br><span class="line">    <span class="keyword">local</span> prefix = pandoc.text.<span class="built_in">sub</span>(image.src,<span class="number">1</span>,length)</span><br><span class="line">    <span class="keyword">local</span> postfix = pandoc.text.<span class="built_in">sub</span>(image.src,length+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (prefix == path_prefix) <span class="keyword">then</span></span><br><span class="line">        image.src = new_path .. postfix</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- delete image caption info and title (just a hack)</span></span><br><span class="line">    image.caption = &#123;&#125;</span><br><span class="line">    image.title = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">RawBlock</span> <span class="params">(raw)</span></span></span><br><span class="line">    <span class="keyword">if</span> raw.<span class="built_in">format</span>:<span class="built_in">match</span>(<span class="string">&#x27;html&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> res = pandoc.<span class="built_in">read</span>(raw.text,<span class="string">&#x27;html&#x27;</span>)</span><br><span class="line">        <span class="comment">-- https://pandoc.org/lua-filters.html#type-blocks</span></span><br><span class="line">        <span class="keyword">if</span> ( #res.blocks == <span class="number">1</span> ) <span class="keyword">then</span></span><br><span class="line">            <span class="comment">-- convert Plain to Para</span></span><br><span class="line">            <span class="keyword">return</span> pandoc.Para(res.blocks[<span class="number">1</span>].content)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- function Pandoc(pandoc)</span></span><br><span class="line"><span class="comment">--     logging.temp(&#x27;Pandoc&#x27;,pandoc)</span></span><br><span class="line"><span class="comment">-- end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- return in global scope (can be loaded via `require`)</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    &#123; RawBlock = RawBlock &#125;,</span><br><span class="line">    &#123; Meta = Meta &#125;,</span><br><span class="line">    &#123; Image = Image &#125;,</span><br><span class="line">    <span class="comment">-- &#123; Pandoc = Pandoc &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后给出完整的插件代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code modified from https://github.com/wzpan/hexo-renderer-pandoc/blob/master/index.js</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&#x27;node:child_process&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;node:path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;node:assert&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; yellow &#125; = <span class="built_in">require</span>(<span class="string">&#x27;picocolors&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">config</span>.<span class="property">pandoc</span> = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;</span><br><span class="line">    <span class="attr">pandoc_bin</span>: <span class="string">&#x27;pandoc&#x27;</span>,</span><br><span class="line">    <span class="attr">math_engine</span>: <span class="string">&#x27;mathjax&#x27;</span>,</span><br><span class="line">    <span class="attr">markdown_mode</span>: <span class="string">&#x27;gfm&#x27;</span>,</span><br><span class="line">    <span class="attr">filters</span>: [],</span><br><span class="line">    <span class="attr">lua_filters</span>: [],</span><br><span class="line">    <span class="attr">extra</span>: [],</span><br><span class="line">&#125;, hexo.<span class="property">config</span>.<span class="property">pandoc</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// must have the `?.lua` specified!</span></span><br><span class="line"><span class="keyword">const</span> pandoc_env = &#123; ...process.<span class="property">env</span>, <span class="attr">LUA_PATH</span>: path.<span class="title function_">join</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;lua&#x27;</span>, <span class="string">&#x27;?.lua&#x27;</span>) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">argument</span> = (<span class="params">name, value = <span class="literal">undefined</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`--<span class="subst">$&#123;name&#125;</span>=<span class="subst">$&#123;value&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`--<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is_string</span> = obj =&gt; <span class="keyword">typeof</span> (obj) === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is_array</span> = obj =&gt; <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">is_object</span> = obj =&gt; <span class="keyword">typeof</span> (obj) === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get_cache</span> = (<span class="params">stream, encoding</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> buf = stream.<span class="title function_">getCache</span>();</span><br><span class="line">    stream.<span class="title function_">destroy</span>();</span><br><span class="line">    <span class="keyword">if</span> (!encoding) <span class="keyword">return</span> buf;</span><br><span class="line">    <span class="keyword">return</span> buf.<span class="title function_">toString</span>(encoding);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">renderer</span> = (<span class="params">data, options</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; log &#125; = hexo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> config = hexo.<span class="property">config</span>.<span class="property">pandoc</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> filters = [];</span><br><span class="line">    <span class="keyword">const</span> lua_filters = [];</span><br><span class="line">    <span class="keyword">const</span> extra = [<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">&#x27;pagetitle:ignored&#x27;</span>)];</span><br><span class="line">    <span class="comment">// To satisfy pandoc&#x27;s requirement that html5 must have a title.</span></span><br><span class="line">    <span class="comment">// Since the markdown file is only rendered as body part,</span></span><br><span class="line">    <span class="comment">// the title is never used and thus does not matter</span></span><br><span class="line">    <span class="keyword">const</span> pandoc_bin = config.<span class="property">pandoc_bin</span>;</span><br><span class="line">    <span class="keyword">const</span> math_engine = <span class="title function_">argument</span>(config.<span class="property">math_engine</span>);</span><br><span class="line">    <span class="keyword">const</span> markdown_mode = config.<span class="property">markdown_mode</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is_array</span>(config.<span class="property">filters</span>)) &#123;</span><br><span class="line">        config.<span class="property">filters</span> = [config.<span class="property">filters</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is_array</span>(config.<span class="property">lua_filters</span>)) &#123;</span><br><span class="line">        config.<span class="property">lua_filters</span> = [config.<span class="property">lua_filters</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is_array</span>(config.<span class="property">extra</span>)) &#123;</span><br><span class="line">        config.<span class="property">extra</span> = [config.<span class="property">extra</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    config.<span class="property">filters</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line">        filters.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;filter&#x27;</span>, filter));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    config.<span class="property">lua_filters</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line">        lua_filters.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;lua-filter&#x27;</span>, filter));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    config.<span class="property">extra</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">is_string</span>(item)) &#123;</span><br><span class="line">            extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(item));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">is_object</span>(item)) &#123;</span><br><span class="line">            <span class="title function_">assert</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(item).<span class="property">length</span> === <span class="number">1</span>, <span class="string">`item in extra must be a key-value tuple or string`</span>);</span><br><span class="line">            <span class="keyword">const</span> [key, value] = <span class="title class_">Object</span>.<span class="title function_">entries</span>(item)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">is_array</span>(value)) &#123;</span><br><span class="line">                value.<span class="title function_">forEach</span>(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">                    extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(key, v));</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(key, value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`unknown extra config for pandoc: <span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">POST_MODEL</span> = hexo.<span class="title function_">model</span>(<span class="string">&#x27;Post&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> source = data.<span class="property">path</span>.<span class="title function_">substring</span>(hexo.<span class="property">source_dir</span>.<span class="property">length</span>).<span class="title function_">replace</span>(<span class="regexp">/\\/g</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> current_post = <span class="variable constant_">POST_MODEL</span>.<span class="title function_">findOne</span>(&#123; source &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_post) &#123;</span><br><span class="line">        <span class="comment">// manually add root path</span></span><br><span class="line">        <span class="keyword">const</span> post_path = <span class="string">`/<span class="subst">$&#123;current_post.path&#125;</span>`</span>;</span><br><span class="line">        <span class="comment">// the filename (xxx.md) may not correspond to title field in Markdown Front Matter</span></span><br><span class="line">        <span class="keyword">const</span> filename = path.<span class="title function_">basename</span>(data.<span class="property">path</span>, <span class="string">&#x27;.md&#x27;</span>);</span><br><span class="line">        log.<span class="title function_">debug</span>(<span class="string">&#x27;Filename: %s&#x27;</span>, <span class="title function_">yellow</span>(filename));</span><br><span class="line">        <span class="comment">// const title = current_post.title;</span></span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">`path:<span class="subst">$&#123;post_path&#125;</span>`</span>));</span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">`title:<span class="subst">$&#123;filename&#125;</span>`</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if we are rendering a post,</span></span><br><span class="line">    <span class="comment">// `data` has the key `path`</span></span><br><span class="line">    <span class="comment">// https://github.com/hexojs/hexo/blob/2ed17cd105768df379dad8bbbe4df30964fe8f2d/lib/hexo/post.js#L269</span></span><br><span class="line">    <span class="comment">// otherwise (e.g., rendering a tag),</span></span><br><span class="line">    <span class="comment">// `path` is not present in `data`.</span></span><br><span class="line">    <span class="comment">// https://github.com/hexojs/hexo/blob/2ed17cd105768df379dad8bbbe4df30964fe8f2d/lib/extend/tag.js#L173</span></span><br><span class="line">    <span class="comment">// https://github.com/hexojs/hexo/blob/a6dc0ea28dddad1b5f1bad7c6f86f1e0627b564a/lib/plugins/tag/blockquote.js#L64</span></span><br><span class="line">    <span class="comment">// are we rendering a standalone post?</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">path</span>) &#123;</span><br><span class="line">        <span class="comment">// only apply template when rendering post, not tags</span></span><br><span class="line">        <span class="keyword">if</span> (config.<span class="property">template</span>) &#123;</span><br><span class="line">            extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;template&#x27;</span>, config.<span class="property">template</span>, <span class="literal">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do not apply `--standalone`,</span></span><br><span class="line">        <span class="comment">// header/footer are to be added by Hexo</span></span><br><span class="line">        <span class="comment">// also set a metavariable to let concerned</span></span><br><span class="line">        <span class="comment">// pandoc filters know</span></span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">&#x27;standalone:true&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// or some thing to be embedded in a post,</span></span><br><span class="line">        <span class="comment">// like tags?</span></span><br><span class="line">        extra.<span class="title function_">push</span>(<span class="title function_">argument</span>(<span class="string">&#x27;metadata&#x27;</span>, <span class="string">&#x27;standalone:false&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> args = [</span><br><span class="line">        <span class="title function_">argument</span>(<span class="string">&#x27;from&#x27;</span>, markdown_mode),</span><br><span class="line">        <span class="title function_">argument</span>(<span class="string">&#x27;to&#x27;</span>, <span class="string">&#x27;html5&#x27;</span>),</span><br><span class="line">        math_engine,</span><br><span class="line">        ...extra,</span><br><span class="line">        ...lua_filters,</span><br><span class="line">        ...filters,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    log.<span class="title function_">debug</span>(<span class="string">&#x27;Pandoc command: %s&#x27;</span>, <span class="title function_">yellow</span>(<span class="string">`<span class="subst">$&#123;pandoc_bin&#125;</span> <span class="subst">$&#123;args.join(<span class="string">&#x27; &#x27;</span>)&#125;</span>`</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> task = <span class="title function_">spawn</span>(pandoc_bin, args, &#123;</span><br><span class="line">            <span class="attr">env</span>: pandoc_env,</span><br><span class="line">            <span class="attr">cwd</span>: process.<span class="title function_">cwd</span>(),</span><br><span class="line">            <span class="attr">stdio</span>: <span class="string">&#x27;pipe&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">const</span> encoding = <span class="string">&#x27;utf-8&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> stdout_chunks = [];</span><br><span class="line">        <span class="keyword">const</span> stderr_chunks = [];</span><br><span class="line"></span><br><span class="line">        task.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> stdout_chunks.<span class="title function_">push</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(chunk)));</span><br><span class="line">        task.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> log.<span class="title function_">error</span>(err));</span><br><span class="line"></span><br><span class="line">        task.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> stderr_chunks.<span class="title function_">push</span>(<span class="title class_">Buffer</span>.<span class="title function_">from</span>(chunk)));</span><br><span class="line">        task.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> log.<span class="title function_">error</span>(err));</span><br><span class="line"></span><br><span class="line">        task.<span class="property">stdin</span>.<span class="title function_">end</span>(data.<span class="property">text</span>, encoding);</span><br><span class="line"></span><br><span class="line">        task.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> stderr_msg = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(stderr_chunks).<span class="title function_">toString</span>(encoding);</span><br><span class="line">            <span class="keyword">if</span> (code) &#123;</span><br><span class="line">                <span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`pandoc process exited with code <span class="subst">$&#123;code&#125;</span>.<span class="subst">$&#123;stderr_msg.length &gt; <span class="number">0</span> ? <span class="string">`\n<span class="subst">$&#123;stderr_msg&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>);</span><br><span class="line">                e.<span class="property">code</span> = code;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reject</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stderr_msg.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                log.<span class="title function_">debug</span>(<span class="string">`Pandoc:\n%s`</span>, <span class="title function_">yellow</span>(stderr_msg.<span class="title function_">trim</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> output = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>(stdout_chunks).<span class="title function_">toString</span>(encoding);</span><br><span class="line">            <span class="keyword">const</span> length = output.<span class="property">length</span>;</span><br><span class="line">            log.<span class="title function_">debug</span>(<span class="string">`Pandoc Output Size: <span class="subst">$&#123;length&#125;</span> bytes`</span>);</span><br><span class="line">            log.<span class="title function_">debug</span>(<span class="string">`Pandoc Output Preview:\n%s`</span>, <span class="title function_">yellow</span>(length &gt; <span class="number">100</span> ? output.<span class="title function_">substring</span>(length - <span class="number">100</span>, length).<span class="title function_">trim</span>() : output.<span class="title function_">trim</span>()));</span><br><span class="line">            <span class="title function_">resolve</span>(output);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;md&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;markdown&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mkd&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mkdn&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mdwn&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mdtxt&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">renderer</span>.<span class="title function_">register</span>(<span class="string">&#x27;mdtext&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, renderer, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h1 id="总结">总结</h1>
<p>写了很多，大概记录了一下 hexo
自定义插件过程，还有很多没有详细介绍的，有兴趣的话参照下方的链接自行编写即可，弄清楚逻辑后代码写起来还是很快的。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a href="https://hexo.io/zh-cn/docs/plugins">插件 | Hexo</a></li>
<li><a
href="https://github.com/wzpan/hexo-renderer-pandoc">wzpan/hexo-renderer-pandoc:
A pandoc-markdown-flavor renderer for hexo. (github.com)</a></li>
<li><a
href="https://nodejs.org/docs/latest-v18.x/api/child_process.html#child_processspawncommand-args-options">Child
process | Node.js v18.13.0 Documentation (nodejs.org)</a></li>
<li><a href="https://pandoc.org/lua-filters.html">Pandoc - Pandoc Lua
Filters</a></li>
<li><a
href="https://github.com/wlupton/pandoc-lua-logging">wlupton/pandoc-lua-logging:
Pandoc lua filter logging support (github.com)</a></li>
<li><a href="http://www.lua.org/manual/5.4/">Lua 5.4 Reference Manual -
contents</a></li>
</ol>
]]></content>
      <categories>
        <category>Hexo使用记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>pandoc</tag>
        <tag>node.js</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串编码</title>
    <url>/posts/c4ef/</url>
    <content><![CDATA[<p><em><strong>Encodings should be known, not divined.</strong></em></p>
<h2 id="问题描述">问题描述</h2>
<p>在前一篇我们使用 pandoc 的 lua filter 解决了 markdown 转 html
中链接问题，但是在调试代码的过程中发现了一个问题，在不同的 shell 中执行
lua
脚本时，输出中文有时会乱码，有时又不会乱码，搞得有点烦，本篇就针对字符串问题做一个探究，搞清楚乱码的源头以及解决方案。</p>
<p>首先看一个简单的示例，下面是一段简单的 c 语言 hello world</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;你好，世界！😉&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件保存格式为：<code>UTF-8</code>（注意看 vscode 的右下角，写着
UTF-8）</p>
<p><img data-src="/posts/c4ef/image-20230117150536045.png"
style="zoom:50%;" /></p>
<span id="more"></span>

<p>使用 msvc 编译后，分别在 git
bash、msys2、powershell上运行后输出结果如下</p>
<p><img data-src="/posts/c4ef/image-20230117150241891.png"
style="zoom: 67%;" /></p>
<blockquote>
<p>注：使用 msvc 编译 UTF-8 文件时，需要添加 <code>/utf-8</code>
参数，否则会使用本机默认编码进行编译，有可能导致编译失败。</p>
<p><img data-src="/posts/c4ef/image-20230119233748271.png" /></p>
</blockquote>
<p>可以看到，仅在 git bash 中能正确输出中文，如果我们将编码保存为
GBK，再编译运行</p>
<p><img data-src="/posts/c4ef/image-20230117151454957.png"
style="zoom:50%;" /></p>
<p>输出结果如下：</p>
<p><img data-src="/posts/c4ef/image-20230117152301608.png"
style="zoom: 67%;" /></p>
<p>可以看到此时在 Git Bash 中输出乱码了，而在 msys2 和 powershell
中可以正确输出中文了，但是 emoji 的输出还是有问题（变成了问号）</p>
<p>再使用 python 输出上面那句话看看效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;你好，世界！😉&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>分别在三个终端中进行测试，输出结果如下</p>
<p><img data-src="/posts/c4ef/image-20230117154659021.png"
style="zoom: 67%;" /></p>
<p>此时 git bash 中直接报错，说 GBK 无法解析 <code>U+1F609</code>
也就是笑脸 😉 ，而在 msys2 和 powershell 中均可以正确输出中文，但是
powershell 中无法输出 emoji 表情，而 msys2 可以正确输出。</p>
<p>这个结果更令人费解了，C 语言和 Python
输出结果不一致，在不同终端下输出也不一样。</p>
<h2 id="编码简史">编码简史</h2>
<p>关于编码的发展过程，下面这篇文章做了很好的介绍</p>
<blockquote>
<p><a
href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">The
Absolute Minimum Every Software Developer Absolutely, Positively Must
Know About Unicode and Character Sets (No Excuses!) – Joel on
Software</a></p>
</blockquote>
<p>参考这篇文章，我们做一个简单的总结。</p>
<h3 id="ascii">ASCII</h3>
<p>在计算机中，所有数据都是以二进制形式存储的，我们在屏幕上阅读的文字如
“A”，“你好”
等也需要以二进制形式存储。<strong>编码描述的就是我们如何将可阅读的字符存储在计算机中</strong>。
ASCII ( /ˈæski/ )
编码是早期常用的一种编码（现在也很常用，只不过是其他编码兼容该编码罢了）。其包含128个字符，使用
8 位存储（剩下的 128 - 255 部分称为扩展 ASCII
编码，不过并不常用），下图展示了所有的ASCII字符及其对应的编码值（图片来自：<a
href="http://www.asciicharstable.com/"><span>http://www.asciicharstable.com/</span></a>）</p>
<p><img data-src="/posts/c4ef/ascii-chars-table-landscape.jpg"
style="zoom: 25%;" /></p>
<p>例如大写字母 <code>A</code> 对应的 ASCII 十进制编码就是
<code>65</code>，也即二进制的 <code>0b01000001</code> 和十六进制的
<code>0x41</code>。</p>
<p>从表中可以看到，仅包含大小写字母，而中文、俄语等文字并不包括在内。为了解决这个问题，一些厂家就自定义了一套编码格式，从而支持其他语言的字符显示。但是厂家自定义的编码并不能跨平台，例如在
IBM 上编写的文档就有可能无法在 Mach 上打开，因为他们使用的编码不同。</p>
<h3 id="ansi">ANSI</h3>
<p>厂家自定义编码太杂乱，为了实现跨平台，后来就统一了编码（车同轨，书同文？），称为
ANSI 编码。ANSI 编码并不将所有的字符都编码到一张表上，其仅确保前 128
个字符（也就是 ASCII 编码部分）是一致的，后面部分的编码由代码页（code
page）决定，不同地区使用不同的代码页，从而在不同地区显示不同的文字。目前
Windows
仍然支持的这种编码方式，可以在控制面板的时钟和区域中进行设置。</p>
<p><img data-src="/posts/c4ef/image-20230118163241733.png"
style="zoom:50%;" /></p>
<p>对于中日韩文而言，其使用的是表意文字（ideograph），可能包含数万个字符，仅使用
8 位显然是无法表示这些字符的。后面就将 ANSI 编码扩展到了两个字节，其中
<code>0x80</code> 至 <code>0xFFFF</code>
部分由代码页来决定编码。中文对应的编码方式有 GB 2312 及其扩展
GBK（<strong>G</strong>uo jia <strong>B</strong>iao zhun
<strong>K</strong>uo zhan，国家标准扩展）。</p>
<blockquote>
<p>注：GBK 和 ANSI 的关系：GBK 属于 ANSI
的一部分，其专门负责对中文进行编码，而其他字母等仍使用 ASCII
编码，例如一段话</p>
<p><code>Hi, 你好</code>，对应的 GBK ANSI 编码为，其中 <code>Hi,</code>
仍是单字节编码，而后面的 <code>你好</code> 则是双字节编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[0x48,0x69,0x20,0xC4,0xE3,0xBA,0xC3]</span><br></pre></td></tr></table></figure>

<p>GBK 实际上是一个定长编码，其描述的所有字符都是双字节，但是此时 ANSI
就是一个变长编码，其既包含单字节字符，也包含双字节字符。</p>
</blockquote>
<p>在 Windows 下，可以使用 <code>chcp</code> 命令查看当前控制台使用的
ANSI 代码页（同时也可以使用该命令切换控制台使用的代码页）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Users\xiao&gt; chcp</span><br><span class="line">活动代码页: 936</span><br></pre></td></tr></table></figure>

<p>在程序中可以使用 <code>GetACP()</code>
函数来查询程序中使用的代码页（需要调用 Windows API）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winnls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current Windows ANSI code page identifier is: %u&quot;</span>,<span class="built_in">GetACP</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Cpp\encoding-demo\bin&gt; .\test.exe    </span><br><span class="line">current Windows ANSI code page identifier is: 936</span><br></pre></td></tr></table></figure>

<p>在微软 win32 文档中给出了代码页标识符的相关描述：<a
href="https://learn.microsoft.com/en-us/windows/win32/intl/code-page-identifiers">Code
Page Identifiers - Win32 apps | Microsoft Learn</a></p>
<p><img data-src="/posts/c4ef/image-20230118172323075.png"
style="zoom:50%;" /></p>
<p>可以看到，本机 Windows 的ANSI代码页编号为 936，对应 GB2312
编码，而后续 GBK 发布后更新了 GBK 部分的字符，因此也常称为 GBK
编码。</p>
<p>采用代码页的方式在单语言场景下足够使用了，但是有时我们可能会浏览其他语言的网站，或接收到其他语言的邮件，我们的系统上就无法显示这些字符了（代码页并不能随便切换）。</p>
<p><strong>彩蛋：”烫烫烫烫烫烫烫烫...“？</strong></p>
<p>在 GBK 编码中，烫的编码为 <code>[0xCC,0xCC]</code>，在 MSVC
的调试模式下，会自动将未初始化的内存设置为
<code>0xCC</code>（字节），用来进行 <a
href="https://learn.microsoft.com/zh-cn/cpp/build/reference/rtc-run-time-error-checks?view=msvc-170">运行时错误检查</a>。</p>
<p>添加 <code>/RTC1</code>
编译标志即可开启检查功能，我们进行调试时，就会看到如下字样</p>
<p><img data-src="/posts/c4ef/image-20230120002426547.png"
style="zoom: 50%;" /></p>
<p>下面是测试代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处故意不初始化</span></span><br><span class="line"><span class="type">uint32_t</span> v;</span><br><span class="line"><span class="type">uint8_t</span> *arr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(&amp;v);</span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(arr, arr + <span class="number">4</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>输出结果就为 <code>烫烫</code></p>
<p>除了 <code>烫</code>，还有可能出现 <code>屯屯屯屯</code>，因为 MSVC
在调试时会将动态分配的内存值初始化为 <code>0xCD</code>，而
<code>屯</code> 的 GBK 编码刚好是 <code>[0xCD,0xCD]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;烫&quot;</span>.encode(<span class="string">&quot;gbk&quot;</span>)</span><br><span class="line"><span class="string">b&#x27;\xcc\xcc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;屯&#x27;</span>.encode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;\xcd\xcd&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="unicode">Unicode</h3>
<p>为了解决在同一系统上的跨语言显示问题，就只能将全部字符编码到一张表上，这种表示方式称为
Unicode，中文称为 <strong>统一码</strong>，不过一般直接说 Unicode
即可。注意这里我们用的表述是
字符的<strong>表示方式</strong>，而不是编码方式。Unicode
为每一个字符分配一个 code point（码点），就唯一表示一个字符，例如
<code>你</code> 的 Unicode 码点为 <code>U+4F60</code>，<code>U+</code>
前缀就表示这是一个 Unicode 码点，后面的十六进制就表示具体的代码值。</p>
<p><strong>码点和编码之间并不是一一对应关系，码点只是一个形式化的表示方式（可以理解为字符在字符空间中的一个坐标），其并不关心具体如何在计算机中存储的</strong>。UTF
(<strong>U</strong>nicode <strong>T</strong>ransformation
<strong>F</strong>ormat，Unicode 传输格式)
才是决定具体如何在计算机中存储和传输的，根据使用场景不同，包含以下六类：</p>
<ul>
<li>UTF-8</li>
<li>UTF-8 with BOM</li>
<li>UTF-16 LE</li>
<li>UTF-16 BE</li>
<li>UTF-32 BE</li>
<li>UTF-32 LE</li>
</ul>
<p>注：BOM 表示 <strong>B</strong>yte <strong>O</strong>rder
<strong>M</strong>ark，字节顺序标志，LE 和 BE 分别代表 Little Endian
（小端）以及 Big Endian （大端）</p>
<h4 id="大小端与字节顺序">大小端与字节顺序</h4>
<p>大小端描述的是字节在多字节数据中的存储顺序，例如一个
<code>uint32_t</code> 是 4 个字节，例如
<code>0x1f2f3f4f</code>，其各字节信息如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Value(uint32_t): 0x1f2f3f4f</span><br><span class="line">Byte View:</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">| bits |   0..7   |   8..15  |  16..23  |  24..31  |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">| byte |  byte[0] |  byte[1] |  byte[2] |  byte[3] |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">|  hex |    4f    |    3f    |    2f    |    1f    |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br><span class="line">|  bin | 01001111 | 00111111 | 00101111 | 00011111 |</span><br><span class="line">+------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>而其实际在内存中存储按字节顺序可以分为两种存储顺序</p>
<ul>
<li><p><strong>按内存地址从低到高，字节顺序从低字节到高字节存储</strong></p>
<p>这种字节排列顺序称为小端，因为低位字节（小值）优先存储</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Little Endian Memory View:</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">| addr | 0x1fdd3356050 | 0x1fdd3356051 | 0x1fdd3356052 | 0x1fdd3356053 |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  hex |       4f      |       3f      |       2f      |       1f      |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  bin |    01001111   |    00111111   |    00101111   |    00011111   |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>按内存地址从低到高，字节顺序从高字节到低字节存储</strong></p>
<p>这种字节排列顺序称为大端，因为高位字节（大值）优先存储</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Big Endian Memory View:</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">| addr | 0x1fdd3356550 | 0x1fdd3356551 | 0x1fdd3356552 | 0x1fdd3356553 |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  hex |       1f      |       2f      |       3f      |       4f      |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br><span class="line">|  bin |    00011111   |    00101111   |    00111111   |    01001111   |</span><br><span class="line">+------+---------------+---------------+---------------+---------------+</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>注：<strong>无论是大端还是小端，一个字节中的 bit
的排列顺序永远都是从低位到高位</strong></p>
<blockquote>
<p>大端和小端出自 Jonathan Swift 的《格列佛游记》（Gulliver's
Trabels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。</p>
<p>一下是 Jonathan Swift 在1726年关于大小端之争的历史描述：</p>
<p><em>“......下面要告诉你的是，Lilliput 和 Blefuscu
这两大强国在过去36个月里一直在苦战。战争开始是由于以下的原因：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是当今皇帝的祖父小时候吃鸡蛋，一次按古法打鸡蛋是碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由
Blefuscu
的国王大臣们煽动起来的。叛乱平息后，流亡的人总是逃到那个帝国去寻救避难。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。”</em></p>
<p><em>（此段译文摘自网上蒋剑锋译的
《格列佛游记》第一卷第4章。）</em></p>
<p><img data-src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHCBIUEhcVEhUYFxcZGRoXGRoZGhocIB0aGBciHRgaIBoaICwkICEpIhoZJDYkKS0vNDMzGSI4PjgzPSwyMzUBCwsLDw4PHhISHTMjIiM6Ly8vMzM6Mi8yOjIvMjI0LzQ0LzIyMi8yMjIzLzIyMjo7MjQyLzQ0MjIzMjIyMjIvL//AABEIAJ8BPgMBIgACEQEDEQH/xAAbAAEBAAMBAQEAAAAAAAAAAAAABgEEBQMHAv/EAEcQAAEDAgQDBQMICAMHBQAAAAEAAgMEEQUSITEGQVETIjJhcRSBkQcjM0JSYqGxFSQ0Q1NyksGisvEWF0Rjg8LRNoKT0vD/xAAaAQEAAwEBAQAAAAAAAAAAAAAAAQIDBAUG/8QALhEBAAICAQMCBAMJAAAAAAAAAAECAxEEEiExQVEiYYGRE6HwFCMyQmJxscHx/9oADAMBAAIRAxEAPwD7MiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiICIiAiIgIiIMIpziDjKiozkkkzynwwxjPITyGUbX+8QuGcVxqr/Z4Y6CI7ST9+W1tCIho0+Th71S161jdp0a2vS4AXOgXEr+LsOhJEtXC0jdoe1zv6W3Km/wDYNkuuIVVTVnS7XyFkd/KNm3xXYoeFsPht2VJC0jmY2ud/U+5/FctubjjxuV4pLSf8qOE7MlfIfuQyn82hef8AvQouUNWR17A/+VTsaG+EBvoLfkv3nPUrOef7V/M6EzH8qGFbPlkjP34ZB/laV38N4loanSCpikP2Q8Zv6Tr+C9HsDtHAOHmAfzXDxLg/DqgHtKWK5+sxuR39Udj8VavPr6wdCvRfOxw/iFH3sOrHSRjU09Wc7bdGybs05aDqVv8ACPyhUta7sX2hqAS3s3ODmvI37N40d6b9LjVddMtckbrKsxpbIiLRAiIgIiICIiAiIgIi5eMY7S0jc1VMyIcg494/ytHed7gg6aKDPHss+mG0E9QOUkloYzfmHP39NF+XRY/P46ilpAdhFGZXgdCZO78Cs75aV8ymImV8sr587g+pf9Pitc4/8pzYh8G3WBwBTfWqa5x6mod/9VjPMxR6p6ZfQUXz48AQj6Orr4z1bUH+7Vn/AGbxKK3suKzG31ahjZQfIuOvvsleXin10dMvoCKBbxFi9L+20bamMby0Zu4AczE7U+6wVJgHE9JWtvTShzh4mHuvb/Mw6j12810VtW0bidqu2iIrAiIgIiICwsqR4o4uFO8U1LH7RWP8MTTowH68jvqtG9ufkNVEzodnHMcpqOIy1MgY3YX1c49GtGpPoo51TimJ+HNh9IeZ/aJGnoPqA9d/ULawXhQ9r7ViL/aao6i+scXPLGw6afat/dVS4M3M9KfdpWvu4+A8NUlGPmIwHnxSu70jidyXnXXoLDyXXRF51rTadzO1ojQiIqJEREBfmWRrGlzyGtaCXOJsABqSSdgv0of5RMPqpBG9rXTUcZDqinjJbI8A3vmF87RvlFtve3XFSL21M6RM6edRUTYy90VO50WHtOWWYaPqCN42X2byJ58+i79fwlRS0raYxBjGD5tzNHsd9tr9819Te9+d1tcPYjS1FO11G5vZABoa0BuSw8BZ9UjoumtL5bVnVfh1+u6NJThvHaimqG4diTsznD9VqdhM0fUd0kGnrsdbF16pfibA462ndE/uu8UTxuyQeB4I19fK68+A8dfUwvhqNKqmd2U4+0R4ZB5OAOvUG2ll6XGz/i17+YUtGlaiIulUREQEREGFyce4gpaKPtKmRrB9UbucejWjUqexvjGR8xpMKjFRUDR8h+ih5Xe4bnfujpzOi4OKYdHh8Zq6h5rcRlIjhdIL/Ou0aI49mtbe/wCAteyyvlrWdeZn0TEMxcW4jidU+mo2miiYA6WV7c0oafCMp7rXO5DewJvou9hPBVFA7tHNNRMdTLUHtHk9e9oPcL+a2OEcC9jpgxxzzSEyzv3LpH6uN+YGw+PMruLzeRybWtqs9l61ZWERca4iIoBERBlTuPcJQVLhKwugqW6sni7rwfvW8Y9dbc1QotKXtSd1lExtM4BxRNFO2ixUNbOfoZm6MnA/Br+o015C4vcKa4gwOGsgdDMNN2OHiY8eF7TyI/EaLR4IxyYukoK4/rVPazv40P1ZRfc6gH1HO4Hr8fkRljXrDOY0tERF0qiIo/5QMaliiipqQ/rVW/soz9hv7yTyyg78r35KJnQ1OIOJ5ppnUOF2dONJpzqynGx12c/ew69SDbf4b4chomEMu+R/elmfq+R25JJ1tfl+ZuV7cPYJDRU7YYRoNXuPie8+J7jzJ/AWHJdNeRyOTN51Xw0rXQiIuNcREQEREBERAWVhEEljXC8rJTV4Y9sNT+8jP0c43s9uwd978jqt3hviiOqLoXtMFVHpLA/RwI3LftN53HIjqCtjiXiGGiiD33fI85YomavkfsGtHS5Fz58zYHlcOcPSun9vxCzqpwtGweGnZrZjertTc8rnzK6/4se8n0n1/wCKevZWqNx39SxOlrW6RzkUdT0u76GQ+YIsSeTLc1ZLgcd4f7RhtTHa5EZkb1zR99tvXLb3qvGydGSJ+ibRuFki5HC2Impoaec7yRMc7+a1n/4gV117bIREQeUkjWtLnEAAEkk2AA3JJ2C+eV2L1OLSOgoHGGjack1UNHSW8UcXl97z6aO866WTGal8THubhsDsshYbGplbqWh32B1G+/MFtpTU7I2NjjYGMYA1rWiwAHIBcXJ5P4favn/C9a7a2D4RBSRCKnjDGD4uP2nO3cfMqV4l+Yxajq6jv05a6BhO0Ez9nn+ba52segVwuBxpLReySR10rIo5GkC+rsw1a5jBcuINjoOS4MN5m/fvvtPv3WmOygWFMfJ5ic89Cz2hjw9ncD3tLe1YPA8ZtTcWBPUX5qnWeSnRaa+yYERFmkREQEREBERAUhx7SPjbFiNOPnqN2Zw2zwHSRhPSxJ8hmVevzJG17S1wu1wLXA82kWI94WuHJOO8TCJjcNvD6xk0TJYzdkjGvafuuFx+a2lC/JhK6OKooXm7qOd8bb7mJ5Lo3H179vIK5XvRO42xF89wv9axqsqHaspWMpIugeQXSkeYOZvo5fQl8++TkXjrXnxPr6ku/wAP/wC965+VbpxStXyr0RF4jUREQEREBERAREQFxOJuI46Nje6ZJnnLDCzV73nbQahvV3wudF21xeJOG4K2MB+ZkjDmjmZpIx3Ihw3F92/kbEa4ujq+Pwid+jm8M8NSCU1uIuElY8aDdkDT+7YNr2Ni71sTcudWKMwviOelmbSYtZrzpDVDSOYcg47Mf1/G2hdaK2eL9W5+ntr5FdMI5gcC07HQ+h0KJmA1Ow1PuWMeUpv5I3H9FRsP7uSaP4SuP/crdQ/yRAnC2PP7yWZ498pH/aVcL6NgwpP5R8WfT0LhD9NO9tNFbfPLoSDyIaHWPWyrFCcXfO4vhkJ8LO3qHD7zGDIfcR+Kra2qzPsO1gWFMpKaOnj8MbQ0n7Tt3u9S4k+9b5Om1/Ic/LVEXgWmZnctnzXiDjarFQKbJ+jWO09oqWOeTt4AwOj573I+8FQcPcKULSKnP7bK7X2iR4lufu6lrbctyOqpqiBkjCyRjXsdoWvaHNPq06FStVwHA15koJZaKQ7mFxLHdM0bjYjyBA12XTGWk16Y+H9fdXUq5FCYHxBiArzQythq8gBkniLmdm374y5c/wBxoGp33tdrDLjmk6laJ2IiLJIiIgIiICIiAiIglMI+a4hqWDaoo45j/NE4RjT0zFXqgXf+o4bbigfm9O2db8VfFe/gneOv9mM+RfPeEfmK/EqN2h7f2tn3mTgE28mnI2/Ur6EojjrC5mSRYlRszT04LZIx+9gOr2abltyR6ncgBM2PrpNSJ1KlRaGC4xDVwNmp35mu+LXc2OHJw6e/Zb68K1ZrOpbbERFUEREBERAREQERCeqDUxPDYamJ0VQwSRu3B68iDuCORGqh48VlwaaOlqZDUUshtA+4dPHrYMdGO89mtgQPTk1dGv4rlqZHU2ENEsg0kqXfQx+h+u7oBcfzarocPcJxUzzNI91RVO1fPJq6/MMB8LeWmttL20XZX93XWTxPp/v5KeZ7KIFcHjnEvZsOqJL2d2ZjZ1zydxtvTNf3LvKNxke3YrT0bdYqUirqTyzj6GM+etyDuHHoqcbH15I+6bdoVnCmGmloaeAixZEwO/nIu/8AxErsoi9tkwoTic5Maw158MjKiG/R2S7R7yQrtSnyhYRJUUmen/aKd7aiG25fHqW+dxfTmQFW9eqsx7ph2lhczh3Go6ymZURbPHebza8eNh9D8RY81018/es1nUtYkUlxLjsz5vYMP1qXC8sm7aeM7vcftkEWHmOZCrVIcZ4bLHIzEqQXngFpGD99B9dp6lo1H/kBaYOnr7/T236Is7XDuBQ0UAiiBJJzPe7xPed3uPXy5LqrTwnEYqmCOeF2Zj25genItPQg3BHULcVLzabT1eUwIiKiRERAREQEREBEWrileynhkmk8ETHPd55RoB5k2A8yrREzOoE/w+O2x2slA7tPBFSg8i557R3vBaR/qrxR3yZYe9lD2030tXI+qk/6h7g9MoBt94qxXv0r01iPZgyiIriFxng+WOZ1XhLxDM7WSF30M3q0eFx6jz2JJX5wfjGN8ns9ZG6jqtuzk0a/zZJ4XA8vwvurtczGsDpquPs6qJsjeVxq09WuGrT5grDLgpk8+fdMWmH6WFHuwHFMP1oZPbKcf8PO60jR0jl/sdPIrawzjeklf2U+ekn2MVQMhuTbuvPddflsT0Xm5OJenzhpF4lTIiLlWERFAIiIChPlKZKDA6V7xh+cMqmx91/eNmuc7csvYED8SRa7XlU07JGOjkaHMe0tc07FpFiFthv0XiyJ7vLDKSGKJjKdjWRgAsDPDY65vO+9zqbraUXwdPJTVM2FvcZGRN7WB+5bE46Rv6OGYW8vKy7XEnEkFEwdpd8j9I4Wd573HYBo2F+f5nRWyYrTfUd9oiezHFWPso4M9s8ryI4YxqZJHaNAA5AkE/Dche3BHD7qSnLpzmqZnGWof1e7XLfo29ul7nmtDhjhyd8/6QxKxqCLRRDVtOw8h1eb6nzKtl6nHwRir858qWnbKIi6FRERBAY1gNVRzvrMMb2jZDmqaTYPPOSPo/fTnrvey6nD/ElNWtPYvs9uj4njK9hGhDmHodLi4VUpniPg2lrHCXvQ1DdWTxHK8EdbeIctdbbELmzcauXv4laLadRfmWRrGlz3BrRqXOIAA6knRR0mM4jh3dxGI1EA2q4BqB1kj5eZFh6rgcTshqJWYg2R1fQtt21O2RwMP/MEYI0G5a4A9dDdvDHEtFtT2hbqbnDGKRRYpJT0BdPRzHO7s2OLaeY+KzrZezdYbaC46a/Rlo4NJTOgjdSdn2LhdvZgNbb0Gx5EHUHdbyxz3i1vGk1ERFgsIiICIiAiIgKK4hccRrmYZHcwxFs1a4bZWm8cN+pNiR6fZK3+J+IXxvbSUTe0rZBZjRqImneR52AA1AP+vY4S4dZQ0/ZhxfK9xkmlO75Haucb625Af3JK9Licfv12+il7ejvMaAAALAaADkv2iL0mYiIgIiIC52KYPT1TMlTCyRvLO0Ej0O4PmCuiiCCdwJLT64XWywD+DJ87F6AO1b66lef6Wxim0qqBtQ0by0j7n/4394n4L6AiyvhpfzCYmYQMHyhYeSGzOkpn/Yniewj3gEfiu3SY9Ry/RVML/wCWVl/he67tRTskGV7GuHRzQ4fArhVfA2FSXzUcNz9luT/JZc1uDjnxMwt1y6LXA7G/pqv1lPQqZPyX4UPBHJH/ACTSj83FY/3Z0P8AEqrdO3es/wBg/q/JPWo5JGtF3uDR1cQB+Knca43oKZjvn45JADljjdnc59u63uXAubbr9R/JjhQIL4XyEfxJZHfhmAVBhuAUdN+z08UZ6tY0H+q1/wAVenBrE952ibvl/CFPjEjJHwwCCSokMs1XUDXc5WxxEXytB0zXGp2FlecO8GwUrzM9zqiqd455Tmd5hoOjR6a20uqhF2xWIncQoyiIrAiIgIiICIiDBCkMX4BpJZO2gz0s/wDFgOS998zPC4HntdWCIPkWFYBi+ESvdE0VtNIS6SOOzHB322sPhd5NuCNOQIoqHjygkdkle6mk5x1DDGR7z3fxV0tLEMMp6huWeKOVvSRjXfC40XPl41Mk7nytFphrwyNe3MxzXtPNpDh8Qv2puo+TWguXUzp6R5+tBK5v4OuPhZeR4WxaP9nxUuA2bPCx/wAXjX8FyX4E/wAsrRdUrKlDBxEw/wDASj/qsJ/sgqsfG9FSn0nI/NZTwcnyT1wqkUsZuIHaNpKOPzfK93+VY/QWOzW7augpxzFPEXH0DpLEeqmvByT51B1woq+uhgaXzyMjYPrPcGj3X3PkFJu4gq8QJjwmMsjJs+slaWsA59mwi73eo9w3XVw/5PaJjxJUmSsl+3UvMnwZ4beoKrmMDQA0AAaADQAei68fDpWdz3lWbzLhcL8LwULHZC6SV5vLNIbvkPmTsPL8zqqFEXYoIiICIiAiIgIiIOXX47SwPyTTMY4NDyHG1mkkBxOwF2nU9CtptZGXOYHtLmsbI4X2Y8nK4+Ryu18ionia4raoGofTiSjhYCyLtM5zz3aBkcbjMNG698eS8J6KeVk7Wwlj3YfQgxC/1JJXSwAu3JZdmp+sLoK+i4io5niOKdj3OuWgHxBuriwnR4H3br3xDF6eBzWzSNY5wLmg3JIaQHGwGwzD4rhP4lD5qVlLZzXSZJWOglDo2lhIJdcNiILcuVwJObTYr88STOZiFO8S9iPZqhucx5xcywkMtyJyk/8AtKChgxSB72xtkaXujEzW37xiJsH2Otr6LynxylY3M+VoHaOhvqfnGXzM0G4yu+BUziVC+pre1p3DtY6SKWnlIIaXiWW7HaeB7TlcN7OB3AWlRVVm0s0rHxD9JVUj2vabx54pxZ2W/wBZwF9jcdUFpHjVK6J0zZmGJhIc8OuGkGxDrbG5Gh6rYlrY2SMic9ofIHFjCdXBgu+w52BCh8YvM2vnhjeInwwxgmNzO1lZI8ue1rgHOAa5jc9tbaXAWcabWPnqKuGFrm074xGS94kLaYl84jiEZDu07SSPxi+UeSC3irY3SPia9pfHlL2g6tDxdhI6EA/BelLUslY2SNwcxwu1w2IUY+nkNXU1lM0uljdC4NAt20LoGl8Vzz0zN6PaORK7fBQP6Pp7hzfm9nCxGp0I5FB30REBERAREQEREBa8VUxz3sa4FzMudvNuYXbf1Gq2FKU2IxQ19YJXZM5gy3a6zrRWNiBbdB1KriGkjBMkzGgF7STewMZs8E20sd15v4oomtzunaG66kOA0AJ1I8wuBVxOOF4o0Nddz66wsbm5daw53Xb4zaXYZVhoJJp5QANSSYzoAEG7S4zTSFojka4uJa0ai5a3M4C45NN0rsapoXiOWVrHlucNNyct7XsBtfRcvH6hsdVRSPJDGmbM6xIGaKwvYG1yubiOIg17ZY6jsmOpbB5iLw4iZ3d1GhFigrKrEYYo+1keGx93vG9u+QG/EkD3rXbjlKWB4laGukbECbtBkd4WagalcvjSTPQtex1h21I8PDS6zRUxuz5dyAO9byWliwjq4II3vFS01bGyEMLBlcx/1eVrjXrYoKmpxGGMuD5GtLIzK+5tljF7vPlofgvCgxymmdkimY91s2W9nZftBp1I81EV0dTavima9748NlibJl0maTIY3i277ENcPtNJGhC7E9UyqkomU4c58UrZXyZHBsbGxua8F7gBd+bJkBJ1vawugopcWp2wGofKxsQuDITZos/Jufvaeq9Zq6Jj42Pe1r5cwjaTq4tGZwb1sNVCQQzywUtMyFsgDqieVkrnRsLGzPZGxzhG83Ln5wMv7rdI6KSpbRQVAcyWEVMLpBqWSwtYIpWuIFyQGPBsL3ItqQgvo6ljnvY1wLmWDwN2lwzC/qNVsKT4QkndPWGojLJc8TX6Wa5zIQ0vYebXWzDmAbHUKsQEREBERAREQEREGLJZZRBiyyiIMWSyyiDFllEQYssoiAiIgIiICIiAiIgIiICIiDFkssogxZZREGLJZZRBiyWWUQEREBERB//Z" /></p>
</blockquote>
<p>大小端在日常使用中两者都有可能遇到，但在网络传输中 TCP/IP
规定数据包字节序为大端，如果是小端机器，那么在传输过程中就需要先将小端数据转换成大端数据再进行发送，同时在接受数据时也需要先将数据转换成小端再进行读取（仅针对多字节数据，例如
<code>short</code>，<code>int</code>，<code>double</code>等
），字节序和字符串编码一样，<strong>我们在使用前必须提前知道处理的数据字节序情况</strong>，否则就会出问题。</p>
<h4 id="utf-8--utf-8-with-bom">UTF-8 &amp; UTF-8 with BOM</h4>
<p>前面提到，UTF-8 后面的 8 表示其编码单位是 8 位，即我们可以使用
<code>char</code> 来存储 UTF-8 字符串，但是很明显 8 位存不下所有的
Unicode 字符，那么就使用多个编码单位来表示一个字符。</p>
<p>为了确保我们可以从字节流中准确还原出 Unicode 字符，UTF-8
编码规则如下（RFC3629）</p>
<ol type="1">
<li>确定 Unicode 字符所需要的字节数</li>
<li>在首字节中添加长度标识前缀（<code>110</code>，<code>1110</code>，<code>11110</code>)，在剩下字节中添加标识前缀（<code>10</code>）</li>
<li>对于单字节字符，直接使用 ASCII
编码，对于多字节字符，从低位到高位开始，每次选取 6
位填入编码中（从后向前）</li>
</ol>
<p>下表展示了 Code 和 UTF-8 编码之间的转换关系</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">UTF-8 &lt;-&gt; Unicode Conversion</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|    Unicode Range    |  Byte[0] |  Byte[1] |  Byte[2] |  Byte[3] |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+000000 ~ U+00007F | 0xxxxxxx |          |          |          |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+000080 ~ U+0007FF | 110xxxxx | 10xxxxxx |          |          |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |          |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+010000 ~ U+10FFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：实际上使用 4 个字节的 UTF-8 编码最大可以表示到 U+1FFFFF（21位的
Unicode 字符），且 UTF-8 最多可以使用 6 个字节来表示一个 Unicode
字符，但是为了和 UTF-16 的表示范围一致，其将最大可表示范围限制到了
<code>U+10FFFF</code>（也就是 20 位的 Unicode 字符）</p>
</blockquote>
<p>下面来几个转换样例（编码）：</p>
<p><code>A</code>：U+0041</p>
<p>对于在 <code>U+0000</code> 到 <code>U+007F</code>
之间的字符，直接使用 ASCII 码即可</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">| U+000000 ~ U+00007F | 0xxxxxxx |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">|       U+000041      |  1000001 |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">|       U+000041      | 01000001 |</span><br><span class="line">+---------------------+----------+</span><br><span class="line">|       U+000041      |   \x41   |</span><br><span class="line">+---------------------+----------+</span><br></pre></td></tr></table></figure>

<p><code>α</code>：U+03B1</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">| U+000080 ~ U+0007FF | 110xxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       U+0003B1      |    01110 |   110001 |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       U+0003B1      | 11001110 | 10110001 |</span><br><span class="line">+---------------------+----------+----------+</span><br><span class="line">|       U+0003B1      |   \xce   |   \xb1   |</span><br><span class="line">+---------------------+----------+----------+</span><br></pre></td></tr></table></figure>

<p><code>你</code>：U+4F60</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+004F60      |     0100 |   111101 |   100000 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+004F60      | 11100100 | 10111101 | 10100000 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+004F60      |   \xe4   |   \xbd   |   \xa0   |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p><code>🧐</code>：U+1F9D0</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |  Byte[3] |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">| U+010000 ~ U+1FFFFF | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       U+01F9D0      |      000 |   011111 |   100111 |   010000 |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       U+01F9D0      | 11110000 | 10011111 | 10100111 | 10010000 |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br><span class="line">|       U+01F9D0      |   \xf0   |   \x9f   |   \xa7   |   \x90   |</span><br><span class="line">+---------------------+----------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>Unicode 转 UTF-8 代码实现（C++），通过简单的位运算就可以实现了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">encode_utf8</span><span class="params">(<span class="type">uint32_t</span> u)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint8_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span> (u &lt; <span class="number">0x80</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(u);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &lt; <span class="number">0x800</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xc0</span> | (u &gt;&gt; <span class="number">6</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | (u &amp; <span class="number">0x3f</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &lt; <span class="number">0x10000</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xe0</span> | (u &gt;&gt; <span class="number">12</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | (u &amp; <span class="number">0x3f</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &lt; <span class="number">0x10ffff</span>) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xf0</span> | (u &gt;&gt; <span class="number">18</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | ((u &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x3f</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | ((u &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3f</span>));</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x80</span> | (u &amp; <span class="number">0x3f</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; fmt::format(<span class="string">&quot;Failed to encode &#123;&#125; to UTF-8, replaced with U+FFFD&quot;</span>,</span><br><span class="line">                             <span class="built_in">unicode</span>(u))</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xef</span>);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xbf</span>);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xbd</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 UTF-8
字符串的解码，也是类似，我们首先判断当前字节流前缀信息，得出当前字符的字节位数，然后根据这个信息读取后续的字节数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> one_byte = (curr_byte &gt;&gt; <span class="number">7</span>) == <span class="number">0x0</span>; </span><br><span class="line"><span class="type">bool</span> two_bytes = (curr_byte &gt;&gt; <span class="number">5</span>) == <span class="number">0x6</span>;</span><br><span class="line"><span class="type">bool</span> three_bytes = (curr_byte &gt;&gt; <span class="number">4</span>) == <span class="number">0xE</span>;</span><br><span class="line"><span class="type">bool</span> four_bytes = (curr_byte &gt;&gt; <span class="number">3</span>) == <span class="number">0x1E</span>;</span><br></pre></td></tr></table></figure>

<p>完整 UTF-8 转 Unicode 代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">decode_utf8</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint32_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="type">uint32_t</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint8_t</span> curr = *it;</span><br><span class="line">    <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">7</span>) == <span class="number">0x0</span>) &#123;</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">5</span>) == <span class="number">0x6</span>) &#123;</span><br><span class="line">      c |= (curr &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">6</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>);</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">4</span>) == <span class="number">0xE</span>) &#123;</span><br><span class="line">      c |= (curr &amp; <span class="number">0xf</span>) &lt;&lt; <span class="number">12</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">6</span>;  <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>);</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((curr &gt;&gt; <span class="number">3</span>) == <span class="number">0x1E</span>) &#123;</span><br><span class="line">      <span class="comment">// get 3 bit from value</span></span><br><span class="line">      c |= (curr &amp; <span class="number">0x7</span>) &lt;&lt; <span class="number">18</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">12</span>; <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>) &lt;&lt; <span class="number">6</span>;  <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">      c |= (*it &amp; <span class="number">0x3f</span>);</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      std::cerr &lt;&lt; fmt::format(<span class="string">&quot;Failed to decode byte &#123;&#125; at index: &#123;&#125;&quot;</span>,</span><br><span class="line">                               <span class="built_in">hex</span>(*it), it - s.<span class="built_in">begin</span>())</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">      <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：对于 UTF-8
的解码，还有很多加速算法，这里就不做过多的介绍了，详细可以参考这篇博客：<a
href="https://nullprogram.com/blog/2017/10/06/">A Branchless UTF-8
Decoder (nullprogram.com)</a></p>
</blockquote>
<p>最后我们再简单介绍一下 UTF-8 with BOM，从名字上就可以知道，UTF-8 with
BOM 就是在 UTF-8 的基础之上添加了一个 BOM（字节序标志），这个标志的
Unicode code point为 <code>U+FEFF</code> ，表示
”零宽无间断间隔“，仅在传输过程中用来确认字节顺序，打印时不占字宽，（但在控制台打印等宽表格中会计算其长度，导致输出有问题，这一点需要注意）。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">UTF-8 encoding of U+00FEFF</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FEFF      |     1111 |   111011 |   111111 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FEFF      | 11101111 | 10111011 | 10111111 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FEFF      |   \xef   |   \xbb   |   \xbf   |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>将文件手动保存为 UTF-8 with BOM</p>
<p><img data-src="/posts/c4ef/image-20230127221806025.png"
style="zoom:50%;" /></p>
<p>以二进制形式读取文件（<code>rb</code>），我们可以看到文件的前三个字节为固定的
<code>[0xEF,0xBB,0xBF]</code></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">+----------------+--------------+-----------------+</span><br><span class="line">|      file      | size (bytes) |  first 3 bytes  |</span><br><span class="line">+----------------+--------------+-----------------+</span><br><span class="line">| UTF-8 with BOM |     207      | b&#x27;\xef\xbb\xbf&#x27; |</span><br><span class="line">|     UTF-8      |     204      | b&#x27;\xe3\x80\x8e&#x27; |</span><br><span class="line">+----------------+--------------+-----------------+</span><br></pre></td></tr></table></figure>

<p>由于 UTF-8
的编码单位为字节，实际上完全没必要考虑字节顺序的问题，因此并不推荐使用
UTF-8 with BOM ，甚至在某些情况下 UTF-8 with BOM
还会导致代码无法运行（例如 PHP）。</p>
<p><strong>彩蛋：”锟斤拷“ 是怎么来的？</strong></p>
<p>对于编码失败的情况，UTF-8 编码器会直接将其转换成 <code>U+FFFD</code>
，显示为 <code>�</code>，其对应的 UTF-8 编码如下：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">UTF-8 encoding of U+00FFFD</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       Unicode       |  Byte[0] |  Byte[1] |  Byte[2] |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">| U+000800 ~ U+00FFFF | 1110xxxx | 10xxxxxx | 10xxxxxx |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FFFD      |     1111 |   111111 |   111101 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FFFD      | 11101111 | 10111111 | 10111101 |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br><span class="line">|       U+00FFFD      |   \xef   |   \xbf   |   \xbd   |</span><br><span class="line">+---------------------+----------+----------+----------+</span><br></pre></td></tr></table></figure>

<p>即
<code>[0xEF,0xBF,0xBD]</code>，在编码错误的情况下，就可能会连着出现，也就是</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[...,0xEF,0xBF,0xBD,0xEF,0xBF,0xBD,...]</span><br></pre></td></tr></table></figure>

<p>由于 <strong>GBK
编码是双字节编码</strong>，其会将其解析为三个汉字，而这三个字就是
<code>锟斤拷</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b&#x27;\xef\xbf\xbd\xef\xbf\xbd&#x27;</span>.decode(<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;锟斤拷&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在中文环境下，出现 <code>锟斤拷</code>
就基本上就表示我们将一个原本是正常编码的文件<strong>采用 UTF-8
编码打开并以 UTF-8 保存</strong>，由于 UTF-8
编码无法对文件中字符进行编码，就全部替换成了
<code>�</code>，此时我们再通过 GBK 打开时就会出现满屏的
<code>锟斤拷</code>
了，而且这种错误是不可逆的，因为无法编码的字符已经被替换成了
<code>�</code>，我们再也无法找回之前的编码了。</p>
<p>下面给出了一个具体示例：</p>
<p>文件初始内容：</p>
<p><img data-src="/posts/c4ef/image-20230120000459771.png"
style="zoom:50%;" /></p>
<p>我们原本的文件是 GBK 编码的，我们将窗口关闭，再打开。由于 VS Code
并不知道文件的编码，便默认使用 UTF-8 编码打开，内容如下：</p>
<p><img data-src="/posts/c4ef/image-20230120000558448.png" /></p>
<p>如果此时我们手贱，将文件保存的话（<kbd>Ctrl</kbd> +
<kbd>S</kbd>），文件就会以 UTF-8 编码保存，而其中 <code>�</code>
就会直接写入到文件中。</p>
<p>假如我们又看到了文件名中的
<code>文本-gbk</code>，知道文件的正确编码为 GBK，再次使用 GBK
编码打开时，文件内容如下：<img data-src="/posts/c4ef/image-20230120000912272.png" /></p>
<p>我们永远也不知道文件里写了什么了！😭</p>
<blockquote>
<p><em>“白色相簿”什么的，已经无所谓了。</em></p>
<p><em>因为已经不再有歌，值得去唱了。</em></p>
<p><em>传达不了的恋情，已经不需要了。</em></p>
<p><em>因为已经不再有人，值得去爱了。</em></p>
</blockquote>
<p>血的教训告诉我们：<strong>当打开不知道编码的文件时，千万不要手贱按下保存，保存后很有可能无法还原了！</strong></p>
<h4 id="utf-16--utf-32">UTF-16 &amp; UTF-32</h4>
<p>UTF-16 的编码单位为 16 位，即 2 字节，而 UTF-32 的编码单位为 32
位，4字节。</p>
<blockquote>
<p>注：编码单位（code
uint）是编码中每个字符编码的基本元素，对于定长编码中，编码单位大小就等于字符大小，例如
GBK 中编码单位为 2 字节，其可表示的所有字符都是 2
字节；对于变长编码，一个字符的编码可以由多个编码单位进行表示。</p>
</blockquote>
<p>由于 UTF-16 和 UTF-32
的编码单位为多字节，必定要考虑字节顺序问题。我们可以手动指定字节顺序（和
UTF-8 with BOM 类似，在文件开头添加 <code>U+FEFF</code>
来自动判断编码），也可以直接使用 <code>LE</code>
后缀或<code>BE</code>后缀的编码来表示，例如 UTF-16LE 和 UTF-16BE。</p>
<p>在 UTF-16 编码中，一个字符由1个或2个16位整数表示，最大可表示字符为
<code>U+10FFFF</code>，<strong>参考 UTF-16
规范（RFC2781）</strong>，其编码和解码规则如下：</p>
<ol type="1">
<li>对于 <code>U+0000 ~ U+FFFF</code>
的字符，其直接使用1个16位整数表示即可，且值等于 Unicode Code Point
值。</li>
<li>对于 <code>U+010000 ~ U+10FFFF</code>
的字符，使用2个16位整数表示（称为 surrogate
pair，代理对，意为16位整数对表示一个字符），每个部分存储 Unicode Code
Point 的10 位（需要进行特殊处理），再在前面添加前缀（6
位），第一个前缀为 <code>110110</code>，第二个前缀为
<code>110111</code></li>
<li>对于 <code>&gt; U+10FFFF</code> 的字符无法使用 UTF-16
编码表示（目前并不存在）</li>
</ol>
<blockquote>
<p>为了保证 UTF-16 解码的唯一性，对于 <code>U+D800 ~ U+DFFF</code> 的
Unicode 字符不做编码。</p>
</blockquote>
<p>同样，下面给出了一个转换示例</p>
<p><code>🧐</code>：U+1F9D0</p>
<ol type="1">
<li><p>首先减去 <code>0x10000</code>，确保 <code>U'</code> 的范围在
<code>0xFFFFF</code> 之间（最多支持 20 位）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">U&#x27; = U - 0x10000</span><br><span class="line">   = 0xf9d0</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别取出 <code>U'</code> 的
前10位和后10位，填充到两个16位整数中</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">w0 = (U&#x27; &gt;&gt; 10) &amp; 0x3ff</span><br><span class="line">   = 0b0000111110</span><br><span class="line">w1 = U&#x27; &amp; 0x3ff</span><br><span class="line">   = 0b0111010000</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后添加6位的前缀</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">w0 = w0 | 0xd800</span><br><span class="line">   = 0b1101100000111110</span><br><span class="line">   = 0xd83e</span><br><span class="line">w1 = w1 | 0xdc00</span><br><span class="line">   = 0b1101110111010000 </span><br><span class="line">   = 0xddd0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终得到 <code>🧐</code> 的 UTF-16 编码为
<code>[0xd83e,0xddd0]</code></p>
<ul>
<li>UTF-16LE： <code>b'\x3e\xd8\xd0\xdd'</code></li>
<li>UTF-16BE： <code>b'\xd8\x3e\xdd\xd0'</code></li>
</ul>
<p>代码写起来就十分简单了，将上面的过程翻译成 C++ 位运算即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint16_t</span>&gt; <span class="title">encode_utf16</span><span class="params">(<span class="type">uint32_t</span> u)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint16_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">if</span> (u &lt; <span class="number">0xd800</span> || (u &gt; <span class="number">0xdfff</span> &amp;&amp; u &lt;= <span class="number">0xffff</span>)) &#123;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(u);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u &gt; <span class="number">0xffff</span> &amp;&amp; u &lt;= <span class="number">0x10ffff</span>) &#123;</span><br><span class="line">    u -= <span class="number">0x10000</span>;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(((u &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0x3ff</span>) | <span class="number">0xd800</span>);</span><br><span class="line">    res.<span class="built_in">emplace_back</span>((u &amp; <span class="number">0x3ff</span>) | <span class="number">0xdc00</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cerr &lt;&lt; fmt::format(</span><br><span class="line">                     <span class="string">&quot;Failed to encode &#123;&#125; to UTF-16, replaced with U+FFFD&quot;</span>,</span><br><span class="line">                     <span class="built_in">unicode</span>(u))</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0xfffd</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于解码也是一样，不过我们需要验证一下 surrogate
的有效性（必须成对存在）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">decode_utf16</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint16_t</span>&gt; &amp;s)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">uint32_t</span>&gt; res;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="type">uint16_t</span> w0 = *it;</span><br><span class="line">    <span class="keyword">if</span> (w0 &lt; <span class="number">0xd800</span> || w0 &gt; <span class="number">0xdfff</span>) &#123;</span><br><span class="line">      res.<span class="built_in">emplace_back</span>(w0);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(++it != s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">uint16_t</span> w1 = *it;</span><br><span class="line">    <span class="keyword">if</span> (w1 &lt; <span class="number">0xdc00</span> || w1 &gt; <span class="number">0xdfff</span>) &#123;</span><br><span class="line">      std::cerr &lt;&lt; fmt::format(<span class="string">&quot;Failed to decode word &#123;:#04x&#125; at index &#123;&#125;&quot;</span>, w1,</span><br><span class="line">                               it - s.<span class="built_in">begin</span>())</span><br><span class="line">                &lt;&lt; std::endl;</span><br><span class="line">      <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="built_in">emplace_back</span>(<span class="number">0x10000</span> + ((w0 &amp; <span class="number">0x3ff</span>) &lt;&lt; <span class="number">10</span>) | (w1 &amp; <span class="number">0x3ff</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：UTF-16、UTF-16LE、UTF-16BE 的区别：</p>
<ul>
<li>UTF-16 类似于 UTF-8 with BOM，在文件开头添加 <code>U+FEFF</code>
标记，用来标识存储内容的字节顺序</li>
<li>而 UTF-16LE 和 UTF-16BE则是在编码时就约定好字节顺序，不需要通过 BOM
来确定。</li>
</ul>
<p>对于 UTF-32、UTF-32LE、UTF-32BE 也是类似，和 UTF-8 with BOM
类似，一般直接使用 LE 或 BE 版本即可，最好不要在文件开头添加
BOM（有可能影响文件解析）</p>
</blockquote>
<p>而对于 UTF-32 编码，就简单很多了，目前最大的 Unicode 字符也就到
<code>U+10FFFF</code>，使用 32 位来表示完全足够了（即 Unicode code point
就是 UTF-32 编码值）。但是代价也很明显，存储代价太大了，对于纯 ASCII
的代码，需要 4 倍的存储空间。而在 Python 中就采用了
Latin-1（ASCII）、UTF-16 和 UTF-32
的混合表示方式（代价是性能，但是其字符串操作上十分便捷）。</p>
<h2 id="unicode-in-c">Unicode in C++</h2>
<p>目前 Windows 并不支持 UTF-8（使用的 UTF-16），如果我们编写了一段 c++
程序输出 UTF-8
字符串，我们会看到乱码的结果。<strong>除此之外，对于文件的读写、命令行参数的传递也会出现同样的问题</strong>。如果我们想编写跨平台应用程序，最好保证使用的所有字符串都是
UTF-8。通过 <code>Boost.Nowide</code>
库可以实现这个转换。（单纯输出乱码的话可以使用 <code>fmt::print</code>
来解决乱码问题）</p>
<p>使用时我们需要<strong>确保在程序中使用的 <code>char*</code> 和
<code>std::string</code> 都是 UTF-8
编码的</strong>，进行文件I/O、解析命令行命令以及 stdout、stdin、stderr
时统一使用nowide库进行操作，就基本可以屏蔽掉大部分的坑。</p>
<p>对于命令行命令的解析，有一点小坑，我们需要手动链接
<code>shell32.dll</code> ，这个在 Windows SDK
中自带，只需要链接上即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/nowide/args.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/nowide/iostream.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/ranges.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> nw = boost::nowide;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  nw::args _(argc, argv);</span><br><span class="line">  <span class="function">std::vector&lt;std::string&gt; <span class="title">args</span><span class="params">(argv, argv + argc)</span></span>;</span><br><span class="line">  nw::cout &lt;&lt; fmt::format(<span class="string">&quot;arguments: &#123;&#125;&quot;</span>, args) &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 xmake</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">target(<span class="string">&quot;nw&quot;</span>)</span><br><span class="line">    set_kind(<span class="string">&quot;binary&quot;</span>)</span><br><span class="line">    set_languages(<span class="string">&quot;cxx17&quot;</span>)</span><br><span class="line">    add_files(<span class="string">&quot;src/nw.cpp&quot;</span>)</span><br><span class="line">    add_packages(<span class="string">&quot;fmt&quot;</span>,<span class="string">&quot;tabulate&quot;</span>,<span class="string">&quot;boost&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> is_plat(<span class="string">&quot;windows&quot;</span>) <span class="keyword">then</span> </span><br><span class="line">        add_cxxflags(<span class="string">&quot;/utf-8&quot;</span>,&#123;tools=<span class="string">&quot;cl&quot;</span>&#125;)</span><br><span class="line">        add_cxxflags(<span class="string">&quot;/RTC1&quot;</span>,&#123;tools=<span class="string">&quot;cl&quot;</span>&#125;)</span><br><span class="line">        add_defines(<span class="string">&quot;BOOST_USE_WINDOWS_H&quot;</span>,<span class="string">&quot;NOMINMAX&quot;</span>)</span><br><span class="line">        add_links(<span class="string">&quot;shell32&quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    set_installdir(<span class="built_in">path</span>.join(<span class="built_in">os</span>.scriptdir()))</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img data-src="/posts/c4ef/image-20230129173623164.png"
style="zoom:50%;" /></p>
<p>此处链接 <code>shell32.dll</code> 十分关键，如果没有就会报错
LNK2019：无法解析的外部符号 <code>__imp_CommandLineToArgvW</code></p>
<p><img data-src="/posts/c4ef/image-20230129173845768.png"
style="zoom:50%;" /></p>
<p>这个函数实际上就是 Windows
提供的命令行参数编码转换函数，具体可以参考：<a
href="https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw">CommandLineToArgvW
function (shellapi.h) - Win32 apps | Microsoft Learn</a></p>
<p>还有另外一种解决方案，就是开启 UTF-8 实验性功能，这样 Windows
强制所有编码都是
UTF-8，就是对一些老应用不友好，特别是之前编译的中文应用，因为其使用的可能是
GBK 编码。</p>
<p><img data-src="/posts/c4ef/image-20230118163241733.png"
style="zoom:50%;" /></p>
<p>将其勾上然后重启电脑就可以了，这样我们直接通过 <code>std::cout</code>
以及 <code>std::fstream</code>
打开文件时就不会乱码了，但是无法确保其他人也这么做，所以还是老老实实使用
Nowide 库比较靠谱。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">The
Absolute Minimum Every Software Developer Absolutely, Positively Must
Know About Unicode and Character Sets (No Excuses!) – Joel on
Software</a></li>
<li><a href="https://utf8everywhere.org/zh-cn">UTF-8 遍地开花
(utf8everywhere.org)</a></li>
<li><a
href="https://www.boost.org/doc/libs/1_81_0/libs/nowide/doc/html/index.html">Boost.Nowide:
Boost.Nowide - 1.81.0</a></li>
<li><a
href="https://learn.microsoft.com/en-us/windows/win32/api/winnls/nf-winnls-getacp">GetACP
function (winnls.h) - Win32 apps | Microsoft Learn</a></li>
<li><a
href="https://learn.microsoft.com/en-us/windows/win32/intl/code-pages?source=recommendations">Code
Pages - Win32 apps | Microsoft Learn</a></li>
<li><a
href="https://learn.microsoft.com/en-us/windows/win32/intl/code-page-identifiers">Code
Page Identifiers - Win32 apps | Microsoft Learn</a></li>
<li><a
href="https://stackoverflow.com/questions/61449854/getting-error-lnk2019-unresolved-external-symbol-when-compiling-sdl2-code-in-wi">visual
c++ - Getting error LNK2019: unresolved external symbol when compiling
SDL2 code in Windows using MSVC - Stack Overflow</a></li>
<li><a
href="https://stackoverflow.com/questions/56419639/what-does-beta-use-unicode-utf-8-for-worldwide-language-support-actually-do">c#
- What does "Beta: Use Unicode UTF-8 for worldwide language support"
actually do? - Stack Overflow</a></li>
</ol>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>Unicode</tag>
        <tag>UTF-8</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>虚函数执行原理理解</title>
    <url>/posts/55c5/</url>
    <content><![CDATA[<p>刷牛客时经常能刷到面向对象相关的题目，多态作为面向对象中的一个重要特性（封装，继承和多态），在八股中经常考察其实现原理。为了方便理解，我们给出一个简单的多态样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value + v; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value - v; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value * v; &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> v * <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> value&#123;<span class="number">0xfeff</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> v)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> value + <span class="number">2</span> * v; &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> value * <span class="number">2</span> * v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> value&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来就是经典调用函数写输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.value = <span class="number">2</span>;</span><br><span class="line">  A *a = &amp;b;</span><br><span class="line">  a-&gt;value = <span class="number">4</span>;</span><br><span class="line">  <span class="type">int</span> v = <span class="number">20</span>;</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;b.A::value=&#123;&#125;\nb.B::value=&#123;&#125;\n&quot;</span>, b.A::value, b.B::value);</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func1(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func1</span>(v));</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func2(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func2</span>(v));</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func3(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func3</span>(v));</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;a-&gt;func4(&#123;&#125;) = &#123;&#125;\n&quot;</span>, v, a-&gt;<span class="built_in">func4</span>(v));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>执行如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Cpp\learn-git&gt; xmake -brv learn-git &amp;&amp; xmake run learn-git</span><br><span class="line">[100%]: build ok!</span><br><span class="line">b.A::value=4</span><br><span class="line">b.B::value=2</span><br><span class="line">a-&gt;func1(20) = 42</span><br><span class="line">a-&gt;func2(20) = -16</span><br><span class="line">a-&gt;func3(20) = 80</span><br><span class="line">a-&gt;func4(20) = 40</span><br></pre></td></tr></table></figure>

<p>执行结果不难想到，根据虚函数运行时绑定的特性（晚绑定），通过基类调用虚函数时会根据实际类型调用对应的函数。对于非虚函数则是直接调用普通的成员函数（是
A 类时调用 <code>A::func3</code>，是 B 类时调用
<code>B::func3</code>），且需要调用的函数在编译期间就已经确定好了。</p>
<h2 id="成员函数指针">成员函数指针</h2>
<p>例子就介绍到这，下面我们要简单理解 C++
中实现原理，首先从成员函数指针来看，对于任意一个类别的成员函数，我们可以使用类似与函数指针的表达方式，即<code>void(T::*)()</code>，写成模板形式的话如下（当然，使用
<code>auto</code> 是最简单的，就是容易变成 auto
script，然后导致代码理解起来有困难）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">R</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如 <code>A::func1</code> 就可以采用如下的定义方式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type ptr_test = &amp;A::test;</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/55c5/image-20230202162248754.png"
style="zoom: 67%;" /></p>
<p>可以看到，其实际上就是
<code>void (A::*)()</code>，但是这样比写函数指针稍微舒服一点，我们可以通过
<code>.*</code> 和 <code>-&gt;*</code> 的方式来调用成员函数指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(a-&gt;*ptr_test)();</span><br><span class="line">((*a).*ptr_test)();</span><br></pre></td></tr></table></figure>

<p>除此之外，我们也可以使用 <code>std::function</code>
的方式来封装封装成员函数，在函数的入参添加 <code>A*</code> 或
<code>A&amp;</code> 参数接口（对于 <code>const</code> 的函数还需要添加
<code>const</code> 修饰符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::function&lt;<span class="type">void</span>(A*)&gt; std_ptr_test = &amp;A::test;</span><br></pre></td></tr></table></figure>

<p>然后在调用这个函数时将对象指针也作为参数传递过去即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std_ptr_test</span>(a);</span><br></pre></td></tr></table></figure>

<p>最后总结一下调用成员函数的几种方式（<em><strong>”茴“字的 4
种写法</strong></em>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常版</span></span><br><span class="line">a-&gt;<span class="built_in">test</span>();</span><br><span class="line"><span class="comment">// 指针版</span></span><br><span class="line">MemberFuncPtr&lt;A,<span class="type">void</span>&gt;::type ptr_test = &amp;A::test;</span><br><span class="line">(a-&gt;*ptr_test)();</span><br><span class="line"><span class="comment">// std::function 版</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(A*)&gt; std_ptr_test = &amp;A::test;</span><br></pre></td></tr></table></figure>

<p>之所以出现后面两种写法，主要就是为了实现
<code>Delegate</code>，当我们需要由代码来决定成员函数的调用时机时（例如事件响应等），我们就可以使用后面两种调用方式，不过在我们这里主要是探究虚函数的调用机制。</p>
<h2 id="成员函数指针的大小">成员函数指针的大小？</h2>
<p>当我们通过 <code>&amp;A::test</code>
拿到成员函数的地址时，我们自然将其联想到和普通函数指针大小一致，但是不然，<strong>其大小与不同的编译器有关（或者更准确的说，与
C++ Compiler ABI 有关）。</strong></p>
<p>我们在 <a href="https://godbolt.org">Compiler Explorer</a>
中进行运行测试（不支持 MSVC Compiler 的运行测试，但是可以测试 Clang 和
GCC）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof &amp;A::func = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(&amp;A::func) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下表所示</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Compiler</th>
<th>Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">x86-64 gcc 9.4</td>
<td>16</td>
</tr>
<tr class="even">
<td style="text-align: left;">x86-64 clang 15.0.0</td>
<td>16</td>
</tr>
<tr class="odd">
<td style="text-align: left;">x86-64 msvc v19.25.28614 (default)</td>
<td>8</td>
</tr>
<tr class="even">
<td style="text-align: left;">x86-64 msvc v19.25.28614
(single_inheritance)</td>
<td>8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">x86-64 msvc v19.25.28614
(multiple_inheritance)</td>
<td>16</td>
</tr>
<tr class="even">
<td style="text-align: left;">x86-64 msvc v19.25.28614
(virtual_inheritance)</td>
<td>24</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：关于 MSVC 的成员函数指针大小的设置，参考<a
href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/pointers-to-members?view=msvc-160">pointers_to_members
pragma | Microsoft Learn</a>，可以手动指定成员函数指针形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pointers_to_members( full_generality, virtual_inheritance )</span><br></pre></td></tr></table></figure>

<ul>
<li>single_inheritance 表示单继承</li>
<li>multiple_inheritance 表示多继承</li>
<li>virtual_inheritance 表示虚继承</li>
</ul>
<p>如果不指定，就是根据函数类型自动选择空间最小的表示方式（也就是混合上面三种表示方式）</p>
</blockquote>
<h2 id="虚表和虚指针">虚表和虚指针</h2>
<p>对于一个包含虚函数的类而言，其会在类的起始处添加一个指向虚表的指针（vtable），称为虚指针（vptr）（在
MSVC C++ 中称为 vftable 和 vfptr）</p>
<p>虚表中存储了各种各样的类别数据信息（RTTI等），也存储了虚函数的实际地址，通过虚指针和虚表，我们就可以在运行过程中动态解析函数地址并进行调用。</p>
<p>MSVC、Clang 以及 GCC 中都提供了类内存布局查看的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gcc 调用命令</span></span><br><span class="line">g++ -fdump-lang-class=- test.cpp</span><br><span class="line"><span class="comment"># clang 查看命令 （-Xclang 表示传递后面的参数给 clang compiler） </span></span><br><span class="line">clang++-15 -Xclang -fdump-record-layouts test.cpp</span><br><span class="line">clang++-15 -Xclang -fdump-vtable-layouts test.cpp</span><br><span class="line"><span class="comment"># msvc 查看命令</span></span><br><span class="line">cl /d1 reportAllClassLayout test.cpp</span><br></pre></td></tr></table></figure>

<p>我们可以使用一个简单的类测试</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> n&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>x86-64 gcc 9.4 输出结果</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">➜  src g++ -fdump-lang-class=- test.cpp</span><br><span class="line">Vtable for A</span><br><span class="line">A::_ZTV1A: 3 entries</span><br><span class="line">0     (int (*)(...))0</span><br><span class="line">8     (int (*)(...))(&amp; _ZTI1A)</span><br><span class="line">16    (int (*)(...))A::func</span><br><span class="line"></span><br><span class="line">Class A</span><br><span class="line">   size=16 align=8</span><br><span class="line">   base size=12 base align=8</span><br><span class="line">A (0x0x7ff174281420) 0</span><br><span class="line">    vptr=((&amp; A::_ZTV1A) + 16)</span><br></pre></td></tr></table></figure>

<p>x86-64 clang 15.0.7 输出结果</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">➜  src clang++-15 -Xclang -fdump-record-layouts test.cpp</span><br><span class="line"></span><br><span class="line">*** Dumping AST Record Layout</span><br><span class="line">         0 | class A</span><br><span class="line">         0 |   (A vtable pointer)</span><br><span class="line">         8 |   int n</span><br><span class="line">           | [sizeof=16, dsize=12, align=8,</span><br><span class="line">           |  nvsize=12, nvalign=8]</span><br><span class="line">             </span><br><span class="line">*** Dumping IRgen Record Layout    </span><br><span class="line">...</span><br><span class="line">➜  src clang++-15 -Xclang -fdump-vtable-layouts test.cpp</span><br><span class="line">Vtable for &#x27;A&#x27; (3 entries).</span><br><span class="line">   0 | offset_to_top (0)</span><br><span class="line">   1 | A RTTI</span><br><span class="line">       -- (A, 0) vtable address --</span><br><span class="line">   2 | void A::func()</span><br><span class="line"></span><br><span class="line">VTable indices for &#x27;A&#x27; (1 entries).</span><br><span class="line">   0 | void A::func()</span><br></pre></td></tr></table></figure>

<p>x86-64 msvc 19.25.28614 输出结果</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(base) PS D:\Code\Cpp\learn-git&gt; cl /d1 reportAllClassLayout test.cpp</span><br><span class="line">...</span><br><span class="line">class A size(16):</span><br><span class="line">        +---</span><br><span class="line"> 0      | &#123;vfptr&#125;</span><br><span class="line"> 8      | n</span><br><span class="line">        | &lt;alignment member&gt; (size=4)</span><br><span class="line">        +---</span><br><span class="line"></span><br><span class="line">A::$vftable@:</span><br><span class="line">        | &amp;A_meta</span><br><span class="line">        |  0</span><br><span class="line"> 0      | &amp;A::func</span><br><span class="line"></span><br><span class="line">A::func this adjustor: 0</span><br></pre></td></tr></table></figure>

<p>从图中我们可以看出，三个编译器给出的虚表结构以及内存布局基本一致，虚指针都位于类的前8字节，可以使用
<code>reinterpret_cast</code>
来读取，而虚表本质上是一个指针数组。我们可以尝试直接从虚表中拿到虚函数的真实地址进行调用。代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> v + <span class="number">20</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="comment">// 读取类的前8字节，拿到虚表指针</span></span><br><span class="line">  <span class="type">uintptr_t</span> *vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span> **&gt;(&amp;a);</span><br><span class="line">  <span class="comment">// 从虚表中拿到虚函数的地址</span></span><br><span class="line">  <span class="type">uintptr_t</span> ptr_func = vptr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">using</span> Func = <span class="built_in">int</span> (*)(A *, <span class="type">int</span>);</span><br><span class="line">  Func f = <span class="built_in">reinterpret_cast</span>&lt;Func&gt;(ptr_func);</span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">f</span>(&amp;a, <span class="number">20</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a.func(20) = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  res = a.<span class="built_in">func</span>(<span class="number">20</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;a.func(20) = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>uintptr_t</code> 表示和指针大小一致的整型数，在 64 位平台上就为
<code>uint64_t</code>，使用这个方便跨平台使用</p>
</blockquote>
<p>如果调用调用正确，我们可以看到两行一样的输出</p>
<p><img data-src="/posts/55c5/image-20230202183658979.png" /></p>
<p>输出的确如我们所愿（x86-64 msvc 19.25.28614）</p>
<p>再在 compiler explorer 上跑下 GCC 和 Clang 的结果</p>
<p><img data-src="/posts/55c5/image-20230202190619327.png"
style="zoom:67%;" /></p>
<p>GCC 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202190941102.png"
style="zoom:67%;" /></p>
<p>这个例子比较简单，没有考虑继承情况，以及最关键的 this
指针问题，下面给一个稍微复杂一点的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v = &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> v + n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> n&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> n, <span class="type">int</span> f) : <span class="built_in">A</span>(n), <span class="built_in">f</span>(f) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;v = &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f = &quot;</span> &lt;&lt; f &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> v + n + f;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> f&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">B <span class="title">b</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">  A *a = &amp;b;</span><br><span class="line">  <span class="type">uintptr_t</span> *vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span> **&gt;(&amp;b);</span><br><span class="line">  <span class="type">uintptr_t</span> ptr_func = vptr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">using</span> Func = <span class="built_in">int</span> (*)(A *, <span class="type">int</span>);</span><br><span class="line">  Func f = <span class="built_in">reinterpret_cast</span>&lt;Func&gt;(ptr_func);</span><br><span class="line">  <span class="type">int</span> res = <span class="built_in">f</span>(a, <span class="number">30</span>);</span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  res = a-&gt;<span class="built_in">func</span>(<span class="number">30</span>);</span><br><span class="line">  std::cout &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MSVC 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202192352189.png"
style="zoom:67%;" /></p>
<p>GCC 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202192817764.png"
style="zoom:67%;" /></p>
<p>Clang 执行结果</p>
<p><img data-src="/posts/55c5/image-20230202192847211.png"
style="zoom:67%;" /></p>
<h2 id="虚函数调用过程">虚函数调用过程</h2>
<p>最后，我们尝试理解成员函数指针到底是什么？为什么其比寻常的函数指针更大？</p>
<p>我们直接将其转换成字节数组，然后读取其值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">Ret</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> size_a = <span class="built_in">sizeof</span>(&amp;A::func);</span><br><span class="line">  <span class="type">uint8_t</span> bytes[size_a];</span><br><span class="line">  MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type ptr = &amp;A::func;</span><br><span class="line">  std::<span class="built_in">copy</span>(&amp;ptr, &amp;ptr + size_a, bytes);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint8_t</span> v : bytes) &#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; (<span class="type">uint32_t</span>)v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个结果会随着编译器不同有所改变，在 MSVC 下，输出结果如下</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[ 4d 40 8c 7a f7 7f  0  0 ]</span><br></pre></td></tr></table></figure>

<p>而在 Clang 和 GCC 下，二者输出都是</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br></pre></td></tr></table></figure>

<p>一个好像看不出什么结果，我们多弄点类和继承，再来看看效果</p>
<p>测试代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">Ret</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_bytes</span><span class="params">(<span class="keyword">typename</span> MemberFuncPtr&lt;T, Ret, Args...&gt;::type func_ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(func_ptr);</span><br><span class="line">  std::array&lt;<span class="type">uint8_t</span>, size&gt; content;</span><br><span class="line">  <span class="type">uint8_t</span> *arr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span> *&gt;(&amp;func_ptr);</span><br><span class="line">  std::<span class="built_in">copy</span>(arr, arr + size, content.<span class="built_in">begin</span>());</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint8_t</span> v : content) &#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; (<span class="type">uint32_t</span>)v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;A::func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(&amp;A::func1);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;A::func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(&amp;A::func2);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;B::func3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;B, <span class="type">void</span>&gt;(&amp;B::func3);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;B::func4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;B, <span class="type">void</span>&gt;(&amp;B::func4);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func1);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func2);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func3);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&amp;C::func4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  <span class="built_in">print_bytes</span>&lt;C, <span class="type">void</span>&gt;(&amp;C::func4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p>msvc （添加 <code>/RTC1</code> 标志，将所有未初始化的栈上内存标记为
<code>0xcc</code> ）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&amp;A::func1</span><br><span class="line">[ a2 40 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;A::func2</span><br><span class="line">[ 87 1a 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;B::func3</span><br><span class="line">[ b8 2a 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;B::func4</span><br><span class="line">[ bf 3c 4e 34 f6 7f  0  0 ]</span><br><span class="line">&amp;C::func1</span><br><span class="line">[ a2 40 4e 34 f6 7f  0  0  0  0  0  0 cc cc cc cc ]</span><br><span class="line">&amp;C::func2</span><br><span class="line">[ 87 1a 4e 34 f6 7f  0  0  0  0  0  0 cc cc cc cc ]</span><br><span class="line">&amp;C::func3</span><br><span class="line">[ b8 2a 4e 34 f6 7f  0  0  8  0  0  0 cc cc cc cc ]</span><br><span class="line">&amp;C::func4</span><br><span class="line">[ bf 3c 4e 34 f6 7f  0  0  8  0  0  0 cc cc cc cc ]</span><br></pre></td></tr></table></figure>

<p>GCC / Clang</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&amp;A::func1</span><br><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;A::func2</span><br><span class="line">[  9  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;B::func3</span><br><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;B::func4</span><br><span class="line">[  9  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func1</span><br><span class="line">[  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func2</span><br><span class="line">[  9  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func3</span><br><span class="line">[  1  0  0  0  0  0  0  0  8  0  0  0  0  0  0  0 ]</span><br><span class="line">&amp;C::func4</span><br><span class="line">[  9  0  0  0  0  0  0  0  8  0  0  0  0  0  0  0 ]</span><br></pre></td></tr></table></figure>

<p>C++ 代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(&amp;A::func1);</span><br></pre></td></tr></table></figure>

<p>可以对应到下面的汇编</p>
<p>MSVC</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lea     rcx, OFFSET FLAT:[thunk]:A::`vcall<span class="number">&#x27;</span>&#123;<span class="number">0</span>,&#123;flat&#125;&#125;<span class="string">&#x27; &#125;&#x27;</span>            ; A::`vcall<span class="number">&#x27;</span>&#123;<span class="number">0</span>&#125;&#x27;</span><br><span class="line">call    <span class="type">void</span> <span class="built_in">print_bytes</span>&lt;A,<span class="type">void</span>&gt;(<span class="built_in">void</span> (__cdecl A::*)(<span class="type">void</span>)) ; print_bytes&lt;A,<span class="type">void</span>&gt;</span><br></pre></td></tr></table></figure>

<p>GCC 对应调用的汇编</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mov     r12d, <span class="number">1</span></span><br><span class="line">mov     r13d, <span class="number">0</span></span><br><span class="line">mov     rcx, r12</span><br><span class="line">mov     rbx, r13</span><br><span class="line">mov     rax, r12</span><br><span class="line">mov     rdx, r13</span><br><span class="line">mov     rax, rdx</span><br><span class="line"># 最终 rdi = <span class="number">1</span>, rsi = <span class="number">0</span>，也就是输入到函数的参数</span><br><span class="line">mov     rdi, rcx</span><br><span class="line">mov     rsi, rax</span><br><span class="line">call    <span class="type">void</span> <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type)</span><br></pre></td></tr></table></figure>

<p>Clang 对应汇编</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">mov     qword ptr [rbp - <span class="number">24</span>], <span class="number">0</span></span><br><span class="line">mov     qword ptr [rbp - <span class="number">32</span>], <span class="number">1</span></span><br><span class="line"># 最终 rdi = <span class="number">1</span>, rsi = <span class="number">0</span>，也就是输入到函数的参数 </span><br><span class="line">mov     rdi, qword ptr [rbp - <span class="number">32</span>]</span><br><span class="line">mov     rsi, qword ptr [rbp - <span class="number">24</span>]</span><br><span class="line">call    <span class="type">void</span> <span class="built_in">print_bytes</span>&lt;A, <span class="type">void</span>&gt;(MemberFuncPtr&lt;A, <span class="type">void</span>&gt;::type)</span><br><span class="line">mov     rdi, qword ptr [rbp - <span class="number">160</span>]      # <span class="number">8</span>-byte Reload</span><br></pre></td></tr></table></figure>

<p>从结果中可以很清楚的看到，MSVC 和 GCC、Clang
的输出结果完全不一样，但从 MSVC
的结果上来看，存储的确实应该是一个指针，对于多继承情况下还包含一个4字节（<code>uint32_t</code>）的偏移量，而
GCC 和 Clang 是两个64位的值。</p>
<p>根据网上搜集的资料，我们可以得到这两个结构体的含义</p>
<ul>
<li><p><a href="https://rants.vastheman.com/2021/09/21/msvc/">MSVC C++
ABI Member Function Pointers « Rants from Vas
(vastheman.com)</a></p></li>
<li><p><a
href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#member-pointers">Itanium
C++ ABI (itanium-cxx-abi.github.io)</a></p></li>
</ul>
<p>MSVC C++ ABI member function pointer 结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// single inheritance</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">  <span class="comment">// thunk function pointer</span></span><br><span class="line">  <span class="type">uintptr_t</span> ptr;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// muiltiple inheritance</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">    <span class="comment">// thunk function pointer</span></span><br><span class="line">    <span class="type">uintptr_t</span> ptr;</span><br><span class="line">    <span class="comment">// adjustor</span></span><br><span class="line">    <span class="type">uint32_t</span> adj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>GCC / Clang Itanium C++ ABI member function pointer 结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gcc / clang</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">    <span class="comment">// function pointer / vtable offset in bytes</span></span><br><span class="line">    <span class="type">uintptr_t</span> ptr;</span><br><span class="line">    <span class="comment">// adjustor</span></span><br><span class="line">    <span class="type">ptrdiff_t</span> adj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>在 x86-64 上，通过 ptr
的最后一位判断是否是虚函数，因为虚函数指针大小为 8 字节，也就是说 ptr
的值一定是偶数，即 ptr 的最后一位永远都是
0，这样对于普通函数而言，这个值就为偶数，而虚函数则是奇数。</strong></p>
<p><strong>在 arm 上，对于虚函数的判断方式转换成了 adj，通过 adj
的最后一位标识是否是虚函数</strong></p>
<blockquote>
<p>这一点我们同样可以从汇编代码上看出来</p>
<p>C++代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print_bytes&lt;A, void&gt;(&amp;A::func1);</span><br></pre></td></tr></table></figure>

<p>对应 ARM64 汇编</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">movs    r3, #0</span><br><span class="line">str     r3, [r7, #8]</span><br><span class="line">movs    r3, #1</span><br><span class="line">str     r3, [r7, #12]</span><br><span class="line">add     r3, r7, #8</span><br><span class="line">ldm     r3, &#123;r0, r1&#125;</span><br><span class="line"># 最终传入的值为 &#123;0x0,0x1&#125;</span><br><span class="line">bl      void print_bytes&lt;A, void&gt;(MemberFuncPtr&lt;A, void&gt;::type)</span><br></pre></td></tr></table></figure>

</blockquote>
<p>这样，我们可以尝试解析成员函数指针并进行调用（仅限于 Itanium C++
ABI，也就是 GCC 和 Clang，对于 MSVC
实在是没办法，居然是又新增了一段跳转函数，属实是恶心人了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> n + v; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> n - v; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> n&#123;<span class="number">0xfffd</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">MemberFuncPtr</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="built_in">Ret</span> (T::*)(Args...);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">member_func_info</span> &#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr;</span><br><span class="line">  <span class="type">ptrdiff_t</span> adj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">member_func_info</span></span><br><span class="line"><span class="function"><span class="title">from_raw</span><span class="params">(<span class="keyword">typename</span> MemberFuncPtr&lt;T, Ret, Args...&gt;::type func_ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;member_func_info *&gt;(&amp;func_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">typename</span> Ret, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">Ret <span class="title">invoke</span><span class="params">(T *obj, <span class="keyword">typename</span> MemberFuncPtr&lt;T, Ret, Args...&gt;::type func_ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">           Args &amp;&amp;...args)</span> </span>&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr_this = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(obj);</span><br><span class="line">  member_func_info func_info = <span class="built_in">from_raw</span>&lt;T, Ret, Args...&gt;(func_ptr);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&lt;ptr=&quot;</span> &lt;&lt; func_info.ptr &lt;&lt; <span class="string">&quot;,adj=&quot;</span> &lt;&lt; func_info.adj &lt;&lt; <span class="string">&quot;&gt;&quot;</span></span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line">  <span class="type">uintptr_t</span> adj_this = ptr_this + func_info.adj;</span><br><span class="line">  <span class="type">uintptr_t</span> vptr = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span> *&gt;(adj_this);</span><br><span class="line">  <span class="type">uintptr_t</span> func_address = vptr + func_info.ptr &amp; (~<span class="number">0x1</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  // arm case</span></span><br><span class="line"><span class="comment">  uintptr_t adj_this = ptr_this + func_info.adj &gt;&gt; 1;</span></span><br><span class="line"><span class="comment">  uintptr_t vptr = *reinterpret_cast&lt;uintptr_t *&gt;(adj_this);</span></span><br><span class="line"><span class="comment">  uintptr_t func_address = vptr + func_info.ptr;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// call function</span></span><br><span class="line">  <span class="keyword">using</span> Func = <span class="built_in">Ret</span> (*)(T *, Args...);</span><br><span class="line">  Func f = *<span class="built_in">reinterpret_cast</span>&lt;Func *&gt;(func_address);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">f</span>(obj, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a&#123;<span class="number">10</span>&#125;;</span><br><span class="line">  <span class="comment">// 主打的就是一个脱裤子放屁</span></span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">invoke</span>&lt;A, <span class="type">int</span>&gt;(&amp;a, &amp;A::func2, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">  <span class="comment">// 等价于 a.func2(20);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img data-src="/posts/55c5/image-20230202221518873.png" /></p>
<p>对于 clang 也是一样</p>
<p><img data-src="/posts/55c5/image-20230202223902378.png" /></p>
<h2 id="总结">总结</h2>
<p><strong>虚函数的出现是因为我们无法在静态编译过程中确定要执行的函数，需要动态查找待执行的函数</strong>。具体而言就是通过对象示例中存储的一个指向虚函数表（vtable）的虚指针（vptr），结合待调用的虚函数信息（在
vtable 上的偏移量）获取到实际的函数地址，最后调用函数。</p>
<p>对于普通的函数而言，在静态编译过程中能够获取到函数地址，而虚函数则多了一个查找的过程（虚继承情况可能还要再多一次虚基的寻址过程）。</p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 易错点整理(一)</title>
    <url>/posts/764b/</url>
    <content><![CDATA[<p>最近刷牛客的 C++ 语言专项练习（选择题），本来以为 C++
掌握的还不错吧，一做题就全露馅了，细节太多了（ C++ 本身的
<strong>未定义行为 undefined behavior</strong> 以及
C++这么多年来的更新带来的包袱太多了）</p>
<p>基本上所有的问题都可以在 <a
href="https://en.cppreference.com/w/">cppreference.com</a>
上面找到答案，还有样例，比较权威，然后实现相关的可以使用 <a
href="https://godbolt.org/">Compiler Explorer (godbolt.org)</a>
查看编译细节。</p>
<h2 id="c-语法细节">C++ 语法细节</h2>
<h3 id="自增自减运算符的重载">自增/自减运算符的重载</h3>
<p><em><strong>题1</strong></em>：如果定义了一个类myclass,
则为myclass类对象以成员函数形式重载 <strong>后 ++ 运算符</strong>
的声明应该是：</p>
<p>A. <code>myclass operator++()</code></p>
<p>B. <code>myclass operator++(int)</code></p>
<p>C. <code>myclass &amp;operator++()</code></p>
<p>D. <code>myclass &amp;operator(int)</code></p>
<p><em><strong>答案</strong></em>：B</p>
<p><em><strong>解析</strong></em>：这题纯纯考察自增/自减的重载，没什么难点，单纯是不记得这个写法了</p>
<span id="more"></span>

<blockquote>
<h4 id="increment-and-decrement">Increment and decrement</h4>
<p>When the postfix increment or decrement operator appears in an
expression, the corresponding user-defined function (operator++ or
operator--) is called with an integer argument <code>0</code>.
Typically, it is implemented as T operator++(int) or T operator--(int),
where the argument is ignored. The postfix increment and decrement
operators are usually implemented in terms of the prefix versions:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前置自增</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called ++A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置自增，相比前置版本的函数签名，就差了一个 int</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called A++&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a++;</span><br><span class="line">    ++a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230209205555494.png" /></p>
<p>关键点就是：<strong>后置自增函数相比于前置自增函数需要添加一个
<code>int</code> 参数进行区别</strong></p>
<p>注：对于前置自增/自减和后置自增/自减运算符本身也是常考察的内容：</p>
<ul>
<li><p><code>i++</code> 的含义是 <strong>将 i 增加
1，返回加之前的值</strong>，用一个函数来表示就是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_increment</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = v;</span><br><span class="line">    v += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>++i</code> 的含义是 <strong>将 i 增加
1，返回加之后的值</strong>，用于用函数来表示就是</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">postfix_increment</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v+= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从我们代码实现上也可以看出，<em><strong>在未优化的情况下</strong></em>，后置自增会比前置自增多用一个临时变量，从而造成性能开销，<strong>但是现在的编译器都很智能了，对于这个基本上都会直接优化掉</strong>（开启
<code>-O2</code>
优化）。<em><strong>所以在平时写的时候怎么舒服怎么来就行，只要确保可读性就行</strong></em>。</p>
<h3 id="转义字符">转义字符</h3>
<p><em><strong>题2</strong></em>：有转义字符如下：<code>'\0X41'</code>、<code>'\0x41'</code>、<code>'\X41'</code>、<code>'\x41'</code>、<code>'\a'</code>、<code>'\b'</code>、<code>'\c'</code>、<code>'\r'</code>
其中错误的转义字符个数是（</p>
<p><em><strong>解析</strong></em>：这题也是考察的 C++ 语法，错误的有 4
个，<code>\0X41</code>、<code>\0x41</code>、<code>\X41</code>、<code>\c</code></p>
<p>详细参考：<a
href="https://en.cppreference.com/w/cpp/language/escape">Escape
sequences - cppreference.com</a></p>
<p><strong>1. 简单转义字符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\&#x27; 表示 &#x27;</span><br><span class="line">\&quot; 表示 &quot;</span><br><span class="line">\\ 表示 \</span><br><span class="line">\? 表示 ?</span><br><span class="line">\a 表示 蜂鸣器（主板上）</span><br><span class="line">\b 表示 退格</span><br><span class="line">\f 表示 新一页</span><br><span class="line">\n 表示 换行 (Line Feed)</span><br><span class="line">\r 表示 回车 (Carriage Return)</span><br><span class="line">\t 表示 水平制表符</span><br><span class="line">\v 表示 垂直制表符</span><br></pre></td></tr></table></figure>

<p>注：<code>\n\r</code> 在 CRLF （Carriage Return / Line
Feed）表示回车换行，一般在 Windows 下的纯文本中常用，而在 Unix
系统下常用 <code>\n</code> 即 换行，在 VS Code 中也可以进行设置</p>
<p><img data-src="/posts/764b/image-20230209221937788.png"
style="zoom: 33%;" /></p>
<p><strong>2. 数值表示形式</strong></p>
<p>char 本质上也是一个整数，那么我们可以使用数值编码也是一样的</p>
<ul>
<li>八进制形式：<code>\&lt;nnn&gt;</code>，例如 <code>\141</code> 表示
ASCII 字符 <code>'a'</code></li>
<li>十六进制形式：<code>\x&lt;nn&gt;</code>，例如 <code>\x61</code> 表示
ASCII 字符
<code>'a'</code>（这个是区分大小写的，只能使用小写的<code>\x</code>，但是后面的十六进制大小写都可以），例如
<code>\x3F</code> 和 <code>\x3f</code> 都行</li>
</ul>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v0 = <span class="string">&quot;\x61&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v1 = <span class="string">&quot;\141&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v2 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; v0 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. Unicode 表示形式</strong></p>
<ul>
<li><code>\u&lt;nnnn&gt;</code>，表示 <code>U+&lt;nnnn&gt;</code>的
Unicode，这种方式只能表示到 <code>U+FFFF</code>，对于 Emoji
等只能使用下面这种完整形式了</li>
<li><code>\U&lt;nnnnnnnn&gt;</code>，表示
<code>U+&lt;nnnnnnnn&gt;</code>的 Unicode，可以完整的表示
Unicode（<code>U+FFFFFFFF</code>），就是表示起来比较麻烦</li>
</ul>
<p>而对于上面提到的 <code>\c</code> ，其在 C++
中有定义，但是具体实现有关，没有一个统一的含义，因此不能算在转义字符行列中</p>
<h3 id="域解析操作符">域解析操作符</h3>
<p><em><strong>题3</strong></em>：外部变量可以供其所在的程序文件中的任何函数使用（）</p>
<ol type="1">
<li><p>正确</p></li>
<li><p>错误</p></li>
</ol>
<p><em><strong>解析</strong></em>：这一题一眼
<strong>错误</strong>，因为在函数中使用同名的变量就会将其覆盖掉，这样就无法使用外部变量了，但是看到评论中提到可以使用
<code>::&lt;variable&gt;</code>来访问外面作用域。这个查了一下，称为
Scope Resolution Operator（作用域解析运算符），那么我们可以写成这样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> v = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; ::v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230209234348279.png" /></p>
<p>对于命名空间、类空间中定义的变量和静态函数都可以使用这个方式访问</p>
<h3 id="纯虚函数的函数体">纯虚函数的函数体</h3>
<p><em><strong>题4</strong></em>：（多选）c/c++中，有关纯虚函数说法正确的是（
）</p>
<ol type="1">
<li><p>子类中必须覆盖基类的纯虚函数</p></li>
<li><p>含有纯虚函数的类不能被实例化</p></li>
<li><p>基类的纯虚函数没有函数体</p></li>
<li><p>含有纯虚函数的类一定是抽象类</p></li>
</ol>
<p><em><strong>解析</strong></em>：这题主要考察
<em><strong>虚函数</strong></em> 相关的一些概念，正确的有 2，4</p>
<p>对于 1
，如果我们需要层层抽象的话，就可能会在子类中包含纯虚函数，因此子类不一定需要覆盖基类的纯虚函数</p>
<p>对于 4 ，乍一看好像是对的，我们都 <em><strong>声明</strong></em>
其是纯虚函数了，为啥还要 <em><strong>定义</strong></em> 函数方法呢？</p>
<p>这一部分其实在 cppreference 上也有介绍</p>
<blockquote>
<p>The definition of a pure virtual function may be provided (and must
be provided if the pure virtual is the <a
href="https://en.cppreference.com/w/cpp/language/destructor">destructor</a>):
the member functions of the derived class are free to call the abstract
base's pure virtual function using qualified function id. This
definition must be provided outside of the class body (the syntax of a
function declaration doesn't allow both the pure specifier
<strong><code>= 0</code></strong> and a function body).</p>
<p>Making a virtual call to a pure virtual function from a constructor
or the destructor of the abstract class is undefined behavior
(regardless of whether it has a definition or not).</p>
<p><a
href="https://en.cppreference.com/w/cpp/language/abstract_class">Abstract
class - cppreference.com</a></p>
<p>翻译一下就是：</p>
<p>纯虚函数可以提供函数定义（如果是析构函数的话必须要提供），但是不能以类内的方式存在，需要在类外部进行定义。<code>=0</code>
语法就已经禁止函数定义了。</p>
<p>并且在抽象类的构造/析构函数中调用 <strong>纯虚函数</strong> 是
<em><strong>未定义行为</strong></em> ,千万不要这么做。</p>
</blockquote>
<p>说起来有点抽象，举个例子吧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstract</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 只能采用类外定义的方式进行定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Abstract::func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;calling Abstract::func\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Abstract &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 子类要么继续保持抽象类，要么重写 func</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;calling Derived::func\n&quot;</span>;</span><br><span class="line">        Abstract::<span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Abstract* a = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result of a-&gt;Abstract::func():\n&quot;</span>;</span><br><span class="line">    a-&gt;Abstract::<span class="built_in">func</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result of a-&gt;func():\n&quot;</span>;</span><br><span class="line">    a-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230210110358443.png"
style="zoom:50%;" /></p>
<p>由于 C++ 中没有引入类似 <code>abstract</code>
这类的关键字，我们只能通过声明虚函数的方式来讲一个类设置为抽象类，并且我们需要强制子类实现某个函数，但是有时为了代码复用，又想提供一个默认的函数实现时，就可以采用这种方法。</p>
<h3 id="void-的大小">void 的大小？</h3>
<p><em><strong>题5</strong></em>：32位编译器下，<code>sizeof(void)</code>
的值是多少？</p>
<p><em><strong>解析</strong></em>：void
的大小和编译器以及语言有关在。</p>
<ul>
<li><p>C 中，<code>sizeof(void)</code>
值和编译器有关，有可能为0，有可能为1</p></li>
<li><p>C++ 中，<code>sizeof(void)</code> 会直接报错</p>
<p><img data-src="/posts/764b/image-20230210111608942.png"
style="zoom: 50%;" /></p></li>
</ul>
<p>那么对于 <code>void*</code>
指针而言，我们将其自增，地址值会如何变化呢？</p>
<p>由于我们无法取得 <code>void</code>
的大小，<strong>自然也就无法对其进行指针运算了</strong>，要想实现运算，只能通过强制类型转换。</p>
<p><img data-src="/posts/764b/image-20230210112209205.png"
style="zoom:50%;" /></p>
<p>为了跨平台方便，在头文件 <code>cstdint</code> 中定义了
<code>uintptr_t</code>来表示和指针同样大小的整形类型，用来显式表示地址值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> size = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span>* v = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">    <span class="type">void</span>* v1 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(v);</span><br><span class="line">    <span class="type">uintptr_t</span> v2 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(v1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of v1 = &quot;</span></span><br><span class="line">              &lt;&lt; v1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of v2 = &quot;</span> </span><br><span class="line">              &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>)</span><br><span class="line">              &lt;&lt; std::showbase</span><br><span class="line">              &lt;&lt; v2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of v2 + 1 = &quot;</span> </span><br><span class="line">              &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>)</span><br><span class="line">              &lt;&lt; std::showbase</span><br><span class="line">              &lt;&lt; v2 + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（std::cout 这张流式输出方式真的太繁琐了，还不如使用 <code>fmt</code>
库）</p>
<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230210114206263.png"
style="zoom:50%;" /></p>
<p>当然，我们也可以将 <code>uintptr_t</code>
强制类型转换到指针，然后读取其内容，不过十分危险，容易出错，日常不推荐这样使用。</p>
<h3 id="类变量初始化和析构顺序">类变量初始化和析构顺序</h3>
<p><em><strong>题6</strong></em>：给出下列代码的实际运行结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">const</span> <span class="type">char</span>* p_szName):<span class="built_in">m_szName</span>(p_szName) &#123;std::cout &lt;&lt; m_szName &lt;&lt; <span class="string">&quot;,&quot;</span>;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt;<span class="string">&quot;~&quot;</span>&lt;&lt;m_szName &lt;&lt; <span class="string">&quot;, &quot;</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* m_szName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> <span class="type">char</span>*p_szName)</span><br><span class="line">      :<span class="built_in">m_szName</span>(p_szName)</span><br><span class="line">      ,<span class="built_in">m_objA</span>((<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;A&quot;</span>)</span><br><span class="line">      ,<span class="built_in">m_objB</span>((<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;B&quot;</span>)</span><br><span class="line">      ,<span class="built_in">Base</span>((<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;C&quot;</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; m_szName &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;~&quot;</span>&lt;&lt;m_szName &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* m_szName;</span><br><span class="line">	Base m_objB;</span><br><span class="line">	Base m_objA;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>解析</strong></em>：这道题就考察的类变量初始化和析构的顺序问题，如果没有写代码测试的话确实不知道运行结果是怎么样的。</p>
<p>同样在 cppreference 上有详细的介绍：<a
href="https://en.cppreference.com/w/cpp/language/constructor">Constructors
and member initializer lists - cppreference.com</a></p>
<blockquote>
<h4 id="initialization-order">Initialization order</h4>
<p>The order of member initializers in the list is irrelevant: the
actual order of initialization is as follows:</p>
<ol type="1">
<li>If the constructor is for the most-derived class, virtual bases are
initialized in the order in which they appear in depth-first
left-to-right traversal of the base class declarations (left-to-right
refers to the appearance in base-specifier lists)</li>
<li>Then, direct bases are initialized in left-to-right order as they
appear in this class's base-specifier list</li>
<li>Then, non-static data member are initialized in order of declaration
in the class definition.</li>
<li>Finally, the body of the constructor is executed</li>
</ol>
<p>(Note: if initialization order was controlled by the appearance in
the member initializer lists of different constructors, then the <a
href="https://en.cppreference.com/w/cpp/language/destructor">destructor</a>
wouldn't be able to ensure that the order of destruction is the reverse
of the order of construction)</p>
<p>简单翻译一下就是：</p>
<p><em><strong>类成员初始化的顺序</strong></em> 与在类构造函数中
<em><strong>成员初始化列表</strong></em>
的顺序<em><strong>没有任何关系</strong></em>，其取决于以下四点：</p>
<ol type="1">
<li>对于多层嵌套继承，使用DFS，从左到右的顺序初始化基类（继承树的遍历）</li>
<li>对于直接基类按从左到右的顺序初始化基类</li>
<li>对于非静态的数据成员将会按照
<em><strong>类定义时的声明顺序</strong></em> 进行初始化</li>
<li>最终执行构造函数体</li>
</ol>
<p>注：如果 <strong>成员初始化顺序</strong> 由
<strong>成员初始化列表</strong> 来控制的话，就无法确保析构顺序为
<strong>构造顺序的逆序</strong> 了</p>
</blockquote>
<p>讲了这么多，关键就一点：<strong>类内非静态成员的初始化顺序是按照声明时的顺序进行初始化，在析构时则按照相反的顺序进行析构</strong></p>
<p>由此，我们可以轻松知道代码执行的结果了</p>
<p><code>Derived</code> 继承了
<code>Base</code>，那么在初始化之前必须要初始化基类，因此首先初始化
<code>Base</code>，那么首先就会输出 <code>C</code>，之后按顺序初始化
<code>B</code>、初始化 <code>A</code>，最终执行函数体
<code>D</code>，</p>
<p>那么在析构时则按照构造的相反顺序，首先执行函数体<code>D</code>，后析构<code>A</code>，再析构
<code>B</code>，最后析构基类 <code>C</code></p>
<p>最终输出如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C,B,A,D,~D,~A,~B,~C,</span><br></pre></td></tr></table></figure>

<p>而带代码实际运行结果也是如此</p>
<p><img data-src="/posts/764b/image-20230210121645460.png"
style="zoom:50%;" /></p>
<h3 id="函数重载方式">函数重载方式</h3>
<p><em><strong>题7</strong></em>：以下不是double
compare(int,int)的重载函数的是()</p>
<ol type="1">
<li><code>int compare(double,double)</code></li>
<li><code>double compare(double,double)</code></li>
<li><code>double compare(double,int)</code></li>
<li><code>int compare(int,int)</code></li>
</ol>
<p><em><strong>解析</strong></em>：这题考察的是函数重载的定义方式，在
C++ 中支持同名函数，使用不同的参数调用不同的重载函数。具体通过 name
mangling
实现。<strong>而重载函数的区别主要在于函数入参数量以及入参类型</strong>。</p>
<p>而 1 和 2
仅在函数返回类型上不一致，调用时我们就不知道如何调用了。</p>
<p><img data-src="/posts/764b/image-20230210141729168.png"
style="zoom:50%;" /></p>
<h3 id="指针和引用">指针和引用</h3>
<p><em><strong>题8</strong></em>：关于引用以下说法错误的是（）。</p>
<ol type="1">
<li>引用必须初始化，指针可以不初始化</li>
<li>引用初始化以后不能被改变，而指针可以改变指向</li>
<li>不存在指向空值的引用，但是存在指向空值的指针</li>
<li>一个引用可以看作是某个变量的一个“别名”</li>
<li>引用传值，指针传地址</li>
<li>函数参数可以声明为引用或指针类型</li>
</ol>
<p><em><strong>解析</strong></em>：答案是
5，传递引用实际上就是传递指针，这一点从汇编代码上可以看出来</p>
<p>通过 compiler explorer 查看输出如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>* a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用 GCC 12.2 编译代码如下</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">func1(int&amp;):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        nop</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">func2(int*):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        nop</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h3 id="数组入参">数组入参</h3>
<p><em><strong>题8</strong></em>：在32位环境下，以下程序的输出结果是？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> x[<span class="number">14</span>])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sizeof</span>(x) + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> x[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sizeof</span>(x) + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived stDerived;</span><br><span class="line">    Base *pstBase = &amp;stDerived;</span><br><span class="line">    <span class="type">char</span> x[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pstBase-&gt;<span class="built_in">foo</span>(<span class="number">100</span>) + pstBase-&gt;<span class="built_in">foo</span>(x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>解析</strong></em>：这题主要考察的是虚函数调用以及数组作为参数调用函数的一些细节：</p>
<p>这一部分在 cppreference 上有介绍：<a
href="https://en.cppreference.com/w/cpp/language/array">Array
declaration - cppreference.com</a></p>
<blockquote>
<h4 id="array-to-pointer-decay">Array-to-pointer decay</h4>
<p>There is an <a
href="https://en.cppreference.com/w/cpp/language/implicit_conversion">implicit
conversion</a> from lvalues and rvalues of array type to rvalues of
pointer type: it constructs a pointer to the first element of an array.
This conversion is used whenever arrays appear in context where arrays
are not expected, but pointers are:</p>
<p>翻译一下就是：当我们使用数组作为入参调用函数时，数组会隐式退化成指针</p>
</blockquote>
<p>那么如果我们有一个函数，想要遍历数组的所有元素时，<strong>我们是绝对不能使用
<code>sizeof</code>
来获取数组的长度的，因此此时数组已经退化为指针了！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_array</span><span class="params">(<span class="type">int</span> x[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(x) / <span class="built_in">sizeof</span>(x[<span class="number">0</span>]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(print_array) sizeof(x) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(print_array) length(x) = &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; x[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(x) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(x) / <span class="built_in">sizeof</span>(x[<span class="number">0</span>]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;length(x) = &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">print_array</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并不会如我们期待的输出数组中所有的元素，而是输出前 8 个元素值</p>
<p><img data-src="/posts/764b/image-20230210150327901.png"
style="zoom:50%;" /></p>
<p>（不过我们都用数组了，数组的长度肯定是已知的，这样低级错误应该还是不会犯的，况且现代编译器都会提示这个问题）</p>
<p><img data-src="/posts/764b/image-20230210150530111.png"
style="zoom: 33%;" /></p>
<p>回到这一题，前一个函数符合虚函数调用，会调用子类的
<code>int foo(int)</code>，输出结果
2000，而后面一个由于不是虚函数，则会直接调用父类定义的
<code>int foo(int x[14])</code>，并且在其中使用
<code>sizeof(x)</code>，32位环境下指针大小为 4，那么最终结果就是 2000+14
= 2014</p>
<h3 id="函数入参求值顺序">函数入参求值顺序</h3>
<p><em><strong>题9</strong></em>：阅读C语言代码输出（）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p=arr;</span><br><span class="line">    *(p++)+=<span class="number">89</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,*p,*(++p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>解析</strong></em>：这一题直接考察 printf
的求值顺序，但是实际上这是一个
<em><strong>未定义行为</strong></em>，不同编译器下结果不一致，这题的目的在于：<strong>我们不能理所当然的假设参数的求值顺序就是从左到右或从右到左，也千万不要写出类似的代码</strong></p>
<p>GCC 下输出为</p>
<p><img data-src="/posts/764b/image-20230210153919168.png"
style="zoom:50%;" /></p>
<p>Clang下输出如下，还对我们的调用给出了警告（这说明编译器的警告有时候还是要看看的，不是说编译过了就行）</p>
<p><img data-src="/posts/764b/image-20230210153955611.png"
style="zoom:50%;" /></p>
<p>同样，在函数调用时的参数求值顺序也不能假设，示例如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">arg0</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called argument0\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">arg1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called argument1\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">arg2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called argument2\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">arg0</span>(),<span class="built_in">arg1</span>(),<span class="built_in">arg2</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不同的编译器下输出结果不一致，我们不能假定其一定是从左到右进行求值，也有可能从右向左求值。</p>
<p>Clang 15.0 输出结果</p>
<p><img data-src="/posts/764b/image-20230210152746441.png"
style="zoom:50%;" /></p>
<p>GCC 12.2 输出结果</p>
<p><img data-src="/posts/764b/image-20230210152810621.png"
style="zoom:50%;" /></p>
<h2 id="stl">STL</h2>
<h3 id="迭代器失效">迭代器失效</h3>
<p><em><strong>题9</strong></em>：会导致下列的代码片段崩溃的
<code>CONTAINER</code> 类型是？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CONTAINER::iterator iter, tempIt;</span><br><span class="line"><span class="keyword">for</span> (iter = cont.<span class="built_in">begin</span>(); iter != cont.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    tempIt = iter;</span><br><span class="line">    ++iter;</span><br><span class="line">    cont.<span class="built_in">erase</span>(tempIt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设cont是一个 <code>CONTAINER</code>
的实例，里面包含数个元素，那么当 <code>CONTAINER</code> 为：</p>
<p>1、vector 2、list 3、map 4、deque</p>
<p>会导致上面的代码片段崩溃的 <code>CONTAINER</code> 类型是？</p>
<p><em><strong>解析</strong></em>：这题考察的是STL容器的迭代器，我们尝试对容器进行修改然后继续使用修改之前的迭代器，这样子的操作非常容易出问题，因为对于
vector 和 deque 这样的顺序存储容器而言，其数据存储是连续的，当我们进行
remove
的时候有可能影响迭代器，从而使迭代器失效，而访问一个失效的迭代器就会使程序崩溃。</p>
<p>对于任何一种迭代器，我们都不要尝试对其修改后再使用之前的迭代器，实际上
<code>erase</code>
函数会返回修改后的迭代器，我们要写代码可以正确运行，直接使用这个即可。即</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">CONTAINER::iterator iter, tempIt;</span><br><span class="line"><span class="keyword">for</span> (iter = cont.<span class="built_in">begin</span>(); iter != cont.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    iter = cont.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以保证代码的正确运行</p>
<h2 id="c-库函数">C 库函数</h2>
<h3 id="查找字符串">查找字符串</h3>
<p><em><strong>题6</strong></em>：从字符串中寻找一串字符的函数是（）</p>
<p>A. <code>strcmp</code></p>
<p>B. <code>strstr</code></p>
<p>C. <code>strcat</code></p>
<p>D. <code>strfind</code></p>
<p><strong>解析</strong>：看函数名字就想选
<code>strfind</code>，但是这个函数实际上是 matlab 的字符串查找函数，而在
C 库中对应的是 <code>strstr</code>。</p>
<p>（主要还是没用过，不知道）</p>
<p>其函数签名如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strstr</span><span class="params">(<span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span>* s2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其作用就是返回 s2 在 s1 中第一次出现的位置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sub = <span class="string">&quot;foobar&quot;</span>;</span><br><span class="line">    <span class="comment">// 此处我们拿到的 v 就是 sub 中的一个指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v = <span class="built_in">strstr</span>(sub,s);</span><br><span class="line">    <span class="type">uintptr_t</span> s0 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(sub);</span><br><span class="line">    <span class="type">uintptr_t</span> v0 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of sub = &quot;</span> &lt;&lt; s0 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of strstr(sub,s) = &quot;</span> &lt;&lt; v0 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230210115052441.png"
style="zoom:50%;" /></p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行切换MSVC版本</title>
    <url>/posts/30a2/</url>
    <content><![CDATA[<p>在 WIndows 下跑 Python 深度学习代码时，需要编译 C++ 库（点名
Pytorch3d），但是使用最新版本的 MSVC 进行编译的时候会报错，去 Github 看
Issue 时有提到降级可能有效，我们可以通过添加组件的方式直接下载指定版本的
MSVC
编译器。然后手动修改进行切换。为了怕后面遇到类似问题时忘记怎么搞，还是简单记录一下吧，具体操作如下：</p>
<ol type="1">
<li><p>首先打开 Visual Studio Installer，点击 <code>修改</code> 按钮</p>
<p><img data-src="/posts/30a2/image-20230220223924979.png" /></p>
<span id="more"></span>
</li>
<li><p>在 <code>单个组件</code> 菜单中，找到指定版本的 MSVC</p>
<p>注意编译器的名称是
<code>MSVC v&lt;xxx&gt; - VS &lt;xxxx&gt; C++ x64/86 生成工具(v&lt;xx&gt;.&lt;xx&gt;)</code>，千万不要下错了</p>
<p><img data-src="/posts/30a2/image-20230220224128371.png" /></p></li>
<li><p>下载完成后，我们找到 Visual Studio 的安装目录， 其中
<code>VC</code> 目录就包含了 MSVC 相关的文件</p>
<p><img data-src="/posts/30a2/image-20230220224414127.png" /></p></li>
<li><p>进入 <code>VC</code> 目录，在 <code>Tools\MSVC</code>
我们就可以找到安装的所有 MSVC 编译器</p>
<p><img data-src="/posts/30a2/image-20230220224544477.png" /></p></li>
<li><p>我们可以进入一个子目录，进入 <code>bin\Hostx64\x64</code>
文件夹，然后在这个文件夹下打开 Developer PowerShell，输入
<code>.\cl.exe</code> 查看版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) PS C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\bin\Hostx64\x64&gt; cl</span><br><span class="line">用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.25.28614 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">用法: cl [ 选项... ] 文件名... [ /link 链接选项... ]</span><br><span class="line">(base) PS C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\bin\Hostx64\x64&gt; .\cl.exe</span><br><span class="line">用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.29.30147 版</span><br><span class="line">版权所有(C) Microsoft Corporation。保留所有权利。</span><br><span class="line"></span><br><span class="line">用法: cl [ 选项... ] 文件名... [ /link 链接选项... ]</span><br></pre></td></tr></table></figure>

<p>可以看到，当我们直接输入 <code>cl</code> 时，调用的是环境变量中设置的
MSVC 编译器，而输入 <code>.\cl.exe</code> 直接调用当前目录下的
<code>cl.exe</code> 时就会调用当前目录的 MSVC 编译器</p></li>
<li><p>最后我们只需要切换当前环境变量中使用的 <code>cl</code>
就行，这里需要进入 <code>&lt;vs-path&gt;\VC\Auxiliary\Build</code>
路径，在这个路径下面就制定了默认使用的 MSVC 版本</p></li>
</ol>
<p><img data-src="/posts/30a2/image-20230220225257590.png" /></p>
<p>我们只需要修改其中的包含 <code>VCToolsVersion</code> 和
<code>VCRedistVersion</code>
字样的文件，将其中对应版本全部替换成我们需要的 MSVC 版本即可</p>
<p><code>Microsoft.VCToolsVersion.default.props</code></p>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version = <span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">ToolsVersion</span> = <span class="string">&quot;4.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">VCToolsVersion</span> <span class="attr">Condition</span> = <span class="string">&quot;&#x27;$(VCToolsVersion)&#x27; == &#x27;&#x27;&quot;</span> &gt;</span>14.25.28610<span class="tag">&lt;/<span class="name">VCToolsVersion</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">VCToolsRedistVersion</span> <span class="attr">Condition</span> = <span class="string">&quot;&#x27;$(VCToolsRedistVersion)&#x27; == &#x27;&#x27;&quot;</span> &gt;</span>14.25.28508<span class="tag">&lt;/<span class="name">VCToolsRedistVersion</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span>     </span><br></pre></td></tr></table></figure>

<p><code>Microsoft.VCToolsVersion.default.txt</code>（这个文件实际上就一个版本号，直接改掉就可以）</p>
   <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">14.25.28610</span><br></pre></td></tr></table></figure>

<ol start="7" type="1">
<li>切换完成后，我们再使用 Developer Powershell
打开时就不会出问题了</li>
</ol>
<p>注：上面的更改仅适用于命令行，在 Visual Studio
中可以直接手动更换，具体参考官方教程：<a
href="https://learn.microsoft.com/en-us/cpp/build/how-to-modify-the-target-framework-and-platform-toolset?view=msvc-170">How
to: Modify the Target Framework and Platform Toolset | Microsoft
Learn</a></p>
<p>使用命令行是因为 Python 编译 C
库需要从命令行调用，所以只能这样修改，而 cmake
等编译工具实际上也只需要指定版本即可，具体可以参考官方文档：<a
href="https://cmake.org/cmake/help/latest/variable/MSVC_VERSION.html">MSVC_VERSION
— CMake 3.26.0-rc4 Documentation</a></p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>MSVC</tag>
      </tags>
  </entry>
  <entry>
    <title>zerotier实现内网穿透</title>
    <url>/posts/f9ab/</url>
    <content><![CDATA[<p>zerotier
可以将不同局域网下的主机连接到同一个虚拟局域网内（即内网穿透），使用之前需要注册一个
zerotier账号，所有对虚拟网络的操作（设备管理、ip设置等）都需要在 web
端进行。官方网址：<a
href="https://www.zerotier.com/">https://www.zerotier.com/</a></p>
<h2 id="注册-zerotier-账号">注册 Zerotier 账号</h2>
<blockquote>
<p>注：zerotier 服务器在国外，访问的时候可能需要挂梯子。</p>
</blockquote>
<p>进入<a href="https://www.zerotier.com/">官网</a></p>
<p><img data-src="/posts/f9ab/zerotier-website.jpg" style="zoom:50%;" /></p>
<p>点击右上角的 Sign Up 按钮就可以进入注册页面</p>
<span id="more"></span>

<p><img data-src="/posts/f9ab/zerotier-signup.jpg" style="zoom:50%;" /></p>
<p>填写好相关信息后就会收到确认邮件，点击邮件中的链接即可激活账号。之后就可以创建虚拟网络进行相关配置了。</p>
<h2 id="创建虚拟局域网">创建虚拟局域网</h2>
<p>登入账号后我们会直接进入虚拟网络管理界面：<a
href="https://my.zerotier.com/">ZeroTier Central</a></p>
<p><img data-src="/posts/f9ab/zerotier-center.jpg" style="zoom:50%;" /></p>
<p>点击黄色按钮就可以创建一个新的虚拟局域网</p>
<p><img data-src="/posts/f9ab/zerotier-center-after.jpg"
style="zoom:50%;" /></p>
<p>网络名称是随机生成的，但网络ID是唯一的。点击网络名称便可以进入网络管理页面，我们可以进行相关的设置</p>
<p><img data-src="/posts/f9ab/zerotier-network-info.jpg"
style="zoom:50%;" /></p>
<p>主要包括：</p>
<ul>
<li>网络相关信息修改（名称，描述，IP区段）</li>
<li>节点的添加和删除</li>
<li>路由规则</li>
</ul>
<p>一般而言，如果不需要将虚拟网络和外网联通，并不需要设置路由规则，因此只需要管理成员的加入（分配
ip 地址）即可</p>
<h2 id="客户端安装">客户端安装</h2>
<p>对 windows 端和 macos
端，安装起来很方便，只需要从官网下载对应的安装包即可。</p>
<p>对于 Linux
端而言，稍微复杂一点，不过官网也直接给出了安装命令，我们按照命令进行安装即可。</p>
<p>option 1: ssl 命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://install.zerotier.com | sudo bash</span><br></pre></td></tr></table></figure>

<p>option 2: 添加 apt 软件源安装（支持更新）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s <span class="string">&#x27;https://raw.githubusercontent.com/zerotier/ZeroTierOne/master/doc/contact%40zerotier.com.gpg&#x27;</span> | gpg --import &amp;&amp; \</span><br><span class="line"><span class="keyword">if</span> z=$(curl -s <span class="string">&#x27;https://install.zerotier.com/&#x27;</span> | gpg); <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$z</span>&quot;</span> | sudo bash; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>第二种方式我们可以通过 apt 进行软件的更新，因此较为推荐使用。</p>
<p>添加软件源之后使用 <code>sudo apt update</code>
更新软件源，然后使用下列命令搜索 zerotier</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt search zerotier</span><br></pre></td></tr></table></figure>

<p>如果运行结果类似如下，则说明我们添加成功，使用
<code>sudo apt install zerotier-one</code> 即可完成安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) ➜  ~ sudo apt search zerotier</span><br><span class="line">Sorting... Done</span><br><span class="line">Full Text Search... Done</span><br><span class="line">zerotier-one/bionic,now 1.10.3 amd64 [installed]</span><br><span class="line">  ZeroTier network virtualization service</span><br></pre></td></tr></table></figure>

<p>安装完成后我们可以使用下列命令查看（必须要添加 sudo，否则会报错）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo zerotier-cli info</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) ➜  ~ sudo zerotier-cli info</span><br><span class="line">200 info 86dcfa11b5 1.10.3 ONLINE</span><br></pre></td></tr></table></figure>

<p>如果不添加 sudo，运行如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) ➜  ~ zerotier-cli info</span><br><span class="line">zerotier-cli: authtoken.secret not found or readable <span class="keyword">in</span> /var/lib/zerotier-one (try again as root)</span><br></pre></td></tr></table></figure>

<p>提示我们无法读取 <code>authtoken.secret</code> 文件，要求使用 root
再次尝试</p>
<h2 id="加入虚拟局域网">加入虚拟局域网</h2>
<p>zerotier上加入网络也十分简单，需要两步</p>
<ol type="1">
<li>客户端发起加入网络请求</li>
<li>web 端网络管理界面通过请求</li>
</ol>
<p>在任意一个平台下都可以使用下面命令发起加入网络请求（linux 和 macos
有可能需要添加 sudo）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-cli <span class="built_in">join</span> &lt;network ID&gt;</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@VM-0-17-ubuntu:/home/ubuntu# zerotier-cli join e5cd7a9e1c0f9729</span><br><span class="line">200 join OK</span><br></pre></td></tr></table></figure>

<p>然后需要在web端同意加入网络</p>
<p><img data-src="/posts/f9ab/zerotier-members.jpg" style="zoom:50%;" /></p>
<p>其中没有打勾的那一个节点就是等待添加的节点，打上勾就会自动添加并分配ip地址，在主机上使用<code>ifconfig</code>
（linux,macos）/ <code>ipconfig</code> (windows)
命令查看分配到的ip地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-17-ubuntu:/home/ubuntu<span class="comment"># ifconfig</span></span><br><span class="line">...</span><br><span class="line">ztppixkcjv: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 2800</span><br><span class="line">        inet 172.27.98.228  netmask 255.255.0.0  broadcast 172.27.255.255</span><br><span class="line">        inet6 fe80::fa:60ff:fe11:d5b3  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 2a:c8:16:2e:89:37  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 11  bytes 866 (866.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>其中那个 zt
开头的就是我们添加的虚拟网络了，我们可以查看到分配好的虚拟网络地址，此时我们可以使用
ping 来测试虚拟区域网中设备的连通性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-17-ubuntu:/home/ubuntu<span class="comment"># ping 172.27.58.47</span></span><br><span class="line">PING 172.27.58.47 (172.27.58.47) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=1 ttl=64 time=1729 ms</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=2 ttl=64 time=728 ms</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=3 ttl=64 time=353 ms</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=4 ttl=64 time=349 ms</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=5 ttl=64 time=346 ms</span><br><span class="line">64 bytes from 172.27.58.47: icmp_seq=6 ttl=64 time=344 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.27.58.47 ping statistics ---</span><br><span class="line">7 packets transmitted, 6 received, 14.2857% packet loss, time 6007ms</span><br><span class="line">rtt min/avg/max/mdev = 343.977/641.470/1728.966/505.726 ms, pipe 2</span><br></pre></td></tr></table></figure>

<p>其中 <code>172.27.58.47</code>
是运行在本地虚拟机的节点，由于zerotier根服务器设置在国外，第一次连接时需要通过根服务器找到对应主机信息，通过
UDP 建立连接，建立 P2P
网络，因此第一次连接较慢，但整体时延仍然很高，国内可以通过添加
<code>MOON</code> 节点来加速网络连接。</p>
<h2 id="optional-添加-moon-节点">(optional) 添加 MOON 节点</h2>
<h3 id="云服务器配置">云服务器配置</h3>
<p>由于zerotier的根服务器设置在国外，在国内组网时网络时延较高，因此可以通过设置
<strong>带有公网IP的云服务器</strong> 作为 <code>MOON</code>
节点作为根节点，降低网络时延</p>
<p>官网教程：<a href="https://docs.zerotier.com/zerotier/moons/">Private
Root Servers | ZeroTier
Documentation</a>（有一说一，官网这个教程写的真是...，第一次搞硬是没搞对，看了别人的教程才知道哪里有问题）</p>
<p>对于云服务器的配置和带宽，由于 MOON
节点仅用来建立连接，并不参与实际的网络数据交换，选择最丐的1核2G+1mbps带宽足够了。</p>
<p>配置过程分为以下4步：（在 zerotier 根目录下执行，全程 sudo）</p>
<ol type="1">
<li><p>根据本机 <code>identity.public</code>生成
<code>moon.json</code></p></li>
<li><p>修改 <code>moon.json</code> 文件，添加主机公网IP</p></li>
<li><p>从 <code>moon.json</code> 生成 <code>moon</code> 文件，并拷贝到
<code>moons.d</code> 文件夹下</p></li>
<li><p>重启 zerotier 服务</p></li>
</ol>
<p>zerotier应用的根目录（linux下）位于<code>/var/lib/zerotier</code>，其目录内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">ls</span> /var/lib/zerotier-one</span><br><span class="line">authtoken.secret  identity.public  moons.d     peers.d  zerotier-cli     zerotier-one      zerotier-one.port</span><br><span class="line">controller.d      identity.secret  networks.d  planet   zerotier-idtool  zerotier-one.pid  zerotier-one.te</span><br></pre></td></tr></table></figure>

<p>其中 <code>identity.public</code> 以及 <code>identity.secret</code>
就是用来表示本机的公钥和私钥了，使用这个 <code>identity.public</code>
我们就可以生成 <code>moon.json</code>，调用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo zerotier-idtool initmoon identity.public &gt;&gt; moon.json</span><br></pre></td></tr></table></figure>

<p>生成的 moon.json 内容如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;id&quot;</span>: <span class="string">&quot;5f1932174d&quot;</span>,</span><br><span class="line"> <span class="string">&quot;objtype&quot;</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line"> <span class="string">&quot;roots&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;identity&quot;</span>: <span class="string">&quot;5f1932174d:0:cf7728b3e66e4f207e537bfdee885c736d3430806c6cb279ce345103cef2302f42891547b73425793d0ea5cd7f18fd4c4a3aabf75193a23a609641d472ca01c6&quot;</span>,</span><br><span class="line">   <span class="string">&quot;stableEndpoints&quot;</span>: []</span><br><span class="line">  &#125;</span><br><span class="line"> ],</span><br><span class="line"> <span class="string">&quot;signingKey&quot;</span>: <span class="string">&quot;03f731a23d88171014e862dc222745b02f263eb58f72637a12a00a60175cd41dac20b91be0dc69ac233da8d8f119a3d4397228f89036d651d179469e373a8285&quot;</span>,</span><br><span class="line"> <span class="string">&quot;signingKey_SECRET&quot;</span>: <span class="string">&quot;76e23ef7ba06eeec08c85592bff86415143fd27c89efd0009a64ae0be864a9ba5ba592a8262cfe55210371499849a6c725eecaaf17e88d9ee2293a9eceb50dad&quot;</span>,</span><br><span class="line"> <span class="string">&quot;updatesMustBeSignedBy&quot;</span>: <span class="string">&quot;03f731a23d88171014e862dc222745b02f263eb58f72637a12a00a60175cd41dac20b91be0dc69ac233da8d8f119a3d4397228f89036d651d179469e373a8285&quot;</span>,</span><br><span class="line"> <span class="string">&quot;worldType&quot;</span>: <span class="string">&quot;moon&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>stableEndpoints</code>
一栏处填写服务器的公网IP以及端口号（一定要在云服务器中放通端口，具体百度即可，关键词：<strong>服务器安全组</strong>）</p>
<p>数据格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;xxx.xxx.xxx.xxx/xxxx&quot;</span><br></pre></td></tr></table></figure>

<p>完整示例如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;id&quot;</span>: <span class="string">&quot;5f1932174d&quot;</span>,</span><br><span class="line"> <span class="string">&quot;objtype&quot;</span>: <span class="string">&quot;world&quot;</span>,</span><br><span class="line"> <span class="string">&quot;roots&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;identity&quot;</span>: <span class="string">&quot;5f1932174d:0:cf7728b3e66e4f207e537bfdee885c736d3430806c6cb279ce345103cef2302f42891547b73425793d0ea5cd7f18fd4c4a3aabf75193a23a609641d472ca01c6&quot;</span>,</span><br><span class="line">   <span class="string">&quot;stableEndpoints&quot;</span>: [<span class="string">&quot;49.235.186.44/9993&quot;</span>]    &lt;-- 修改此处</span><br><span class="line">  &#125;</span><br><span class="line"> ],</span><br><span class="line"> <span class="string">&quot;signingKey&quot;</span>: <span class="string">&quot;03f731a23d88171014e862dc222745b02f263eb58f72637a12a00a60175cd41dac20b91be0dc69ac233da8d8f119a3d4397228f89036d651d179469e373a8285&quot;</span>,</span><br><span class="line"> <span class="string">&quot;signingKey_SECRET&quot;</span>: <span class="string">&quot;76e23ef7ba06eeec08c85592bff86415143fd27c89efd0009a64ae0be864a9ba5ba592a8262cfe55210371499849a6c725eecaaf17e88d9ee2293a9eceb50dad&quot;</span>,</span><br><span class="line"> <span class="string">&quot;updatesMustBeSignedBy&quot;</span>: <span class="string">&quot;03f731a23d88171014e862dc222745b02f263eb58f72637a12a00a60175cd41dac20b91be0dc69ac233da8d8f119a3d4397228f89036d651d179469e373a8285&quot;</span>,</span><br><span class="line"> <span class="string">&quot;worldType&quot;</span>: <span class="string">&quot;moon&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后保存，使用下列命令生成 moon 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-idtool genmoon moon.json </span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-17-ubuntu:/var/lib/zerotier-one<span class="comment"># zerotier-idtool genmoon moon.json </span></span><br><span class="line">wrote 0000005f1932174d.moon (signed world with timestamp 1617851943432)</span><br></pre></td></tr></table></figure>

<p>然后将该文件拷贝到 <code>moons.d</code> 文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p moons.d &amp;&amp; <span class="built_in">mv</span> moon moons.d/</span><br></pre></td></tr></table></figure>

<p>最后重启一下服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service zerotier-one restart</span><br></pre></td></tr></table></figure>

<h3 id="客户端配置">客户端配置</h3>
<p>在客户端上直接使用 <code>orbit</code> 即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-cli orbit 5f1932174d 5f1932174d</span><br></pre></td></tr></table></figure>

<p>然后使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zerotier-cli peers</span><br></pre></td></tr></table></figure>

<p>查看我们是否配置成功（是否有 MOON 节点出现，且能否显示 MOON
节点的公网 IP）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-4-ubuntu:/var/lib/zerotier-one<span class="comment"># zerotier-cli orbit 5f1932174d 5f1932174d</span></span><br><span class="line">200 orbit OK</span><br><span class="line">root@VM-0-4-ubuntu:/var/lib/zerotier-one<span class="comment"># zerotier-cli peers</span></span><br><span class="line">200 peers</span><br><span class="line">&lt;ztaddr&gt;   &lt;ver&gt;  &lt;role&gt; &lt;lat&gt; &lt;<span class="built_in">link</span>&gt; &lt;lastTX&gt; &lt;lastRX&gt; &lt;path&gt;</span><br><span class="line">3a46f1bf30 -      PLANET   135 DIRECT 2209     2073     185.180.13.82/9993</span><br><span class="line">5f1932174d 1.6.4  MOON       4 DIRECT 159      155      49.235.186.44/38167</span><br><span class="line">62f865ae71 -      PLANET   206 DIRECT 2209     2007     50.7.252.138/9993</span><br><span class="line">778cde7190 -      PLANET   213 DIRECT 2209     1995     103.195.103.66/9993</span><br><span class="line">992fcf1db7 -      PLANET   225 DIRECT 2209     1968     195.181.173.159/9993</span><br><span class="line">c3a0da579a 1.6.4  LEAF      42 DIRECT 2560     2516     222.178.10.188/48425</span><br><span class="line">e5cd7a9e1c 1.6.4  LEAF     329 DIRECT 2209     10660    35.236.84.174/32150</span><br><span class="line">fa2671ab8a 1.6.4  LEAF      41 DIRECT 2943     2902     222.178.10.188/63370</span><br></pre></td></tr></table></figure>

<p>可以看到peers中第二个的role已经变成了MOON，此时再来ping，可以发现网络延时降低很多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-0-17-ubuntu:/var/lib/zerotier-one<span class="comment"># ping 172.27.126.84</span></span><br><span class="line">PING 172.27.126.84 (172.27.126.84) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.27.126.84: icmp_seq=1 ttl=64 time=16.8 ms</span><br><span class="line">64 bytes from 172.27.126.84: icmp_seq=2 ttl=64 time=4.37 ms</span><br><span class="line">64 bytes from 172.27.126.84: icmp_seq=3 ttl=64 time=4.49 ms</span><br><span class="line">64 bytes from 172.27.126.84: icmp_seq=4 ttl=64 time=4.53 ms</span><br><span class="line">64 bytes from 172.27.126.84: icmp_seq=5 ttl=64 time=4.55 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.27.126.84 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4009ms</span><br><span class="line">rtt min/avg/max/mdev = 4.368/6.955/16.842/4.943 ms</span><br></pre></td></tr></table></figure>

<p>原本 ping 是 300+ ms 的时延，配置了 moon 节点后直接 10ms 以内</p>
<p><strong>注：两个 MOON 节点不要互相 orbit</strong></p>
<p>使用 zerotier-one
的主要目的就是在宿舍远程控制实验室的服务器（虽然有很多现成的远程控制软件，但是大多都是远程图形界面的，写起来还是卡卡的，这种搞法既支持远程控制，也支持
ssh 直连）</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>nohup命令使用</title>
    <url>/posts/80b6/</url>
    <content><![CDATA[<p>最近需要在服务器上跑模型，需要长时间运行，但是服务器是通过 ssh
连接的，如果我们中途断开连接，正在跑的代码也会自动关闭。实在是有点整蛊，要想
ssh 断开连接后代码还可以继续执行，需要使用 <code>nohup</code> 命令。</p>
<p>使用 <code>nohup --help</code>，我们可以得到帮助信息</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(base) ➜  ~ nohup --help</span><br><span class="line">Usage: nohup COMMAND [ARG]...</span><br><span class="line">  or:  nohup OPTION</span><br><span class="line">Run COMMAND, ignoring hangup signals.</span><br><span class="line"></span><br><span class="line">      --help     display this help and exit</span><br><span class="line">      --version  output version information and exit</span><br><span class="line"></span><br><span class="line">If standard input is a terminal, redirect it from an unreadable file.</span><br><span class="line">If standard output is a terminal, append output to &#x27;nohup.out&#x27; if possible,</span><br><span class="line">&#x27;$HOME/nohup.out&#x27; otherwise.</span><br><span class="line">If standard error is a terminal, redirect it to standard output.</span><br><span class="line">To save output to FILE, use &#x27;nohup COMMAND &gt; FILE&#x27;.</span><br><span class="line"></span><br><span class="line">NOTE: your shell may have its own version of nohup, which usually supersedes</span><br><span class="line">the version described here.  Please refer to your shell&#x27;s documentation</span><br><span class="line">for details about the options it supports.</span><br><span class="line"></span><br><span class="line">GNU coreutils online help: &lt;https://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">Report nohup translation bugs to &lt;https://translationproject.org/team/&gt;</span><br><span class="line">Full documentation at: &lt;https://www.gnu.org/software/coreutils/nohup&gt;</span><br><span class="line">or available locally via: info &#x27;(coreutils) nohup invocation&#x27;</span><br></pre></td></tr></table></figure>

<p>其中第三行解释了 nohup 命令的作用</p>
<blockquote>
<p><em>Run COMMAND, ignoring hangup signals.</em></p>
</blockquote>
<p>从描述中我们可以看到，其作用其实很简单，就是忽略 <code>hup</code>
信号。那么现在问题来了，<code>hup</code> 信号是什么？有什么作用？</p>
<span id="more"></span>

<h2 id="signal">SIGNAL</h2>
<p>信号可以理解成一种操作系统和进程之间的交互方式（IPC），当用户进程接收到信号时，其需要对信号进行响应，例如停止运行等（因此也可以理解为软件中断）</p>
<p>通过 <code>kill -l</code>
命令，我们可以查询到当前系统支持的所有信号（前 15
个信号为固定语义信号，后面的和具体实现有关，不同的 linux
之间不一致。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">(base) ➜  test-nohup kill -l</span><br><span class="line">HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS</span><br></pre></td></tr></table></figure>

<blockquote>
<p>具体信号含义以及对应的数字值可以参考：</p>
<p><a
href="https://www.man7.org/linux/man-pages/man7/signal.7.html">signal(7)
- Linux manual page (man7.org)</a> 中 Standard signals 部分</p>
</blockquote>
<p>也可以使用 <code>kill</code> 命令向进程发送信号，例如
<code>kill -9 &lt;PID&gt; </code> 就表示强制杀死进程号为
<code>PID</code> 的进程</p>
<p>下面展示几个比较常用的信号</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">signal name</th>
<th style="text-align: center;">signal number</th>
<th style="text-align: left;">description</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">SIGHUP</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;">Hangup detected on controlling terminal or
death of controlling process</td>
<td>检测到控制程序或命令行挂起</td>
</tr>
<tr class="even">
<td style="text-align: left;">SIGINT</td>
<td style="text-align: center;">2</td>
<td style="text-align: left;">Interrupt from keyboard</td>
<td>键盘中断（<kbd>Ctrl</kbd> + <kbd>C</kbd>）</td>
</tr>
<tr class="odd">
<td style="text-align: left;">SIGKILL</td>
<td style="text-align: center;">9</td>
<td style="text-align: left;">Kill signal</td>
<td>杀死信号</td>
</tr>
<tr class="even">
<td style="text-align: left;">SIGSEGV</td>
<td style="text-align: center;">11</td>
<td style="text-align: left;">Invalid memory reference</td>
<td>无效的内存引用（访问）</td>
</tr>
</tbody>
</table>
<p>在 python 中，我们可以使用 <code>signal</code>
库来响应信号（也可以用来忽略信号，但是跨平台就难做了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stderr&#x27;</span>,file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_signal</span>(<span class="params">signum:<span class="built_in">int</span>,frame</span>):</span><br><span class="line">    _signal = signal.Signals(signum)</span><br><span class="line">    e = OSError()</span><br><span class="line">    e.errno = <span class="number">0</span></span><br><span class="line">    e.strerror = <span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] received signal: <span class="subst">&#123;_signal.name&#125;</span>(<span class="subst">&#123;_signal.value&#125;</span>)&#x27;</span></span><br><span class="line">    <span class="keyword">raise</span> e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGINT,on_signal)</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p>通过 <code>python main.py</code> 运行后，再通过键盘输入
<kbd>Ctrl</kbd> +
<kbd>C</kbd>，就可以看到响应输出，同时程序也结束了（手动抛出了一个异常）</p>
<p><img data-src="/posts/80b6/image-20230312232908661.png"
style="zoom: 67%;" /></p>
<p>对于 SIGHUP
信号，我们也可以同样进行测试，<strong>通过终端运行代码，然后关闭终端</strong>，就可以在输出中看到结果。稍微修改一下代码，将
stdout 和 stderr 重定向到文件中便于查看</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stderr&#x27;</span>,file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_signal</span>(<span class="params">signum:<span class="built_in">int</span>,frame</span>):</span><br><span class="line">    _signal = signal.Signals(signum)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] received signal: <span class="subst">&#123;_signal.name&#125;</span>(<span class="subst">&#123;_signal.value&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGHUP,on_signal)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.log&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        sys.stdout = f</span><br><span class="line">        sys.stderr = f</span><br><span class="line">        asyncio.run(main())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<p><img data-src="/posts/80b6/image-20230312233524825.png"
style="zoom:50%;" /></p>
<p>我们的代码只是接受信号并输出一句话，并没有看到预期的
exit，说明程序被操作系统关闭了，如果需要命令在终端关闭后还能继续执行，就需要通过
<code>nohup</code> 命令来确保进程能在后台继续执行。</p>
<h2 id="nohup-简单使用">nohup 简单使用</h2>
<p><code>nohuo</code> 命令使用起来很简单，在待执行的命令之前添加一个
<code>nohup</code> 即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> &lt;your-command&gt;</span><br></pre></td></tr></table></figure>

<p>示例如下，还是之前的 python 代码，但是我们通过 <code>nohup</code>
来执行，然后关闭终端，测试运行效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> python main.py</span><br></pre></td></tr></table></figure>

<p>运行后终端会提示一句话</p>
<p><img data-src="/posts/80b6/image-20230312235648581.png"
style="zoom:67%;" /></p>
<p>同时我们会在当前目录下看到 <code>nohup.out</code>
文件，虽然里面没有任何东西（因为我们将 python 的输出重定向到了
<code>output.log</code>）</p>
<p><img data-src="/posts/80b6/image-20230312235934838.png"
style="zoom:50%;" /></p>
<p>我们可以看到程序是执行完循环后主动退出的，而不是由操作系统关闭，说明
<code>nohup</code> 命令起作用了。</p>
<p>为了更清楚的看到 <code>nohup</code> 的作用，我们将 python
代码中的输出重定向去掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stderr&#x27;</span>,file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_signal</span>(<span class="params">signum:<span class="built_in">int</span>,frame</span>):</span><br><span class="line">    _signal = signal.Signals(signum)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] received signal: <span class="subst">&#123;_signal.name&#125;</span>(<span class="subst">&#123;_signal.value&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGHUP,on_signal)</span><br><span class="line">    <span class="comment"># with open(&#x27;output.log&#x27;,&#x27;w&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#     sys.stdout = f</span></span><br><span class="line">    <span class="comment">#     sys.stderr = f</span></span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>然后再次执行，并关闭命令行</p>
<p>命令行输出如下</p>
<p><img data-src="/posts/80b6/image-20230313000446837.png"
style="zoom: 67%;" /></p>
<p>但是程序本身的输出并没有出现在这里，查看
<code>nohup.out</code>，我们可以在 <code>nohup.out</code>
中看到完整的输出结果</p>
<p><img data-src="/posts/80b6/image-20230313225021012.png"
style="zoom:50%;" /></p>
<p>可以看到程序最后输出了
<code>exit</code>，表示程序正常退出，但我们同样接受到了
<code>SIGHUP</code> 信号，此时却没有被系统杀死，这就是
<code>nohup</code> 在起作用了。</p>
<h2 id="后台运行程序">后台运行程序</h2>
<p>当我们通过 <code>nohup</code>
执行应用程序时，当前终端并不能进行交互，但是我们也看不到进程的任何输出（因为
<code>nohup</code> 将其重定向到 <code>nohup.out</code>
里了），与其让终端等待进程执行完，不如将进程放在后台执行，然后使用终端进行其他操作。</p>
<p>后台执行程序也十分简单，只需要在命令后添加一个 <code>&amp;</code>
即可，然后在终端中就会输出后台执行命令的 <code>PID</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stderr&#x27;</span>,file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_signal</span>(<span class="params">signum:<span class="built_in">int</span>,frame</span>):</span><br><span class="line">    _signal = signal.Signals(signum)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] received signal: <span class="subst">&#123;_signal.name&#125;</span>(<span class="subst">&#123;_signal.value&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGHUP,on_signal)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.log&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        sys.stdout = f</span><br><span class="line">        sys.stderr = f</span><br><span class="line">        asyncio.run(main())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/80b6/image-20230313225834031.png"
style="zoom:67%;" /></p>
<p>此时终端就可以不等待进程执行完，立即返回了，<strong>但是如果进程有输出的话，还是会继续输出到命令行中，让我们无法进行交互，因此后台执行的进程最好将输出都给重定向一下</strong></p>
<p>我们也可以对其进行测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] write <span class="subst">&#123;i:03d&#125;</span> to stderr&#x27;</span>,file=sys.stderr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_signal</span>(<span class="params">signum:<span class="built_in">int</span>,frame</span>):</span><br><span class="line">    _signal = signal.Signals(signum)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;[<span class="subst">&#123;datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>)&#125;</span>] received signal: <span class="subst">&#123;_signal.name&#125;</span>(<span class="subst">&#123;_signal.value&#125;</span>)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    signal.signal(signal.SIGHUP,on_signal)</span><br><span class="line">    <span class="comment"># with open(&#x27;output.log&#x27;,&#x27;w&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#     sys.stdout = f</span></span><br><span class="line">    <span class="comment">#     sys.stderr = f</span></span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;exit&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/80b6/image-20230313230232701.png"
style="zoom:67%;" /></p>
<p>此时我们按什么都没用，因为我们无法直接和进程交互，可以通过
<code>kill</code> 方式向进程发送信号，然后停止进程（由于 stdout
一直有输出，命令行交互的体验极差，让人想直接把他 kill 掉）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -HUP 1688</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/80b6/image-20230313230446035.png"
style="zoom:67%;" /></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 1850</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/80b6/image-20230313230618924.png"
style="zoom:67%;" /></p>
<p>此时我们可以发现，<code>nohup</code>
命令和后台运行简直是绝配，既可以将输出重定向到文件，且可以保证终端关闭后代码也能继续执行，完整代码就是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> &lt;your-command&gt; &amp;</span><br></pre></td></tr></table></figure>

<h2 id="输出重定向pipe操作">输出重定向（pipe操作）</h2>
<p><code>nohup</code>
命令自动帮我们配置好了输出重定向，有时候我们也想将输出保存到文件，从而便于我们观察输出结果（尤其是
gcc 编译结果，一报错出特别多，stdout
溢出了也看不到结果），此时我们就需要手动进行输入输出的重定向了。</p>
<p>在代码中，有三个特殊的文件，分别是
<code>stdin</code>、<code>stdout</code> 以及 <code>stderr</code>，在
python 中可以使用 <code>sys.stdin</code> 以及 <code>sys.stdout</code> 和
<code>sys.stderr</code> (之前的代码中也有使用，我们分别向 stderr 和
stdout 中输出了结果)</p>
<p>由于这三个是特殊的文件，自然也可以使用其他文件来代替，此时就是重定向了，而在
unix 环境下（其实 powershell
目前也支持了）可以在操作系统层面进行重定向，这样我们就不需要修改代码了。</p>
<p>下面列举了常用的重定向操作符</p>
<table>
<thead>
<tr class="header">
<th>operator</th>
<th>name</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[a]&gt;[b]</code></td>
<td>output to</td>
<td>将 a 的内容输出到 b 中</td>
</tr>
<tr class="even">
<td><code>[a]&gt;&gt;[b]</code></td>
<td>append to</td>
<td>将 a 的内容追加到 b 中</td>
</tr>
<tr class="odd">
<td><code>[a]&lt;[b]</code></td>
<td>read from</td>
<td>将 b 的内容读取到 a 中</td>
</tr>
<tr class="even">
<td>`[a]</td>
<td>[b]`</td>
<td>pipeing</td>
</tr>
</tbody>
</table>
<p>实例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello to stdout&#x27;</span>,file=sys.stdout)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello to stderr&#x27;</span>,file=sys.stderr)</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py &gt; stdout.log</span><br></pre></td></tr></table></figure>

<p>如果不加上任何符号，则默认将 stdout 重定向到 stdout.log 中，但是
stderr 还是会在终端中输出</p>
<p>运行结果</p>
<p><img data-src="/posts/80b6/image-20230313232650321.png"
style="zoom:67%;" /></p>
<p>同时 <code>stdout.log</code> 结果</p>
<p><img data-src="/posts/80b6/image-20230313232709124.png"
style="zoom:67%;" /></p>
<p>和我们的预期结果一样</p>
<p>要想指定输入输出流的文件，我们可以使用数字来代指（可以理解为指针），其中
<code>0</code> 表示 <code>stdin</code>， <code>1</code> 表示
<code>stdout</code>，<code>2</code> 表示 <code>stderr</code></p>
<p>还是上面的代码，但是我们调整一下调用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py 1&gt;stdout.log 2&gt;stderr.log</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： 数字和符号之间没有空格，即
<code>1&gt;</code>，<code>0&lt;</code> 的形式</p>
</blockquote>
<p>运行结果</p>
<p><img data-src="/posts/80b6/image-20230313233059684.png"
style="zoom:67%;" /></p>
<p>两个文件结果</p>
<p><img data-src="/posts/80b6/image-20230313233205333.png" /></p>
<p>最后，我们可以将 stderr 重定向到
stdout，不过写法稍微特殊一点，可以理解为 C
语言的取地址（<code>&amp;1</code> 相当于是拿到 stdout 实际输出地址）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py &gt; stdout.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>这样 stdout 和 stderr 的结果就都会出现在 stdout.log 里面了</p>
<p><img data-src="/posts/80b6/image-20230313233726388.png"
style="zoom: 67%;" /></p>
<p>而对于 <code>|</code> ，一个很常用的例子就是检索（通过
<code>grep</code> 实现），例如我们想查询当前 python 环境中是否安装
<code>numpy</code>，可以使用一下命令进行查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip list | grep numpy</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/80b6/image-20230313233446900.png" /></p>
<p>还有很多高级用法，但是基本使用就介绍到这里</p>
<blockquote>
<p>注：为什么要有两个输出 <code>stdout</code> 和
<code>stderr</code>？</p>
<p>例如 pandoc 程序 ，其可以接受一个 md 文档并将其转换成
html，如果我们只是使用 pandoc
做其中一步操作，还需要后续操作的话，我们就可以使用 stdout
读取其输出结果，而通过 stderr
拿到其日志输出、警告的信息。这也是为什么即使我们优先输出到
stdout，然后再输出到 stderr，最终仍然是 stderr 的结果优先输出，因为
stderr 是<strong>无缓冲的</strong>，有结果就直接输出了。</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>nohup</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile常见环境使用</title>
    <url>/posts/4a2b/</url>
    <content><![CDATA[<h2 id="ubuntu国内镜像">ubuntu(国内镜像)</h2>
<p>由于网内网络环境的问题，ubuntu不换源的话基本没法用，我们首先参考普通
ubuntu 系统如何换源，然后将其转换成命令形式，便于应用于 Dockerfile
中。</p>
<p>随便在网上搜
"ubuntu换源"，可以搜出一大堆教程，这里我们直接参考阿里云开源镜像站的<a
href="https://developer.aliyun.com/mirror/ubuntu">官方教程</a>，官方教程中给出了操作办法，就是手动将所有的源地址替换为阿里云的镜像地址：</p>
<p><img data-src="/posts/4a2b/image-20230626220459741.png"
style="zoom:67%;" /></p>
<p>首先我们使用 docker 跑一个 ubuntu 的镜像看下基本情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> ubuntu:20.04 /bin/bash</span><br></pre></td></tr></table></figure>

<p>注：后面也会出写一个笔记记录常用的 docker 命令。</p>
<p>在 ubuntu 下使用 <code>sudo apt-get install xxx</code> 安装软件，所有
<code>apt</code> 相关的配置项存储在 <code>/etc/apt</code>
文件夹下，其内容如下</p>
<p><img data-src="/posts/4a2b/image-20230626215508213.png"
style="zoom:67%;" /></p>
<span id="more"></span>

<p>其中 <code>sources.list</code> 以及 <code>sources.list.d</code>
就涉及软件源的配置信息，<code>sources.list</code>
用来存储默认的软件源信息（或者说官方源），而 <code>sources.list.d</code>
则用来存储第三方软件源，例如 docker 软件源、nvidia
驱动源等，一般安装软件我们只需要配置 <code>sources.list</code>
即可，第三方源的配置和官方源的配置差不太多。</p>
<p>使用 <code>cat</code> 命令查看 <code>sources.list</code>
文件内容（较长，可能显示不全）</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">root@302e32342092:/etc/apt# cat sources.list</span><br><span class="line"># See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to</span><br><span class="line"># newer versions of the distribution.</span><br><span class="line">deb http://archive.ubuntu.com/ubuntu/ focal main restricted</span><br><span class="line"># deb-src http://archive.ubuntu.com/ubuntu/ focal main restricted</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ focal-security main restricted</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ focal-security main restricted</span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ focal-security universe</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ focal-security universe</span><br><span class="line">deb http://security.ubuntu.com/ubuntu/ focal-security multiverse</span><br><span class="line"># deb-src http://security.ubuntu.com/ubuntu/ focal-security multiverse</span><br></pre></td></tr></table></figure>

<p>我们可以看到其软件源就是通过以下格式指定的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deb &lt;apt source&gt;</span><br></pre></td></tr></table></figure>

<p>从源的URL链接中不难发现，这些链接实际上都是同一个域名底下的，我们换源是可以只更换前面的域名（即最后一个<code>/</code>之前的所有即可）。</p>
<p>既然都是替换了，那么肯定不能使用文本编辑器一个一个替换，最好的办法就是通过
<code>sed</code> 命令进行替换</p>
<h3 id="sed-命令简单介绍"><code>sed</code> 命令简单介绍</h3>
<p>from <a href="https://www.gnu.org/software/sed/">GNU sed - GNU
Project - Free Software Foundation</a></p>
<blockquote>
<p>sed (stream editor) is a non-interactive command-line text
editor.</p>
</blockquote>
<p>其功能十分强大，目前我们只用到了其 <code>s</code> 命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s/regexp/replacement/[flags]</span><br><span class="line">(substitute) Match the regular-expression against the content of the pattern space. </span><br><span class="line">If found, replace matched string with replacement.</span><br></pre></td></tr></table></figure>

<p>例如将文本中所所有的<code>foo</code>替换成<code>bar</code>就可以使用如命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s/foo/bar/g test.txt</span><br></pre></td></tr></table></figure>

<p>测试如下</p>
<p><img data-src="/posts/4a2b/image-20230626225050330.png" /></p>
<p>其中 <code>-i</code> 表示 inplace，即直接在当前文件中替换文本，最后的
<code>g</code> 表示对所有的匹配项进行替换</p>
<p>对于某些特殊字符，我们可以通过随意指定分隔符来避免频繁的转义，其格式如下所示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">s&lt;delimiter&gt;regexp&lt;delimiter&gt;replacement&lt;delimiter&gt;[flags]</span><br></pre></td></tr></table></figure>

<p>例如我们需要替换文本中所有的 <code>a/b/c</code> 为
<code>e/f/g</code>，就可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s@a/f/g@e/f/g@g test.txt</span><br></pre></td></tr></table></figure>

<p>测试如下</p>
<p><img data-src="/posts/4a2b/image-20230626225349769.png" /></p>
<h3 id="替换链接">替换链接</h3>
<p>那么这样我们就可以我们通过文本替换实现换源，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s/archive.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>这条命令将所有的 <code>archive.ubuntu.com</code> 替换为
<code>mirrors.aliyun.com</code>，对于<code>security.ubuntu.com</code>也是一样，虽然我们并不会对容器中的
ubuntu 进行安全更新，但是 <code>security.ubuntu.com</code>
会严重影响软件源的更新速度，因此也需要一同替换掉，最终完整的换源命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s/archive.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">sed -i s/security.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>通过 <code>&amp;&amp;</code> 将两条命令合并成一条执行，最后执行
<code>apt-get update</code> 更新软件源即可</p>
<p><img data-src="/posts/4a2b/image-20230626230105000.png"
style="zoom: 67%;" /></p>
<p>此时可以看到软件源更新速度就很快了。</p>
<blockquote>
<p>注：上面的方法仅适用于 ubuntu x86_64
架构的版本，对于其他版本（arm64、RISC-V等）则需要使用另外的软件源，不过替换方法都是一致的，找到需要替换的链接，然后通过
<code>sed</code> 进行替换即可。</p>
<p>例如在 arm 版的 ubuntu 中，其软件源为
<code>http://ports.ubuntu.com/ubuntu-ports/</code>，其对应的阿里云镜像为
<code>https://mirrors.aliyun.com/ubuntu-ports/</code>，我们同样使用
<code>sed</code> 进行替换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i s/ports.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>(阿里云镜像地址来自： <a
href="https://developer.aliyun.com/mirror/ubuntu-ports">https://developer.aliyun.com/mirror/ubuntu-ports</a>)</p>
</blockquote>
<h2 id="ssh-服务器">ssh 服务器</h2>
<p>启动 docker
容器后，有可能需要连接到容器中修改代码什么的（一般用于深度学习模型训练环境，部署代码的话最好不要这么做），最朴素的办法就是安装一个命令行的文本编辑器，例如
vi，vim，nano 等，命令用熟了还是很轻松的，但是学习成本太高了，后面发现
vscode 的 Remote SSH 插件可以通过 SSH
连接到主机，之后就像本地代码一样进行调试运行等，简直不要太方便（实际上还有更好的办法，直接通过
vscode 的 Dev Containers 插件直接连接到容器中），不过设置 SSH
通用性更高，例如搭建 hadoop 等环境进行测试时就可以使用。</p>
<p><img data-src="/posts/4a2b/image-20230626232514059.png"
style="zoom:50%;" /></p>
<p><img data-src="/posts/4a2b/image-20230626232428553.png"
style="zoom:50%;" /></p>
<p>在配置脚本安装之前，我们首先看看手动如何安装 ssh
服务器（openssh-server），直接通过apt安装即可，运行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install openssh-server</span><br></pre></td></tr></table></figure>

<p>之后提示我们具体需要安装哪些包，以及是否确定安装</p>
<p><img data-src="/posts/4a2b/image-20230626232955966.png"
style="zoom: 67%;" /></p>
<p>但是我们可以看到，建议安装了一堆包，实际上有些包我们可以不装的，可以通过参数
<code>--no-install-recommends</code> 来取消安装这些包，运行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install openssh-server --no-install-recommends</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img data-src="/posts/4a2b/image-20230626233651500.png"
style="zoom: 67%;" /></p>
<p>相比之前我们所需要安装的依赖就少多了</p>
<p>但是还有一个问题，安装过程中有一个
<code>Do you want to continue? [Y/n]</code>
，提示我们是否确定，但是我们需要用命令完成自动化安装过程，安装过程中是完全无交互的，因此需要默认安装，可以通过
<code>-y</code> 来进行默认安装（具体可以参考 apt-get 的 <a
href="https://linux.die.net/man/8/apt-get">man 页面</a>）</p>
<p><img data-src="/posts/4a2b/image-20230626233919076.png"
style="zoom:67%;" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install openssh-server --no-install-recommends -y</span><br></pre></td></tr></table></figure>

<p>这样当我们输入命令后就会自动安装了。</p>
<p>可以编写一个完整的安装 ssh 的 Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i s/archive.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    sed -i s/security.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install --no-install-recommends -y -q \</span></span><br><span class="line"><span class="language-bash">    openssh-server &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;service&quot;</span>,<span class="string">&quot;ssh&quot;</span>,<span class="string">&quot;start&quot;</span>,<span class="string">&quot;-D&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>其暴露一个端口 22（SSH的默认端口），而且使用
<code>service ssh start -D</code>
来确保命令前台运行（保证容器不会被杀死）</p>
<p>我们先尝试能否成功构建镜像，使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t openssh-server:ubuntu20.04 .</span><br></pre></td></tr></table></figure>

<p>进行构建，然后通过以下命令创建容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --<span class="built_in">rm</span> -p 54132:22 openssh-server:ubuntu20.04</span><br></pre></td></tr></table></figure>

<p>其中 <code>-d</code> 表示 detach，将容器列入后台运行，由于我们在
<code>CMD</code>
中已经指定了一个前台应用，容器不会立刻被docker杀死，<code>--rm</code>
表示容器运行结束后会被直接删除（常用于测试场景），<code>-p 54132:22</code>
表示将宿主机的54132端口绑定到容器的22端口（即SSH端口上，这样我们就可以通过
54132端口连接到容器的SSH服务了）。</p>
<p><img data-src="/posts/4a2b/image-20230626235528936.png"
style="zoom:80%;" /></p>
<p>最后我们使用 ssh 连接命令尝试连接到容器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -p 54132 root@localhost</span><br></pre></td></tr></table></figure>

<p>首先会提示我们是否需要建立连接（这一步可以说明SSH端口是通的）</p>
<p><img data-src="/posts/4a2b/image-20230626235851436.png"
style="zoom:80%;" /></p>
<p>但是此时直接提示我们输入密码，但是我们似乎并没有设置过 root
账户的密码，这就意味着我们永远无法连接到容器</p>
<p><img data-src="/posts/4a2b/image-20230627000040652.png"
style="zoom:80%;" /></p>
<p>我们可以通过一下命令连接到容器进行修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it &lt;container-id&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p>然后输入一下命令设置明文密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;root:123&quot; | chpasswd</span><br></pre></td></tr></table></figure>

<p>之后我们再尝试通过 SSH 进行连接，结果如下</p>
<p><img data-src="/posts/4a2b/image-20230627000800488.png"
style="zoom: 67%;" /></p>
<p>提示我们 Permission denied，这是因为 SSH 默认是不允许 root
用户通过密码登录的，我们需要修改 <code>/etc/ssh/sshd_config</code></p>
<p>通过 <code>cat /etc/ssh/sshd_config</code> 可以看到这一点</p>
<p><img data-src="/posts/4a2b/image-20230627085934013.png"
style="zoom:67%;" /></p>
<p>再查看 sshd_config 的相关配置选项（查看其相关的 <a
href="https://man7.org/linux/man-pages/man5/sshd_config.5.html">man
页面</a> 即可，注意查看版本，我们使用的 ubuntu
版本比较新，老的配置文档不一定适用）</p>
<p><img data-src="/posts/4a2b/image-20230627091111102.png"
style="zoom:67%;" /></p>
<p>可以看到 <code>PermitRootLogin</code>
的可选参数有四个：<code>yes</code>，<code>prohibit-password</code>，<code>forced-commands-only</code>，<code>no</code></p>
<blockquote>
<p>注：其中 <code>yes</code>，<code>prohibit-password</code>以及
<code>no</code> 的含义比较直观，但是 <code>forced-commands-only</code>
还不太理解，其限定 <code>root</code>
用户通过秘钥进行登录，但是只能执行特定的 <code>command</code> ，这个
<code>command</code> 实际上需要在 ssh 登录的时候指定，即
<code>authorized_keys</code> 中指定，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">command=”/bin/ps” ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAt0BETg9J6hZb5Kqxy+yfNtKHfwxUELz7PqGtGiM5eNb8DHC8kj02SCFoql5rpaecMGybWRiSK8/k+EsK7TMgd4O+p6WkNyLD3WZrmVzUEPaxAdYf1eeCQooTJ+B1TKXDNlF9t8xTVsHd67HmPWYU6i3+kaDSX7cbrz2ds2zUGSozj1UQ8AJDJMbGOqpjs3nVh2EpSDgY7znqmUDnygVPiM4c3OfEzs5iCxVd4ggpPhH8d0bwy8RmPsooxJYUY4rE1C5iWCvB7P810yUFB0OilxiX9AfZa9shC3n5bqaX0ioY1eC44hFFPL602fJyKMj6w/zxN5aIeFO03Sl9+FU4YQ== root@iZ23wan41azZ</span><br></pre></td></tr></table></figure>

<p>就限定通过 <code>root</code> 私钥登录的时候只能执行
<code>/bin/ps</code>，无法执行其他命令，在运维场景下较为实用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PermitRootLogin yes&quot;</span> &gt;&gt; /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/4a2b/image-20230627091955121.png"
style="zoom:67%;" /></p>
<p>然后重启一下 ssh 服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>

<p>（此处重启时由于没有前台应用，容器会被 docker
给杀死，再重启一下容器即可）</p>
<p>再尝试登录的时候就可以成功了，提示我们输入密码</p>
<p><img data-src="/posts/4a2b/image-20230627093607706.png"
style="zoom:67%;" /></p>
<p>每次登录都输入密码还是有点麻烦（可以通过 <code>sshd_config</code>
设置密码可为空来绕过，但是还会提示用户进行交互，无法实现自动化远程登录），为此我们需要配置远程登录，首先通过
<code>ssh-keygen</code> 创建一对秘钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f ~/key -N <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/4a2b/image-20230627094530454.png"
style="zoom:67%;" /></p>
<p>其中 <code>-t rsa</code> 指定加密算法为 rsa，<code>-N ""</code>
表示私钥密码为空 ，输出私钥路径为 <code>~/key</code>
，公钥路径会在私钥后添加 <code>.pub</code>，即 <code>~/key.pub</code>
，此处创建的秘钥是可以复用的，不过不推荐这么做，安全性较低。</p>
<p>然后将公钥信息拷贝到 <code>~/.ssh/authorized_keys</code> 里即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/.ssh</span><br><span class="line"><span class="built_in">cat</span> ~/key.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>然后再重启一下 ssh，最终使用私钥登录测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 54132 -i key root@localhost</span><br></pre></td></tr></table></figure>

<p>测试结果如下</p>
<p><img data-src="/posts/4a2b/image-20230627100723208.png"
style="zoom:67%;" /></p>
<p>提示我们权限不对，需要调整 key
的权限，按照下面的方式调整权限即可（适用于Windows，对于 macos 直接使用
<code>chmod</code> 命令修改权限即可）</p>
<p><img data-src="/posts/4a2b/modify-windows-privilege.png" /></p>
<p>再尝试登录的时候就可以登陆了</p>
<p><img data-src="/posts/4a2b/image-20230627101433963.png"
style="zoom:67%;" /></p>
<p>最后给出完整的 Dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 ubuntu 软件源</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i s/archive.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    sed -i s/security.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install --no-install-recommends -y \</span></span><br><span class="line"><span class="language-bash">    openssh-server &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝公钥和私钥，便于后续使用</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> public-key.pem /root/public-key.pem</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> private-key.pem /root/private-key.pem</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将公钥拷贝到 authorized_keys 中，其中设置权限是必须的</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> /root/.ssh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">touch</span> /root/.ssh/authorized_keys &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 700 /root/.ssh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 600 /root/.ssh/authorized_keys &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">cat</span> /root/public-key.pem &gt;&gt; /root/.ssh/authorized_keys</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 ssh 前台运行</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;service&quot;</span>,<span class="string">&quot;ssh&quot;</span>,<span class="string">&quot;start&quot;</span>,<span class="string">&quot;-D&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<h2 id="minicondapython">miniconda(python)</h2>
<p>跑深度学习时经常需要配环境，需要安装 cuda 驱动、pytorch
等必要的软件库，虽然使用 anaconda 已经可以很好的管理 python 环境，使用
docker 来运行可以确保代码的可移植性，便于在另外一台机器上跑代码。</p>
<p>anaconda 官方起始有 docker 镜像，但是只有 debian 和
alpine，且通常我们会在 nvidia 的 cuda
容器中进行安装，可以参考官方的安装脚本进行配置，仓库地址：<a
href="https://github.com/ContinuumIO/docker-images/blob/master/miniconda3/debian/Dockerfile">docker-images/miniconda3/debian/Dockerfile
at master · ContinuumIO/docker-images · GitHub</a></p>
<p>代码如下</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:bullseye-slim</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;Anaconda, Inc&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> LANG=C.UTF-<span class="number">8</span> LC_ALL=C.UTF-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hadolint ignore=DL3008</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update -q &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -q -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">        bzip2 \</span></span><br><span class="line"><span class="language-bash">        ca-certificates \</span></span><br><span class="line"><span class="language-bash">        git \</span></span><br><span class="line"><span class="language-bash">        libglib2.0-0 \</span></span><br><span class="line"><span class="language-bash">        libsm6 \</span></span><br><span class="line"><span class="language-bash">        libxext6 \</span></span><br><span class="line"><span class="language-bash">        libxrender1 \</span></span><br><span class="line"><span class="language-bash">        mercurial \</span></span><br><span class="line"><span class="language-bash">        openssh-client \</span></span><br><span class="line"><span class="language-bash">        procps \</span></span><br><span class="line"><span class="language-bash">        subversion \</span></span><br><span class="line"><span class="language-bash">        wget \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get clean \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH /opt/conda/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;/bin/bash&quot;</span> ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Leave these args here to better use the Docker build cache</span></span><br><span class="line"><span class="keyword">ARG</span> CONDA_VERSION=py310_23.<span class="number">3.1</span>-<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    UNAME_M=<span class="string">&quot;<span class="subst">$(uname -m)</span>&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;x86_64&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-x86_64.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;aef279d6baea7f67940f16aad17ebe5f6aac97487c7c03466ff01f4819e5a651&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;s390x&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-s390x.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;ed4f51afc967e921ff5721151f567a4c43c4288ac93ec2393c6238b8c4891de8&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;aarch64&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-aarch64.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;6950c7b1f4f65ce9b87ee1a2d684837771ae7b2e6044e0da9e915d1dee6c924c&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;ppc64le&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-ppc64le.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;b3de538cd542bc4f5a2f2d2a79386288d6e04f0e1459755f3cefe64763e51d16&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">fi</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    wget <span class="string">&quot;<span class="variable">$&#123;MINICONDA_URL&#125;</span>&quot;</span> -O miniconda.sh -q &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;SHA256SUM&#125;</span> miniconda.sh&quot;</span> &gt; shasum &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;CONDA_VERSION&#125;</span>&quot;</span> != <span class="string">&quot;latest&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">sha256sum</span> --check --status shasum; <span class="keyword">fi</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p /opt &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    bash miniconda.sh -b -p /opt/conda &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> miniconda.sh shasum &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">ln</span> -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;. /opt/conda/etc/profile.d/conda.sh&quot;</span> &gt;&gt; ~/.bashrc &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;conda activate base&quot;</span> &gt;&gt; ~/.bashrc &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    find /opt/conda/ -follow -<span class="built_in">type</span> f -name <span class="string">&#x27;*.a&#x27;</span> -delete &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    find /opt/conda/ -follow -<span class="built_in">type</span> f -name <span class="string">&#x27;*.js.map&#x27;</span> -delete &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    /opt/conda/bin/conda clean -afy</span></span><br></pre></td></tr></table></figure>

<p>理解起来很简单，第一步安装 miniconda
的依赖（有些依赖我们并不需要，可根据自己需要调整），第二步根据系统版本选择对应的
miniconda 安装脚本进行安装，将其添加到 <code>/etc/profile.d</code> 和
<code>~/.bashrc</code>中（确保 miniconda
的初始化脚本在用户登录或用户交互前自动执行），最后清理掉无用的数据即可</p>
<h3 id="miniconda-换源">miniconda 换源</h3>
<p>国内 miniconda 也很慢，同样可以对其进行换源，这里参考清华源的<a
href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">换源教程</a>，直接在用户目录下创建
`.condarc`，然后填写如下信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">default_channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span></span><br><span class="line"><span class="attr">custom_channels:</span></span><br><span class="line">  <span class="attr">conda-forge:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">msys2:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">bioconda:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">menpo:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch-lts:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">simpleitk:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">deepmodeling:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/</span></span><br></pre></td></tr></table></figure>

<p>这一部分最好直接通过 <code>COPY</code>
命令的方式，将本地文件拷贝至容器中进行替换</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> .condarc /root/.condarc</span></span><br></pre></td></tr></table></figure>

<h3 id="创建新环境并安装包">创建新环境并安装包</h3>
<p>配置好 miniconda 后我们就可以安装指定版本的 python
并配置我们需要的依赖包了，现在的问题在于，创建新环境后需要激活环境，然后再进行安装，那么如何在
dockerfile 中激活环境呢？可以通过 <code>Dockerfile</code> 中的
<code>SHELL</code> 命令指定所需要使用的 shell。</p>
<p>首先给出完整的 Dockerfile，然后再进行解析</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> continuumio/miniconda3:<span class="number">23.3</span>.<span class="number">1</span>-<span class="number">0</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> .condarc /root/.condarc</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [ <span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;--login&quot;</span>,<span class="string">&quot;-c&quot;</span> ]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> conda create -n <span class="built_in">test</span> python=3.9 -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    conda activate <span class="built_in">test</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    conda install numpy -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&#x27;conda activate test&#x27;</span> &gt;&gt; ~/.bashrc</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>其中的关键在于下面这条语句：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [ <span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;--login&quot;</span>,<span class="string">&quot;-c&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>这一条语句的含义就是我们后面所执行的所有命令，都会通过 SHELL 指定的
shell 进行调用，例如我们后面有语句
<code>RUN conda activate base</code>，其会就等价于</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash --login -c <span class="string">&quot;conda activate base&quot;</span></span><br></pre></td></tr></table></figure>

<p>关键在于 <code>--login</code> 参数，其强制 Shell
以登录模式调用命令，其关键在于 <code>--login</code> 在启动 shell
时会加载 <code>/etc/profile</code> 以及 <code>/etc/profile.d</code>
中指定的脚本文件，从前面的 Dockerfile 中我们也可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh</span><br></pre></td></tr></table></figure>

<p>这个 <code>conda.sh</code> 就是用来激活环境的脚本，我们可以通过
<code>/bin/bash --noprofile --norc</code> 来测试</p>
<p><img data-src="/posts/4a2b/image-20230702111917783.png"
style="zoom:50%;" /></p>
<p>可以看到当我们加载 <code>/etc/profile</code>
后就可以激活环境了，在非交互模式下也是如此。</p>
<p>下面给出一个完整的 pytorch + cuda 的环境</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nvidia/cuda:<span class="number">11.3</span>.<span class="number">1</span>-cudnn8-runtime-ubuntu20.<span class="number">04</span></span><br><span class="line"><span class="comment"># 环境变量设置，设置 console 的语言、时区以及 nvidia 驱动</span></span><br><span class="line"><span class="keyword">ENV</span> LANG=$&#123;LANG:-C.UTF-<span class="number">8</span>&#125; LC_ALL=$&#123;LC_ALL:-C.UTF-<span class="number">8</span>&#125; TZ=$&#123;TZ:-Asia/Shanghai&#125; \</span><br><span class="line">    NVIDIA_DRIVER_CAPABILITIES=$&#123;NVIDIA_DRIVER_CAPABILITIES:-compute,utility&#125; </span><br><span class="line"><span class="comment"># 安装 ubuntu 依赖    </span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -ex &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    sed -i s@/security.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /etc/apt/sources.list.d &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean -q &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get update -q &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -q -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">        bzip2 \</span></span><br><span class="line"><span class="language-bash">        ca-certificates \</span></span><br><span class="line"><span class="language-bash">        git \</span></span><br><span class="line"><span class="language-bash">        wget \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get clean \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="comment"># 安装 miniconda，这一段直接复制的官方的 dockerfile</span></span><br><span class="line"><span class="keyword">ENV</span> PATH /opt/conda/bin:$PATH</span><br><span class="line"><span class="comment"># Leave these args here to better use the Docker build cache</span></span><br><span class="line"><span class="keyword">ARG</span> CONDA_VERSION=py310_23.<span class="number">3.1</span>-<span class="number">0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    UNAME_M=<span class="string">&quot;<span class="subst">$(uname -m)</span>&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;x86_64&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-x86_64.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;aef279d6baea7f67940f16aad17ebe5f6aac97487c7c03466ff01f4819e5a651&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;s390x&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-s390x.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;ed4f51afc967e921ff5721151f567a4c43c4288ac93ec2393c6238b8c4891de8&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;aarch64&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-aarch64.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;6950c7b1f4f65ce9b87ee1a2d684837771ae7b2e6044e0da9e915d1dee6c924c&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$&#123;UNAME_M&#125;</span>&quot;</span> = <span class="string">&quot;ppc64le&quot;</span> ]; <span class="keyword">then</span> \</span></span><br><span class="line"><span class="language-bash">        MINICONDA_URL=<span class="string">&quot;https://repo.anaconda.com/miniconda/Miniconda3-<span class="variable">$&#123;CONDA_VERSION&#125;</span>-Linux-ppc64le.sh&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">        SHA256SUM=<span class="string">&quot;b3de538cd542bc4f5a2f2d2a79386288d6e04f0e1459755f3cefe64763e51d16&quot;</span>; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">fi</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    wget <span class="string">&quot;<span class="variable">$&#123;MINICONDA_URL&#125;</span>&quot;</span> -O miniconda.sh -q &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;SHA256SUM&#125;</span> miniconda.sh&quot;</span> &gt; shasum &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;CONDA_VERSION&#125;</span>&quot;</span> != <span class="string">&quot;latest&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">sha256sum</span> --check --status shasum; <span class="keyword">fi</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p /opt &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    bash miniconda.sh -b -p /opt/conda &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> miniconda.sh shasum &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">ln</span> -s /opt/conda/etc/profile.d/conda.sh /etc/profile.d/conda.sh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;. /opt/conda/etc/profile.d/conda.sh&quot;</span> &gt;&gt; ~/.bashrc &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;conda activate base&quot;</span> &gt;&gt; ~/.bashrc &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    find /opt/conda/ -follow -<span class="built_in">type</span> f -name <span class="string">&#x27;*.a&#x27;</span> -delete &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    find /opt/conda/ -follow -<span class="built_in">type</span> f -name <span class="string">&#x27;*.js.map&#x27;</span> -delete &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    /opt/conda/bin/conda clean -afy</span></span><br><span class="line"><span class="comment"># 创建指定版本的环境   </span></span><br><span class="line"><span class="keyword">ARG</span> CONDA_ENV_NAME=ml</span><br><span class="line"><span class="keyword">ARG</span> CONDA_ENV_PY_VER=<span class="number">3.9</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./condarc /root/.condarc</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    conda create -n <span class="variable">$&#123;CONDA_ENV_NAME&#125;</span> python=<span class="variable">$&#123;CONDA_ENV_PY_VER&#125;</span> -y &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&quot;conda activate <span class="variable">$&#123;CONDA_ENV_NAME&#125;</span>&quot;</span> &gt;&gt; ~/.bashrc &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    conda clean -afy</span></span><br><span class="line"><span class="comment"># 激活环境，配置清华源并安装库</span></span><br><span class="line"><span class="comment"># 通过 pip 进行安装，如果通过 conda 安装还会手动安装 cudnn、cuda 等包，实际上我们已经有了</span></span><br><span class="line"><span class="comment"># 推荐使用 pip install -r requirements 进行安装</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;--login&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> conda activate <span class="variable">$&#123;CONDA_ENV_NAME&#125;</span> &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    pip install torch==1.12.1+cu113 torchvision==0.13.1+cu113 \</span></span><br><span class="line"><span class="language-bash">                torchaudio==0.12.1 --extra-index-url https://download.pytorch.org/whl/cu113 &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /root/.cache/pip &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    conda clean -afy</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>构建时间可能较长（pytorch 包太大了），启动时注意参数
<code>--shm_size</code> ，尤其是在多线程数据加载中</p>
<h2 id="总结">总结</h2>
<p>个人理解 dockerfile
实际上就是运维脚本的另外一种形式，关键还是在于脚本语言的熟悉程度，linux
命令较为熟悉的话就可以很轻松的构建出合适的镜像。</p>
<p>参考资料</p>
<ol type="1">
<li><a
href="https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b11uhvFDQ">ubuntu镜像_ubuntu下载地址_ubuntu安装教程-阿里巴巴开源镜像站
(aliyun.com)</a></li>
<li><a href="https://linux.die.net/man/8/apt-get">apt-get(8) - Linux man
page (die.net)</a></li>
<li><a
href="https://www.man7.org/linux/man-pages/man5/sshd_config.5.html">sshd_config(5)
- Linux manual page (man7.org)</a></li>
<li><a
href="https://blog.csdn.net/huigher/article/details/52972013">sshd_config
中 PermitRootLogin 的探讨_huigher的博客-CSDN博客</a></li>
<li><a
href="https://blog.csdn.net/u011095110/article/details/81020839">Linux下service
xxx start/stop/restart启动服务、关闭服务、重启服务深入理解@_service
start_King-Long的博客-CSDN博客</a></li>
<li><a
href="https://blog.csdn.net/weixin_40415591/article/details/121661857">windows
ssh Permissions for “xxx“ are too
open错误详细解决方案_菜到不知所措的博客-CSDN博客</a></li>
<li><a
href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">anaconda |
镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source
Mirror</a></li>
<li>LPIC Shell 基础：<a
href="https://learning.lpi.org/en/learning-materials/102-500/105/105.1/105.1_01/">105.1
Lesson 1 (lpi.org)</a></li>
<li><a
href="https://blog.csdn.net/weixin_44966641/article/details/123930747">共享内存简介及docker容器的shm设置与修改_docker
shm_Adenialzz的博客-CSDN博客</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake项目结构模版</title>
    <url>/posts/d235/</url>
    <content><![CDATA[<h1 id="整体结构">整体结构</h1>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .gitmodules</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── LICENSE</span><br><span class="line">├── README.md</span><br><span class="line">├── build</span><br><span class="line">├── cmake</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── ...</span><br><span class="line">├── data</span><br><span class="line">│   ├── .gitkeep</span><br><span class="line">│   └── ...</span><br><span class="line">├── extern</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── ...</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── glad</span><br><span class="line">│   ├── lumos</span><br><span class="line">│   └── stb</span><br><span class="line">└── test</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── test_gl.cpp</span><br><span class="line">    ├── test_imageio.cpp</span><br><span class="line">    ├── test_imgui.cpp</span><br><span class="line">    ├── test_pcg.cpp</span><br><span class="line">    ├── test_random_permutation.cpp</span><br><span class="line">    └── test_viewer.cpp</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>含义：</p>
<ul>
<li><p><code>CMakeLists.txt</code>：组织项目的源代码，不会包含具体的编译细节，仅包含项目的声明、跨平台控制等，示例如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>.<span class="number">0</span>)</span><br><span class="line"><span class="keyword">project</span>(Lumos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># used with command `cmake -DENABLE_TESTING=ON -B build -S .`</span></span><br><span class="line"><span class="comment"># Define an option with default value OFF (disabled)</span></span><br><span class="line"><span class="keyword">option</span>(<span class="keyword">ENABLE_TESTING</span> <span class="string">&quot;Enable testing&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line">cmake_path(<span class="keyword">SET</span> DATA_PATH NORMALIZE <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(cmake)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(extern)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">ENABLE_TESTING</span>)</span><br><span class="line">  <span class="keyword">enable_testing</span>()</span><br><span class="line">  <span class="keyword">add_subdirectory</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>src</code>、<code>test</code>、<code>extern</code>
分别代表源代码、测试代码以及第三方依赖库，每一个都会包含各自的
<code>CMakeLists.txt</code>，用来管理代码，对于 <code>src</code>
中的库代码（自定义的
library），个人推荐将头文件（<code>.h</code>）和源代码文件
（<code>.cpp</code>） 分开放，同时 include
目录时设定好文件夹层级，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── core</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── include</span><br><span class="line">│   │   └── lumos</span><br><span class="line">│   │       └── core</span><br><span class="line">│   └── src</span><br><span class="line">└── gui</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── include</span><br><span class="line">    │   └── lumos</span><br><span class="line">    │       └── gui</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure>

<p>这样做稍微有点繁琐，但是代码的组织逻辑比较清晰</p>
<p>对于 <code>extern</code> 文件夹，其用来添加第三方依赖，推荐使用
<code>git submodule</code> 来管理版本，下载时使用
<code>git clone --recursive &lt;repo-url&gt;</code> 即可。</p></li>
</ul>
<h1 id="依赖管理">依赖管理</h1>
<h2 id="添加-submodule">添加 submodule</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule add &lt;repo-url&gt; &lt;local-submodule-path&gt;</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/ocornut/imgui.git extern/imgui</span><br></pre></td></tr></table></figure>

<h2 id="使用指定-commit">使用指定 commit</h2>
<p>为确保代码稳定性，我们可能需要使用特定版本的代码，例如 imgui
中我们想使用 tag 为 <code>v1.89.7-docking</code>，我们需要进入 submodule
目录手动切换一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> extern/imgui</span><br><span class="line">git checkout v1.89.7-docking</span><br></pre></td></tr></table></figure>

<p>当我们提交后 github 就会默认链接到该 repo 对应的 commit 了</p>
<h2 id="删除-submodule">删除 submodule</h2>
<p>在 git 中删除 submodule
较为繁琐，没有一个直接删除的方法，参考网上的操作大概有以下5个步骤：</p>
<ol type="1">
<li><p>删除子模块目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf extern/imgui</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 <code>.git</code> 的缓存</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached extern/imgui</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 <code>.gitmodules</code> 中对应的子模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[submodule &quot;extern/imgui&quot;]</span><br><span class="line">	path = extern/imgui</span><br><span class="line">	url = https://github.com/ocornut/imgui.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除 <code>.git/config</code> 中相应条目</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">    [core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = <span class="literal">true</span></span><br><span class="line">        bare = <span class="literal">false</span></span><br><span class="line">        logallrefupdates = <span class="literal">true</span></span><br><span class="line">        ignorecase = <span class="literal">true</span></span><br><span class="line">        precomposeunicode = <span class="literal">true</span></span><br><span class="line">    ...</span><br><span class="line">[submodule <span class="string">&quot;extern/imgui&quot;</span>]</span><br><span class="line">	url = https://github.com/ocornut/imgui.git</span><br><span class="line">...</span><br><span class="line">5. 删除 `.git` 中子模块目录</span><br><span class="line"></span><br><span class="line">    ```bash</span><br><span class="line">    <span class="built_in">rm</span> -rf .git/modules/extern/imgui</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="个人偏好命名方式">个人偏好命名方式</h1>
<p>命名方式有很多，选择自己喜欢的就行，关键在于<strong>统一</strong></p>
<p><strong>文件名</strong></p>
<p>小写下划线，例如
<code>image_utils.h</code>，<code>imgae_utils.cpp</code></p>
<p><strong>命名空间</strong></p>
<p>小写（尽量不要添加下划线，使用子命名空间即可），例如
<code>lumos::xxx</code>，<code>lumos::core::xxx</code></p>
<p><strong>类名</strong></p>
<p>首字母大写驼峰命名，对于全部大写的当成单词仅首字母大写，例如
<code>HTML</code> 写成 <code>Html</code>，<code>RGBA</code> 写成
<code>Rgba</code></p>
<p>函数</p>
<p><strong>类函数名</strong></p>
<p>对于 <code>public / protected</code>
方法而言使用首字母大写驼峰命名，例如 <code>Initialize</code>，对于
<code>private</code> 方法使用首字母小写驼峰命名，例如
<code>createContext</code></p>
<p><strong>类变量</strong></p>
<p>全部以 <code>m_</code> 开头，小写下划线，例如
<code>m_handle</code></p>
<p><strong>变量名</strong></p>
<p>小写下划线，例如 <code>image_data</code></p>
<p><strong>常量</strong></p>
<p>全部大写，例如 <code>BUFFER_SIZE</code></p>
<p><strong>cmake文件名</strong></p>
<p>以 <code>-</code> 连接，例如 <code>add-imgui.cmake</code></p>
<p><strong>cmake函数名</strong></p>
<p>小写下划线（类似于 cmake 的函数命名方式），例如
<code>add_imgui</code></p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 易错点整理</title>
    <url>/posts/17bc/</url>
    <content><![CDATA[<h1 id="魔法方法和内置属性">魔法方法和内置属性</h1>
<h2 id="容器类型">容器类型</h2>
<p>根据以下程序，下列选项中，说法正确的是（）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(): </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">pass</span> </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self,pos</span>): </span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">30</span>,<span class="number">10</span>)[pos] </span><br><span class="line">foo = Foo() </span><br></pre></td></tr></table></figure>

<ol type="1">
<li><code>foo</code> 对象表现得像个序列</li>
<li>可以使用 <code>len(foo)</code> 来查看对象 <code>foo</code>
的元素个数</li>
<li>可以使用 <code>for i in foo:print(i)</code> 来遍历 <code>foo</code>
的元素</li>
<li>不能使用 <code>foo[0]</code> 来访问对象 <code>foo</code>
的第一个元素</li>
</ol>
<blockquote>
<p><a
href="https://docs.python.org/3.9/glossary.html#term-sequence">https://docs.python.org/3.9/glossary.html#term-sequence</a></p>
</blockquote>
<p>对于第一个选项，Python文档中定义序列(sequence)必须实现两个方法，<code>__getitem__</code>以及<code>__len__</code>，即支持通过整数的索引以及返回序列的长度，而
<code>Foo</code> 仅实现了整数索引功能，因此不是序列。</p>
<p>对于第二个选项，<code>len(foo)</code> 实际上会调用
<code>__len__</code> 方法来获取序列长度，类没实现该方法故不行</p>
<p>对于第三个选项，<code>for</code> 语句支持两种，一种为通过
<code>__iter__</code> 进行调用，另一种则为
<code>__getitem__</code>，因此<strong>正确</strong></p>
<p>对于第四个选项，由于我们定义了 <code>__getitem__</code>
方法，我们是可以通过 <code>foo[0]</code> 来访问 <code>foo</code>
的第一个元素的</p>
<span id="more"></span>

<h2 id="__slots__"><code>__slots__</code></h2>
<blockquote>
<p><a
href="https://docs.python.org/3.9/reference/datamodel.html?highlight=__slots__#slots">https://docs.python.org/3.9/reference/datamodel.html?highlight=__slots__#slots</a></p>
</blockquote>
<p><code>__slots__</code>
属性用来<strong>显式指定对象所包含的属性</strong>，相比
<code>__dict__</code> 效率更高，但是使用上有很多细节需要注意</p>
<p>只有 <code>__slots__</code>
中指定的属性可以被赋值，其他的会报错，示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;foo&#x27;</span>,<span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">f = Foo()</span><br><span class="line">f.foo = <span class="string">&#x27;foo&#x27;</span>   <span class="comment"># ✓</span></span><br><span class="line">f.bar = <span class="string">&#x27;bar&#x27;</span>   <span class="comment"># ✓</span></span><br><span class="line">f.fooo = <span class="string">&#x27;fooo&#x27;</span> <span class="comment"># ✗</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/17bc/image-20230729210618254.png"
style="zoom:50%;" /></p>
<p>如果子类继承父类情况：</p>
<ul>
<li>子类中没有定义 <code>__slots__</code> ，则子类不会继承父类的
<code>__slots__</code>，但是变量会继承，<code>__slots__</code>无法起到限定作用</li>
<li>子类中定义了 <code>__slots__</code>，则子类的 <code>__slots__</code>
结果为与父类 <code>__slots__</code> 并集</li>
</ul>
<p>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    __slots__ = [<span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Foo test&#x27;</span>)</span><br><span class="line">    foo = Foo()</span><br><span class="line">    foo.foo = <span class="number">1</span></span><br><span class="line">    foo.bar = <span class="number">2</span> <span class="comment"># ✗</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    traceback.print_exc()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Bar test&#x27;</span>)</span><br><span class="line">    foo = Bar()</span><br><span class="line">    foo.foo = <span class="number">1</span> </span><br><span class="line">    foo.bar = <span class="number">2</span> <span class="comment"># 没有验证限制，可以正确执行</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    traceback.print_exc()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;FooBar test&#x27;</span>)</span><br><span class="line">    foo = FooBar()</span><br><span class="line">    foo.foo = <span class="number">1</span></span><br><span class="line">    foo.bar = <span class="number">2</span></span><br><span class="line">    foo.foobar = <span class="number">3</span> <span class="comment"># ✗</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    traceback.print_exc()</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img data-src="/posts/17bc/image-20230730122529281.png" /></p>
<h2 id="__init__-和-__new__"><code>__init__</code> 和
<code>__new__</code></h2>
<blockquote>
<p><a
href="https://docs.python.org/3.9/reference/datamodel.html?highlight=__new__#basic-customization">https://docs.python.org/3.9/reference/datamodel.html?highlight=__new__#basic-customization</a></p>
</blockquote>
<p>在 Python 中，对象的创建和初始化是两个分开的过程，</p>
<ul>
<li><code>__new__</code>
负责对象的创建，为类的<strong>静态方法</strong>，其返回一个类实例对象</li>
<li><code>__init__</code>
负责对象的初始化，<strong>其不需要返回任何值</strong>，当存在继承时，不会自动调用父类的
<code>__init__</code>，需要手动通过
<code>super()__init__([args...])</code> 进行调用</li>
</ul>
<h1 id="dictfromkeys">dict.fromkeys</h1>
<p>执行以下程序，输出结果为？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">d = <span class="built_in">dict</span>.from_keys(a)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(d))</span><br></pre></td></tr></table></figure>

<p>此处的坑点在于
<code>list(d)</code>，<strong>直接遍历字典等价于遍历其所有的键</strong>，即</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.keys():</span><br><span class="line">    <span class="built_in">print</span>(k)</span><br></pre></td></tr></table></figure>

<h1 id="列表生成式和-">列表生成式和 <code>*</code></h1>
<p>执行以下程序，输出结果为？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">b = [[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]] * <span class="number">2</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span></span><br><span class="line">b[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;4&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a,b) </span><br></pre></td></tr></table></figure>

<p>乍一看两个都可完成列表的重复，但关键在于复制的<strong>深浅</strong>，具体可以参考官方文档对于
<a
href="https://docs.python.org/3.9/tutorial/datastructures.html?highlight=list">list
的介绍</a></p>
<ul>
<li>使用列表生成式（Generator
Statement）创建列表式会创建多个对象，使用时更灵活</li>
<li>使用 <code>*</code>
来重复对象时将<strong>指向同一个内存地址</strong></li>
</ul>
<p>我们可以测试 <code>*</code> 的效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> [[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>]] * <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(v))</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img data-src="/posts/17bc/image-20230729201613453.png"
style="zoom:50%;" /></p>
<p>因此上面的结果就显而易见了</p>
<p><code>a[0][1]</code> 就仅会修改列表第一个元素，而
<code>b[0][0]</code>
由于两个元素实际上指向同一个内存地址，会同步进行修改</p>
<p>最终结果为
<code>[['1', '3'], ['1', '2']] [['4', '2'], ['4', '2']]</code></p>
<h1 id="切片">切片</h1>
<h2 id="元组和列表">元组<code>[:]</code>和列表<code>[:]</code></h2>
<p>这个有点细节了，<strong>由于元组是不可变的（immutable）</strong>，其切片就是其本身，而列表可变，其切片将会复制一个列表</p>
<p><img data-src="/posts/17bc/image-20230729205320321.png"
style="zoom:50%;" /></p>
<p>可以通过<code>id</code>来观察内存地址，其中元组切片内存地址不变，列表切片会复制一个，内存地址发生变化</p>
<h2 id="越界处理">越界处理</h2>
<p>在切片表达式中如果请求越界的话不会报异常，而是返回空列表/元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;a = <span class="subst">&#123;a&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(a[<span class="number">10</span>])</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">import</span> traceback</span><br><span class="line">    traceback.print_exc()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;a[10:] = <span class="subst">&#123;a[<span class="number">10</span>:]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/17bc/image-20230730133221572.png" /></p>
<h1 id="类与继承">类与继承</h1>
<h2 id="private">private</h2>
<blockquote>
<p><a
href="https://docs.python.org/3/tutorial/classes.html#private-variables">https://docs.python.org/3/tutorial/classes.html#private-variables</a></p>
</blockquote>
<p>在 Python 中并不存在 private 和 protected
关键词，但是我们可以通过其他方式进行设置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;called in Foo.__init__&#x27;</span>)</span><br><span class="line">        self.__private_func()</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__private_func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;this is private function of Foo: <span class="subst">&#123;Foo.__private_func.__name__&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">foo.__private_func()</span><br></pre></td></tr></table></figure>

<p>我们定义了一个函数 <code>__private_func</code>，其包含前缀
<code>__</code> ，然后我们分别在 <code>__init__</code>
和外部直接调用该方法，运行结果如下</p>
<p><img data-src="/posts/17bc/image-20230730105137694.png" /></p>
<p>提示我们通过 <code>foo.__private_func()</code>
的方式调用函数报错，没有这个属性，我们可以通过 <code>Foo.__dict__</code>
来查看一个类中定义的所有属性：</p>
<p>结果如下</p>
<p><img data-src="/posts/17bc/image-20230730105440201.png" /></p>
<p>我们可以看到，<code>Foo.__private_func</code> 变成了
<code>_Foo__private_func</code>，在原来的函数面前添加了
<code>_&lt;class-name&gt;</code> 前缀，我们可以测试直接调用效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">foo._Foo__private_func()</span><br></pre></td></tr></table></figure>

<p>可以正常调用，接下来测试一下继承后的函数调用效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.__private_func()</span><br><span class="line">        </span><br><span class="line">bar = Bar()</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/17bc/image-20230730110313051.png" /></p>
<p>从这里我们可以看出，当对象尝试调用一个以 <code>__</code>
开头的自定义函数（非魔法方法？）时，会添加
<code>_&lt;class-name&gt;</code> 前缀，然后再调用，相当于做了一个 name
mangling（名称改写，在 C++ 中重载函数就是这样实现的）</p>
<h2 id="protected">protected</h2>
<p><strong>“君子协定”</strong></p>
<blockquote>
<p><a
href="https://peps.python.org/pep-0008/#descriptive-naming-styles">https://peps.python.org/pep-0008/#descriptive-naming-styles</a></p>
<ul>
<li><code>_single_leading_underscore</code>: weak “internal use”
indicator. E.g. <code>from M import *</code> does not import objects
whose names start with an underscore.</li>
</ul>
</blockquote>
<p>Python 中不存在类似于 Java 和 C++ 中的 protected 机制，其不像 private
那样提供一个名称改写的方式“曲线救国”实现，而直接通过一个口头约定，但是当全量导入时（即
<code>from M import *</code>
时会默认忽略以单下划线起始命名的对象，在函数中定义
<code>_some_function</code>
和不同的函数没有任何区别，用与不用全看个人。</p>
<h2 id="类变量和实例变量">类变量和实例变量</h2>
<p>我们可以直接在类中定义变量（类似于类的静态变量），如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">foo = Foo()</span><br><span class="line">foo.count = foo.count + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(foo.count)</span><br><span class="line"><span class="built_in">print</span>(Foo.count)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img data-src="/posts/17bc/image-20230730113511934.png" /></p>
<p>此处关键在于，<strong>类变量可以作为类实例属性的模板</strong>，当实例尝试对类变量进行修改时就会复制类变量（写时拷贝，Copy
On Write？）</p>
<h1 id="字符串操作">字符串操作</h1>
<h2 id="strip">strip</h2>
<p><em>str.strip([chars])</em>：删除字符串首尾所有在 <code>chars</code>
中的字符，例如 <code>'abbacabb'.strip('ab')</code> 就会删除首尾的
<code>a</code> 和 <code>b</code> 最终就只剩下 <code>c</code>
了，默认使用 <code>' '</code>，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27; abc  &#x27;</span>.strip()</span><br></pre></td></tr></table></figure>

<p>输出结果为 <code>abc</code></p>
<h2 id="split">split</h2>
<p><em>str.split(sep=None, maxsplit=-1)</em>：使用 <code>sep</code>
中指定的字符串分割字符串，<code>maxsplit</code>
用来限制分割字符串的数目</p>
<p>这个函数有点坑的在于首尾出现 <code>sep</code> 时，例如
<code>'&lt;&gt;A&lt;&gt;B&lt;&gt;C&lt;&gt;'.split('&lt;&gt;')</code>，其结果为
<code>['','A','B','C','']</code></p>
<p>不过这么输出也合理，因为 <code>sep</code> 需要用来分割两个字符串</p>
<h2 id="endswith">endswith</h2>
<p><em>str.endswith(suffix[, start[, end]])</em>：判断字符串是否以
<code>suffix</code> 结尾，可以指定 <code>start</code> 和
<code>end</code> 判断字符串的子串（区间为
<code>[start,end)</code>，左闭右开）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.endswith(<span class="string">&#x27;bb&#x27;</span>,<span class="number">1</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果为 <code>True</code></p>
<h1 id="布尔判断">布尔判断</h1>
<p>除了显式的 <code>bool</code>
类型外，以下三种情况应用于条件判断语句时也为 <code>False</code></p>
<blockquote>
<p><a
href="https://docs.python.org/3.9/library/stdtypes.html?highlight=strip#truth-value-testing">https://docs.python.org/3.9/library/stdtypes.html?highlight=strip#truth-value-testing</a></p>
</blockquote>
<ul>
<li><p>值为 <code>None</code></p></li>
<li><p>任意一种数值类型的0：<code>0</code>，<code>0.0</code>，<code>0j</code>（复数），<code>Decimal(0)</code>，<code>Fraction(0,1)</code></p></li>
<li><p>空序列/容器：<code>''</code>（空字符串），<code>()</code>（空元组），<code>[]</code>（空列表），<code>&#123;&#125;</code>（空字典），<code>set()</code>（空集合），<code>range(0)</code>（空范围）</p></li>
</ul>
<p>这个还是值得注意的，下面表达式就是等价的，可以让代码看起来不那么冗余</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> Obj &lt;==&gt; <span class="keyword">if</span> Obj <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> <span class="type">List</span> &lt;==&gt; <span class="keyword">if</span> <span class="built_in">len</span>(<span class="type">List</span>) != <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="运算符优先级">运算符优先级</h1>
<blockquote>
<p><a
href="https://docs.python.org/3/reference/expressions.html?highlight=precedence#operator-precedence">https://docs.python.org/3/reference/expressions.html?highlight=precedence#operator-precedence</a></p>
<p>表格中给出了 Python 中所有的运算符优先级</p>
</blockquote>
<p>比较值得注意的就是位运算的优先级以及逻辑判断的优先级</p>
<ul>
<li><code>not &gt; and &gt; or</code></li>
<li><code>&amp; &gt; ^ &gt; |</code></li>
</ul>
<h1 id="值相等的不可变对象">值相等的不可变对象</h1>
<p>对于字符串和元组而言，由于其是不可变对象（immutable），Python为节约存储空间，会在<strong>特定条件下</strong>两个值相同的对象指向同一个内存地址</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全是不可变对象的元组，指向同一个内存地址</span></span><br><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;aasd&quot;</span>)</span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;aasd&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment"># 包含可变对象的元组</span></span><br><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;aasd&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;aasd&quot;</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment"># 普通小整数</span></span><br><span class="line">a = <span class="number">128</span></span><br><span class="line">b = <span class="number">128</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br><span class="line"><span class="comment"># 超级大整数</span></span><br><span class="line">a = <span class="number">1</span>&lt;&lt;<span class="number">128</span></span><br><span class="line">b = <span class="number">1</span>&lt;&lt;<span class="number">128</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)==<span class="built_in">id</span>(b))</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img data-src="/posts/17bc/image-20230730104541126.png" /></p>
<h1 id="修改元组中的元素">修改元组中的元素</h1>
<blockquote>
<p>有点类似于 JavaScript 中的
const，确保存储的元素存储地址不发生变化，并不保证存储元素不发生变化（也就是不允许重新赋值）</p>
</blockquote>
<p>执行以下程序，下列选项中，说法正确的是（）</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>])      ①   </span><br><span class="line">tup[<span class="number">2</span>]+=[<span class="number">5</span>,<span class="number">6</span>]          ②   </span><br></pre></td></tr></table></figure>

<ul>
<li>执行代码②后，变量tup[2]的id发生改变</li>
<li>①和②均可以执行而不会抛出异常</li>
<li>执行代码②时会抛出异常，最终tup的值为(1,2,[3,4,5,6])</li>
<li>执行代码②时会抛出异常，最终tup的值为(1,2,[3,4])</li>
</ul>
<p>首先我们从图片中可以知道 tup 是一个元组，其禁止对内部元素重新赋值，即
<code>tup[2] = xxx</code></p>
<p>对于 <code>tup[2] += [5,6]</code> 这句话而言，其实际上是下面结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tup[2] = tup[2] + [5,6]</span><br></pre></td></tr></table></figure>

<p>由于 <code>tup[2] + [5.6]</code>
会返回一个新的列表，相当于重新赋值了，就会报错</p>
<p>我们可以手动捕获这个异常查看最终结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    tup[<span class="number">2</span>] += [<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="keyword">import</span> traceback</span><br><span class="line">    traceback.print_exc()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(tup)</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/17bc/image-20230730134751568.png" /></p>
<p>相应的，如果不涉及到元素引用的修改，对元素的修改也是成立的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">tup[<span class="number">2</span>].extend([<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(tup)</span><br></pre></td></tr></table></figure>

<p>此时就可以正确拿到修改后的元组</p>
<p><img data-src="/posts/17bc/image-20230730134808647.png" /></p>
<h1 id="作用域">作用域</h1>
<h2 id="global-和-nonlocal">global 和 nonlocal</h2>
<p>当我们需要<strong>修改全局或者外部作用域的变量</strong>时，就需要使用
<code>global</code> 或 <code>nonlocal</code>
关键字来说明，否则就会报错，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">global_v = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    global_v += <span class="number">10</span></span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="built_in">print</span>(global_v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">global</span> global_v</span><br><span class="line">    global_v += <span class="number">10</span></span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line"><span class="built_in">print</span>(global_v)</span><br></pre></td></tr></table></figure>

<p><img data-src="/posts/17bc/image-20230730093356142.png"
style="zoom:50%;" /></p>
<h2 id="lambda-和函数闭包">lambda 和函数闭包</h2>
<p>可以通过函数闭包的方式实现静态变量（也可以使用<code>hasattr</code>、<code>setattr</code>
和 <code>getattr</code> 来设置），例如实现一个计数器（这个实际上有点像
<code>JavaScript</code> 的写法，函数式编程）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counter</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count_value</span>():</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line">    <span class="keyword">return</span> increment, count_value</span><br></pre></td></tr></table></figure>

<p>在函数内使用外部变量是以<strong>引用方式</strong>读取（C++中的lambda可以指定不同变量捕获方式，比较灵活），因此会在<strong>执行函数才会读取变量的值。</strong></p>
<h1 id="函数默认参数">函数默认参数</h1>
<p>执行下列程序，输出结果为？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a=(<span class="params"></span>),b=[]</span>):</span><br><span class="line">    a += (<span class="number">1</span>,)</span><br><span class="line">    b.append(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> a,b</span><br><span class="line"></span><br><span class="line">fun()</span><br><span class="line"><span class="built_in">print</span>(fun())</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a
href="https://docs.python.org/3/reference/compound_stmts.html#function">https://docs.python.org/3/reference/compound_stmts.html#function</a></p>
<p>参考官方文档：<strong>Default parameter values are evaluated from
left to right when the function definition is executed.</strong> This
means that the expression is evaluated once, when the function is
defined, and that the same “pre-computed” value is used for each call.
<strong>This is especially important to understand when a default
parameter value is a mutable object</strong>, such as a list or a
dictionary: if the function modifies the object (e.g. by appending an
item to a list), the default parameter value is in effect modified. This
is generally not what was intended. A way around this is to use
<code>None</code> as the default, and explicitly test for it in the body
of the function.</p>
<p><strong>函数默认参数将在函数定义时就初始完成，然后在后续的调用中一直使用这个”预计算好的“默认值。</strong></p>
</blockquote>
<p>对于不可变的对象，例如元组和字符串而言，<strong>在函数中的修改并不会修改默认值</strong>，因为他们的值是不可变的（immutable），但是对于列表和字典这样的可变对象而言，<strong>就相当于全局变量一样会一直更新</strong>。</p>
<p>虽然 <code>a</code> 为一个元组，但是 <code>a += (1,)</code> 等价于
<code>a = a + (1,)</code> 相当于我们对 a
重新设置了一个值（其实对b重新赋值的话也不会有影响，但是 append
是直接修改 b 的元素）</p>
<p>因此最终输出为
<code>((1,), [1, 1])</code>（函数多个返回值会合并为一个元组统一输出）</p>
<h1 id="装饰器">装饰器</h1>
<blockquote>
<p><a
href="https://docs.python.org/3/glossary.html#term-decorator">https://docs.python.org/3/glossary.html#term-decorator</a></p>
<p>Decorator expressions are evaluated when the function is defined, in
the scope that contains the function definition.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@f1(<span class="params">arg</span>)</span></span><br><span class="line"><span class="meta">@f2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(): <span class="keyword">pass</span></span><br><span class="line">func = f1(arg)(f2(func))</span><br></pre></td></tr></table></figure>

<p>上面例子可能有点抽象，举个实际一点的例子，计时器以及重复执行（实现带参数的装饰器）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> perf_counter_ns</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="comment"># 统计函数的运行时间</span></span><br><span class="line">        start = perf_counter_ns()</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">        end = perf_counter_ns()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;cost: <span class="subst">&#123;(end-start)/<span class="number">1e6</span>:<span class="number">03.3</span>f&#125;</span> ms&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Repeat</span>(<span class="params">count</span>):</span><br><span class="line">    <span class="comment"># 相比于不带参数版本的装饰器，其还需要一层函数作为中间层</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">            <span class="comment"># 将函数执行 count 次</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">                func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">            </span><br><span class="line"><span class="meta">@Timer</span></span><br><span class="line"><span class="meta">@Repeat(<span class="params">count=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_func1</span>():</span><br><span class="line">    <span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">    sleep(<span class="number">0.25</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_func2</span>():</span><br><span class="line">    <span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">    sleep(<span class="number">0.25</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line">test_func1()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">test_func2 = Timer(Repeat(count=<span class="number">5</span>)(test_func2))</span><br><span class="line">test_func2()</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/17bc/image-20230729215357790.png"
style="zoom:50%;" /></p>
<h1 id="else-语句">else 语句</h1>
<p>这里的 else 语句并不是 <code>if ... else ...</code> 的 else，其为
<code>while ...</code>、<code>try ... except ...</code>
、<code>for ...</code> 语句的 else 语句</p>
<p>示例如下</p>
<p>对于 <code>while</code> 和 <code>for</code>
两个循环而言，<code>else</code> 语句将会在循环顺利执行完后执行（即不碰到
<code>break</code>，<code>return</code>就更不用说了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;for(without break) done&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> j == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;for(with break) done&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    i-=<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;while(without break) done&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">i = <span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    i-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;while(with break) done&#x27;</span>)    </span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img data-src="/posts/17bc/image-20230729221242531.png"
style="zoom:50%;" /></p>
<p>对于 <code>try ... except ...</code> 语句而言，else
语句会在没有任何异常时执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func_with_exception</span>():</span><br><span class="line">    a = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_without_exception</span>():</span><br><span class="line">    a = <span class="number">0</span> / <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    func_with_exception()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">import</span> traceback</span><br><span class="line">    traceback.print_exc()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;execute safely!&#x27;</span>)   </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    func_without_exception()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">import</span> traceback</span><br><span class="line">    traceback.print_exc()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;execute safely!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果（第一个抛出异常，第二没有异常顺利执行）</p>
<p><img data-src="/posts/17bc/image-20230729222813033.png"
style="zoom:50%;" /></p>
<h1 id="finally-作用"><code>finally</code> 作用</h1>
<p><strong>无论什么情况都会执行！</strong></p>
<blockquote>
<p>If a <a
href="https://docs.python.org/3/reference/compound_stmts.html#finally"><code>finally</code></a>
clause is present, the <code>finally</code> clause will execute as the
last task <strong>before</strong> the <a
href="https://docs.python.org/3/reference/compound_stmts.html#try"><code>try</code></a>
statement completes. The <code>finally</code> clause runs whether or not
the <code>try</code> statement produces an exception. The following
points discuss more complex cases when an exception occurs:</p>
<ul>
<li>If an exception occurs during execution of the <code>try</code>
clause, the exception may be handled by an <a
href="https://docs.python.org/3/reference/compound_stmts.html#except"><code>except</code></a>
clause. <strong>If the exception is not handled by an
<code>except</code> clause, the exception is re-raised after the
<code>finally</code> clause has been executed.</strong></li>
<li>An exception could occur during execution of an <code>except</code>
or <code>else</code> clause. <strong>Again, the exception is re-raised
after the <code>finally</code> clause has been executed.</strong></li>
<li>If the <code>finally</code> clause executes a <a
href="https://docs.python.org/3/reference/simple_stmts.html#break"><code>break</code></a>,
<a
href="https://docs.python.org/3/reference/simple_stmts.html#continue"><code>continue</code></a>
or <a
href="https://docs.python.org/3/reference/simple_stmts.html#return"><code>return</code></a>
statement, exceptions are not re-raised.</li>
<li>If the <code>try</code> statement reaches a <a
href="https://docs.python.org/3/reference/simple_stmts.html#break"><code>break</code></a>,
<a
href="https://docs.python.org/3/reference/simple_stmts.html#continue"><code>continue</code></a>
or <a
href="https://docs.python.org/3/reference/simple_stmts.html#return"><code>return</code></a>
statement, <strong>the <code>finally</code> clause will execute just
prior to the <code>break</code>, <code>continue</code> or
<code>return</code> statement’s execution.</strong></li>
<li>If a <code>finally</code> clause includes a <code>return</code>
statement, <strong>the returned value will be the one from the
<code>finally</code> clause’s <code>return</code> statement</strong>,
not the value from the <code>try</code> clause’s <code>return</code>
statement.</li>
</ul>
</blockquote>
<p>引入 <code>finally</code>
后函数的执行流比较复杂，不熟情况少用，容易整蛊感觉</p>
<h1 id="正则表达式">正则表达式</h1>
<p>一开始比较迷惑的就是匹配结果里的 group
函数，如果不写参数，其返回的就是整个正则表达式所匹配的部分，同时也可以提供索引来获取指定的
capturing group</p>
<p>示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&quot;(\w+) (\w+)&quot;</span>)</span><br><span class="line"><span class="comment"># 当前正则表达式的捕获组个数</span></span><br><span class="line"><span class="built_in">print</span>(pattern.groups)</span><br><span class="line"><span class="keyword">match</span> = pattern.<span class="keyword">match</span>(<span class="string">&quot;Isaac Newton, physicist&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group())</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">match</span>.group(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<p><img data-src="/posts/17bc/image-20230730120839938.png" /></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历二叉树的n种方式</title>
    <url>/posts/7a74/</url>
    <content><![CDATA[<h1 id="二叉树实现">二叉树实现</h1>
<p>不同语言实现起来都差不多，给出 C++ 版本的模版实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> ptr_type = TreeNode&lt;T&gt; *;</span><br><span class="line"></span><br><span class="line">  value_type val&#123;&#125;;</span><br><span class="line">  ptr_type left&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  ptr_type right&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> TreeNode&lt;T&gt; &amp;node) &#123;</span><br><span class="line">  <span class="keyword">return</span> os &lt;&lt; node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归遍历">递归遍历</h1>
<p>由于二叉树本身的递归特性，通过递归函数可以很简单的遍历二叉树，根据访问根节点顺序不同可以分为前序、中序和后序，对应代码如下</p>
<p>首先定义访问函数以及递归遍历函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(TreeNode&lt;T&gt; *node)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;visit: &quot;</span> &lt;&lt; *node &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::function&lt;<span class="type">void</span>(node_ptr)&gt; recursive;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="前序">前序</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">recursive = [&amp;](node_ptr node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意观察三个函数的执行顺序</span></span><br><span class="line">    <span class="built_in">visit</span>(node);</span><br><span class="line">    <span class="built_in">recursive</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">recursive</span>(node-&gt;right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="中序">中序</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">recursive = [&amp;](node_ptr node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">recursive</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">visit</span>(node);</span><br><span class="line">    <span class="built_in">recursive</span>(node-&gt;right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="后序">后序</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">recursive = [&amp;](node_ptr node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">recursive</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">recursive</span>(node-&gt;right);</span><br><span class="line">    <span class="built_in">visit</span>(node);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="迭代遍历">迭代遍历</h1>
<p>在某些极端场景（或迭代器实现时）我们需要将递归函数转换成迭代实现，此时我们就需要通过<strong>栈</strong>模拟递归（针对前、中、后序遍历），同时还用<strong>队列</strong>实现层序遍历。</p>
<h2 id="前中后序遍历">前、中、后序遍历</h2>
<p>首先我们需要分析一下递归函数的执行过程（以中序遍历为例）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">recursive(5)          </span><br><span class="line">  recursive(3)        </span><br><span class="line">    recursive(2)      </span><br><span class="line">      recursive(8)    </span><br><span class="line">        visit(8)      </span><br><span class="line">      visit(2)</span><br><span class="line">    visit(3)</span><br><span class="line">    recursive(4)</span><br><span class="line">      visit(4)</span><br><span class="line">      recursive(7)</span><br><span class="line">        visit(7)</span><br><span class="line">  visit(5)</span><br><span class="line">  recursive(1)</span><br><span class="line">    visit(1)</span><br></pre></td></tr></table></figure>

<p>通过不同的缩进展示了不同函数之间的执行顺序以及所在的作用域</p>
<p>从递归函数的调用过程可以看出，每一个节点实际上都会访问两遍（<code>recursive</code>
以及
<code>visit</code>），而<strong>函数调用顺序一定是按照先序遍历的顺序</strong>，访问调用顺序则是我们预期的顺序。</p>
<p>对于先序遍历而言，其在进入<code>recursive</code>就执行<code>visit</code>，我们可以在出栈的同时执行
<code>visit</code> ，这样节省一次入栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">preorder_iter</span><span class="params">(TreeNode&lt;T&gt;* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> node_ptr = <span class="keyword">typename</span> TreeNode&lt;T&gt;::ptr_type;</span><br><span class="line">  std::stack&lt;node_ptr&gt; stack;</span><br><span class="line">  stack.<span class="built_in">emplace</span>(root);</span><br><span class="line">  <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    node_ptr curr = stack.<span class="built_in">top</span>();</span><br><span class="line">    stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">visit</span>(node_ptr);</span><br><span class="line">    <span class="keyword">if</span>(curr-&gt;right) &#123;</span><br><span class="line">      stack.<span class="built_in">emplace</span>(curr-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处左节点后入栈，确保下个循环开始时左节点位于栈首</span></span><br><span class="line">    <span class="keyword">if</span>(curr-&gt;left) &#123;</span><br><span class="line">      stack.<span class="built_in">emplace</span>(curr-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于中序遍历和后序遍历而言就稍微麻烦一点，因为我们必须要完成两次遍历（第一次入栈模拟的是<code>recursive</code>的调用，第二次入栈模拟的就是<code>visit</code>
的调用），为此我们除了存储节点外还需要添加一个状态标记
<code>first</code>，用来标识我们是否是第一次访问该节点，如果不是，就执行
<code>visit</code> 函数。</p>
<p>剩下就是如何确定入栈顺序了</p>
<p>先看中序遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">inorder_iter</span><span class="params">(TreeNode&lt;T&gt;* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> node_ptr = <span class="keyword">typename</span> TreeNode&lt;T&gt;::ptr_type;</span><br><span class="line">  std::stack&lt;std::pair&lt;node_ptr,<span class="type">bool</span>&gt;&gt; stack;</span><br><span class="line">  stack.<span class="built_in">emplace</span>(root,<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> [curr,first] = stack.<span class="built_in">top</span>();</span><br><span class="line">    stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(!first) &#123;</span><br><span class="line">      <span class="built_in">visit</span>(node_ptr);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等价于 recursive(curr-&gt;left)</span></span><br><span class="line">    <span class="comment">// 等价于 visit(curr);</span></span><br><span class="line">    <span class="comment">// 等价于 recursive(curr-&gt;right);</span></span><br><span class="line">    <span class="keyword">if</span>(curr-&gt;right) &#123;</span><br><span class="line">      stack.<span class="built_in">emplace</span>(curr-&gt;right,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stack.<span class="built_in">emplace</span>(curr,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span>(curr-&gt;left) &#123;</span><br><span class="line">      stack.<span class="built_in">emplace</span>(curr-&gt;left,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解起来很简单，</p>
<ul>
<li><p><code>(node_ptr,true)</code> 等价于一次
<code>recursive(node_ptr)</code> 调用，</p></li>
<li><p><code>(node_ptr,false)</code> 等价于一次
<code>visit(node_ptr)</code> 调用</p></li>
</ul>
<p>对于中序而言，其执行顺序为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">recursive(node-&gt;left)</span><br><span class="line">visit(node)</span><br><span class="line">recursive(node-&gt;right)</span><br></pre></td></tr></table></figure>

<p>根据等价关系等价于出栈顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop (node-&gt;left,true)</span><br><span class="line">pop (node,false)</span><br><span class="line">pop (node-&gt;right,true)</span><br></pre></td></tr></table></figure>

<p>为实现这样一个出栈顺序，我们就必须反着压栈，也就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push (node-&gt;right,true)</span><br><span class="line">push (node,false)</span><br><span class="line">push (node-&gt;left,true)</span><br></pre></td></tr></table></figure>

<p>对于后序遍历而言也是一样，只需要修改入栈顺序即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">stack.<span class="built_in">emplace</span>(curr,<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span>(curr-&gt;right) &#123;</span><br><span class="line">	stack.<span class="built_in">emplace</span>(curr-&gt;right,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(curr-&gt;left) &#123;</span><br><span class="line">  	stack.<span class="built_in">emplace</span>(curr-&gt;left,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="层序遍历">层序遍历</h2>
<p>前面介绍的前中后序遍历实际上都是
DFS（深度优先搜索）的特殊情况，都是用栈实现，而层序遍历则对应于
BFS（广度优先搜索），代码写起来和先序遍历的代码几乎一样，只不过数据结构从栈换成了队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">level_order_iter</span><span class="params">(TreeNode&lt;T&gt;* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> node_ptr = <span class="keyword">typename</span> TreeNode&lt;T&gt;::ptr_type;</span><br><span class="line">  std::queue&lt;node_ptr&gt; queue;</span><br><span class="line">  queue.<span class="built_in">emplace</span>(root);</span><br><span class="line">  <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 相应的替换成 queue 对应的队首和弹出函数</span></span><br><span class="line">    node_ptr curr = queue.<span class="built_in">front</span>();</span><br><span class="line">    queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">visit</span>(node_ptr);</span><br><span class="line">    <span class="keyword">if</span>(curr-&gt;right) &#123;</span><br><span class="line">      stack.<span class="built_in">emplace</span>(curr-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curr-&gt;left) &#123;</span><br><span class="line">      stack.<span class="built_in">emplace</span>(curr-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="莫里斯遍历">🔥莫里斯遍历</h1>
<p>前面介绍的遍历方法空间复杂度都为 <span
class="math inline">\(\mathcal{O}(n)\)</span>，迭代实现的比较好理解，因为我们使用了栈/队列存储中间结果，对于递归函数而言，多次的函数调用也是需要空间开销的（要不然哪来的
StackOverflow，相对于显式的使用栈，递归函数就等价于隐式使用栈，因此所有递归函数都可以改写成使用栈实现的迭代形式）。</p>
<p>而莫里斯遍历在同样时间复杂度情况下可以实现 <span
class="math inline">\(\mathcal{O}(1)\)</span>
空间复杂度，代价就是时间复杂度的常数高一点（写起来复杂一点），但还是<span
class="math inline">\(\mathcal{O}(n)\)</span></p>
<p>其核心思想就是<strong>利用节点中的空闲指针</strong>（指向<code>null</code>的那些），将二叉树转换成一个链表（近似），从而实现
<span class="math inline">\(\mathcal{O}(1)\)</span> 的空间复杂度。</p>
<p>其更新规则如下：</p>
<ol type="1">
<li><p>设 <code>curr</code> 为当前遍历的节点（初始为根节点
<code>root</code>）</p></li>
<li><p>如果 <code>curr</code> 存在左子树：</p>
<p>遍历左子树，找到其最右端的节点（也就是<strong>中序遍历中位于根节点前面的那一个节点</strong>），记为
<code>prev</code>，将该节点的右指针指向 <code>curr</code>，即
<code>prev.right = curr</code>，更新 <code>curr</code> 为其左节点
<code>curr = curr.left</code>（此处利用<strong>最右端节点的右指针一定是空</strong>性质）</p>
<p>如果我们在遍历左子树过程中碰到 <code>prev.right == curr</code>
的情况，<strong>说明我们已经遍历完 <code>curr</code>
的左子树</strong>，清除副作用 <code>prev.right = null</code>，然后更新
<code>curr</code> 为其右节点 <code>curr = curr.right</code></p></li>
<li><p>如果 <code>curr</code>
不存在左子树，表示其此时为所在子树的最左节点，更新 <code>curr</code>
为其右节点 <code>curr = curr.right</code></p></li>
</ol>
<h2 id="前中序遍历">前、中序遍历</h2>
<p>根据更新规则，可以写出前序遍历代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">morris_inorder_traversal</span><span class="params">(TreeNode&lt;T&gt;* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> node_ptr = <span class="keyword">typename</span> TreeNode&lt;T&gt;::ptr_type;</span><br><span class="line">  node_ptr curr = root;</span><br><span class="line">  <span class="keyword">while</span>(curr) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!curr-&gt;left) &#123;</span><br><span class="line">      <span class="built_in">visit</span>(curr);</span><br><span class="line">      curr = curr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    node_ptr prev = curr-&gt;left;</span><br><span class="line">    <span class="keyword">while</span>(prev-&gt;right &amp;&amp; prev-&gt;right != curr) &#123;</span><br><span class="line">      prev = prev-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prev-&gt;right == curr) &#123;</span><br><span class="line">      prev-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">      curr = curr-&gt;right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev-&gt;right = curr;</span><br><span class="line">      <span class="comment">// 第一次访问到中间节点时调用 visit</span></span><br><span class="line">      <span class="built_in">visit</span>(curr);</span><br><span class="line">      curr = curr-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图展示了莫里斯遍历的执行过程</p>
<p><img data-src="/posts/7a74/morris-traversal.png" /></p>
<p>其关键在于找到当前节点<code>curr</code>中序遍历下的前驱节点<code>prev</code>，这个操作是否是
<span class="math inline">\(\mathcal{O}(n)\)</span> ？</p>
<p>由于<strong>树中每条边都会最多被遍历两次（一次建立连接，一次消除连接），而树中边的个数为
<span class="math inline">\(n-1\)</span>，最终时间复杂度为 <span
class="math inline">\(\mathcal{O}(n)\)</span>，空间复杂度为 <span
class="math inline">\(\mathcal{O}(1)\)</span></strong></p>
<p>图中所有非叶子节点都会被遍历2次，前序遍历会在第一次访问到该节点时调用
<code>visit</code>，而中序遍历会在第二次访问到该节点时调用
<code>visit</code>，因此前序和中序莫里斯遍历的写法基本一致，只是调用
<code>visit</code> 的时机不一样。</p>
<p>下面给出完整的中序遍历代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">morris_inorder_traversal</span><span class="params">(TreeNode&lt;T&gt;* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> node_ptr = <span class="keyword">typename</span> TreeNode&lt;T&gt;::ptr_type;</span><br><span class="line">  node_ptr curr = root;</span><br><span class="line">  <span class="keyword">while</span>(curr) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!curr-&gt;left) &#123;</span><br><span class="line">      <span class="built_in">visit</span>(curr);</span><br><span class="line">      curr = curr-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    node_ptr prev = curr-&gt;left;</span><br><span class="line">    <span class="keyword">while</span>(prev-&gt;right &amp;&amp; prev-&gt;right != curr) &#123;</span><br><span class="line">      prev = prev-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prev-&gt;right == curr) &#123;</span><br><span class="line">      prev-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="comment">// 第二次访问到中间节点时调用 visit</span></span><br><span class="line">      <span class="built_in">visit</span>(curr);</span><br><span class="line">      curr = curr-&gt;right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev-&gt;right = curr;</span><br><span class="line">      curr = curr-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序遍历">后序遍历</h2>
<p>对于后序遍历而言，情况稍微复杂点，我们无法直接得到后序遍历的结果，而是将后序遍历作为一个中序遍历执行特殊操作后得到的结果。</p>
<p>这个特殊操作就是<strong>反转一部分中序遍历的结果</strong>，具体而言，需要<strong>反转中序遍历后从根节点左节点到左子树最后一个节点这一段路径</strong>，这是一个递归规则，可以应用于任意子树中。</p>
<p>下面简单解释一下为什么这个特殊操作就可以得到后序遍历结果：</p>
<p>设二叉树的某一段呈这个形状</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   a</span><br><span class="line">  ╱ ╲</span><br><span class="line">s0   b</span><br><span class="line">    ╱ ╲</span><br><span class="line">  s1   c</span><br><span class="line">      ╱ ╲</span><br><span class="line">    s2   d</span><br><span class="line">        ╱ ╲</span><br><span class="line">      s3   e</span><br><span class="line">          ╱ ╲</span><br><span class="line">        s4   f</span><br></pre></td></tr></table></figure>

<p>设子树的后序遍历序列为 <span
class="math inline">\(\text{post}(k)\)</span>，其中k为子树的根节点，根据后序遍历定义，我们可以得到子树
<span class="math inline">\(a\)</span> 的后序遍历序列的递推公式 <span
class="math display">\[
\text{post}(a) = \text{post}(s0) | \text{post}(s1) | \text{post}(s2) |
\text{post}(s3) | \text{post}(s4)|fedcba
\]</span> 其中 <span class="math inline">\(|\)</span>
表示拼接两个序列，由此我们可以写出另外一种形式的后序遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">post</span><span class="params">(TreeNode&lt;T&gt;* node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> node_ptr = <span class="keyword">typename</span> TreeNode&lt;T&gt;::ptr_type;</span><br><span class="line">  std::stack&lt;node_ptr&gt; stack;</span><br><span class="line">  <span class="comment">// 先遍历所有的子树</span></span><br><span class="line">  <span class="keyword">for</span>(node_ptr curr = node;curr != <span class="literal">nullptr</span>;curr = curr-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">post</span>(curr-&gt;left);</span><br><span class="line">    stack.<span class="built_in">push</span>(curr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 再反向输出结果</span></span><br><span class="line">  <span class="keyword">while</span>(!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">visit</span>(stack.<span class="built_in">top</span>());</span><br><span class="line">    stack.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处我们用到了 <strong>栈</strong> 来进行反转，其空间复杂度为 <span
class="math inline">\(\mathcal{O}(n)\)</span>，也可以使用链表反转方法进行反转，这样的空间复杂度为
<span
class="math inline">\(\mathcal{O}(1)\)</span>，使用链表反转的后序遍历代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头插法实现链表反转</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; TreeNode&lt;T&gt;* <span class="title">reverse_linked_list</span><span class="params">(TreeNode&lt;T&gt;* start)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> node = TreeNode&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> node_ptr = <span class="keyword">typename</span> node::ptr_type;</span><br><span class="line">  <span class="type">static</span> node head&#123;&#125;;</span><br><span class="line">  head.right = <span class="literal">nullptr</span>;</span><br><span class="line">  node_ptr curr = start;</span><br><span class="line">  <span class="keyword">while</span>(curr) &#123;</span><br><span class="line">    node_ptr temp = curr-&gt;right;</span><br><span class="line">    curr-&gt;right = head.right;</span><br><span class="line">    head.right = curr;</span><br><span class="line">    curr = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">post_linked_list</span><span class="params">(TreeNode&lt;T&gt;* node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> node_ptr = <span class="keyword">typename</span> TreeNode&lt;T&gt;::ptr_type;</span><br><span class="line">  <span class="comment">// 遍历完该链表上的所有左子树</span></span><br><span class="line">  <span class="keyword">for</span>(node_ptr curr = node;curr != <span class="literal">nullptr</span>;curr=curr-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">post_linked_list</span>(curr-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 反转</span></span><br><span class="line">  node_ptr reversed_head = <span class="built_in">reverse_linked_list</span>(node);</span><br><span class="line">  <span class="keyword">for</span>(node_ptr curr = reversed_head; curr != <span class="literal">nullptr</span>; curr=curr-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">visit</span>(curr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">reverse_linked_list</span>(reversed_head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们可以将这个递归函数通过莫里斯遍历的形式改写成迭代形式。</p>
<p>从代码中可以观察到，每当我们知道已经遍历完左子树之后，就可以通过反转链表输出结果，而在莫里斯遍历中，每当
<code>prev-&gt;right == curr</code>
时，我们就刚好遍历完左子树，那么只需要在此处调用反转输出函数即可。基于莫里斯遍历的后序遍历方法代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">void</span> <span class="title">morris_postorder_traversal</span><span class="params">(TreeNode&lt;T&gt;* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> node = TreeNode&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> node_ptr = <span class="keyword">typename</span> node::ptr_type;</span><br><span class="line">  node_ptr curr = root;</span><br><span class="line">    </span><br><span class="line">  std::function&lt;<span class="type">void</span>(node_ptr)&gt; add_path = [](node_ptr head) &#123;</span><br><span class="line">    node_ptr rhead = <span class="built_in">reverse_linked_list</span>(head);</span><br><span class="line">    <span class="keyword">for</span>(node_ptr i = rhead; i != <span class="literal">nullptr</span>; i=i-&gt;right) &#123;</span><br><span class="line">      <span class="built_in">visit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse_linked_list</span>(rhead);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(curr) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!curr-&gt;left) &#123;</span><br><span class="line">      curr = curr-&gt;right;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node_ptr prev = curr-&gt;left;</span><br><span class="line">    <span class="keyword">while</span>(prev-&gt;right &amp;&amp; prev-&gt;right != curr) &#123;</span><br><span class="line">      prev = prev-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prev-&gt;right == curr) &#123;</span><br><span class="line">      prev-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="built_in">add_path</span>(curr-&gt;left);</span><br><span class="line">      curr = curr-&gt;right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev-&gt;right = curr;</span><br><span class="line">      curr = curr-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">add_path</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码最后单独添加了一个 <code>add_path(root)</code>
是因为莫里斯遍历完成后实际上还有根节点的输出没完成，需要遍历一遍添加这个输出。</p>
<p>（还有一种解决方案就是再添加一个根节点，将原来的根节点作为新根节点的左节点，这样就可以在一个循环内输出所有的结果了）</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>生成排列和组合</title>
    <url>/posts/454a/</url>
    <content><![CDATA[<h1 id="所有排列">所有排列</h1>
<p>由于排列本身的递归形式，可以通过回溯不断生成所有的排列。例如序列为
<code>[1,2,3,4]</code>，当我们确定第一个位置为 <code>1</code>
后，剩下三个位置，此时有效的排列就变成了 剩下三个数 <code>[2,3,4]</code>
在剩下三个位置上的全排列了，这样我们就从求 <code>[1,2,3,4]</code>
的全排列变成了求 <code>[2,3,4]</code> 全排列，当序列长度为 1
时其排列就为其本身，递归终止。</p>
<p>根据这个思路我们就可以写出所有的全排列了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">permutations</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; numbers,</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::vector&lt;<span class="type">int</span>&gt;&amp; curr,</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::vector&lt;<span class="type">int</span>&gt;&amp; visited,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; output)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curr.<span class="built_in">size</span>() == <span class="built_in">numbers</span>().<span class="built_in">size</span>()) &#123;</span><br><span class="line">        output.<span class="built_in">emplece_back</span>(curr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numbers.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        curr.<span class="built_in">emplace_back</span>(numbers[i]);</span><br><span class="line">        <span class="built_in">permutations</span>(numbers,curr,visited,output);</span><br><span class="line">        curr.<span class="built_in">pop_back</span>();</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="无重复元素的所有排列">无重复元素的所有排列</h1>
<p>如果所提供的序列中包含重复元素，我们通过上面的算法就可能生成重复结果，最简单的办法就是使用
<code>set</code>
去重了，但是这不是我们想要的，是否可以直接生成不包含重复元素的全排列呢？从原理进行分析：</p>
<p>例如序列 <code>[1,2,2,4]</code>，为便于展示，我们将两个 2
标上下标，根据前面的算法，我们首先确定位置1的元素 <span
class="math display">\[
[2_{a},]
\]</span> 此时我们确定了编号为 a 的 2，此时还剩下三个元素 <span
class="math inline">\([2_{b},1,4]\)</span>，其结果就应该是剩下三个的全排列。</p>
<p>如果我们确定位置1的元素为 <span class="math display">\[
[2_{b},]
\]</span> 此时剩下 <span class="math inline">\([2_{a},1,4]\)</span>
三个元素全排列，但是这个部分生成的结果和 <span
class="math inline">\(2_a\)</span>
生成的完全一致，因此我们可以全部跳过。</p>
<p>因此，<strong>如果我们知道当前位置该值已经设置过，就可以直接跳过了</strong>，从而确保每次生成都是不一样的，我们可以使用一个
map
来进行计数，这样我们遍历每一个位置的时候都会使用不一样的元素，从而杜绝了重复元素。</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">permutations</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; numbers</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; output)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span>(count.<span class="built_in">find</span>(i) == count.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            count[i] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count[i] ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; recursion;</span><br><span class="line">    recursion = [&amp;]()&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>() == numbers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            output.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : count) &#123;</span><br><span class="line">            <span class="keyword">if</span>(value == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count[key]--;</span><br><span class="line">            curr.<span class="built_in">emplace_back</span>(key);</span><br><span class="line">            <span class="built_in">recursion</span>();</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">            count[key]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">recursion</span>();</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="所有组合">所有组合</h1>
<p>从给定候选序列 <code>nums</code>(不包含重复元素) 中生成长度为
<code>k</code>
的组合序列，其生成过程十分类似于排列，区别就是组合中没有顺序信息，例如候选序列为
<code>[1,2,3,4]</code>，<code>k</code>等于2，<code>[1,2]</code> 和
<code>[2,1]</code> 实际上表示的是同一个组合，因此仅使用
<code>visited</code>
数组并不够用，还需要确保同一个组合仅生成一次，实现起来也很简单，我们只需要确保遍历时前面已经访问过的后面不再访问即可。例如
<code>[1,2,3,4]</code>，我们从 1 开始，所有的组合为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1,2],[1,3],[1,4]</span><br></pre></td></tr></table></figure>

<p>当从2开始的时候，可选范围为 [2,3,4]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2,3],[2,4]</span><br></pre></td></tr></table></figure>

<p>当从3开始的时候，可选范围为 [3,4]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[3,4]</span><br></pre></td></tr></table></figure>

<p>相比于排列，越往后候选元素的个数越少，而排列在循环过程中候选元素个数不变。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">combination</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums,</span></span></span><br><span class="line"><span class="params"><span class="function">                 std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt;&amp; output)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; recursion;</span><br><span class="line">    recursion = [&amp;](<span class="type">int</span> s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            output.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            curr.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">recursion</span>(i+<span class="number">1</span>);</span><br><span class="line">            curr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">recursion</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="下一个排列">下一个排列</h1>
<p>这个实际上是 C++ STL 中的 <code>next_permutation</code>
原理，对于一个支持比较（operator&lt;）的序列，可以通过该函数得到下一个排列结果</p>
<p>例如
<code>[1,2,3,4]</code>，不断执行<code>next_permutation</code>的输出结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="keyword">do</span> std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">next_permutation</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()));</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">132</span><br><span class="line">213</span><br><span class="line">231</span><br><span class="line">312</span><br><span class="line">321</span><br></pre></td></tr></table></figure>

<p>其关键在于：<strong>所有的排列中，升序序列为最小，降序序列为最大</strong>，</p>
<p>我们可以从 123 的排列中看出来，123最小，321最大</p>
<p>对于任意一个序列，我们从后向前找到最大的升序序列（最大），位置从
<code>[j,n-1]</code>，然后从升序序列中找到第一个大于
<code>nums[j-1]</code> 的元素
<code>nums[k]</code>，交换两元素，再将升序序列反转即可。</p>
<p>下图展示了序列 <code>1432765</code> 的下一排列生成图示，其对应序列为
<code>1435267</code></p>
<p><img data-src="/posts/454a/image-20230809172245015.png" /></p>
<p>按照这三个步骤，我们可以很简单的写出代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">next_permutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 找到 nums 的升序序列 </span></span><br><span class="line">    <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已经是最大，返回最小（重新开始）</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">        std::<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 找到稍微大一点的</span></span><br><span class="line">    <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    i = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; j &amp;&amp; nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">    <span class="comment">// 3. 升序序列转降序序列</span></span><br><span class="line">    std::<span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + j + <span class="number">1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="随机排列">随机排列</h1>
<p>随机排列同样是一个递归问题，当我们确定位置1的元素后，剩下的结果就是后续元素的排列，一直递归下去就可以拿到结果。由于序列的序号是连续且有序的，我们可以使用二分法逐步确定。</p>
<p>通过随机数生成一个 <code>[0,nums.size()-1]</code> 范围的数
<code>m</code> 后，我们剩下两个方向，<code>[0,m-1]</code> 以及
<code>[m+1,nums.size()-1]</code>，之后分别在左右两侧生成，直到结束。</p>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">random_permutation</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums,</span></span></span><br><span class="line"><span class="params"><span class="function">                        std::vector&lt;<span class="type">int</span>&gt;&amp; output)</span> </span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; recursion;</span><br><span class="line">    recursion = [&amp;](<span class="type">int</span> l,<span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">uniform_sample</span>(l,r);</span><br><span class="line">        output.<span class="built_in">emplace_back</span>(nums[m]);</span><br><span class="line">        <span class="built_in">recursion</span>(l,m<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">recursion</span>(m+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">recursion</span>(<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应 uniform_sample 的实现可自行百度，只要可以实现 <code>[l,r]</code>
区间的均匀采样即可。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake依赖管理</title>
    <url>/posts/dbe7/</url>
    <content><![CDATA[<h1 id="git-submodule-管理依赖">Git Submodule 管理依赖</h1>
<p>由于 C++
自身的特殊性，要想实现跨平台代码，只能使用源码分发（也有类似于 Conan 的
C++ 依赖解决方案，但是对于一些冷门的库可能就不支持，还是得自己写）。</p>
<p>最简单的办法就是通过 git
的子模块将其添加到项目中，这种依赖管理方式确保可以访问到源代码，其缺点也很明显，我们在下载库的时候需要通过下载依赖库（也就是子模块），如果子模块较大可能下载起来比较耗时。</p>
<p>前面一个笔记中也提到了，要想删除添加的 git submodule
十分麻烦，没有一个简单的命令可以直接删除，需要手动调整需要文件才能删除干净。</p>
<h1 id="fetchcontent-模块添加依赖">FetchContent 模块添加依赖</h1>
<p>而 FetchContent 是 CMake 提供的一种新式依赖管理方案（在 3.11
版本首次出现），其在 CMake
的配置过程中自动下载依赖项并配置（或者由用户自行配置）。这样可以保持我们的代码库整洁。</p>
<span id="more"></span>

<p>使用时首先引入这个模块</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br></pre></td></tr></table></figure>

<p>主要包含下面三个函数</p>
<ul>
<li><p><code>FetchContent_Declare</code>：用来指定依赖库的下载路径（git
仓库地址或者 URL 链接，其会自动解压缩）</p></li>
<li><p><code>FetchContent_MakeAvailable</code>：自动配置依赖库（相当于调用了
<code>add_subdirectory</code>）</p></li>
<li><p><code>FetchContent_Populate</code>：手动配置依赖库，这个函数会帮我们配置好一系列变量，然后由使用者自行管理如何编译）</p>
<p>其会设置一些常用的变量</p>
<ul>
<li><code>&lt;lowercaseName&gt;_SOURCE_DIR</code>，指定的库源代码地址</li>
<li><code>&lt;lowercaseName&gt;_BINARY_DIR</code>，指定库的编译输出地址</li>
</ul>
<p>当我们使用的时候就可以通过 <code>add_subdirectory</code>
进行添加，也可以手写 <code>CMakeLists.txt</code> 来手动添加库</p></li>
</ul>
<p>其中有点需要注意的就是 <code>FetchContent_MakeAvailable</code>
需要在所有的 <code>FetchContent_Declare</code>
声明完成后再写，这样可以确保我们依赖加载完全了，因为一个依赖有可能使用
<code>FetchContent</code> 添加另外一个依赖（隐式依赖）</p>
<blockquote>
<p><a
href="https://cmake.org/cmake/help/latest/module/FetchContent.html#fetchcontent">FetchContent
— CMake 3.27.4 Documentation</a></p>
<p>Projects should aim to declare the details of all dependencies they
might use before they call <code>FetchContent_MakeAvailable()</code> for
any of them. This ensures that if any of the dependencies are also
sub-dependencies of one or more of the others, the main project still
controls the details that will be used (because it will declare them
first before the dependencies get a chance to).</p>
</blockquote>
<h1 id="实际使用">实际使用</h1>
<p>下面给出一个实际案例：</p>
<p>我们需要添加四个依赖：<code>fmt</code>，<code>glfw</code>，<code>imgui</code>，<code>glad</code></p>
<p>对于前三个，我们都可以使用 <code>FetchContent</code> 来添加，由于
<code>glad</code>
是使用网站生成的，我们需要手动将其将其添加到源代码库中。</p>
<p><code>fmt</code> 库的添加代码</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">FetchContent_Declare(</span><br><span class="line">    fmt</span><br><span class="line">    GIT_REPOSITORY https://github.com/fmtlib/fmt.git</span><br><span class="line">    GIT_TAG <span class="number">10.1</span>.<span class="number">0</span></span><br><span class="line">    GIT_SHALLOW <span class="keyword">ON</span></span><br><span class="line">)</span><br><span class="line">FetchContent_MakeAvailable(fmt)</span><br></pre></td></tr></table></figure>

<p>这里我们通过 <code>GIT_REPOSITORY</code> 指定了待下载库的 git
仓库连接，同时通过 <code>GIT_TAG</code> 指定我们需要的版本（也可使用
commit 号），最后的 <code>GIT_SHALLOW</code> 表示我们在
<code>git clone</code> 时设置
<code>--depth 1</code>，这样可以确保我们仅下载需要的部分，而不下载完整的
git 仓库，减少下载时间。</p>
<p>由于 <code>fmt</code> 库本身比较简单，且是一个 header-only
的库，我们直接通过 <code>FetchContent_MakeAvailable</code>
将其添加到代码中即可，当我们需要使用该库时直接链接即可，例如</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(test_fmt main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(test_fmt PRIVATE fmt::fmt)</span><br></pre></td></tr></table></figure>

<p><code>glfw</code> 库的添加代码</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">FetchContent_Declare(</span><br><span class="line">    glfw</span><br><span class="line">    GIT_REPOSITORY https://github.com/glfw/glfw</span><br><span class="line">    GIT_TAG <span class="number">3.3</span>.<span class="number">8</span></span><br><span class="line">    GIT_SHALLOW <span class="keyword">ON</span></span><br><span class="line">)</span><br><span class="line">FetchContent_Populate(glfw)</span><br><span class="line"><span class="keyword">set</span>(GLFW_BUILD_TESTS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="variable">$&#123;glfw_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(glfw::glfw ALIAS glfw)</span><br></pre></td></tr></table></figure>

<p>由于 glfw 库包含一堆 tests 和 examples
，我们可能并不想生成这些文件，为此我们可以通过
<code>FetchContent_Populate</code> 来手动配置 glfw 的编译。</p>
<p>我们在添加 glfw 编译目标之前通过参数 <code>GLFW_BUILD_TESTS</code>
来取消生成 tests，然后将其添加到代码库中，最终由于 glfw
没有提供别名输出（<code>glfw::glfw</code>，可以用来防止打错名字，例如我们直接错写成
<code>glfv</code> 时，没有这个依赖库 cmake 也不会报错，但是写成
<code>glfw::glfv</code> 时没有这个依赖库 cmake
会报错，提示我们找不到这个依赖库），我们手动为其添加一个别名。</p>
<p><code>imgui</code> 库的添加代码</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">FetchContent_Populate(imgui)</span><br><span class="line">add_imgui(</span><br><span class="line">  USE_STD_STRING </span><br><span class="line">  USE_FREETYPE </span><br><span class="line">  IMGUI_DIR <span class="variable">$&#123;imgui_SOURCE_DIR&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>对于 imgui 而言稍微复杂一点，因为其并没有提供开箱即用的
<code>CMakeLists.txt</code>
供我们使用，我们需要手动配置使用哪些文件进行编译，为此我们写了一个小函数
<code>add_imgui</code> 来辅助配置，完整代码如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(add_imgui)</span><br><span class="line">  <span class="keyword">set</span>(options USE_STD_STRING USE_FREETYPE)</span><br><span class="line">  <span class="keyword">set</span>(one_value_args IMGUI_DIR)</span><br><span class="line">  <span class="keyword">set</span>(multi_value_args <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">cmake_parse_arguments</span>(ARGS <span class="string">&quot;$&#123;options&#125;&quot;</span> <span class="string">&quot;$&#123;one_value_args&#125;&quot;</span></span><br><span class="line">                             <span class="string">&quot;$&#123;multi_value_args&#125;&quot;</span> <span class="variable">$&#123;ARGN&#125;</span> )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;add imgui (opengl3 + glfw) [ STATIC ] with c++17&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">list</span>(APPEND CMAKE_MESSAGE_INDENT <span class="string">&quot;  &quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># Using dear imgui via a shared library is not recommended, </span></span><br><span class="line">  <span class="comment"># because we don&#x27;t guarantee backward nor forward ABI compatibility </span></span><br><span class="line">  <span class="comment"># (also function call overhead, as dear imgui is a call-heavy API)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># we should use imgui as static library</span></span><br><span class="line">  <span class="keyword">add_library</span>(imgui STATIC</span><br><span class="line">    <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/imgui_demo.cpp </span><br><span class="line">    <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/imgui_draw.cpp </span><br><span class="line">    <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/imgui_tables.cpp </span><br><span class="line">    <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/imgui_widgets.cpp </span><br><span class="line">    <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/imgui.cpp </span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">add_library</span>(imgui::imgui ALIAS imgui)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set_property</span>(<span class="keyword">TARGET</span> imgui PROPERTY CXX_STANDARD <span class="number">17</span>)</span><br><span class="line">  <span class="keyword">set_property</span>(<span class="keyword">TARGET</span> imgui PROPERTY CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">target_include_directories</span>(imgui PUBLIC </span><br><span class="line">    <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span></span><br><span class="line">  )</span><br><span class="line">  <span class="comment"># backends</span></span><br><span class="line">  <span class="keyword">target_sources</span>(imgui PUBLIC     </span><br><span class="line">    <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/backends/imgui_impl_opengl3.cpp</span><br><span class="line">    <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/backends/imgui_impl_glfw.cpp</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">target_include_directories</span>(imgui PUBLIC </span><br><span class="line">    <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/backends</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">target_link_libraries</span>(imgui PUBLIC </span><br><span class="line">    glfw::glfw</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># extensions</span></span><br><span class="line">  <span class="keyword">if</span> ( ARGS_USE_STD_STRING )</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;enable std::string support for imgui::InputText&quot;</span>)</span><br><span class="line">    <span class="keyword">target_sources</span>(imgui PUBLIC </span><br><span class="line">      <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/misc/cpp/imgui_stdlib.cpp</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">target_include_directories</span>(imgui PUBLIC </span><br><span class="line">      <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/misc/cpp</span><br><span class="line">    )</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( ARGS_USE_FREETYPE )</span><br><span class="line">    <span class="keyword">find_package</span>(Freetype QUIET)</span><br><span class="line">    <span class="keyword">if</span>(Freetype_FOUND)</span><br><span class="line">      <span class="keyword">message</span>(STATUS <span class="string">&quot;enable freetype for imgui&quot;</span>)</span><br><span class="line">      <span class="keyword">target_sources</span>(imgui PRIVATE </span><br><span class="line">        <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/misc/freetype/imgui_freetype.cpp</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">target_include_directories</span>(imgui PRIVATE </span><br><span class="line">        <span class="variable">$&#123;ARGS_IMGUI_DIR&#125;</span>/misc/freetype</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">target_link_libraries</span>(imgui PRIVATE </span><br><span class="line">        Freetype::Freetype</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">target_compile_definitions</span>(imgui PRIVATE </span><br><span class="line">        IMGUI_ENABLE_FREETYPE</span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;disable freetype for imgui&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">list</span>(POP_BACK CMAKE_MESSAGE_INDENT)</span><br><span class="line"></span><br><span class="line"><span class="keyword">endfunction</span>(add_imgui)</span><br></pre></td></tr></table></figure>

<p>函数 <code>add_imgui</code> 通过提供 imgui
源代码目录以及一些配置项来简化配置流程，其默认使用 glfw + opengl
作为渲染后端。</p>
<p>然后对于 glad 库（用来加载 OpenGL 函数），其配置代码也十分简单</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置为动态链接库</span></span><br><span class="line"><span class="keyword">add_library</span>(glad SHARED src/gl.c)</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(glad PRIVATE -DGLAD_API_CALL_EXPORT_BUILD)</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(glad PUBLIC -DGLAD_API_CALL_EXPORT)</span><br><span class="line"><span class="keyword">target_include_directories</span>(glad PUBLIC <span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_library</span>(glad::glad ALIAS glad)</span><br></pre></td></tr></table></figure>

<h1 id="externalproject-添加依赖">ExternalProject 添加依赖</h1>
<p>这个也是 CMake 中下载依赖的一种方式，其早于 <code>FetchContent</code>
出现，可以提供和 <code>FetchContent</code>
类似的功能，主要通过一个巨大的函数进行依赖配置</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">ExternalProject_Add</span><br></pre></td></tr></table></figure>

<p>我们可以在其中指定编译的命令等，也可以使用
<code>ExternalProject_Add_Step</code>
来手动管理依赖的编译步骤，不过这种方式个人感觉没有
<code>FetchContent_Declare</code> 和 <code>FetchContent_Populate</code>
使用来的方便，就不过多介绍了，网上也有很多相关的教程。</p>
<blockquote>
<p><a
href="https://cmake.org/cmake/help/latest/module/ExternalProject.html">ExternalProject
— CMake 3.27.4 Documentation</a></p>
</blockquote>
<h1 id="杂项">杂项</h1>
<p><strong>在 Windows 下使用动态链接库时可能会因为找不到 dll
库的位置而无法启动应用</strong>，我们需要手动将动态链接库（例如
<code>glad.dll</code>
）拷贝到可执行环境目录下，才可以正常运行，但是每次手动拷贝太麻烦了，cmake
也可以自动帮我们完成这一任务。</p>
<p>（图片太大可能看不清字，写的是：<strong>由于找不到
glad.dll，无法继续执行代码，重新安装程序可能会解决此问题。</strong>）</p>
<p><em>比较坑的点在于 Windows 下使用 VSCode 完全看不到这个错误提示，而在
Visual Studio 中就可以看到，恶心坏了</em></p>
<p><img data-src="/posts/dbe7/image-20230827220434585.png" /></p>
<p>解决方案有很多：</p>
<ul>
<li>强制所有编译输出到同一个目录下，这样就可以确保一定能找到了（个人感觉比较丑陋，只能算一个
workaround）</li>
<li>找到该应用所有的依赖库，将其拷贝到可执行文件输出路径下（<strong>关键在于如何找到可执行文件的所有依赖库呢？</strong>）</li>
</ul>
<p>这个问题肯定不止我们一个人碰到过，cmake 给我们提供好了这个变量</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %target-name% 对应的所有运行时依赖</span></span><br><span class="line">$&lt;TARGET_RUNTIME_DLLS:%<span class="keyword">target</span>-name%&gt;</span><br></pre></td></tr></table></figure>

<p>以及</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># %target-name% 的可执行文件输出路径</span></span><br><span class="line">$&lt;TARGET_FILE_DIR:%<span class="keyword">target</span>-name%&gt;</span><br></pre></td></tr></table></figure>

<p>这样我们可以通过 <code>add_custom_command</code>
来进行自动拷贝了，完整代码如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> test_imgui POST_BUILD</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy -t </span><br><span class="line">  $&lt;TARGET_FILE_DIR:test_imgui&gt; </span><br><span class="line">  $&lt;TARGET_RUNTIME_DLLS:test_imgui&gt;</span><br><span class="line">  COMMAND_EXPAND_LISTS</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这一段代码来源于 cmake 官方文档（看来是需要这个功能的人太多了）</p>
<blockquote>
<p><a
href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#genex:TARGET_RUNTIME_DLLS">genex:TARGET_RUNTIME_DLLS</a></p>
</blockquote>
<p>当然，这个功能要求 cmake 的版本比较新，需要在 cmake 版本高于
3.21，记得更新 <code>cmake_minimum_required</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.21</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>Antlr4使用</title>
    <url>/posts/b5fa/</url>
    <content><![CDATA[<h1 id="helloantlr4">Hello，ANTLR4</h1>
<p>ANTLR 是一个用 Java 写的语法分析工具，类似 Lex Yacc 以及 Flex
Bison（这两个都有点太老了，而且Windows上也不好用），通过编写一个内嵌代码的文件（<code>.g4</code>）来定义文法，然后由
ANTLR 对文件进行分析，生成不同后端的分析程序，例如 C++、Python、Java
等，相比我们手写分析程序，只要我们定义好文法，就可以完成解析过程，提高开发效率。</p>
<p>使用 ANTLR4 的最简单方式就是 Python 了，我们直接通过 pip 安装即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install antlr4-tools</span><br></pre></td></tr></table></figure>

<p>由于 ANTLR 需要 Java ，如果没有安装 Java
环境会在第一次运行时自动安装。</p>
<p>之后我们可以定义一个简单的表达式文法来测试效果</p>
<p><em><strong>Expr.g4</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grammar Expr;		</span><br><span class="line">prog:	expr EOF ;</span><br><span class="line">expr:	expr (&#x27;*&#x27;|&#x27;/&#x27;) expr</span><br><span class="line">    |	expr (&#x27;+&#x27;|&#x27;-&#x27;) expr</span><br><span class="line">    |	INT</span><br><span class="line">    |	&#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="line">    ;</span><br><span class="line">NEWLINE : [\r\n]+ -&gt; skip;</span><br><span class="line">INT     : [0-9]+ ;</span><br></pre></td></tr></table></figure>

<p>（注意到文法中包含左递归，但是 ANTLR 会自动帮我们处理好）</p>
<span id="more"></span>

<p>通过下列命令测试文法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">antlr4-parse Expr.g4 prog -tree</span><br></pre></td></tr></table></figure>

<p>其命令格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java org.antlr.v4.gui.Intrepreter [X.g4|XParser.g4 XLexer.g4] startRuleName</span><br><span class="line">  [-tokens] [-tree] [-gui] [-encoding encodingname]</span><br><span class="line">  [-trace] [-profile filename.csv] [input-filename(s)]</span><br><span class="line">Omitting input-filename makes rig read from stdin.</span><br></pre></td></tr></table></figure>

<p>prog 对应于 <code>startRuleName</code></p>
<p>此时会等待我们输入，我们输入一个有效的表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10*(5*2)</span><br></pre></td></tr></table></figure>

<p>然后输入 <kbd>Ctrl</kbd> + <kbd>D</kbd>（Unix系统）或者
<kbd>Ctrl</kbd>
+<kbd>Z</kbd>（Windows系统）来终止输入，此时就可以看到输出结果</p>
<p>（由于是在 Python 中调用 Java 命令行，可以有点慢）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">10*(4+2) </span><br><span class="line">^Z</span><br><span class="line">(prog:1 (<span class="built_in">expr</span>:1 (<span class="built_in">expr</span>:3 10) * (<span class="built_in">expr</span>:4 ( (<span class="built_in">expr</span>:2 (<span class="built_in">expr</span>:3 5) + (<span class="built_in">expr</span>:3 2)) ))) &lt;EOF&gt;)</span><br></pre></td></tr></table></figure>

<p>可以看到其成功对我们的文法进行分析，并通过嵌套关系表示出语法分析树，这样用只是展示
ANTLR 的分析效果，但是实际我们需要将其和应用集成起来，那么就需要使用
ANTLR
编译文法文件后生成不同语言的分析代码，从而实现高效的分析（最开始本来想用
ANTLR来进行 HTTP
报文的解析的，但是好像有点杀鸡用牛刀的意思，而且其无法支持流式输入，后面就自行写了一个简单的），不过对于
URL 解析或者 MySQL 语句的解析倒是挺好用的。</p>
<blockquote>
<p><a
href="https://github.com/antlr/antlr4/blob/dev/doc/getting-started.md">antlr4/doc/getting-started.md
at dev · antlr/antlr4 (github.com)</a></p>
</blockquote>
<h1 id="antlr4-for-cpp">ANTLR4 for CPP</h1>
<p>在 C++ 环境中使用 ANTLR4 相对而言较为繁琐，其包含两个步骤</p>
<ol type="1">
<li>编译文法文件，生成对应的 C++ 解析代码（<code>Lexer.cpp</code> 以及
<code>Parser.cpp</code>）</li>
<li>链接 ANTLR4 的 C++ 运行库</li>
</ol>
<p>由于 C++
本身的特殊性，第一个步骤可以通过命令行手动完成，但是第二个编译过程就很麻烦了，不过官方也给出了样例代码：</p>
<blockquote>
<p><a
href="https://github.com/antlr/antlr4/blob/dev/runtime/Cpp/README.md">antlr4/runtime/Cpp/README.md
at dev · antlr/antlr4 (github.com)</a></p>
</blockquote>
<p>一般而言，只需要将 <code>&lt;ANTLR4_ROOT&gt;/runtime/Cpp/cmake</code>
文件夹中的 <code>FindANTLR.cmake</code> 以及
<code>ExternalAntlr4Cpp.cmake</code> 拷贝到项目本地，然后在
<code>CMakeLists.txt</code> 中 <code>include</code> 进来即可</p>
<p>示例如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">// 将两个 .cmake 文件放在 cmake 文件夹下</span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/cmake)</span><br><span class="line"></span><br><span class="line">// 设置编译 ANTLR4 的一些选项，MSVC CRT链接方式（MT/MD）、静态/动态链接库等</span><br><span class="line">// 设置所需要的 ANTLR4 版本（此处选择最新版）</span><br><span class="line"><span class="keyword">set</span>(ANTLR4_TAG <span class="number">4.13</span>.<span class="number">0</span>)</span><br><span class="line">// 添加外部依赖，通过 ExternalProject_Add 方式实现</span><br><span class="line">// 其默认会创建 static 和 shared 两种库，可以自行选择需要的库进行链接</span><br><span class="line"><span class="keyword">include</span>(ExternalAntlr4Cpp)</span><br><span class="line"></span><br><span class="line">// 对于第二个步骤，FindANTLR.cmake 提供 antlr_target 宏来自动化编译文法文件的过程，其使用示例如下</span><br><span class="line">antlr_target(</span><br><span class="line">	ExprParser Expr.g4 PARSER LEXER</span><br><span class="line">  PACKAGE parser</span><br><span class="line">)</span><br><span class="line">// 其会自动生成对应语言的分析代码，同时输出三个 cmake 变量，我们可以将其添加到编译目标中</span><br><span class="line"><span class="keyword">add_executable</span>(demo main.cpp)</span><br><span class="line"><span class="keyword">target_sources</span>(demo PRIVATE <span class="variable">$&#123;ANTLR_ExprParser_CXX_OUTPUTS&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(demo PRIVATE <span class="variable">$&#123;ANTLR_ExprParser_OUTPUT_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line">// 最后连接到 antlr 的 cpp runtime 即可</span><br><span class="line"><span class="keyword">target_link_libraries</span>(demo PRIVATE antlr4_static)</span><br></pre></td></tr></table></figure>

<p>个人在使用过程中感觉整个过程用起来有点别扭，主要有两个地方</p>
<ol type="1">
<li>使用 <code>ExternalAntlr4Cpp</code> 时并没有为我们创建 ALIAS
目标（即 <code>glm::glm</code>
这种，可以防止拼写错误问题），并且在编译时才会触发下载，无法提前代码状态（因为其使用的是
<code>ExternalProject_Add</code>）</li>
<li>通过 <code>antlr_target</code>
方式添加的目标也仅在编译过程中才会创建，没编译前也是什么都没有，这样我们就不知道什么时候编译出错了，我们可能想将其作为源代码的一部分进行管理（因为其使用的是
<code>add_custom_command</code> 实现，在编译时才会执行）。</li>
</ol>
<p>针对官方提供集成方案的两个缺点，我们参考官方集成方案进行一些修改，将
<code>ExternalProject_Add</code> 替换为 <code>FetchContent</code>
实现，同时通过 <code>execute_process</code> 方式替换
<code>add_custom_command</code>，使得在每次重新配置时都会触发下载。</p>
<h1 id="自行实现的-antlr4-集成方式">自行实现的 ANTLR4 集成方式</h1>
<h2 id="fetchcontent-下载依赖">FetchContent 下载依赖</h2>
<p>思路很简单，就是下载 + <code>add_subdirectory</code> 的老套路，不过
ANTLR4 比较坑的是动态链接库和静态链接库的处理上，
需要添加很多处理来保证编译正确（主要是 Windows 恶心人的
<code>__declspec(dllexport)</code> 以及
<code>__declspec(dllimport)</code>），而在 ANTLR4 的原始 CMakeLists.txt
设置有点问题（主要是宏定义的可见范围设置有误）</p>
<p><em>&lt;ANTLR4_ROOT&gt;/runtime/Cpp/runtime/CMakeLists.txt</em>（L120~132）</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">  <span class="keyword">set</span>(static_lib_suffix <span class="string">&quot;-static&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">TARGET</span> antlr4_shared)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(antlr4_shared PUBLIC ANTLR4CPP_EXPORTS)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">TARGET</span> antlr4_static)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(antlr4_static PUBLIC ANTLR4CPP_STATIC)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">if</span>(CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(extra_share_compile_flags <span class="string">&quot;-MP /wd4251&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(extra_static_compile_flags <span class="string">&quot;-MP&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>其中问题就出在
<code>target_compile_definitions(antlr4_shared PUBLIC ANTLR4CPP_EXPORTS)</code>
上。</p>
<p>这个宏的作用就是控制 Windows DLL导出/DLL导入的，代码位于</p>
<p><em>&lt;ANTLR4_ROOT&gt;/runtime/Cpp/runtime/src/antlr4-common.h</em>（L54~62）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ANTLR4CPP_EXPORTS</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> ANTLR4CPP_PUBLIC __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">ifdef</span> ANTLR4CPP_STATIC</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ANTLR4CPP_PUBLIC</span></span><br><span class="line">  <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ANTLR4CPP_PUBLIC __declspec(dllimport)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>可以看到，当启用 <code>ANTLR4CPP_EXPORTS</code> 时就会开启
dllexport，而没启用且不是静态链接就是 <code>dllimport</code>.</p>
<p>但设置为 PUBLIC 时会在所有的编译单元中都启用该宏，导致编译
<code>main.cpp</code>
的时候会提示LINK2019错误，也就是找不到符号（当然找不到，本来应该是
import 的变成了 export，怎么可能找得到符号呢）。</p>
<p>这个问题改起来也很简单，只需要将 <code>PUBLIC</code> 改成
<code>PRIVATE</code> 即可（可以向官方提 ISSUE），在
<code>ExternalAntlr4Cpp.cmake</code>
中给出了解决方案（不知道为什么不直接修改这个代码）</p>
<p>通过创建 <code>IMPORTED</code> 的 target 并将该 target
私有链接到原有的库，就可以避免 <code>ANTLR4CPP_EXPORTS</code>
传递到我们的业务代码中了。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(antlr4_shared SHARED IMPORTED)</span><br><span class="line"><span class="keyword">add_dependencies</span>(antlr4_shared antlr4_runtime-build_shared)</span><br><span class="line"><span class="keyword">set_target_properties</span>(</span><br><span class="line">	antlr4_shared PROPERTIES</span><br><span class="line">  IMPORTED_LOCATION <span class="variable">$&#123;ANTLR4_RUNTIME_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(antlr4_shared</span><br><span class="line">    INTERFACE <span class="variable">$&#123;ANTLR4_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ANTLR4_SHARED_LIBRARIES)</span><br><span class="line">  <span class="keyword">set_target_properties</span>(</span><br><span class="line">  	antlr4_shared PROPERTIES</span><br><span class="line">    IMPORTED_IMPLIB <span class="variable">$&#123;ANTLR4_SHARED_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>不过 CMake 在使用 IMPORTED target
时比较恶心，需要手动指定链接库的位置，这个也在
<code>ExternalAntlr4Cpp.cmake</code>
中写死了（感觉不太优雅，不过能跑就行吧）</p>
<p>了解官方的解决方案后，我们自行编写起来就简单很多了</p>
<p><code>add-antlr4.cmake</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(add_antlr4 TAG)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR_OPTIONS SHARED WITH_STATIC_CRT WITH_LIBCXX DISABLE_WARNINGS)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR_ONE_VALUE_ARGS <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR_MULTI_VALUE_ARGS <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">cmake_parse_arguments</span>(ANTLR4CPP</span><br><span class="line">                        <span class="string">&quot;$&#123;ANTLR_OPTIONS&#125;&quot;</span></span><br><span class="line">                        <span class="string">&quot;$&#123;ANTLR_ONE_VALUE_ARGS&#125;&quot;</span></span><br><span class="line">                        <span class="string">&quot;$&#123;ANTLR_MULTI_VALUE_ARGS&#125;&quot;</span></span><br><span class="line">                        <span class="variable">$&#123;ARGN&#125;</span>)</span><br><span class="line">  <span class="keyword">include</span>(CMakePrintHelpers)</span><br><span class="line">  FetchContent_Declare(</span><br><span class="line">    antlr4_cpp</span><br><span class="line">    GIT_REPOSITORY https://github.com/antlr/antlr4</span><br><span class="line">    GIT_TAG <span class="variable">$&#123;TAG&#125;</span></span><br><span class="line">    GIT_SHALLOW <span class="keyword">TRUE</span></span><br><span class="line">  )</span><br><span class="line">  FetchContent_Populate(antlr4_cpp)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>(antlr4_cpp_SOURCE_DIR </span><br><span class="line">    <span class="variable">$&#123;antlr4_cpp_SOURCE_DIR&#125;</span>/runtime/Cpp</span><br><span class="line">    CACHE INTERNAL <span class="string">&quot;&quot;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 可以从 VERSION 中读取到版本信息</span></span><br><span class="line">  <span class="keyword">file</span>(STRINGS <span class="variable">$&#123;antlr4_cpp_SOURCE_DIR&#125;</span>/VERSION ANTLR_VERSION)</span><br><span class="line">  cmake_print_variables(ANTLR_VERSION)</span><br><span class="line">  cmake_print_variables(ANTLR4CPP_WITH_STATIC_CRT)</span><br><span class="line">  cmake_print_variables(ANTLR4CPP_WITH_LIBCXX)</span><br><span class="line">  cmake_print_variables(ANTLR4CPP_DISABLE_WARNINGS)</span><br><span class="line">  cmake_print_variables(ANTLR4CPP_SHARED)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>(WITH_DEMO <span class="keyword">FALSE</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(WITH_STATIC_CRT <span class="variable">$&#123;ANTLR4CPP_WITH_STATIC_CRT&#125;</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(WITH_LIBCXX <span class="variable">$&#123;ANTLR4CPP_WITH_LIBCXX&#125;</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(DISABLE_WARNINGS <span class="variable">$&#123;ANTLR4CPP_DISABLE_WARNINGS&#125;</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR4_INSTALL <span class="keyword">FALSE</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR_BUILD_CPP_TESTS <span class="keyword">FALSE</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR4_INCLUDE_DIRS </span><br><span class="line">    <span class="variable">$&#123;antlr4_cpp_SOURCE_DIR&#125;</span>/runtime/src </span><br><span class="line">    CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR4_OUTPUT_DIR </span><br><span class="line">    <span class="variable">$&#123;antlr4_cpp_BINARY_DIR&#125;</span>/runtime </span><br><span class="line">    CACHE INTERNAL <span class="string">&quot;&quot;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ANTLR4CPP_SHARED)</span><br><span class="line">    <span class="keyword">set</span>(ANTLR_BUILD_SHARED <span class="keyword">TRUE</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(ANTLR_BUILD_STATIC <span class="keyword">FALSE</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(ANTLR_BUILD_SHARED <span class="keyword">FALSE</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(ANTLR_BUILD_STATIC <span class="keyword">TRUE</span> CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment"># from https://github.com/antlr/antlr4/blob/dev/runtime/Cpp/cmake/ExternalAntlr4Cpp.cmake</span></span><br><span class="line">  <span class="keyword">if</span>(MSVC)</span><br><span class="line">    <span class="keyword">set</span>(ANTLR4_STATIC_LIBRARIES</span><br><span class="line">      <span class="variable">$&#123;ANTLR4_OUTPUT_DIR&#125;</span>/antlr4-runtime-static.lib CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(ANTLR4_SHARED_LIBRARIES</span><br><span class="line">      <span class="variable">$&#123;ANTLR4_OUTPUT_DIR&#125;</span>/antlr4-runtime.lib CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">set</span>(ANTLR4_RUNTIME_LIBRARIES</span><br><span class="line">      <span class="variable">$&#123;ANTLR4_OUTPUT_DIR&#125;</span>/antlr4-runtime.dll CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(ANTLR4_STATIC_LIBRARIES</span><br><span class="line">      <span class="variable">$&#123;ANTLR4_OUTPUT_DIR&#125;</span>/libantlr4-runtime.a CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(MINGW)</span><br><span class="line">      <span class="keyword">set</span>(ANTLR4_SHARED_LIBRARIES</span><br><span class="line">        <span class="variable">$&#123;ANTLR4_OUTPUT_DIR&#125;</span>/libantlr4-runtime.dll.a CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">      <span class="keyword">set</span>(ANTLR4_RUNTIME_LIBRARIES</span><br><span class="line">        <span class="variable">$&#123;ANTLR4_OUTPUT_DIR&#125;</span>/libantlr4-runtime.dll CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">elseif</span>(CYGWIN)</span><br><span class="line">      <span class="keyword">set</span>(ANTLR4_SHARED_LIBRARIES</span><br><span class="line">        <span class="variable">$&#123;ANTLR4_OUTPUT_DIR&#125;</span>/libantlr4-runtime.dll.a CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">      <span class="keyword">set</span>(ANTLR4_RUNTIME_LIBRARIES</span><br><span class="line">        <span class="comment"># https://github.com/antlr/antlr4/pull/2235#discussion_r173871830</span></span><br><span class="line">        <span class="comment"># due to cmake: https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html</span></span><br><span class="line">        <span class="variable">$&#123;ANTLR4_OUTPUT_DIR&#125;</span>/cygantlr4-runtime-<span class="variable">$&#123;ANTLR_VERSION&#125;</span>.dll CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">elseif</span>(APPLE)</span><br><span class="line">      <span class="keyword">set</span>(ANTLR4_RUNTIME_LIBRARIES</span><br><span class="line">        <span class="variable">$&#123;ANTLR4_OUTPUT_DIR&#125;</span>/libantlr4-runtime.dylib CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>()</span><br><span class="line">      <span class="keyword">set</span>(ANTLR4_RUNTIME_LIBRARIES</span><br><span class="line">        <span class="variable">$&#123;ANTLR4_OUTPUT_DIR&#125;</span>/libantlr4-runtime.so CACHE INTERNAL <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">add_subdirectory</span>(</span><br><span class="line">    <span class="variable">$&#123;antlr4_cpp_SOURCE_DIR&#125;</span> </span><br><span class="line">    <span class="variable">$&#123;antlr4_cpp_BINARY_DIR&#125;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ANTLR4CPP_SHARED)</span><br><span class="line">    <span class="keyword">add_library</span>(antlr4_runtime_shared SHARED IMPORTED)</span><br><span class="line">    <span class="keyword">target_include_directories</span>(antlr4_runtime_shared</span><br><span class="line">      INTERFACE <span class="variable">$&#123;ANTLR4_INCLUDE_DIRS&#125;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">set_target_properties</span>(antlr4_runtime_shared </span><br><span class="line">      PROPERTIES</span><br><span class="line">      IMPORTED_LOCATION <span class="variable">$&#123;ANTLR4_RUNTIME_LIBRARIES&#125;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">set_target_properties</span>(antlr4_runtime_shared </span><br><span class="line">      PROPERTIES</span><br><span class="line">      IMPORTED_IMPLIB <span class="variable">$&#123;ANTLR4_SHARED_LIBRARIES&#125;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">add_library</span>(antlr4::antlr4_shared ALIAS antlr4_runtime_shared)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">target_include_directories</span>(antlr4_static INTERFACE <span class="variable">$&#123;ANTLR4_INCLUDE_DIRS&#125;</span>)</span><br><span class="line">    <span class="keyword">add_library</span>(antlr4::antlr4_static ALIAS antlr4_static)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">endfunction</span>(add_antlr4)</span><br></pre></td></tr></table></figure>

<p>其中我们指定了一些参数</p>
<ul>
<li><p><code>TAG</code>：Antlr 的版本（可以使用 git commit id 以及
tag）</p></li>
<li><p><code>SHARED</code> ：是否使用动态链接库</p></li>
<li><p><code>WITH_STATIC_CRT</code>：静态 CRT（MSVC编译flag为
<code>-MT</code> / <code>-MTd</code>），默认是动态 CRT （MSVC编译flag为
<code>-MD</code> / <code>-MDd</code>，这样我们就需要安装
vcredist）</p></li>
<li><p><code>WITH_LIBCXX</code>：在 unix 下是否连接到
libcxx，相当于一种另外的 c++ 运行库（对应的还有 libstdc++）</p></li>
<li><p><code>DISABLE_WARNINGS</code>：很简单，是否开启警告（我们在编译
Windows 动态链接库时就发现 W4275）</p>
<p><a
href="https://learn.microsoft.com/zh-cn/cpp/error-messages/compiler-warnings/compiler-warning-level-2-c4275?view=msvc-170">编译器警告（等级
2）C4275 | Microsoft Learn</a></p>
<p>不是什么大问题，但是很多，因为 ANTLR4 Runtime 的 所有异常都继承自
<code>std::exception</code>，但是 MSVC 会提示
<code>std::exception</code> 并不是 DLL导出的，可能存在问题。</p></li>
</ul>
<p>对于第二个，我们的修改很少，就是调整 <code>add_custom_command</code>
为 <code>execute_process</code>，这样在每次进行 cmake
配置时就会生成，便于 debug。</p>
<p>完整代码</p>
<p><code>add-antlr4-parser.cmake</code></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(add_antlr4_parser TARGET_NAME INPUT_FILE)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR_OPTIONS LEXER PARSER LISTENER VISITOR)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR_ONE_VALUE_ARGS NAMESPACE OUTPUT_DIRECTORY)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR_MULTI_VALUE_ARGS GENERATE_FLAGS)</span><br><span class="line">  <span class="keyword">cmake_parse_arguments</span>(ANTLR_TARGET</span><br><span class="line">                        <span class="string">&quot;$&#123;ANTLR_OPTIONS&#125;&quot;</span></span><br><span class="line">                        <span class="string">&quot;$&#123;ANTLR_ONE_VALUE_ARGS&#125;&quot;</span></span><br><span class="line">                        <span class="string">&quot;$&#123;ANTLR_MULTI_VALUE_ARGS&#125;&quot;</span></span><br><span class="line">                        <span class="variable">$&#123;ARGN&#125;</span>)</span><br><span class="line">  <span class="keyword">include</span>(CMakePrintHelpers)</span><br><span class="line">  <span class="keyword">set</span>(ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_INPUT <span class="variable">$&#123;INPUT_FILE&#125;</span>)</span><br><span class="line"></span><br><span class="line">  cmake_path(GET INPUT_FILE STEM ANTLR_INPUT)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ANTLR_TARGET_OUTPUT_DIRECTORY)</span><br><span class="line">    <span class="keyword">set</span>(ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR <span class="variable">$&#123;ANTLR_TARGET_OUTPUT_DIRECTORY&#125;</span>)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR</span><br><span class="line">        <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/antlr4cpp_generated_src/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unset</span>(ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_CXX_OUTPUTS)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((ANTLR_TARGET_LEXER <span class="keyword">AND</span> <span class="keyword">NOT</span> ANTLR_TARGET_PARSER) <span class="keyword">OR</span></span><br><span class="line">      (ANTLR_TARGET_PARSER <span class="keyword">AND</span> <span class="keyword">NOT</span> ANTLR_TARGET_LEXER))</span><br><span class="line">    <span class="keyword">list</span>(APPEND ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_CXX_OUTPUTS</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>.h</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>.cpp)</span><br><span class="line">    <span class="keyword">set</span>(ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_OUTPUTS</span><br><span class="line">        <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>.interp</span><br><span class="line">        <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>.tokens)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">list</span>(APPEND ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_CXX_OUTPUTS</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>Lexer.h</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>Lexer.cpp</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>Parser.h</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>Parser.cpp)</span><br><span class="line">    <span class="keyword">list</span>(APPEND ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_OUTPUTS</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>Lexer.interp</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>Lexer.tokens)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ANTLR_TARGET_LISTENER)</span><br><span class="line">    <span class="keyword">list</span>(APPEND ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_CXX_OUTPUTS</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>BaseListener.h</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>BaseListener.cpp</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>Listener.h</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>Listener.cpp)</span><br><span class="line">    <span class="keyword">list</span>(APPEND ANTLR_TARGET_GENERATE_FLAGS -listener)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ANTLR_TARGET_VISITOR)</span><br><span class="line">    <span class="keyword">list</span>(APPEND ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_CXX_OUTPUTS</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>BaseVisitor.h</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>BaseVisitor.cpp</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>Visitor.h</span><br><span class="line">          <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;/<span class="variable">$&#123;ANTLR_INPUT&#125;</span>Visitor.cpp)</span><br><span class="line">    <span class="keyword">list</span>(APPEND ANTLR_TARGET_GENERATE_FLAGS -visitor)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ANTLR_TARGET_NAMESPACE)</span><br><span class="line">    <span class="keyword">list</span>(APPEND ANTLR_TARGET_GENERATE_FLAGS -package <span class="variable">$&#123;ANTLR_TARGET_NAMESPACE&#125;</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">list</span>(APPEND ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_OUTPUTS <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_CXX_OUTPUTS&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">execute_process</span>(</span><br><span class="line">      <span class="keyword">COMMAND</span> <span class="variable">$&#123;Java_JAVA_EXECUTABLE&#125;</span> -jar <span class="variable">$&#123;ANTLR_EXECUTABLE&#125;</span></span><br><span class="line">              <span class="variable">$&#123;INPUT_FILE&#125;</span></span><br><span class="line">              -o <span class="variable">$&#123;ANTLR_$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR&#125;</span><br><span class="line">              -no-listener</span><br><span class="line">              -Dlanguage=Cpp</span><br><span class="line">              <span class="variable">$&#123;ANTLR_TARGET_GENERATE_FLAGS&#125;</span></span><br><span class="line">      WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">cmake_policy</span>(<span class="keyword">SET</span> CMP0140 NEW)</span><br><span class="line">  <span class="keyword">return</span>(PROPAGATE </span><br><span class="line">    ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_OUTPUT_DIR </span><br><span class="line">    ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_CXX_OUTPUTS </span><br><span class="line">    ANTLR_<span class="variable">$&#123;TARGET_NAME&#125;</span>_OUTPUTS</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">endfunction</span>(add_antlr4_parser)</span><br></pre></td></tr></table></figure>

<p>由于我们在 configure
过程中进行生成，删除了几个不必要的配置，调用参数含义如下：</p>
<ul>
<li><p><code>TARGET_NAME</code>: 指定文法名词，例如
<code>ExprParser</code></p></li>
<li><p><code>INPUT_FILE</code>：对应的文法文件，例如
<code>Expr.g4</code></p></li>
<li><p><code>LEXER</code>、<code>PARSER</code>、<code>LISTENER</code>、<code>VISITOR</code>
都是 BOOL 类型，表示是否开启对应的代码生成</p>
<p>lexer 对应词法分析器，parser 对应语法分析其，listener 和 visitor
是用来遍历语法树的两种方式（当然也可以自行实现语法树的遍历）</p></li>
<li><p><code>NAMESPACE</code>：生成的分析器所属命名空间，例如
<code>parser</code>，对应的语法分析器就是
<code>parser::ExprParser</code></p></li>
<li><p><code>OUTPUT_DIRECTORY</code>：生成的代码输出路径，例如我们可以将其输出到源代码文件夹
<code>$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</code></p></li>
<li><p><code>GENERATE_FLAGS</code>：一些其他的 antlr
文法生成参数，前面的足够使用了， 这个一般用不到</p></li>
</ul>
<p>调用实例如下</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">add_antlr4_parser(</span><br><span class="line">  CalculatorParser Calculator.g4 </span><br><span class="line">  LEXER PARSER </span><br><span class="line">  NAMESPACE parser</span><br><span class="line">  OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/parser</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="杂项">杂项</h1>
<p>目前网上除了 ANTLR4 的 github
的文档外，官方文档上信息很少，要想真正深入学习 ANTLR 的使用还是得看
ANTLR 作者写的那本书 ANTLR 4权威指南，不过网上的 pdf
版本还很多，也有中文版，基本上取代了文档的位置（连基本的 g4 文件 grammar
都是书上讲的清楚一点，唉！）</p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>CMake</tag>
        <tag>ANTLR</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用操作</title>
    <url>/posts/8de3/</url>
    <content><![CDATA[<h1 id="git-clone">git clone</h1>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo-url&gt;</span><br></pre></td></tr></table></figure>

<p>示例命令如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/boostorg/boost.git</span><br></pre></td></tr></table></figure>

<p>一些常用的参数（全部参数选项可以通过 <code>git clone --help</code>
查看）</p>
<ul>
<li><p><code>--recursive</code> 或
<code>--recurse-submodules</code>（在较新版本的 git
中使用，命令的语义更加清晰）：当要拉取的仓库中包含 submodule
时，是默认不会拉取子仓库的，而指定这个参数即可拉取所有的子仓库。</p>
<p>如果我们在下载的时候忘记指定
<code>--recursive</code>，也可以通过下面命令重新拉取子仓库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>--depth</code>：当我们只想下载指定更新次数的分支（这样可以减少下载的大小，在我们只需要最新的提交记录时很有用，当然也可以直接下载
zip 或 tar.gz 等压缩文件来解决。</p></li>
<li><p><code>-b</code> 或者
<code>--branch</code>：指定要拉取的分支名称，例如下载 boost-1.86.0
（这个实际上是一个 tag，但也可以通过这种方式下载）。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/boostorg/boost.git --branch boost-1.86.0</span><br></pre></td></tr></table></figure>
</li>
</ul>
<span id="more"></span>

<h2 id="添加-ssh-密钥">添加 SSH 密钥</h2>
<ol type="1">
<li><p>创建 ssh 密钥对，通过 <code>ssh-keygen</code> 创建即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t &lt;加密方式&gt; -C &lt;密钥注释&gt;</span><br></pre></td></tr></table></figure>

<p>示例如下</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">PS D:\Code\Git&gt; ssh-keygen -t ed25519 -C &quot;foo@example.com&quot;</span><br><span class="line">Generating public/private ed25519 key pair.</span><br><span class="line">Enter file in which to save the key (C:\Users\xiao/.ssh/id_ed25519):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in C:\Users\xiao/.ssh/id_ed25519.</span><br><span class="line">Your public key has been saved in C:\Users\xiao/.ssh/id_ed25519.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:rJ2ufXZ93fAPNsdqBrdUsMSABhse7zBpo0ewRa3nn+s foo@example.com</span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+--[ED25519 256]--+</span><br><span class="line">|      ..*o ..o   |</span><br><span class="line">|       = *+   +  |</span><br><span class="line">|      . Xo.  . o |</span><br><span class="line">|       =.=.   . .|</span><br><span class="line">|      . So.    . |</span><br><span class="line">|       + .. . +. |</span><br><span class="line">|      . o  . *++=|</span><br><span class="line">|       o  o +.===|</span><br><span class="line">|      ..oo oE+..o|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>

<p>会提示我们创建的密钥对已经放置在了 <code>C:\Users\xiao\.ssh</code>
路径下</p></li>
<li><p>更新 ssh 的配置，修改
<code>~/.ssh/config</code>，添加如下内容</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Host gitlab.com</span><br><span class="line">  HostName gitlab.com</span><br><span class="line">  PreferredAuthentications publickey</span><br><span class="line">  IdentityFile ~/.ssh/gitlab.<span class="keyword">private</span>-key.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 gitlab 或者 github 上添加 SSH 密钥</p>
<p>进入用户设置，点击 <code>SSH Keys</code></p>
<p><img data-src="/posts/8de3/image-20240907110021863.png"
style="zoom:50%;" /></p>
<p>点击 Add new key</p>
<p><img data-src="/posts/8de3/image-20240907110149847.png"
style="zoom: 50%;" /></p>
<p>将刚才创建的密钥对中公钥部分添加到此处，然后点击 Add 即可添加 SSH
密钥</p>
<p><img data-src="/posts/8de3/image-20240907110252194.png"
style="zoom:50%;" /></p></li>
<li><p>测试连接，在命令行中输入如下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PS D:\Code\Git&gt; ssh git@gitlab.com</span><br><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Welcome to GitLab, @PureWhiteVK!</span><br><span class="line">Connection to gitlab.com closed.</span><br></pre></td></tr></table></figure>

<p>如果有类似输出，则说明 SSH 密钥添加成功</p></li>
<li><p>通过 SSH 方式下载源码</p>
<p><img data-src="/posts/8de3/image-20240907110430040.png"
style="zoom: 50%;" /></p>
<p>复制 Clone with SSH 中给出命令，在命令行中执行即可拉取源码</p></li>
</ol>
<h1 id="git-branch">git branch</h1>
<h2 id="创建">创建</h2>
<p>直接使用 <code>git checkout</code> 创建分支，示例如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b bugfix/my-bugfix-branch</span><br></pre></td></tr></table></figure>

<p>（这个实际上等价于下面的两条命令）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -f bugfix/my-bugfix-branch</span><br><span class="line">git checkout bugfix/my-bugfix-branch</span><br></pre></td></tr></table></figure>

<p>因此使用 <code>git checkout -b &lt;branch&gt;</code>
是最常用也最典型的操作方式</p>
<h2 id="删除">删除</h2>
<p>通过下面命令删除分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -D &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<p>如果要删除远端分支（不推荐），需要通过 <code>git push</code>
命令完成，示例如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin --delete &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="重命名">重命名</h2>
<p>通过下面命令重命名分支（实际上是移动或者拷贝，这两种方式都可以实现重命名效果）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -m &lt;old-branch&gt; &lt;new-branch&gt;</span><br></pre></td></tr></table></figure>

<p>此处的 <code>-m</code> 表示 move，和 Linux 上 <code>move</code>
命令一致，就是移动分支到新的标识符下。</p>
<p>也可以使用 <code>-c</code> ，其表示 copy，和 Linux 上 <code>cp</code>
命令一致，其好处就是不会丢弃原有的分支</p>
<h1 id="合并">合并</h1>
<p>在 git 中有两种方式可以实现合并，merge 和
rebase，下面简单描述下二者区别：</p>
<ul>
<li><p>merge：<strong>创建一条新的
commit</strong>，将分支1的改动和分支2的改动合并，记录在此 commit 中</p>
<p>优点是能完整的记录所有的改动历史</p>
<p>缺点是主干的历史并不是完全线性的，在版本回退时不太方便（通过 github
的 PR 或者 gitlab 的 MR 都可以确保主干线性历史）</p></li>
<li><p>rebase：将分支1中的相对于分支2不同的 commit 在 分支2
上重新提交一遍，<strong>不会创建新的
commit</strong>，但是分支1中改动部分的 commit
的哈希值会发生改变（因为相当于在分支2上重新做了一遍）</p>
<p>优点是能保证改动历史完全线性</p>
<p>缺点是记录的历史实际上是改动过的（因为哈希值发生变化）</p></li>
</ul>
<p>对于这一部分的介绍推荐使用 <a
href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git
Branching</a> 网站通过图形化方式加深对 <code>git merge</code> 和
<code>git rebase</code> 的理解。</p>
<h1 id="拉取">拉取</h1>
<h2 id="git-fetch">git fetch</h2>
<p>通过 <code>git clone</code> 下载到本地的分支，实际上<code>git</code>
会帮我们自动创建一个 <code>origin/xxx</code> 分支（可以通过
<code>git branch -a</code> 查看所有的分支），而 <code>git fetch</code>
做的就是将远端的更新同步到本地的 <code>origin/xxx</code>
分支中，如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PS D:\Code\Git\Learn-Git&gt; git branch -a</span><br><span class="line">* main</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/main</span><br><span class="line">  remotes/origin/main</span><br></pre></td></tr></table></figure>

<h2 id="git-pull">git pull</h2>
<p><code>pull</code> 想对于 <code>fetch</code>
的区别就是其默认会将远端分支 merge
到本地分支（如果远端分支和本地分支存在冲突的话），如果没有的话就直接
fast-forward 即可</p>
<h2 id="本地强行同步远端分支">本地强行同步远端分支</h2>
<p>当远端分支进行过 rebase
操作后，可能会导致本地分支和远端分支不一致，如果直接使用
<code>git pull</code>
会将远端的操作和本地操作都保留（即出现了两次历史），我们可能想避免这种行为，可以通过以下操作进行同步</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git reset --soft origin/&lt;target-branch-name&gt;</span><br></pre></td></tr></table></figure>

<p>通过 reset 命令本地分支强行重置到指定的分支上，这里我们指定的是
origin 的分支（即远端分支），并通过 <code>--soft</code>
确保本地尚未提交的改动还能继续保留</p>
<h1 id="git-push">git push</h1>
<p>这个命令没什么好说的，就一条</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>如果本地创建了一个分支，想要将该分支也提交到远端的话，直接
<code>git push</code> 会出错，但是 git 也会给出解决方案</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PS D:\Code\Git\Learn-Git&gt; git push</span><br><span class="line">fatal: The current branch new-branch has no upstream branch.</span><br><span class="line">To push the current branch and <span class="built_in">set</span> the remote as upstream, use</span><br><span class="line"></span><br><span class="line">    git push --set-upstream origin new-branch</span><br><span class="line"></span><br><span class="line">To have this happen automatically <span class="keyword">for</span> branches without a tracking</span><br><span class="line">upstream, see <span class="string">&#x27;push.autoSetupRemote&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git help config&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>我们只需要执行上面提到的命令即可</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin new-branch</span><br></pre></td></tr></table></figure>

<p>当然，也可以通过改变 push
的默认行为来自动创建，不过这个设置就看个人了</p>
<h2 id="强行推送远端分支">强行推送远端分支</h2>
<p>当远端分支和本地分支有区别的时候（例如本地进行了 rebase 或者 reset
操作，导致 git
的记录出现问题时），我们可能需要强制将本地分支覆盖掉远端分支，就可以通过下面命令进行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure>

<p>一般这个命令仅在个人的分支使用（例如
<code>bugfix/xxx</code>或<code>feature/xxx</code>）</p>
<h1 id="git-stash">git stash</h1>
<p>当我们本地分支有改动尚未提交（未通过 git add 和 git commit
时）但是需要切换分支时，git 会提示有改动未暂存，此时我们可以通过
<code>git stash</code> 命令暂存，其就使用起来就相当于一个栈，</p>
<ol type="1">
<li><p>入栈操作：就是将当前所有的改动暂存起来</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
</li>
<li><p>出栈操作：就是将当前暂存的改动释放出来，应用到当前分支中</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="说明">说明</h1>
<p>上面介绍了一些常用的 git 命令，如果碰到其他的就直接使用
<code>git &lt;command&gt; --help</code>
查看相关文档，或者直接百度即可。</p>
]]></content>
      <categories>
        <category>技术笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分析工具（1）：内存布局和内存泄漏</title>
    <url>/posts/55d0/</url>
    <content><![CDATA[<h1 id="cc-程序内存布局">C/C++ 程序内存布局</h1>
<p>对于一个经典的 C/C++ 程序，其内存区域可划分为 5 大部分</p>
<ul>
<li>代码段（Text Segment）：只读区域，存储汇编指令</li>
<li>数据段（Data
Segment）：存储非0初始化的全局变量或静态变量、字符串常量</li>
<li>BSS 段（<strong>B</strong>lock <strong>S</strong>tarting
<strong>S</strong>ymbol
Segment）：存储0初始化的全局变量或静态变量，<strong>此段的作用在于减少可执行文件大小</strong>，在可执行文件中通常只需要记录一个长度即可</li>
<li>堆区（Heap）：程序运行过程中进行动态内存分配的区域</li>
<li>栈区（Stack）：程序运行过程中存储函数调用栈帧（存储函数执行时的临时变量）</li>
</ul>
<p>下图展示了这五块在内存上的排列顺序(图片来自^1^)</p>
<p><img data-src="/posts/55d0/memoryLayoutC.jpg" style="zoom: 80%;" /></p>
<span id="more"></span>

<h2 id="查看数据段大小">查看数据段大小</h2>
<p>在 Linux 下可以通过 <code>size</code> 命令查看 C/C++
程序的静态数据段大小情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>size</code> 查看 text，data 和 bss 段大小</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(base) ➜  Debug size memory_layout </span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">   1418     544       8    1970     7b2 memory_layout</span><br></pre></td></tr></table></figure>

<p>此时分别添加字符串常量和0初始化的变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;&#125;;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1230</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次使用 <code>size</code> 命令查看大小，输出如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(base) ➜  Debug size memory_layout</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">   1418     548      12    1978     7ba memory_layout</span><br></pre></td></tr></table></figure>

<p>可以观察到 data 段和 bss 段分别增加了 4 个 byte，分别对应 a 和
b。</p>
<h2 id="为什么需要-stack-和-heap">为什么需要 Stack 和 Heap</h2>
<p>Stack 和 Heap 原本是数据结构中的概念</p>
<ul>
<li>Stack 描述的是 **后进先出（LIFO）**数据结构</li>
<li>Heap
可分为大根堆、小根堆和斐波那契堆等，描述的是一种具有特殊偏序关系的树状结构（父节点值一定大于或小于子节点值之类的）</li>
</ul>
<p>在内存中，这两个概念稍微有点区别</p>
<p>下表展示了 Stack Memory 和 Heap Memory 的对比</p>
<table>
<thead>
<tr class="header">
<th>Stack Memory</th>
<th>Heap Memory</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>存储局部变量、函数参数和函数调用上下文（如返回地址）</td>
<td>存储动态分配的数据</td>
</tr>
<tr class="even">
<td>自动分配和释放数据</td>
<td>手动管理，由程序员负责分配和释放</td>
</tr>
<tr class="odd">
<td>内存管理有效，大小有限，适用于生命周期较短的小数据</td>
<td>大小相对栈更大，适用于长生命周期和较大数据</td>
</tr>
<tr class="even">
<td>内存地址由大到小</td>
<td>内存地址由小到大</td>
</tr>
</tbody>
</table>
<p>概念说起来有点干巴巴的，还是给一个示例和图表辅助说明一下</p>
<p>Stack Memory
的一个最经典的用途就是函数调用的栈，例如递归函数斐波那契数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">face</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用 <code>fact(3)</code> 时，需要首先计算 <code>fact(2)</code>
的值才能继续计算，而计算 <code>fact(2)</code> 又需要进一步计算
<code>fact(1)</code>，此时满足递归终止条件，可直接返回。</p>
<p>可绘制出调用 <code>fact(3)</code> 并获取返回值的栈帧变化情况如下</p>
<p><img data-src="/posts/55d0/绘图1.png" /></p>
<p>Stack Memory 之所以取名为 Stack Memory
就是因为其在函数调用时先调用的函数最后退出，符合 LIFO
特性，因而称之为栈内存。</p>
<p>至于Heap
Memory，首先其特点是数据在Heap中存储可以不连续（存在内存碎片），可以想象成不同数据随意的放在一起（书堆、杂物堆等），如下图所示（图片来自^2^）。</p>
<p><img data-src="/posts/55d0/stack_heap.drawio.png" /></p>
<h1 id="常见内存问题">常见内存问题</h1>
<p>在编写 C/C++ 程序时，一不留神会碰到
SEGFAULT（段错误），这是由于程序进行了异常的内存访问所导致的，常见的内存错误有</p>
<ul>
<li>内存泄漏：动态分配内存而不释放</li>
<li>内存破坏
<ul>
<li>alloc/dealloc mismatch &amp; new/delete type
mismatch（分配/释放不匹配）</li>
<li>double free（重复释放）</li>
<li>heap buffer out of range（堆缓冲越界）</li>
<li>use after free（释放后使用）</li>
<li>use after scope（作用域外使用）</li>
<li>use after return（返回后使用）</li>
<li>stack buffer out of range（栈缓冲越界）</li>
<li>global buffer out of range（全局缓冲越界）</li>
</ul></li>
</ul>
<p>下面分别列举一些例子</p>
<h2 id="memory-leak">memory leak</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">FuncThatCallMalloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> *data = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(<span class="built_in">malloc</span>(<span class="number">20</span>));</span><br><span class="line">  data[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;</span><br><span class="line">  data[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">  data[<span class="number">2</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">  data[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">  data[<span class="number">4</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">  data[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">FuncThatCallMalloc</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">FuncThatCallMalloc</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">FuncThatCallMalloc</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">FuncThatCallMalloc</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次调用 <code>FuncThatCallMalloc</code>，都会请求动态内存分配 20
bytes，但是并未释放，如果在程序运行过程中不断调用该函数，程序占用内存将不断增加，直达操作系统无法再分配内存，导致程序崩溃。</p>
<h2 id="allocdealloc-mismatch">alloc/dealloc mismatch</h2>
<p>C++ 中除了 <code>malloc</code> 和 <code>free</code> 之外，可以使用
<code>new/delete</code> 或者
<code>new[]/delete[]</code>方式进行动态内存分配，使用 <code>new</code>
本质上编译器也会转而为我们调用 <code>malloc</code>，因此可以使用
<code>free</code> 进行释放，但是不匹配的 <code>malloc/free</code>或
<code>new/delete</code>调用也会造成内存泄漏或者内存破坏，下面例子展示了这种情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>() &#123;</span><br><span class="line">    data = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* data&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span>* d = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="keyword">new</span> <span class="built_in">Test</span>());</span><br><span class="line">  <span class="built_in">free</span>(d);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以正常运行并返回0，但是通过 <code>free</code> 并不会调用
<code>~Test()</code>，因此不会释放类 <code>Test</code>
在构造过程中分配的 data 数据，这一段内存就再也无法释放了。</p>
<h2 id="double-free">double free</h2>
<p>在 Linux 中，这一问题会出现在关闭两次文件上，如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FILE* f = <span class="built_in">fopen</span>(<span class="string">&quot;test.bin&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  <span class="built_in">fclose</span>(f);</span><br><span class="line">  <span class="built_in">fclose</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时会直接abort，如下所示</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(base) ➜  Debug ./memory_layout</span><br><span class="line">free(): double free detected <span class="keyword">in</span> tcache 2</span><br><span class="line">[1]    13311 abort      ./memory_layout</span><br></pre></td></tr></table></figure>

<h2 id="heap-buffer-out-of-range">heap buffer out of range</h2>
<p>这一问题也很常见，例如当我们动态分配了一个长度为 100 的
buffer，但我们访问其位置为 120 时出现越界访问，导致程序崩溃</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> h = <span class="number">320</span>;</span><br><span class="line">  <span class="type">int</span> w = <span class="number">320</span>;</span><br><span class="line">  <span class="type">char</span> *buf = <span class="keyword">new</span> <span class="type">char</span>[h + w];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; w; j++) &#123;</span><br><span class="line">      buf[i * w + j] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>[] buf;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(base) ➜  Debug ./memory_layout</span><br><span class="line">[<span class="number">1</span>]    <span class="number">14048</span> segmentation fault  ./memory_layout</span><br></pre></td></tr></table></figure>

<h2 id="use-after-free">use after free</h2>
<p>当我们读取一个已经被释放掉的内存时，其结果是未知的，即使我们并没有再分配新的内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>&#123;<span class="number">123</span>&#125;;</span><br><span class="line">  <span class="type">double</span> *b = <span class="keyword">new</span> <span class="type">double</span>&#123;<span class="number">0.123</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p, a = %d\n&quot;</span>, a, *a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&amp;b = %p, b = %lf\n&quot;</span>, b, *b);</span><br><span class="line">  <span class="keyword">delete</span> b;</span><br><span class="line">  <span class="keyword">delete</span> a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&amp;a = %p, a = %d\n&quot;</span>, a, *a);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;&amp;b = %p, b = %lf\n&quot;</span>, b, *b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(base) ➜  Debug ./memory_layout</span><br><span class="line">&amp;a = 0x55cba8191eb0, a = 123</span><br><span class="line">&amp;b = 0x55cba8191ed0, b = 0.123000</span><br><span class="line">&amp;a = 0x55cba8191eb0, a = -1474748720</span><br><span class="line">&amp;b = 0x55cba8191ed0, b = 0.000000</span><br></pre></td></tr></table></figure>

<h2 id="use-after-return">use after return</h2>
<p>这个问题也很常见，当我们返回一个栈上变量的地址，并再后续代码中使用时，其值是不确定的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> data[<span class="number">2048</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;this is in A!\n&quot;</span>);</span><br><span class="line">  ptr = data;</span><br><span class="line">  data[<span class="number">0</span>] = <span class="number">1337</span>;</span><br><span class="line">  data[<span class="number">2047</span>] = <span class="number">13337</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> b = <span class="number">0.1234</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;this is in B!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">A</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p = %d\n&quot;</span>, ptr, *ptr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p = %d\n&quot;</span>, &amp;ptr[<span class="number">2047</span>], ptr[<span class="number">2047</span>]);</span><br><span class="line">  <span class="built_in">B</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p = %d\n&quot;</span>, ptr, *ptr);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p = %d\n&quot;</span>, &amp;ptr[<span class="number">2047</span>], ptr[<span class="number">2047</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span> is in A!</span><br><span class="line"><span class="number">0x7ffff039b520</span> = <span class="number">1337</span></span><br><span class="line"><span class="number">0x7ffff039d51c</span> = <span class="number">13337</span></span><br><span class="line"><span class="keyword">this</span> is in B!</span><br><span class="line"><span class="number">0x7ffff039b520</span> = <span class="number">1337</span></span><br><span class="line"><span class="number">0x7ffff039d51c</span> = <span class="number">21951</span></span><br></pre></td></tr></table></figure>

<p>此处实际上并不会崩溃，因为函数执行完只会移动栈指针，并不会对内存做过多调整，此时栈内存数据仍会保留，在后续代码中也可以使用，但是不知道什么时候，读取到的值就不对了，从而导致程序执行结果出现异常。</p>
<h2 id="use-after-scope">use after scope</h2>
<p>这个和前一个效果类似，在 C++ 中引入 scope
可以更方便的管理对象生命周期，当对象离开 scope
时会自动调用析构函数，这也是 RAII（Resouce Acquisition Is
Initialization） 实现的基本原理。</p>
<p>但是当我们在 scope 内取一个 scope
外的值时，其值也可能并非我们想的那样</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Test</span>() &#123; data = <span class="number">1337</span>; &#125;</span><br><span class="line">  ~<span class="built_in">Test</span>() &#123; data = <span class="number">1238</span>; &#125;</span><br><span class="line">  <span class="type">int</span> data&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test *ptr1, *ptr2;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// enter scope</span></span><br><span class="line">    Test t0&#123;&#125;;</span><br><span class="line">    ptr1 = &amp;t0;</span><br><span class="line">    &#123;</span><br><span class="line">      Test t1&#123;&#125;;</span><br><span class="line">      ptr2 = &amp;t1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr1-&gt;data = %d\n&quot;</span>, ptr1-&gt;data);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;ptr2-&gt;data = %d\n&quot;</span>, ptr2-&gt;data);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 scope
内的对象也是栈上对象，访问时不容易出现崩溃，但是其值就可能并非我们想的那样了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(base) ➜  Debug ./memory_layout</span><br><span class="line">ptr1-&gt;data = 1238</span><br><span class="line">ptr2-&gt;data = 1238</span><br></pre></td></tr></table></figure>

<h2 id="stack-buffer-overflow">stack buffer overflow</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">void</span>* buf,<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span>* b = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(buf);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">    b[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">123</span>];</span><br><span class="line">  <span class="built_in">Func</span>(buf,<span class="number">153</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(base) ➜  Debug ./memory_layout</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">[1]    19730 abort      ./memory_layout</span><br></pre></td></tr></table></figure>

<p>但是当 overflow
的数据并不大时，并不会造成显著的影响，但是会为程序埋下隐患。</p>
<h2 id="global-buffer-overflow">global buffer overflow</h2>
<p>对于 global buffer overflow
也是同理，无非就是溢出的内存区域变了，这种情况下bug更为隐蔽，因为 global
buffer
段通常溢出一点点也是无大碍，并不影响程序执行，但是拿到数据是否是我们所想就不为所知了（谁知道读写溢出段的值什么时候会被覆盖掉？）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_buffer1[<span class="number">120</span>];</span><br><span class="line"><span class="type">int</span> global_buffer2[<span class="number">120</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">void</span> *buf, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> *b = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(buf);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    b[i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Func</span>(global_buffer1, <span class="number">153</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;global_buffer1: %p~%p\n&quot;</span>,global_buffer1,global_buffer1 + <span class="number">120</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;global_buffer2: %p~%p\n&quot;</span>,global_buffer2,global_buffer2 + <span class="number">120</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(base) ➜  Debug ./memory_layout</span><br><span class="line">global_buffer1: 0x562168281040~0x562168281220</span><br><span class="line">global_buffer2: 0x562168281220~0x562168281400</span><br></pre></td></tr></table></figure>

<p>从结果中我们可以看到，global_buffer1 和 global_buffer2
在内存的排列上时连续的，因此下溢 global_buffer1 会直接修改到
global_buffer2，如果在后续执行中设置
global_buffer2，将覆盖之前设置的值，引发未知的bug。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://www.naukri.com/code360/library/memory-layout-of-c-program">Memory
layout of C program - Naukri Code 360</a></li>
<li>[What and Where Are the Memory Stack and Heap? | Baeldung on
Computer Science](<a
href="https://www.baeldung.com/cs/memory-stack-vs-heap#:~:text=Stack">https://www.baeldung.com/cs/memory-stack-vs-heap#:~:text=Stack</a>
memory is a sort,longer lifespan than stack memory.)</li>
<li><a
href="https://learn.microsoft.com/en-us/cpp/sanitizers/asan?view=msvc-170">AddressSanitizer
| Microsoft Learn</a></li>
</ol>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>内存分析</tag>
      </tags>
  </entry>
  <entry>
    <title>内存分析工具（2）：实现内存泄漏检查</title>
    <url>/posts/daa5/</url>
    <content><![CDATA[<h1 id="基本原理">基本原理</h1>
<p>内存泄漏是指<strong>程序在运行时动态分配了内存，但是没有正确释放或者回收这些内存</strong>，导致已分配的内存无法被重新利用。随着程序的运行，未释放的内存会逐渐累积，可能最终耗尽系统的可用内存。</p>
<p>内存泄漏检查工具的基本原理是通过<strong>监控程序的内存分配和释放操作，来检查是否有未正确释放的内存</strong>，其主要包含以下3个部分：</p>
<ul>
<li>内存分配函数追踪</li>
<li>调用栈分析</li>
<li>内存泄漏报告</li>
</ul>
<p>内存分配函数追踪可通过拦截（Hook）、插桩（Instrumentation）等方式实现，下面对比了几种常见内存泄漏检查方式</p>
<ol type="1">
<li><p>函数拦截（Hook）</p>
<p>原理：拦截CRT提供的内存管理函数，将其替换为自定义的内存管理函数，从而实现内存分配和释放的记录</p>
<p>优点：可通过 <code>LD_PRELOAD</code>
等技术通过动态链接方式实现函数拦截，代码侵入性小</p>
<p>缺点：由于在每一次内存分配/释放时都会记录，会带来一定的性能开销</p></li>
<li><p>代码植入（Code Instrumentation）和影子内存（Shadow Memory）</p>
<p>原理：将程序中每一个内存块的状态映射到另一块内存区域，并在每一次内存操作时更新状态信息（通过代码植入实现）</p>
<p>优点：内存状态追踪结果精确，可实现其他内存检查功能</p>
<p>缺点：编译期植入方法（Address
Sanitizer）需要重新编译代码，而运行时植入方法（Valgrind）使用仿真器运行（Emulator），程序运行速度显著降低</p></li>
</ol>
<p>下一节将详细介绍 ASAN 和 Valgrind
的实现原理和基本使用，本节将着重介绍通过函数拦截方式实现的内存泄漏检查工具。</p>
<span id="more"></span>

<h1 id="通过-ld_preload-实现-malloc-hook">通过 LD_PRELOAD 实现 malloc
hook</h1>
<p>在 Windows 下，可直接通过 <code>_CrtSetAllocHook</code> API
直接添加自定义的内存内存分配/释放函数，</p>
<p>在 Linux 下，GCC 也提供了类似的 Hook 函数，如
<code>__malloc_hook</code>、<code>__realloc_hook</code>、<code>__free_hook</code>、<code>__memalign_hook</code>
等，但其已经在 glibc 2.32 版本被弃用，并在 glibc 2.34 版本中将这些 hook
代码移除，将其放到了 <code>libc_malloc_debug.so.0</code>
中。目前更推荐的方式是通过 <code>LD_PRELOAD</code> 环境变量直接替换
<code>malloc</code> 等函数。</p>
<h2 id="ld_preload">LD_PRELOAD</h2>
<p>在 Linux 系统下，<code>LD_PRELOAD</code>
环境变量的作用是<strong>在动态链接库的加载过程中指定额外的动态库优先加载</strong>。如果
<code>LD_PRELOAD</code>
中的库提供了与系统库（glibc）中相同名称的符号，动态链接器（ld）将会优先使用这些符号进行解析，从而实现对系统库函数的替换和劫持。</p>
<p>从 <code>LD_PRELOAD</code>
的作用可以看出，其仅适用于动态链接场景，对于静态链接的库无法应用，因为静态链接库的符号解析在编译期就已经完成，而动态链接库的符号地址将在函数第一次调用时解析。</p>
<p>我们要劫持的内存管理函数包含在 glibc （GNU C
Library）中，因此需要确保编译的程序是动态链接 glibc 而不是静态链接 glibc
的，可以通过 <code>ldd</code> 命令查看程序依赖的动态链接库，如果包含
libc.so.6，则说明其动态链接到 glibc，我们便可以通过
<code>LD_PRELOAD</code> 方式替换 malloc 并进行内存分配/释放的追踪。</p>
<p>也可以直接使用 <code>file</code> 查看可执行程序的基本情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(base) ➜  build file demo</span><br><span class="line">demo: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=9d1c40ef0056c0cd218526d4e4d0e177ccb0a783, <span class="keyword">for</span> GNU/Linux 3.2.0, with debug_info, not stripped</span><br></pre></td></tr></table></figure>

<p>在链接过程中指定 <code>-static</code> 可实现静态链接 glibc，再次使用
<code>file</code> 查看基本情况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">(base) ➜  build file demo_static</span><br><span class="line">demo_static: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, BuildID[sha1]=771d155d3f1ff156c986dcc67d6e07e3e80a74b1, <span class="keyword">for</span> GNU/Linux 3.2.0, with debug_info, not stripped</span><br></pre></td></tr></table></figure>

<p>使用 <code>ldd</code> 是也将提示 "not a dynamic
executable"，其不包含任何动态链接信息。</p>
<h2 id="动态符号解析机制">动态符号解析机制</h2>
<p>动态符号解析机制是现代操作系统通过动态链接库（如
<code>glibc</code>）实现符号（函数和变量）在程序运行时的地址解析过程。它允许程序在不重新编译的情况下调用共享库中的符号。</p>
<p>在动态链接过程中，程序的符号（例如函数调用）在编译时并不知道最终的内存地址，而是在运行时由<strong>动态链接器</strong>负责解析。这种机制依赖于两张表：<strong>GOT（Global
Offset Table）</strong> 和 <strong>PLT（Procedure Linkage
Table）</strong>，它们协同工作，以便符号在首次调用时完成解析，并优化后续调用。</p>
<ul>
<li><p>全局偏移表（GOT）</p>
<p>是动态链接的二进制文件（可执行程序、动态链接库等）用于管理
<strong>外部函数地址</strong> 的机制。由于这些
<strong>地址在运行时才会确定</strong>（因为动态链接的存在），GOT
提供了一种 <strong>在符号解析后动态更新这些外部符号地址</strong>
的方式。</p>
<p>GOT 中的每个表项都对应一个外部库中的符号，当
<strong>函数第一次被调用时，动态链接器解析其实际地址并将其存储在 GOT
中</strong>。随后的调用将直接使用存储在 GOT
中的地址，从而避免了每次调用时重新解析地址的开销。</p></li>
<li><p>过程链接表（PLT）</p>
<p><strong>过程链接表（PLT）</strong> 充当调用外部函数的跳板。当程序
<strong>首次调用外部函数时，控制会转移到与该函数关联的 PLT
条目</strong>。这个 PLT
条目负责调用动态链接器，以解析该函数的地址（如果尚未解析）。解析完成后，地址会被存储在
<strong>GOT</strong> 中。</p>
<p><strong>因此，</strong> 一旦外部函数或变量的地址被解析后，GOT
条目会被直接使用。<strong>PLT 条目用于协助初次解析</strong>
这些地址，通过动态链接器完成。</p></li>
</ul>
<p>在 compiler explorer 中可以观察到这一点</p>
<p>样例代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* data = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Output 菜单栏中勾选 “Link to
binary”，编译参数为默认，可以看到其汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">malloc@plt-0x10:</span><br><span class="line"> push   QWORD PTR [rip+0x2fe2]        # 404008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br><span class="line"> jmp    QWORD PTR [rip+0x2fe4]        # 404010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br><span class="line"> nop    DWORD PTR [rax+0x0]</span><br><span class="line">main:</span><br><span class="line"> push   rbp</span><br><span class="line"> mov    rbp,rsp</span><br><span class="line"> sub    rsp,0x10</span><br><span class="line"> mov    edi,0x14</span><br><span class="line"> call   401030 &lt;malloc@plt&gt;</span><br><span class="line"> mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line"> mov    eax,0x0</span><br><span class="line"> leave</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>

<p>在调用 malloc 时，其并没有给出真正的地址，而是跳转到 plt 的对应表项
<code>malloc@plt</code>。</p>
<p>而当我们指定 <code>-static</code> 链接选项后，其部分汇编代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">main:</span><br><span class="line"> push   rbp</span><br><span class="line"> mov    rbp,rsp</span><br><span class="line"> sub    rsp,0x10</span><br><span class="line"> mov    edi,0x14</span><br><span class="line"> call   4194e0 &lt;__libc_malloc&gt;</span><br><span class="line"> mov    QWORD PTR [rbp-0x8],rax</span><br><span class="line"> mov    eax,0x0</span><br><span class="line"> leave</span><br><span class="line"> ret</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到其直接调用的就是 <code>__libc_malloc</code>，节省了跳转 plt
获取实际地址的过程。</p>
<p>下图展示了程序（动态链接 glibc）调用 <code>malloc</code>
函数的过程</p>
<p><img data-src="/posts/daa5/plt-flow.drawio.png" style="zoom:67%;" /></p>
<p>下面给出动态符号解析的伪代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Map&lt;FuncId,DynamicResolver&gt; PLT&#123;&#125;;</span><br><span class="line">Map&lt;FuncId,Function&gt; GOT&#123;&#125;;</span><br><span class="line"><span class="comment">// call malloc@plt</span></span><br><span class="line"><span class="keyword">if</span>(GOT.<span class="built_in">find</span>(FuncId) == GOT.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* ptr = PLT[name].<span class="built_in">dl_runtime_resolve</span>();</span><br><span class="line">    GOT[name] = ptr;</span><br><span class="line">&#125;</span><br><span class="line">GOT[name](...)</span><br></pre></td></tr></table></figure>

<p>在代码中，也可以通过 <code>dlsym</code>
直接获取函数符号信息，如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> Malloc = <span class="type">void</span> *(<span class="type">size_t</span>);</span><br><span class="line">  Malloc *my_malloc = <span class="built_in">reinterpret_cast</span>&lt;Malloc *&gt;(<span class="built_in">dlsym</span>(RTLD_DEFAULT, <span class="string">&quot;malloc&quot;</span>));</span><br><span class="line">  <span class="built_in">assert</span>(my_malloc == &amp;malloc);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取-stacktrace">获取 stacktrace</h1>
<blockquote>
<p>[!Note]</p>
<p>参考 <a href="https://github.com/jeremy-rifkin/cpptrace">cpptrace</a>
中不同 unwind 方案</p>
</blockquote>
<p>在内存检测工具中，一个很重要的功能就是获取函数的调用栈，这样我们才能定位到是在何时何地发生的内存泄漏。</p>
<p>其具体可以分为两步</p>
<ol type="1">
<li><p>遍历栈帧列表，回溯每一层函数调用的程序计数器，构造函数调用链</p>
<p>可以使用 libbacktrace、glibc自带的backtrace函数或 libunwind
进行获取</p></li>
<li><p>根据程序计数器的值和调试符号信息，获取函数名、调用源码位置信息</p>
<p>可以使用 libbacktrace 或者 addr2line 命令行工具获取</p></li>
</ol>
<h1 id="实现细节">实现细节</h1>
<blockquote>
<p>[!Note]</p>
<p>为便于说明，后续 malloc 指代 glibc 中相关的内存分配/释放函数，如
free、realloc、calloc 等，malloc hook为我们用于替换 glibc
相关内存分配/释放的函数。</p>
</blockquote>
<p>根据 LD_PRELOAD 的功能描述，使用 malloc hook 替换 malloc
后，所有动态链接 malloc 的地方都将解析为 malloc hook 调用。</p>
<p>为不影响软件的正常执行，我们需要在 malloc hook 中调用
malloc，然后根据其返回结果记录相关信息。</p>
<p>那么如何在 malloc hook 中调用 malloc呢，直接通过
<code>void* data = malloc(20)</code> 这种肯定是不行的，前面提到的
<code>dlsym</code> 就发挥其作用了。</p>
<h2 id="获取-glibc-malloc-函数指针">获取 glibc malloc 函数指针</h2>
<p>我们只需要通过 <code>dlopen</code> 打开系统的 <code>glibc</code>
动态库，然后通过 <code>dlsym</code> 获取 malloc 函数指针即可。</p>
<p><strong>且这一加载步骤只能在第一次调用 malloc 时触发，因为第一次调用
malloc 的时机可能早于静态变量初始化时机</strong></p>
<p>但是在 <code>dlopen</code> 和 <code>dlsym</code>
内部执行过程中也可能调用 malloc，如下所示</p>
<p><img data-src="/posts/daa5/dlopen-recursive-malloc.drawio.png"
style="zoom:67%;" /></p>
<p>但是此时我们还没有拿到 malloc 的函数指针，这样就会陷入死循环。</p>
<p>为解决这种情况，我们就需要提供一块临时内存区域供 <code>dlopen</code>
和 <code>dlsym</code>
使用（即实现一个静态内存池），以确保我们可以正确拿到 glibc 的 malloc
函数指针地址。实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">size_t</span> BUFFER_SIZE = <span class="number">1</span> &lt;&lt; <span class="number">14</span>;</span><br><span class="line"><span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line"><span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> capacity = BUFFER_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">temp_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(capacity &lt; size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span>* ptr = buffer + size;</span><br><span class="line">    pos += size;</span><br><span class="line">    capacity -= size;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">temp_free</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可以避免初始化 malloc 时的递归调用，下图展示了 Malloc Hook
中初始化 glibc malloc 的流程</p>
<p><img data-src="/posts/daa5/initialize-glibc-malloc.drawio-1727008632420-9.png"
style="zoom:67%;" /></p>
<h2 id="避免递归调用">避免递归调用</h2>
<p>这是我们预想的 malloc hook 的基本功能伪代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">my_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">glibc_malloc</span>(size);</span><br><span class="line">    <span class="built_in">Log</span>(ptr,size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 Log
函数将记录每一次内存分配的相关信息，为记录每一次内存分配/释放调用及其相关调用栈，我们需要准备两个
map，一个用于存储每一条分配信息，一个用于存储调用栈信息。第二个 map
是为了减少调用栈的重复存储，以尽可能减少内存占用。</p>
<p>两个 map 的定义如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocInfo</span> &#123;</span><br><span class="line">    <span class="type">uintptr_t</span> ptr&#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span> size&#123;&#125;;</span><br><span class="line">    <span class="type">size_t</span> frame_id&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Frames</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> length&#123;&#125;;</span><br><span class="line">    std::array&lt;<span class="type">uintptr_t</span>,127&gt; pcs&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> AllocMap = map&lt;<span class="type">uintptr_t</span>,AllocInfo&gt;;</span><br><span class="line"><span class="keyword">using</span> FrameMap = map&lt;<span class="type">size_t</span>, Frames&gt;;</span><br></pre></td></tr></table></figure>

<p>AllocMap 的键为通过 malloc，calloc，realloc
等内存分配函数所分配的内存块的首地址。</p>
<p>FrameMap 的键为对 Frames 结构体通过 hash_combine（参考 boost
实现）后获取的 hash 值，以尽可能减少重复。</p>
<p>无论是使用 tree map 还是 hash
map，其在插入过程中都有可能都有可能进行动态内存分配，即如下调用链</p>
<p><img data-src="/posts/daa5/log-recursive-malloc.drawio-1727008883541-13.png"
style="zoom:67%;" /></p>
<p>这样会导致 malloc hook 的递归调用，而在 malloc hook
内部发生的动态内存分配对于软件的内存泄漏检查而言毫无意义，可以直接忽略，因此需要添加一个递归标志位，以判断
malloc hook 是否发生递归调用。</p>
<p>如下图所示</p>
<p><img data-src="/posts/daa5/malloc-hook-basic.drawio-1727008791210-11.png"
style="zoom: 67%;" /></p>
<p>写成伪代码如下所示</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">my_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> entered = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(entered) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">glibc_malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    entered = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">void</span>* ptr = <span class="built_in">glibc_malloc</span>(size);</span><br><span class="line">    <span class="built_in">Log</span>(ptr,size);</span><br><span class="line">    entered = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于在 free、realloc、calloc 等内存分配/释放函数中也会调用到
malloc（因为 Log
记录的调用），因此全局状态标识位必须只有一个，其表示当前程序正在执行内存分配函数过程中。</strong></p>
<h2 id="多线程记录">多线程记录</h2>
<p><strong>内存分配函数可能会在多线程环境下使用，而上述递归标志位、AllocMap
和 FrameMap 都是全局变量，在并发读写时需要加锁。</strong></p>
<ul>
<li><p>对于递归标志位而言，如果对其加锁，则同一时间内将仅有一个变量进入
malloc hook 执行，这样会极大的影响程序性能。但一个线程进入 malloc hook
执行并不应该阻碍另一个线程执行 malloc hook，<strong>即 malloc hook
的递归标志位应该时每个线程独有的状态标志位</strong>，将递归标志位从
<code>static</code> 转换为
<code>thread_local</code>，以避免频繁的进行线程同步。</p></li>
<li><p>而对于 AllocMap 和 FrameMap 而言，可以尝试使用
concurrent_hash_map
等数据结构<strong>缩小加锁的范围</strong>以尽可能提高 malloc hook
的执行效率。</p></li>
</ul>
<p>最后章节中，我们将会对实现的 malloc hook 进行
benchmark，就可以发现不同设计下的性能差距。并给出最终完整版 malloc hook
实现。</p>
<h1 id="参考">参考</h1>
<ol type="1">
<li><a
href="https://book.hacktricks.xyz/binary-exploitation/arbitrary-write-2-exec/aw2exec-got-plt">WWW2Exec
- GOT/PLT | HackTricks</a></li>
<li><a
href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/crtsetallochook?view=msvc-170">_CrtSetAllocHook
| Microsoft Learn</a></li>
<li><a
href="https://man7.org/linux/man-pages/man8/ld.so.8.html">ld.so(8) -
Linux manual page (man7.org)</a></li>
<li><a
href="https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm">AddressSanitizerAlgorithm
· google/sanitizers Wiki (github.com)</a></li>
<li><a
href="https://valgrind.org/docs/manual/design-impl.html">Valgrind</a></li>
<li><a
href="https://github.com/jeremy-rifkin/cpptrace">jeremy-rifkin/cpptrace:
Simple, portable, and self-contained stacktrace library for C++11 and
newer (github.com)</a></li>
</ol>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>内存分析</tag>
      </tags>
  </entry>
</search>
