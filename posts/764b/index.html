<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
  <link rel="mask-icon" href="/images/favicon/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"purewhitevk.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"default"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="最近刷牛客的 C++ 语言专项练习（选择题），本来以为 C++ 掌握的还不错吧，一做题就全露馅了，细节太多了（ C++ 本身的 未定义行为 undefined behavior 以及 C++这么多年来的更新带来的包袱太多了） 基本上所有的问题都可以在 cppreference.com 上面找到答案，还有样例，比较权威，然后实现相关的可以使用 Compiler Explorer (godbolt.o">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 易错点整理(一)">
<meta property="og:url" content="https://purewhitevk.github.io/posts/764b/">
<meta property="og:site_name" content="PureWhiteVK&#39;s Blog">
<meta property="og:description" content="最近刷牛客的 C++ 语言专项练习（选择题），本来以为 C++ 掌握的还不错吧，一做题就全露馅了，细节太多了（ C++ 本身的 未定义行为 undefined behavior 以及 C++这么多年来的更新带来的包袱太多了） 基本上所有的问题都可以在 cppreference.com 上面找到答案，还有样例，比较权威，然后实现相关的可以使用 Compiler Explorer (godbolt.o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230209205555494.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230209221937788.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230209234348279.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210110358443.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210111608942.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210112209205.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210114206263.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210121645460.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210141729168.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210150327901.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210150530111.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210153919168.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210153955611.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210152746441.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210152810621.png">
<meta property="og:image" content="https://purewhitevk.github.io/posts/764b/image-20230210115052441.png">
<meta property="article:published_time" content="2023-02-09T11:53:46.000Z">
<meta property="article:modified_time" content="2023-02-09T11:53:46.000Z">
<meta property="article:author" content="PureWhiteVK">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://purewhitevk.github.io/posts/764b/image-20230209205555494.png">


<link rel="canonical" href="https://purewhitevk.github.io/posts/764b/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://purewhitevk.github.io/posts/764b/","path":"posts/764b/","title":"C++ 易错点整理(一)"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ 易错点整理(一) | PureWhiteVK's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">PureWhiteVK's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">23</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">19</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82"><span class="nav-number">1.</span> <span class="nav-text">C++ 语法细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">1.1.</span> <span class="nav-text">自增&#x2F;自减运算符的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#increment-and-decrement"><span class="nav-number">1.1.1.</span> <span class="nav-text">Increment and decrement</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="nav-number">1.2.</span> <span class="nav-text">转义字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%9F%E8%A7%A3%E6%9E%90%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">1.3.</span> <span class="nav-text">域解析操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E4%BD%93"><span class="nav-number">1.4.</span> <span class="nav-text">纯虚函数的函数体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void-%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.5.</span> <span class="nav-text">void 的大小？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.6.</span> <span class="nav-text">类变量初始化和析构顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#initialization-order"><span class="nav-number">1.6.1.</span> <span class="nav-text">Initialization order</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.</span> <span class="nav-text">函数重载方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-number">1.8.</span> <span class="nav-text">指针和引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%85%A5%E5%8F%82"><span class="nav-number">1.9.</span> <span class="nav-text">数组入参</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#array-to-pointer-decay"><span class="nav-number">1.9.1.</span> <span class="nav-text">Array-to-pointer decay</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%85%A5%E5%8F%82%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.10.</span> <span class="nav-text">函数入参求值顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stl"><span class="nav-number">2.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="nav-number">2.1.</span> <span class="nav-text">迭代器失效</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">C 库函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.1.</span> <span class="nav-text">查找字符串</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="PureWhiteVK"
      src="/images/Touma.Kazusa.256x256.png">
  <p class="site-author-name" itemprop="name">PureWhiteVK</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/PureWhiteVK" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PureWhiteVK" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yl_xiao@outlook.com" title="E-Mail → mailto:yl_xiao@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/dead.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://purewhitevk.github.io/posts/764b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Touma.Kazusa.256x256.png">
      <meta itemprop="name" content="PureWhiteVK">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PureWhiteVK's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ 易错点整理(一) | PureWhiteVK's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 易错点整理(一)
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023/02/09 19:53:46" itemprop="dateCreated datePublished" datetime="2023-02-09T19:53:46+08:00">2023/02/09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">C++学习笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>最近刷牛客的 C++ 语言专项练习（选择题），本来以为 C++
掌握的还不错吧，一做题就全露馅了，细节太多了（ C++ 本身的
<strong>未定义行为 undefined behavior</strong> 以及
C++这么多年来的更新带来的包袱太多了）</p>
<p>基本上所有的问题都可以在 <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/">cppreference.com</a>
上面找到答案，还有样例，比较权威，然后实现相关的可以使用 <a
target="_blank" rel="noopener" href="https://godbolt.org/">Compiler Explorer (godbolt.org)</a>
查看编译细节。</p>
<h2 id="c-语法细节">C++ 语法细节</h2>
<h3 id="自增自减运算符的重载">自增/自减运算符的重载</h3>
<p><em><strong>题1</strong></em>：如果定义了一个类myclass,
则为myclass类对象以成员函数形式重载 <strong>后 ++ 运算符</strong>
的声明应该是：</p>
<p>A. <code>myclass operator++()</code></p>
<p>B. <code>myclass operator++(int)</code></p>
<p>C. <code>myclass &amp;operator++()</code></p>
<p>D. <code>myclass &amp;operator(int)</code></p>
<p><em><strong>答案</strong></em>：B</p>
<p><em><strong>解析</strong></em>：这题纯纯考察自增/自减的重载，没什么难点，单纯是不记得这个写法了</p>
<span id="more"></span>

<blockquote>
<h4 id="increment-and-decrement">Increment and decrement</h4>
<p>When the postfix increment or decrement operator appears in an
expression, the corresponding user-defined function (operator++ or
operator--) is called with an integer argument <code>0</code>.
Typically, it is implemented as T operator++(int) or T operator--(int),
where the argument is ignored. The postfix increment and decrement
operators are usually implemented in terms of the prefix versions:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前置自增</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called ++A&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置自增，相比前置版本的函数签名，就差了一个 int</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;called A++&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a++;</span><br><span class="line">    ++a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230209205555494.png" /></p>
<p>关键点就是：<strong>后置自增函数相比于前置自增函数需要添加一个
<code>int</code> 参数进行区别</strong></p>
<p>注：对于前置自增/自减和后置自增/自减运算符本身也是常考察的内容：</p>
<ul>
<li><p><code>i++</code> 的含义是 <strong>将 i 增加
1，返回加之前的值</strong>，用一个函数来表示就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefix_increment</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = v;</span><br><span class="line">    v += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>++i</code> 的含义是 <strong>将 i 增加
1，返回加之后的值</strong>，用于用函数来表示就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">postfix_increment</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v+= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>从我们代码实现上也可以看出，<em><strong>在未优化的情况下</strong></em>，后置自增会比前置自增多用一个临时变量，从而造成性能开销，<strong>但是现在的编译器都很智能了，对于这个基本上都会直接优化掉</strong>（开启
<code>-O2</code>
优化）。<em><strong>所以在平时写的时候怎么舒服怎么来就行，只要确保可读性就行</strong></em>。</p>
<h3 id="转义字符">转义字符</h3>
<p><em><strong>题2</strong></em>：有转义字符如下：<code>'\0X41'</code>、<code>'\0x41'</code>、<code>'\X41'</code>、<code>'\x41'</code>、<code>'\a'</code>、<code>'\b'</code>、<code>'\c'</code>、<code>'\r'</code>
其中错误的转义字符个数是（</p>
<p><em><strong>解析</strong></em>：这题也是考察的 C++ 语法，错误的有 4
个，<code>\0X41</code>、<code>\0x41</code>、<code>\X41</code>、<code>\c</code></p>
<p>详细参考：<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/escape">Escape
sequences - cppreference.com</a></p>
<p><strong>1. 简单转义字符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\&#x27; 表示 &#x27;</span><br><span class="line">\&quot; 表示 &quot;</span><br><span class="line">\\ 表示 \</span><br><span class="line">\? 表示 ?</span><br><span class="line">\a 表示 蜂鸣器（主板上）</span><br><span class="line">\b 表示 退格</span><br><span class="line">\f 表示 新一页</span><br><span class="line">\n 表示 换行 (Line Feed)</span><br><span class="line">\r 表示 回车 (Carriage Return)</span><br><span class="line">\t 表示 水平制表符</span><br><span class="line">\v 表示 垂直制表符</span><br></pre></td></tr></table></figure>

<p>注：<code>\n\r</code> 在 CRLF （Carriage Return / Line
Feed）表示回车换行，一般在 Windows 下的纯文本中常用，而在 Unix
系统下常用 <code>\n</code> 即 换行，在 VS Code 中也可以进行设置</p>
<p><img data-src="/posts/764b/image-20230209221937788.png"
style="zoom: 33%;" /></p>
<p><strong>2. 数值表示形式</strong></p>
<p>char 本质上也是一个整数，那么我们可以使用数值编码也是一样的</p>
<ul>
<li>八进制形式：<code>\&lt;nnn&gt;</code>，例如 <code>\141</code> 表示
ASCII 字符 <code>'a'</code></li>
<li>十六进制形式：<code>\x&lt;nn&gt;</code>，例如 <code>\x61</code> 表示
ASCII 字符
<code>'a'</code>（这个是区分大小写的，只能使用小写的<code>\x</code>，但是后面的十六进制大小写都可以），例如
<code>\x3F</code> 和 <code>\x3f</code> 都行</li>
</ul>
<p>代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v0 = <span class="string">&quot;\x61&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v1 = <span class="string">&quot;\141&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v2 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; v0 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. Unicode 表示形式</strong></p>
<ul>
<li><code>\u&lt;nnnn&gt;</code>，表示 <code>U+&lt;nnnn&gt;</code>的
Unicode，这种方式只能表示到 <code>U+FFFF</code>，对于 Emoji
等只能使用下面这种完整形式了</li>
<li><code>\U&lt;nnnnnnnn&gt;</code>，表示
<code>U+&lt;nnnnnnnn&gt;</code>的 Unicode，可以完整的表示
Unicode（<code>U+FFFFFFFF</code>），就是表示起来比较麻烦</li>
</ul>
<p>而对于上面提到的 <code>\c</code> ，其在 C++
中有定义，但是具体实现有关，没有一个统一的含义，因此不能算在转义字符行列中</p>
<h3 id="域解析操作符">域解析操作符</h3>
<p><em><strong>题3</strong></em>：外部变量可以供其所在的程序文件中的任何函数使用（）</p>
<ol type="1">
<li><p>正确</p></li>
<li><p>错误</p></li>
</ol>
<p><em><strong>解析</strong></em>：这一题一眼
<strong>错误</strong>，因为在函数中使用同名的变量就会将其覆盖掉，这样就无法使用外部变量了，但是看到评论中提到可以使用
<code>::&lt;variable&gt;</code>来访问外面作用域。这个查了一下，称为
Scope Resolution Operator（作用域解析运算符），那么我们可以写成这样</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> v = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; ::v &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230209234348279.png" /></p>
<p>对于命名空间、类空间中定义的变量和静态函数都可以使用这个方式访问</p>
<h3 id="纯虚函数的函数体">纯虚函数的函数体</h3>
<p><em><strong>题4</strong></em>：（多选）c/c++中，有关纯虚函数说法正确的是（
）</p>
<ol type="1">
<li><p>子类中必须覆盖基类的纯虚函数</p></li>
<li><p>含有纯虚函数的类不能被实例化</p></li>
<li><p>基类的纯虚函数没有函数体</p></li>
<li><p>含有纯虚函数的类一定是抽象类</p></li>
</ol>
<p><em><strong>解析</strong></em>：这题主要考察
<em><strong>虚函数</strong></em> 相关的一些概念，正确的有 2，4</p>
<p>对于 1
，如果我们需要层层抽象的话，就可能会在子类中包含纯虚函数，因此子类不一定需要覆盖基类的纯虚函数</p>
<p>对于 4 ，乍一看好像是对的，我们都 <em><strong>声明</strong></em>
其是纯虚函数了，为啥还要 <em><strong>定义</strong></em> 函数方法呢？</p>
<p>这一部分其实在 cppreference 上也有介绍</p>
<blockquote>
<p>The definition of a pure virtual function may be provided (and must
be provided if the pure virtual is the <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/destructor">destructor</a>):
the member functions of the derived class are free to call the abstract
base's pure virtual function using qualified function id. This
definition must be provided outside of the class body (the syntax of a
function declaration doesn't allow both the pure specifier
<strong><code>= 0</code></strong> and a function body).</p>
<p>Making a virtual call to a pure virtual function from a constructor
or the destructor of the abstract class is undefined behavior
(regardless of whether it has a definition or not).</p>
<p><a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/abstract_class">Abstract
class - cppreference.com</a></p>
<p>翻译一下就是：</p>
<p>纯虚函数可以提供函数定义（如果是析构函数的话必须要提供），但是不能以类内的方式存在，需要在类外部进行定义。<code>=0</code>
语法就已经禁止函数定义了。</p>
<p>并且在抽象类的构造/析构函数中调用 <strong>纯虚函数</strong> 是
<em><strong>未定义行为</strong></em> ,千万不要这么做。</p>
</blockquote>
<p>说起来有点抽象，举个例子吧</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Abstract</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明纯虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 只能采用类外定义的方式进行定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Abstract::func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;calling Abstract::func\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Abstract &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 子类要么继续保持抽象类，要么重写 func</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;calling Derived::func\n&quot;</span>;</span><br><span class="line">        Abstract::<span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Abstract* a = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result of a-&gt;Abstract::func():\n&quot;</span>;</span><br><span class="line">    a-&gt;Abstract::<span class="built_in">func</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;result of a-&gt;func():\n&quot;</span>;</span><br><span class="line">    a-&gt;<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230210110358443.png"
style="zoom:50%;" /></p>
<p>由于 C++ 中没有引入类似 <code>abstract</code>
这类的关键字，我们只能通过声明虚函数的方式来讲一个类设置为抽象类，并且我们需要强制子类实现某个函数，但是有时为了代码复用，又想提供一个默认的函数实现时，就可以采用这种方法。</p>
<h3 id="void-的大小">void 的大小？</h3>
<p><em><strong>题5</strong></em>：32位编译器下，<code>sizeof(void)</code>
的值是多少？</p>
<p><em><strong>解析</strong></em>：void
的大小和编译器以及语言有关在。</p>
<ul>
<li><p>C 中，<code>sizeof(void)</code>
值和编译器有关，有可能为0，有可能为1</p></li>
<li><p>C++ 中，<code>sizeof(void)</code> 会直接报错</p>
<p><img data-src="/posts/764b/image-20230210111608942.png"
style="zoom: 50%;" /></p></li>
</ul>
<p>那么对于 <code>void*</code>
指针而言，我们将其自增，地址值会如何变化呢？</p>
<p>由于我们无法取得 <code>void</code>
的大小，<strong>自然也就无法对其进行指针运算了</strong>，要想实现运算，只能通过强制类型转换。</p>
<p><img data-src="/posts/764b/image-20230210112209205.png"
style="zoom:50%;" /></p>
<p>为了跨平台方便，在头文件 <code>cstdint</code> 中定义了
<code>uintptr_t</code>来表示和指针同样大小的整形类型，用来显式表示地址值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> size = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span>* v = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">    <span class="type">void</span>* v1 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(v);</span><br><span class="line">    <span class="type">uintptr_t</span> v2 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(v1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of v1 = &quot;</span></span><br><span class="line">              &lt;&lt; v1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of v2 = &quot;</span> </span><br><span class="line">              &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>)</span><br><span class="line">              &lt;&lt; std::showbase</span><br><span class="line">              &lt;&lt; v2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of v2 + 1 = &quot;</span> </span><br><span class="line">              &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>)</span><br><span class="line">              &lt;&lt; std::showbase</span><br><span class="line">              &lt;&lt; v2 + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（std::cout 这张流式输出方式真的太繁琐了，还不如使用 <code>fmt</code>
库）</p>
<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230210114206263.png"
style="zoom:50%;" /></p>
<p>当然，我们也可以将 <code>uintptr_t</code>
强制类型转换到指针，然后读取其内容，不过十分危险，容易出错，日常不推荐这样使用。</p>
<h3 id="类变量初始化和析构顺序">类变量初始化和析构顺序</h3>
<p><em><strong>题6</strong></em>：给出下列代码的实际运行结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base</span>(<span class="type">const</span> <span class="type">char</span>* p_szName):<span class="built_in">m_szName</span>(p_szName) &#123;std::cout &lt;&lt; m_szName &lt;&lt; <span class="string">&quot;,&quot;</span>;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt;<span class="string">&quot;~&quot;</span>&lt;&lt;m_szName &lt;&lt; <span class="string">&quot;, &quot;</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* m_szName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> <span class="type">char</span>*p_szName)</span><br><span class="line">      :<span class="built_in">m_szName</span>(p_szName)</span><br><span class="line">      ,<span class="built_in">m_objA</span>((<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;A&quot;</span>)</span><br><span class="line">      ,<span class="built_in">m_objB</span>((<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;B&quot;</span>)</span><br><span class="line">      ,<span class="built_in">Base</span>((<span class="type">const</span> <span class="type">char</span>*)<span class="string">&quot;C&quot;</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; m_szName &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt;<span class="string">&quot;~&quot;</span>&lt;&lt;m_szName &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* m_szName;</span><br><span class="line">	Base m_objB;</span><br><span class="line">	Base m_objA;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="keyword">new</span> <span class="built_in">Derived</span>(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>解析</strong></em>：这道题就考察的类变量初始化和析构的顺序问题，如果没有写代码测试的话确实不知道运行结果是怎么样的。</p>
<p>同样在 cppreference 上有详细的介绍：<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constructor">Constructors
and member initializer lists - cppreference.com</a></p>
<blockquote>
<h4 id="initialization-order">Initialization order</h4>
<p>The order of member initializers in the list is irrelevant: the
actual order of initialization is as follows:</p>
<ol type="1">
<li>If the constructor is for the most-derived class, virtual bases are
initialized in the order in which they appear in depth-first
left-to-right traversal of the base class declarations (left-to-right
refers to the appearance in base-specifier lists)</li>
<li>Then, direct bases are initialized in left-to-right order as they
appear in this class's base-specifier list</li>
<li>Then, non-static data member are initialized in order of declaration
in the class definition.</li>
<li>Finally, the body of the constructor is executed</li>
</ol>
<p>(Note: if initialization order was controlled by the appearance in
the member initializer lists of different constructors, then the <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/destructor">destructor</a>
wouldn't be able to ensure that the order of destruction is the reverse
of the order of construction)</p>
<p>简单翻译一下就是：</p>
<p><em><strong>类成员初始化的顺序</strong></em> 与在类构造函数中
<em><strong>成员初始化列表</strong></em>
的顺序<em><strong>没有任何关系</strong></em>，其取决于以下四点：</p>
<ol type="1">
<li>对于多层嵌套继承，使用DFS，从左到右的顺序初始化基类（继承树的遍历）</li>
<li>对于直接基类按从左到右的顺序初始化基类</li>
<li>对于非静态的数据成员将会按照
<em><strong>类定义时的声明顺序</strong></em> 进行初始化</li>
<li>最终执行构造函数体</li>
</ol>
<p>注：如果 <strong>成员初始化顺序</strong> 由
<strong>成员初始化列表</strong> 来控制的话，就无法确保析构顺序为
<strong>构造顺序的逆序</strong> 了</p>
</blockquote>
<p>讲了这么多，关键就一点：<strong>类内非静态成员的初始化顺序是按照声明时的顺序进行初始化，在析构时则按照相反的顺序进行析构</strong></p>
<p>由此，我们可以轻松知道代码执行的结果了</p>
<p><code>Derived</code> 继承了
<code>Base</code>，那么在初始化之前必须要初始化基类，因此首先初始化
<code>Base</code>，那么首先就会输出 <code>C</code>，之后按顺序初始化
<code>B</code>、初始化 <code>A</code>，最终执行函数体
<code>D</code>，</p>
<p>那么在析构时则按照构造的相反顺序，首先执行函数体<code>D</code>，后析构<code>A</code>，再析构
<code>B</code>，最后析构基类 <code>C</code></p>
<p>最终输出如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C,B,A,D,~D,~A,~B,~C,</span><br></pre></td></tr></table></figure>

<p>而带代码实际运行结果也是如此</p>
<p><img data-src="/posts/764b/image-20230210121645460.png"
style="zoom:50%;" /></p>
<h3 id="函数重载方式">函数重载方式</h3>
<p><em><strong>题7</strong></em>：以下不是double
compare(int,int)的重载函数的是()</p>
<ol type="1">
<li><code>int compare(double,double)</code></li>
<li><code>double compare(double,double)</code></li>
<li><code>double compare(double,int)</code></li>
<li><code>int compare(int,int)</code></li>
</ol>
<p><em><strong>解析</strong></em>：这题考察的是函数重载的定义方式，在
C++ 中支持同名函数，使用不同的参数调用不同的重载函数。具体通过 name
mangling
实现。<strong>而重载函数的区别主要在于函数入参数量以及入参类型</strong>。</p>
<p>而 1 和 2
仅在函数返回类型上不一致，调用时我们就不知道如何调用了。</p>
<p><img data-src="/posts/764b/image-20230210141729168.png"
style="zoom:50%;" /></p>
<h3 id="指针和引用">指针和引用</h3>
<p><em><strong>题8</strong></em>：关于引用以下说法错误的是（）。</p>
<ol type="1">
<li>引用必须初始化，指针可以不初始化</li>
<li>引用初始化以后不能被改变，而指针可以改变指向</li>
<li>不存在指向空值的引用，但是存在指向空值的指针</li>
<li>一个引用可以看作是某个变量的一个“别名”</li>
<li>引用传值，指针传地址</li>
<li>函数参数可以声明为引用或指针类型</li>
</ol>
<p><em><strong>解析</strong></em>：答案是
5，传递引用实际上就是传递指针，这一点从汇编代码上可以看出来</p>
<p>通过 compiler explorer 查看输出如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>* a)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用 GCC 12.2 编译代码如下</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func1(int&amp;):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        nop</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">func2(int*):</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     QWORD PTR [rbp-8], rdi</span><br><span class="line">        nop</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br><span class="line">main:</span><br><span class="line">        push    rbp</span><br><span class="line">        mov     rbp, rsp</span><br><span class="line">        mov     eax, 0</span><br><span class="line">        pop     rbp</span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<h3 id="数组入参">数组入参</h3>
<p><em><strong>题8</strong></em>：在32位环境下，以下程序的输出结果是？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> x[<span class="number">14</span>])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sizeof</span>(x) + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> x[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sizeof</span>(x) + <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived stDerived;</span><br><span class="line">    Base *pstBase = &amp;stDerived;</span><br><span class="line">    <span class="type">char</span> x[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, pstBase-&gt;<span class="built_in">foo</span>(<span class="number">100</span>) + pstBase-&gt;<span class="built_in">foo</span>(x));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>解析</strong></em>：这题主要考察的是虚函数调用以及数组作为参数调用函数的一些细节：</p>
<p>这一部分在 cppreference 上有介绍：<a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/array">Array
declaration - cppreference.com</a></p>
<blockquote>
<h4 id="array-to-pointer-decay">Array-to-pointer decay</h4>
<p>There is an <a
target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/implicit_conversion">implicit
conversion</a> from lvalues and rvalues of array type to rvalues of
pointer type: it constructs a pointer to the first element of an array.
This conversion is used whenever arrays appear in context where arrays
are not expected, but pointers are:</p>
<p>翻译一下就是：当我们使用数组作为入参调用函数时，数组会隐式退化成指针</p>
</blockquote>
<p>那么如果我们有一个函数，想要遍历数组的所有元素时，<strong>我们是绝对不能使用
<code>sizeof</code>
来获取数组的长度的，因此此时数组已经退化为指针了！</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_array</span><span class="params">(<span class="type">int</span> x[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(x) / <span class="built_in">sizeof</span>(x[<span class="number">0</span>]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(print_array) sizeof(x) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;(print_array) length(x) = &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[ &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; x[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(x) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(x) / <span class="built_in">sizeof</span>(x[<span class="number">0</span>]);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;length(x) = &quot;</span> &lt;&lt; length &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">print_array</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并不会如我们期待的输出数组中所有的元素，而是输出前 8 个元素值</p>
<p><img data-src="/posts/764b/image-20230210150327901.png"
style="zoom:50%;" /></p>
<p>（不过我们都用数组了，数组的长度肯定是已知的，这样低级错误应该还是不会犯的，况且现代编译器都会提示这个问题）</p>
<p><img data-src="/posts/764b/image-20230210150530111.png"
style="zoom: 33%;" /></p>
<p>回到这一题，前一个函数符合虚函数调用，会调用子类的
<code>int foo(int)</code>，输出结果
2000，而后面一个由于不是虚函数，则会直接调用父类定义的
<code>int foo(int x[14])</code>，并且在其中使用
<code>sizeof(x)</code>，32位环境下指针大小为 4，那么最终结果就是 2000+14
= 2014</p>
<h3 id="函数入参求值顺序">函数入参求值顺序</h3>
<p><em><strong>题9</strong></em>：阅读C语言代码输出（）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p=arr;</span><br><span class="line">    *(p++)+=<span class="number">89</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,*p,*(++p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em><strong>解析</strong></em>：这一题直接考察 printf
的求值顺序，但是实际上这是一个
<em><strong>未定义行为</strong></em>，不同编译器下结果不一致，这题的目的在于：<strong>我们不能理所当然的假设参数的求值顺序就是从左到右或从右到左，也千万不要写出类似的代码</strong></p>
<p>GCC 下输出为</p>
<p><img data-src="/posts/764b/image-20230210153919168.png"
style="zoom:50%;" /></p>
<p>Clang下输出如下，还对我们的调用给出了警告（这说明编译器的警告有时候还是要看看的，不是说编译过了就行）</p>
<p><img data-src="/posts/764b/image-20230210153955611.png"
style="zoom:50%;" /></p>
<p>同样，在函数调用时的参数求值顺序也不能假设，示例如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">arg0</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called argument0\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">arg1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called argument1\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">arg2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;called argument2\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">arg0</span>(),<span class="built_in">arg1</span>(),<span class="built_in">arg2</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在不同的编译器下输出结果不一致，我们不能假定其一定是从左到右进行求值，也有可能从右向左求值。</p>
<p>Clang 15.0 输出结果</p>
<p><img data-src="/posts/764b/image-20230210152746441.png"
style="zoom:50%;" /></p>
<p>GCC 12.2 输出结果</p>
<p><img data-src="/posts/764b/image-20230210152810621.png"
style="zoom:50%;" /></p>
<h2 id="stl">STL</h2>
<h3 id="迭代器失效">迭代器失效</h3>
<p><em><strong>题9</strong></em>：会导致下列的代码片段崩溃的
<code>CONTAINER</code> 类型是？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER::iterator iter, tempIt;</span><br><span class="line"><span class="keyword">for</span> (iter = cont.<span class="built_in">begin</span>(); iter != cont.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    tempIt = iter;</span><br><span class="line">    ++iter;</span><br><span class="line">    cont.<span class="built_in">erase</span>(tempIt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设cont是一个 <code>CONTAINER</code>
的实例，里面包含数个元素，那么当 <code>CONTAINER</code> 为：</p>
<p>1、vector 2、list 3、map 4、deque</p>
<p>会导致上面的代码片段崩溃的 <code>CONTAINER</code> 类型是？</p>
<p><em><strong>解析</strong></em>：这题考察的是STL容器的迭代器，我们尝试对容器进行修改然后继续使用修改之前的迭代器，这样子的操作非常容易出问题，因为对于
vector 和 deque 这样的顺序存储容器而言，其数据存储是连续的，当我们进行
remove
的时候有可能影响迭代器，从而使迭代器失效，而访问一个失效的迭代器就会使程序崩溃。</p>
<p>对于任何一种迭代器，我们都不要尝试对其修改后再使用之前的迭代器，实际上
<code>erase</code>
函数会返回修改后的迭代器，我们要写代码可以正确运行，直接使用这个即可。即</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER::iterator iter, tempIt;</span><br><span class="line"><span class="keyword">for</span> (iter = cont.<span class="built_in">begin</span>(); iter != cont.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    iter = cont.<span class="built_in">erase</span>(iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以保证代码的正确运行</p>
<h2 id="c-库函数">C 库函数</h2>
<h3 id="查找字符串">查找字符串</h3>
<p><em><strong>题6</strong></em>：从字符串中寻找一串字符的函数是（）</p>
<p>A. <code>strcmp</code></p>
<p>B. <code>strstr</code></p>
<p>C. <code>strcat</code></p>
<p>D. <code>strfind</code></p>
<p><strong>解析</strong>：看函数名字就想选
<code>strfind</code>，但是这个函数实际上是 matlab 的字符串查找函数，而在
C 库中对应的是 <code>strstr</code>。</p>
<p>（主要还是没用过，不知道）</p>
<p>其函数签名如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strstr</span><span class="params">(<span class="type">char</span>* s1,<span class="type">const</span> <span class="type">char</span>* s2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其作用就是返回 s2 在 s1 中第一次出现的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* s = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* sub = <span class="string">&quot;foobar&quot;</span>;</span><br><span class="line">    <span class="comment">// 此处我们拿到的 v 就是 sub 中的一个指针</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* v = <span class="built_in">strstr</span>(sub,s);</span><br><span class="line">    <span class="type">uintptr_t</span> s0 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(sub);</span><br><span class="line">    <span class="type">uintptr_t</span> v0 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of sub = &quot;</span> &lt;&lt; s0 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address of strstr(sub,s) = &quot;</span> &lt;&lt; v0 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img data-src="/posts/764b/image-20230210115052441.png"
style="zoom:50%;" /></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>PureWhiteVK
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://purewhitevk.github.io/posts/764b/" title="C++ 易错点整理(一)">https://purewhitevk.github.io/posts/764b/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/dead.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/55c5/" rel="prev" title="虚函数执行原理理解">
                  <i class="fa fa-chevron-left"></i> 虚函数执行原理理解
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/30a2/" rel="next" title="命令行切换MSVC版本">
                  命令行切换MSVC版本 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PureWhiteVK</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">60k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:37</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.3/jquery.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
